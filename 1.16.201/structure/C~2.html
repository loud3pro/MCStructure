<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C~2 | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.0484522b.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.4c02fc69.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.ab15d2b7.js" as="script"><link rel="preload" href="/mcstructure/assets/js/1.9734fe39.js" as="script"><link rel="preload" href="/mcstructure/assets/js/110.86d45285.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.102fb00e.js"><link rel="prefetch" href="/mcstructure/assets/js/100.9f4887ee.js"><link rel="prefetch" href="/mcstructure/assets/js/101.38d4e8ed.js"><link rel="prefetch" href="/mcstructure/assets/js/102.4cf4c505.js"><link rel="prefetch" href="/mcstructure/assets/js/103.254bae32.js"><link rel="prefetch" href="/mcstructure/assets/js/104.3a611fe2.js"><link rel="prefetch" href="/mcstructure/assets/js/105.a60ad729.js"><link rel="prefetch" href="/mcstructure/assets/js/106.a9dadd40.js"><link rel="prefetch" href="/mcstructure/assets/js/107.1cdafa8f.js"><link rel="prefetch" href="/mcstructure/assets/js/108.289ea0ab.js"><link rel="prefetch" href="/mcstructure/assets/js/109.35965d89.js"><link rel="prefetch" href="/mcstructure/assets/js/11.1efdebfb.js"><link rel="prefetch" href="/mcstructure/assets/js/111.bce93ce8.js"><link rel="prefetch" href="/mcstructure/assets/js/112.b1df2988.js"><link rel="prefetch" href="/mcstructure/assets/js/113.a8d28c8d.js"><link rel="prefetch" href="/mcstructure/assets/js/114.2f28a2d8.js"><link rel="prefetch" href="/mcstructure/assets/js/115.0b9455a1.js"><link rel="prefetch" href="/mcstructure/assets/js/116.54d2cbea.js"><link rel="prefetch" href="/mcstructure/assets/js/117.84dece67.js"><link rel="prefetch" href="/mcstructure/assets/js/118.fd23f544.js"><link rel="prefetch" href="/mcstructure/assets/js/119.0c82af99.js"><link rel="prefetch" href="/mcstructure/assets/js/12.1500ecd9.js"><link rel="prefetch" href="/mcstructure/assets/js/120.df319818.js"><link rel="prefetch" href="/mcstructure/assets/js/121.fe8d085a.js"><link rel="prefetch" href="/mcstructure/assets/js/122.380a2c51.js"><link rel="prefetch" href="/mcstructure/assets/js/123.a24da413.js"><link rel="prefetch" href="/mcstructure/assets/js/124.c2532fc0.js"><link rel="prefetch" href="/mcstructure/assets/js/125.2985dc5d.js"><link rel="prefetch" href="/mcstructure/assets/js/126.6ba94262.js"><link rel="prefetch" href="/mcstructure/assets/js/127.735fef00.js"><link rel="prefetch" href="/mcstructure/assets/js/128.f3e3fa5d.js"><link rel="prefetch" href="/mcstructure/assets/js/129.0d417975.js"><link rel="prefetch" href="/mcstructure/assets/js/13.f04054ca.js"><link rel="prefetch" href="/mcstructure/assets/js/130.0b77cd0e.js"><link rel="prefetch" href="/mcstructure/assets/js/131.2254c64b.js"><link rel="prefetch" href="/mcstructure/assets/js/132.935cc4b6.js"><link rel="prefetch" href="/mcstructure/assets/js/133.0ecb333e.js"><link rel="prefetch" href="/mcstructure/assets/js/134.5715673e.js"><link rel="prefetch" href="/mcstructure/assets/js/135.0027dfea.js"><link rel="prefetch" href="/mcstructure/assets/js/136.42d83b87.js"><link rel="prefetch" href="/mcstructure/assets/js/137.da3ee6d4.js"><link rel="prefetch" href="/mcstructure/assets/js/138.e266fbe7.js"><link rel="prefetch" href="/mcstructure/assets/js/139.c24aa491.js"><link rel="prefetch" href="/mcstructure/assets/js/14.20d1c79c.js"><link rel="prefetch" href="/mcstructure/assets/js/140.88d83e32.js"><link rel="prefetch" href="/mcstructure/assets/js/141.ea97500c.js"><link rel="prefetch" href="/mcstructure/assets/js/142.12103437.js"><link rel="prefetch" href="/mcstructure/assets/js/143.073b2a3f.js"><link rel="prefetch" href="/mcstructure/assets/js/144.5de16957.js"><link rel="prefetch" href="/mcstructure/assets/js/145.6bbe053a.js"><link rel="prefetch" href="/mcstructure/assets/js/146.85aca5e2.js"><link rel="prefetch" href="/mcstructure/assets/js/147.4bca9cc3.js"><link rel="prefetch" href="/mcstructure/assets/js/148.37d63b3a.js"><link rel="prefetch" href="/mcstructure/assets/js/149.222704e4.js"><link rel="prefetch" href="/mcstructure/assets/js/15.9d8ff414.js"><link rel="prefetch" href="/mcstructure/assets/js/150.c5e7d45c.js"><link rel="prefetch" href="/mcstructure/assets/js/151.2ee19433.js"><link rel="prefetch" href="/mcstructure/assets/js/152.933845cb.js"><link rel="prefetch" href="/mcstructure/assets/js/153.f005156d.js"><link rel="prefetch" href="/mcstructure/assets/js/154.6fc09a83.js"><link rel="prefetch" href="/mcstructure/assets/js/155.b6c305d1.js"><link rel="prefetch" href="/mcstructure/assets/js/156.0910151a.js"><link rel="prefetch" href="/mcstructure/assets/js/157.5dab16c5.js"><link rel="prefetch" href="/mcstructure/assets/js/158.de7f170f.js"><link rel="prefetch" href="/mcstructure/assets/js/159.a5c718e7.js"><link rel="prefetch" href="/mcstructure/assets/js/16.9d3aa9da.js"><link rel="prefetch" href="/mcstructure/assets/js/160.38fc5a00.js"><link rel="prefetch" href="/mcstructure/assets/js/161.493ae65d.js"><link rel="prefetch" href="/mcstructure/assets/js/162.2b7257ff.js"><link rel="prefetch" href="/mcstructure/assets/js/163.24187ca7.js"><link rel="prefetch" href="/mcstructure/assets/js/164.560a9bc3.js"><link rel="prefetch" href="/mcstructure/assets/js/17.0889d1c8.js"><link rel="prefetch" href="/mcstructure/assets/js/18.df0372db.js"><link rel="prefetch" href="/mcstructure/assets/js/19.af158d36.js"><link rel="prefetch" href="/mcstructure/assets/js/20.97f59a2a.js"><link rel="prefetch" href="/mcstructure/assets/js/21.5962fd4e.js"><link rel="prefetch" href="/mcstructure/assets/js/22.4d3522c5.js"><link rel="prefetch" href="/mcstructure/assets/js/23.3537cb24.js"><link rel="prefetch" href="/mcstructure/assets/js/24.c75bf0ca.js"><link rel="prefetch" href="/mcstructure/assets/js/25.24e24560.js"><link rel="prefetch" href="/mcstructure/assets/js/26.7766e0fb.js"><link rel="prefetch" href="/mcstructure/assets/js/27.e9f6074c.js"><link rel="prefetch" href="/mcstructure/assets/js/28.fa15c259.js"><link rel="prefetch" href="/mcstructure/assets/js/29.618d33e1.js"><link rel="prefetch" href="/mcstructure/assets/js/3.78f10f89.js"><link rel="prefetch" href="/mcstructure/assets/js/30.6cf1500b.js"><link rel="prefetch" href="/mcstructure/assets/js/31.22856a35.js"><link rel="prefetch" href="/mcstructure/assets/js/32.bffe7ab8.js"><link rel="prefetch" href="/mcstructure/assets/js/33.7806de32.js"><link rel="prefetch" href="/mcstructure/assets/js/34.c50997a1.js"><link rel="prefetch" href="/mcstructure/assets/js/35.50d88856.js"><link rel="prefetch" href="/mcstructure/assets/js/36.0a3b9225.js"><link rel="prefetch" href="/mcstructure/assets/js/37.892173e1.js"><link rel="prefetch" href="/mcstructure/assets/js/38.faa710ad.js"><link rel="prefetch" href="/mcstructure/assets/js/39.08679ec0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.891576c8.js"><link rel="prefetch" href="/mcstructure/assets/js/40.1b76e3aa.js"><link rel="prefetch" href="/mcstructure/assets/js/41.ab86d7dd.js"><link rel="prefetch" href="/mcstructure/assets/js/42.5f6b9020.js"><link rel="prefetch" href="/mcstructure/assets/js/43.74c52cc7.js"><link rel="prefetch" href="/mcstructure/assets/js/44.29f933bd.js"><link rel="prefetch" href="/mcstructure/assets/js/45.89046872.js"><link rel="prefetch" href="/mcstructure/assets/js/46.927693bf.js"><link rel="prefetch" href="/mcstructure/assets/js/47.6c5e2eb5.js"><link rel="prefetch" href="/mcstructure/assets/js/48.fc418a99.js"><link rel="prefetch" href="/mcstructure/assets/js/49.ab1bff3b.js"><link rel="prefetch" href="/mcstructure/assets/js/5.12550f3f.js"><link rel="prefetch" href="/mcstructure/assets/js/50.34a77e29.js"><link rel="prefetch" href="/mcstructure/assets/js/51.cdab9fd0.js"><link rel="prefetch" href="/mcstructure/assets/js/52.eabfd13f.js"><link rel="prefetch" href="/mcstructure/assets/js/53.f32740a7.js"><link rel="prefetch" href="/mcstructure/assets/js/54.fcfdf201.js"><link rel="prefetch" href="/mcstructure/assets/js/55.dd20532e.js"><link rel="prefetch" href="/mcstructure/assets/js/56.a78e3680.js"><link rel="prefetch" href="/mcstructure/assets/js/57.89305262.js"><link rel="prefetch" href="/mcstructure/assets/js/58.35b65b37.js"><link rel="prefetch" href="/mcstructure/assets/js/59.3817674a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.436e88f9.js"><link rel="prefetch" href="/mcstructure/assets/js/60.2398d268.js"><link rel="prefetch" href="/mcstructure/assets/js/61.61cad8b5.js"><link rel="prefetch" href="/mcstructure/assets/js/62.c2d852d2.js"><link rel="prefetch" href="/mcstructure/assets/js/63.168d8107.js"><link rel="prefetch" href="/mcstructure/assets/js/64.db4e10ba.js"><link rel="prefetch" href="/mcstructure/assets/js/65.17e2ed8f.js"><link rel="prefetch" href="/mcstructure/assets/js/66.0ad691e0.js"><link rel="prefetch" href="/mcstructure/assets/js/67.1e9ccecd.js"><link rel="prefetch" href="/mcstructure/assets/js/68.3d418c4b.js"><link rel="prefetch" href="/mcstructure/assets/js/69.bf6a0b1f.js"><link rel="prefetch" href="/mcstructure/assets/js/7.c2acc470.js"><link rel="prefetch" href="/mcstructure/assets/js/70.f9e2f365.js"><link rel="prefetch" href="/mcstructure/assets/js/71.d7256b61.js"><link rel="prefetch" href="/mcstructure/assets/js/72.0282cd39.js"><link rel="prefetch" href="/mcstructure/assets/js/73.b28cf744.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0aab40c1.js"><link rel="prefetch" href="/mcstructure/assets/js/75.11a8476b.js"><link rel="prefetch" href="/mcstructure/assets/js/76.234564da.js"><link rel="prefetch" href="/mcstructure/assets/js/77.89613781.js"><link rel="prefetch" href="/mcstructure/assets/js/78.8cbc90e7.js"><link rel="prefetch" href="/mcstructure/assets/js/79.8dec18f0.js"><link rel="prefetch" href="/mcstructure/assets/js/80.bc89e0ad.js"><link rel="prefetch" href="/mcstructure/assets/js/81.46cda844.js"><link rel="prefetch" href="/mcstructure/assets/js/82.b1dae669.js"><link rel="prefetch" href="/mcstructure/assets/js/83.3a44a1c4.js"><link rel="prefetch" href="/mcstructure/assets/js/84.9604e4ea.js"><link rel="prefetch" href="/mcstructure/assets/js/85.0b6985d2.js"><link rel="prefetch" href="/mcstructure/assets/js/86.0a705d22.js"><link rel="prefetch" href="/mcstructure/assets/js/87.7d036791.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f4f57b27.js"><link rel="prefetch" href="/mcstructure/assets/js/89.d107adcd.js"><link rel="prefetch" href="/mcstructure/assets/js/90.c6964cf1.js"><link rel="prefetch" href="/mcstructure/assets/js/91.461e7454.js"><link rel="prefetch" href="/mcstructure/assets/js/92.ea6588b8.js"><link rel="prefetch" href="/mcstructure/assets/js/93.12f08abd.js"><link rel="prefetch" href="/mcstructure/assets/js/94.ec163f63.js"><link rel="prefetch" href="/mcstructure/assets/js/95.898bdf72.js"><link rel="prefetch" href="/mcstructure/assets/js/96.63aead8b.js"><link rel="prefetch" href="/mcstructure/assets/js/97.e24085ec.js"><link rel="prefetch" href="/mcstructure/assets/js/98.8e55a83d.js"><link rel="prefetch" href="/mcstructure/assets/js/99.8ccfc759.js"><link rel="prefetch" href="/mcstructure/assets/js/vendors~docsearch.d856fa52.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.0484522b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" class="sidebar-link">B</a></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" class="sidebar-link">B~1</a></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" class="sidebar-link">C</a></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" aria-current="page" class="active sidebar-link">C~2</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" class="sidebar-link">D~6</a></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" class="sidebar-link">H</a></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" class="sidebar-link">L</a></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" class="sidebar-link">S~3</a></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" class="sidebar-link">T~1</a></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c-2"><a href="#c-2" class="header-anchor">#</a> C~2</h1> <h3 id="core-sharedmemorytracker-sharedmemorytrackerimpl-mce-framebuilder-bgfxbridge-meshutils-details-tietoframe-dragon-mesh-vertexbufferresourcemanager-std-optional-dragon-rendering-details-bufferhandletypewrapper-dragon-mesh-details-vertexbufferhandletypekey-unsigned-int64-2-container-vtbl"><a href="#core-sharedmemorytracker-sharedmemorytrackerimpl-mce-framebuilder-bgfxbridge-meshutils-details-tietoframe-dragon-mesh-vertexbufferresourcemanager-std-optional-dragon-rendering-details-bufferhandletypewrapper-dragon-mesh-details-vertexbufferhandletypekey-unsigned-int64-2-container-vtbl" class="header-anchor">#</a> <code>Core::SharedMemoryTracker::SharedMemoryTrackerImpl&lt;</code>mce::framebuilder::bgfxbridge::meshutils::details::_tieToFrame&lt;dragon::mesh::VertexBufferResourceManager,std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::VertexBufferHandleTypeKey,unsigned __int64&gt; &gt; &gt;'::<code>2'::Container&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::SharedMemoryTracker::SharedMemoryTrackerImpl&lt;`mce::framebuilder::bgfxbridge::meshutils::details::_tieToFrame&lt;dragon::mesh::VertexBufferResourceManager,std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::VertexBufferHandleTypeKey,unsigned __int64&gt; &gt; &gt;'::`2'::Container&gt;_vtbl
{
  void (__fastcall *~SharedMemoryTrackerBase)(Core::SharedMemoryTracker::SharedMemoryTrackerBase *this);
};

</code></pre></div><h3 id="core-sharedmemorytracker-sharedmemorytrackerimpl-mce-framebuilder-bgfxbridge-meshutils-details-tietoframe-dragon-mesh-indexbufferresourcemanager-std-optional-dragon-rendering-details-bufferhandletypewrapper-dragon-mesh-details-indexbufferhandletypekey-unsigned-int64-2-container"><a href="#core-sharedmemorytracker-sharedmemorytrackerimpl-mce-framebuilder-bgfxbridge-meshutils-details-tietoframe-dragon-mesh-indexbufferresourcemanager-std-optional-dragon-rendering-details-bufferhandletypewrapper-dragon-mesh-details-indexbufferhandletypekey-unsigned-int64-2-container" class="header-anchor">#</a> <code>Core::SharedMemoryTracker::SharedMemoryTrackerImpl&lt;</code>mce::framebuilder::bgfxbridge::meshutils::details::_tieToFrame&lt;dragon::mesh::IndexBufferResourceManager,std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::IndexBufferHandleTypeKey,unsigned __int64&gt; &gt; &gt;'::<code>2'::Container&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::SharedMemoryTracker::SharedMemoryTrackerImpl&lt;`mce::framebuilder::bgfxbridge::meshutils::details::_tieToFrame&lt;dragon::mesh::IndexBufferResourceManager,std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::IndexBufferHandleTypeKey,unsigned __int64&gt; &gt; &gt;'::`2'::Container&gt; : Core::SharedMemoryTracker::SharedMemoryTrackerBase
{
  const std::shared_ptr&lt;`mce::framebuilder::bgfxbridge::meshutils::details::_tieToFrame&lt;dragon::mesh::IndexBufferResourceManager,std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::IndexBufferHandleTypeKey,unsigned __int64&gt; &gt; &gt;'::`2'::Container&gt; mInstance;
};

</code></pre></div><h3 id="core-sharedmemorytracker-sharedmemorytrackerimpl-mce-framebuilder-bgfxbridge-meshutils-details-tietoframe-dragon-mesh-indexbufferresourcemanager-std-optional-dragon-rendering-details-bufferhandletypewrapper-dragon-mesh-details-indexbufferhandletypekey-unsigned-int64-2-container-vtbl"><a href="#core-sharedmemorytracker-sharedmemorytrackerimpl-mce-framebuilder-bgfxbridge-meshutils-details-tietoframe-dragon-mesh-indexbufferresourcemanager-std-optional-dragon-rendering-details-bufferhandletypewrapper-dragon-mesh-details-indexbufferhandletypekey-unsigned-int64-2-container-vtbl" class="header-anchor">#</a> <code>Core::SharedMemoryTracker::SharedMemoryTrackerImpl&lt;</code>mce::framebuilder::bgfxbridge::meshutils::details::_tieToFrame&lt;dragon::mesh::IndexBufferResourceManager,std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::IndexBufferHandleTypeKey,unsigned __int64&gt; &gt; &gt;'::<code>2'::Container&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::SharedMemoryTracker::SharedMemoryTrackerImpl&lt;`mce::framebuilder::bgfxbridge::meshutils::details::_tieToFrame&lt;dragon::mesh::IndexBufferResourceManager,std::optional&lt;dragon::rendering::details::BufferHandleTypeWrapper&lt;dragon::mesh::details::IndexBufferHandleTypeKey,unsigned __int64&gt; &gt; &gt;'::`2'::Container&gt;_vtbl
{
  void (__fastcall *~SharedMemoryTrackerBase)(Core::SharedMemoryTracker::SharedMemoryTrackerBase *this);
};

</code></pre></div><h3 id="core-cpuringbufferallocator-dragon-frameobject-preparedblits-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-dragon-frameobject-preparedblits-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::frameobject::PreparedBlits,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;dragon::frameobject::PreparedBlits,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;
{
  Core::CheckedRingBuffer&lt;2,0&gt; *mBufferInstance;
};

</code></pre></div><h3 id="core-cpuringbufferallocator-dragon-frameobject-preparedblits-2-0-core-checkedringbuffer-2-0-rebind-dragon-frameobject-preparedblits"><a href="#core-cpuringbufferallocator-dragon-frameobject-preparedblits-2-0-core-checkedringbuffer-2-0-rebind-dragon-frameobject-preparedblits" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::frameobject::PreparedBlits,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;dragon::frameobject::PreparedBlits&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;dragon::frameobject::PreparedBlits,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;dragon::frameobject::PreparedBlits&gt;
{
};

</code></pre></div><h3 id="core-cpuringbufferallocator-dragon-frameobject-preparedblits-2-0-core-checkedringbuffer-2-0-rebind-std-container-proxy"><a href="#core-cpuringbufferallocator-dragon-frameobject-preparedblits-2-0-core-checkedringbuffer-2-0-rebind-std-container-proxy" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::frameobject::PreparedBlits,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;dragon::frameobject::PreparedBlits,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;std::_Container_proxy&gt;
{
};

</code></pre></div><h3 id="core-cpuringbufferallocator-dragon-frameobject-blitableentity-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-dragon-frameobject-blitableentity-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::frameobject::BlitableEntity,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;dragon::frameobject::BlitableEntity,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;
{
  Core::CheckedRingBuffer&lt;2,0&gt; *mBufferInstance;
};

</code></pre></div><h3 id="core-cpuringbufferallocator-dragon-frameobject-blitableentity-2-0-core-checkedringbuffer-2-0-rebind-dragon-frameobject-blitableentity"><a href="#core-cpuringbufferallocator-dragon-frameobject-blitableentity-2-0-core-checkedringbuffer-2-0-rebind-dragon-frameobject-blitableentity" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::frameobject::BlitableEntity,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;dragon::frameobject::BlitableEntity&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;dragon::frameobject::BlitableEntity,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;dragon::frameobject::BlitableEntity&gt;
{
};

</code></pre></div><h3 id="core-cpuringbufferallocator-dragon-frameobject-blitableentity-2-0-core-checkedringbuffer-2-0-rebind-std-container-proxy"><a href="#core-cpuringbufferallocator-dragon-frameobject-blitableentity-2-0-core-checkedringbuffer-2-0-rebind-std-container-proxy" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::frameobject::BlitableEntity,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;dragon::frameobject::BlitableEntity,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;std::_Container_proxy&gt;
{
};

</code></pre></div><h3 id="core-cpuringbufferallocator-dragon-platform-registry-basicrenderregistry-dragon-frameobject-components-computedispatch-dragon-frameobject-components-viewsetid-dragon-frameobject-components-defaultpasses-alphatest-dragon-frameobject-components-defaultpasses-blit-dragon-frameobject-components-defaultpasses-opaque-dragon-frameobject-components-defaultpasses-stencilwrite-dragon-frameobject-components-defaultpasses-transparent-dragon-frameobject-components-defaultpasses-postfx-dragon-frameobject-components-defaultpasses-ui-dragon-frameobject-components-lightparameters-dragon-frameobject-components-directionallight-dragon-frameobject-components-ambientlight-dragon-frameobject-components-pointlight-dragon-frameobject-components-meshfilter-dragon-frameobject-components-materialfilter-dragon-frameobject-components-particleobject-dragon-frameobject-components-passstate-dragon-frameobject-components-posteffect-dragon-frameobject-components-rendertarget-dragon-frameobject-components-sceneobject-dragon-frameobject-components-sceneoverlayobject-dragon-frameobject-components-scenesky-dragon-frameobject-components-sceneskyobject-dragon-frameobject-components-selectionoverlayobject-dragon-frameobject-components-cubemap-dragon-frameobject-components-shadowsource-dragon-frameobject-components-shadowcaster-dragon-frameobject-components-shadowoverlay-dragon-frameobject-components-shadowvolume-dragon-frameobject-components-sortindex-dragon-frameobject-components-sortorigin-dragon-frameobject-components-transform-dragon-frameobject-components-uielement-dragon-frameobject-components-forcerasterization-dragon-frameobject-components-forcerasterizationwithmultiply-dragon-frameobject-components-raytraceobject-mce-framebuilder-gamecomponents-alphatestcracks-mce-framebuilder-gamecomponents-atmosphere-mce-framebuilder-gamecomponents-blendedcracksobject-mce-framebuilder-gamecomponents-environmentaltext-mce-framebuilder-gamecomponents-gameface-mce-framebuilder-gamecomponents-inlevelcubemapobject-mce-framebuilder-gamecomponents-iteminhandobject-mce-framebuilder-gamecomponents-sceneobjectactors-mce-framebuilder-gamecomponents-transparentiteminworldobject-mce-framebuilder-gamecomponents-waterholeobject-mce-framebuilder-gamecomponents-playerui-mce-framebuilder-gamecomponents-playervision-mce-framebuilder-gamecomponents-overlayui-mce-framebuilder-gamecomponents-vrconfiguration-mce-framebuilder-gamecomponents-vrpresenceobject-mce-framebuilder-gamecomponents-livingroomviewfilter-mce-framebuilder-gamecomponents-livingroomtransitionfilter-mce-framebuilder-gamecomponents-livingroomsceneobject-mce-framebuilder-gamecomponents-vrfloatinguiquad-mce-framebuilder-gamecomponents-fadetoblackeffect-mce-framebuilder-bgfxbridge-rtxminecraftframerendererresources-mce-framebuilder-bgfxbridge-vanillaminecraftframerendererresources-mce-framebuilder-bgfxbridge-holographicminecraftframerendererresources-sortedview-sortable-2-0-core-checkedringbuffer-2-0-rebind-std-container-proxy"><a href="#core-cpuringbufferallocator-dragon-platform-registry-basicrenderregistry-dragon-frameobject-components-computedispatch-dragon-frameobject-components-viewsetid-dragon-frameobject-components-defaultpasses-alphatest-dragon-frameobject-components-defaultpasses-blit-dragon-frameobject-components-defaultpasses-opaque-dragon-frameobject-components-defaultpasses-stencilwrite-dragon-frameobject-components-defaultpasses-transparent-dragon-frameobject-components-defaultpasses-postfx-dragon-frameobject-components-defaultpasses-ui-dragon-frameobject-components-lightparameters-dragon-frameobject-components-directionallight-dragon-frameobject-components-ambientlight-dragon-frameobject-components-pointlight-dragon-frameobject-components-meshfilter-dragon-frameobject-components-materialfilter-dragon-frameobject-components-particleobject-dragon-frameobject-components-passstate-dragon-frameobject-components-posteffect-dragon-frameobject-components-rendertarget-dragon-frameobject-components-sceneobject-dragon-frameobject-components-sceneoverlayobject-dragon-frameobject-components-scenesky-dragon-frameobject-components-sceneskyobject-dragon-frameobject-components-selectionoverlayobject-dragon-frameobject-components-cubemap-dragon-frameobject-components-shadowsource-dragon-frameobject-components-shadowcaster-dragon-frameobject-components-shadowoverlay-dragon-frameobject-components-shadowvolume-dragon-frameobject-components-sortindex-dragon-frameobject-components-sortorigin-dragon-frameobject-components-transform-dragon-frameobject-components-uielement-dragon-frameobject-components-forcerasterization-dragon-frameobject-components-forcerasterizationwithmultiply-dragon-frameobject-components-raytraceobject-mce-framebuilder-gamecomponents-alphatestcracks-mce-framebuilder-gamecomponents-atmosphere-mce-framebuilder-gamecomponents-blendedcracksobject-mce-framebuilder-gamecomponents-environmentaltext-mce-framebuilder-gamecomponents-gameface-mce-framebuilder-gamecomponents-inlevelcubemapobject-mce-framebuilder-gamecomponents-iteminhandobject-mce-framebuilder-gamecomponents-sceneobjectactors-mce-framebuilder-gamecomponents-transparentiteminworldobject-mce-framebuilder-gamecomponents-waterholeobject-mce-framebuilder-gamecomponents-playerui-mce-framebuilder-gamecomponents-playervision-mce-framebuilder-gamecomponents-overlayui-mce-framebuilder-gamecomponents-vrconfiguration-mce-framebuilder-gamecomponents-vrpresenceobject-mce-framebuilder-gamecomponents-livingroomviewfilter-mce-framebuilder-gamecomponents-livingroomtransitionfilter-mce-framebuilder-gamecomponents-livingroomsceneobject-mce-framebuilder-gamecomponents-vrfloatinguiquad-mce-framebuilder-gamecomponents-fadetoblackeffect-mce-framebuilder-bgfxbridge-rtxminecraftframerendererresources-mce-framebuilder-bgfxbridge-vanillaminecraftframerendererresources-mce-framebuilder-bgfxbridge-holographicminecraftframerendererresources-sortedview-sortable-2-0-core-checkedringbuffer-2-0-rebind-std-container-proxy" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::platform::registry::BasicRenderRegistry&lt;dragon::frameobject::components::ComputeDispatch,dragon::frameobject::components::ViewSetId,dragon::frameobject::components::defaultpasses::AlphaTest,dragon::frameobject::components::defaultpasses::Blit,dragon::frameobject::components::defaultpasses::Opaque,dragon::frameobject::components::defaultpasses::StencilWrite,dragon::frameobject::components::defaultpasses::Transparent,dragon::frameobject::components::defaultpasses::PostFX,dragon::frameobject::components::defaultpasses::UI,dragon::frameobject::components::LightParameters,dragon::frameobject::components::DirectionalLight,dragon::frameobject::components::AmbientLight,dragon::frameobject::components::PointLight,dragon::frameobject::components::MeshFilter,dragon::frameobject::components::MaterialFilter,dragon::frameobject::components::ParticleObject,dragon::frameobject::components::PassState,dragon::frameobject::components::PostEffect,dragon::frameobject::components::RenderTarget,dragon::frameobject::components::SceneObject,dragon::frameobject::components::SceneOverlayObject,dragon::frameobject::components::SceneSky,dragon::frameobject::components::SceneSkyObject,dragon::frameobject::components::SelectionOverlayObject,dragon::frameobject::components::Cubemap,dragon::frameobject::components::ShadowSource,dragon::frameobject::components::ShadowCaster,dragon::frameobject::components::ShadowOverlay,dragon::frameobject::components::ShadowVolume,dragon::frameobject::components::SortIndex,dragon::frameobject::components::SortOrigin,dragon::frameobject::components::Transform,dragon::frameobject::components::UIElement,dragon::frameobject::components::ForceRasterization,dragon::frameobject::components::ForceRasterizationWithMultiply,dragon::frameobject::components::RaytraceObject,mce::framebuilder::gamecomponents::AlphaTestCracks,mce::framebuilder::gamecomponents::Atmosphere,mce::framebuilder::gamecomponents::BlendedCracksObject,mce::framebuilder::gamecomponents::EnvironmentalText,mce::framebuilder::gamecomponents::Gameface,mce::framebuilder::gamecomponents::InLevelCubeMapObject,mce::framebuilder::gamecomponents::ItemInHandObject,mce::framebuilder::gamecomponents::SceneObjectActors,mce::framebuilder::gamecomponents::TransparentItemInWorldObject,mce::framebuilder::gamecomponents::WaterHoleObject,mce::framebuilder::gamecomponents::PlayerUI,mce::framebuilder::gamecomponents::PlayerVision,mce::framebuilder::gamecomponents::OverlayUI,mce::framebuilder::gamecomponents::VrConfiguration,mce::framebuilder::gamecomponents::VrPresenceObject,mce::framebuilder::gamecomponents::LivingRoomViewFilter,mce::framebuilder::gamecomponents::LivingRoomTransitionFilter,mce::framebuilder::gamecomponents::LivingRoomSceneObject,mce::framebuilder::gamecomponents::VrFloatingUiQuad,mce::framebuilder::gamecomponents::FadeToBlackEffect,mce::framebuilder::bgfxbridge::RTXMinecraftFrameRendererResources,mce::framebuilder::bgfxbridge::VanillaMinecraftFrameRendererResources,mce::framebuilder::bgfxbridge::HolographicMinecraftFrameRendererResources&gt;::SortedView::Sortable,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::rebind&lt;std::_Container_proxy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;dragon::platform::registry::BasicRenderRegistry&lt;dragon::frameobject::components::ComputeDispatch,dragon::frameobject::components::ViewSetId,dragon::frameobject::components::defaultpasses::AlphaTest,dragon::frameobject::components::defaultpasses::Blit,dragon::frameobject::components::defaultpasses::Opaque,dragon::frameobject::components::defaultpasses::StencilWrite,dragon::frameobject::components::defaultpasses::Transparent,dragon::frameobject::components::defaultpasses::PostFX,dragon::frameobject::components::defaultpasses::UI,dragon::frameobject::components::LightParameters,dragon::frameobject::components::DirectionalLight,dragon::frameobject::components::AmbientLight,dragon::frameobject::components::PointLight,dragon::frameobject::components::MeshFilter,dragon::frameobject::components::MaterialFilter,dragon::frameobject::components::ParticleObject,dragon::frameobject::components::PassState,dragon::frameobject::components::PostEffect,dragon::frameobject::components::RenderTarget
{
};

</code></pre></div><h3 id="cg-taskorder-dependencybuilder"><a href="#cg-taskorder-dependencybuilder" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::DependencyBuilder&lt;&gt;
{
  std::tuple&lt;&gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;
{
  std::tuple&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;
{
  std::tuple&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithaction-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-drawtaskcontext"><a href="#cg-taskorder-taskbuilderwithaction-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-drawtaskcontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext&gt; : cg::taskorder::TaskBuilder&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; &gt;
{
  dragon::rendering::modules::DrawTaskContext mContext;
  std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;,dragon::rendering::modules::DrawTaskContext const &amp;)&gt; mAction;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-drawtaskcontext-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-drawtaskcontext-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-drawtaskcontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-drawtaskcontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-drawtaskcontext-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-drawtaskcontext-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::DrawTaskContext&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;
{
  std::tuple&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;
{
  std::tuple&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;
{
  std::tuple&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="core-cpuringbufferallocator-bgfx-rtlightinfo-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-bgfx-rtlightinfo-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;bgfx::RtLightInfo,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;bgfx::RtLightInfo,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;
{
  Core::CheckedRingBuffer&lt;2,0&gt; *mBufferInstance;
};

</code></pre></div><h3 id="core-cpuringbufferallocator-unsigned-int-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-unsigned-int-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;unsigned int,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;unsigned int,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;
{
  Core::CheckedRingBuffer&lt;2,0&gt; *mBufferInstance;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; : cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;
{
  cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt; &gt; mDependencies;
};

</code></pre></div><h3 id="core-ringallocatorcontainer-unsigned-char-2-0-core-checkedringbuffer-2-0-startnewscope-l2-lambda-50d2638b4de85edd403aa2ef73ce482e"><a href="#core-ringallocatorcontainer-unsigned-char-2-0-core-checkedringbuffer-2-0-startnewscope-l2-lambda-50d2638b4de85edd403aa2ef73ce482e" class="header-anchor">#</a> <code>Core::RingAllocatorContainer&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::startNewScope::__l2::&lt;lambda_50d2638b4de85edd403aa2ef73ce482e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::RingAllocatorContainer&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::startNewScope::__l2::&lt;lambda_50d2638b4de85edd403aa2ef73ce482e&gt;
{
  unsigned __int64 fence;
  std::atomic&lt;unsigned __int64&gt; *lastCompleted;
  std::atomic&lt;bool&gt; *hasLastCompleted;
};

</code></pre></div><h3 id="chunkrenderobjectcollection-addtochunkqueue-l2-lambda-fbe26c8e4f7c9bae2f810aaf7646b609"><a href="#chunkrenderobjectcollection-addtochunkqueue-l2-lambda-fbe26c8e4f7c9bae2f810aaf7646b609" class="header-anchor">#</a> <code>ChunkRenderObjectCollection::addToChunkQueue::__l2::&lt;lambda_fbe26c8e4f7c9bae2f810aaf7646b609&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkRenderObjectCollection::addToChunkQueue::__l2::&lt;lambda_fbe26c8e4f7c9bae2f810aaf7646b609&gt;
{
};

</code></pre></div><h3 id="conditionalbandwidthoptimizationdefinition"><a href="#conditionalbandwidthoptimizationdefinition" class="header-anchor">#</a> <code>ConditionalBandwidthOptimizationDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConditionalBandwidthOptimizationDefinition
{
  ConditionalBandwidthOptimization mDefaultValues;
  std::vector&lt;ConditionalBandwidthOptimization&gt; mConditionalValues;
};

</code></pre></div><h3 id="clientreplaystatepolicy"><a href="#clientreplaystatepolicy" class="header-anchor">#</a> <code>ClientReplayStatePolicy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientReplayStatePolicy : IReplayStatePolicy
{
  unsigned __int64 mLastValidatedFrame;
  unsigned __int64 mLastUnsupportedFrame;
  ReplayStateConfig mConfig;
};

</code></pre></div><h3 id="clientreplaystatepolicy-vtbl"><a href="#clientreplaystatepolicy-vtbl" class="header-anchor">#</a> <code>ClientReplayStatePolicy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientReplayStatePolicy_vtbl
{
  void (__fastcall *~IReplayStatePolicy)(IReplayStatePolicy *this);
  bool (__fastcall *isReplayNeeded)(IReplayStatePolicy *this, AdvanceFrameResult);
  bool (__fastcall *canRewindToFrame)(IReplayStatePolicy *this, IActorMovementProxy *, unsigned __int64, unsigned __int64);
  MovementCorrection *(__fastcall *shouldCorrectMovement)(IReplayStatePolicy *this, MovementCorrection *result, IActorMovementProxy *, const PlayerAuthInputPacket *, unsigned __int64);
  void (__fastcall *flagUnsupportedMovement)(IReplayStatePolicy *this, unsigned __int64);
};

</code></pre></div><h3 id="camerashakesystem"><a href="#camerashakesystem" class="header-anchor">#</a> <code>CameraShakeSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraShakeSystem : ITickingSystem
{
};

</code></pre></div><h3 id="camerashakesystem-vtbl"><a href="#camerashakesystem-vtbl" class="header-anchor">#</a> <code>CameraShakeSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraShakeSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="commandselector-player"><a href="#commandselector-player" class="header-anchor">#</a> <code>CommandSelector&lt;Player&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelector&lt;Player&gt; : CommandSelectorBase
{
};

</code></pre></div><h3 id="camerashakecommand"><a href="#camerashakecommand" class="header-anchor">#</a> <code>CameraShakeCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraShakeCommand : Command
{
  _BYTE mShakeAction[1];
  CameraShakeType mShakeType;
  __declspec(align(8)) CommandSelector&lt;Player&gt; mTargets;
  float mIntensity;
  float mSeconds;
};

</code></pre></div><h3 id="camerashakecommand-vtbl"><a href="#camerashakecommand-vtbl" class="header-anchor">#</a> <code>CameraShakeCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraShakeCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-camerashakecommand-camerashakeaction"><a href="#commandregistry-defaultidconverter-enum-camerashakecommand-camerashakeaction" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum CameraShakeCommand::CameraShakeAction&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum CameraShakeCommand::CameraShakeAction&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-camerashaketype"><a href="#commandregistry-defaultidconverter-enum-camerashaketype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum CameraShakeType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum CameraShakeType&gt;
{
};

</code></pre></div><h3 id="clearspawnpointcommand"><a href="#clearspawnpointcommand" class="header-anchor">#</a> <code>ClearSpawnPointCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClearSpawnPointCommand : Command
{
  CommandSelector&lt;Player&gt; mTargets;
};

</code></pre></div><h3 id="clearspawnpointcommand-vtbl"><a href="#clearspawnpointcommand-vtbl" class="header-anchor">#</a> <code>ClearSpawnPointCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClearSpawnPointCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-eventcommand-eventaction"><a href="#commandregistry-defaultidconverter-enum-eventcommand-eventaction" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum EventCommand::EventAction&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum EventCommand::EventAction&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-fogcommand-mode"><a href="#commandregistry-defaultidconverter-enum-fogcommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum FogCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum FogCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-musiccommand-action"><a href="#commandregistry-defaultidconverter-enum-musiccommand-action" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum MusicCommand::Action&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum MusicCommand::Action&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-musicrepeatmode"><a href="#commandregistry-defaultidconverter-enum-musicrepeatmode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum MusicRepeatMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum MusicRepeatMode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-ridecommand-rideaction"><a href="#commandregistry-defaultidconverter-enum-ridecommand-rideaction" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum RideCommand::RideAction&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum RideCommand::RideAction&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-ridecommand-ridefilltype"><a href="#commandregistry-defaultidconverter-enum-ridecommand-ridefilltype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum RideCommand::RideFillType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum RideCommand::RideFillType&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-ridecommand-teleportrules"><a href="#commandregistry-defaultidconverter-enum-ridecommand-teleportrules" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum RideCommand::TeleportRules&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum RideCommand::TeleportRules&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-ridecommand-riderules"><a href="#commandregistry-defaultidconverter-enum-ridecommand-riderules" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum RideCommand::RideRules&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum RideCommand::RideRules&gt;
{
};

</code></pre></div><h3 id="commandfilepath"><a href="#commandfilepath" class="header-anchor">#</a> <code>CommandFilePath</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandFilePath
{
  std::string mText;
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-schedulecommand-scheduleaction"><a href="#commandregistry-defaultidconverter-enum-schedulecommand-scheduleaction" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ScheduleCommand::ScheduleAction&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ScheduleCommand::ScheduleAction&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-schedulecommand-onarealoadedaction"><a href="#commandregistry-defaultidconverter-enum-schedulecommand-onarealoadedaction" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ScheduleCommand::OnAreaLoadedAction&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ScheduleCommand::OnAreaLoadedAction&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-areatype"><a href="#commandregistry-defaultidconverter-enum-areatype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum AreaType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum AreaType&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-structureblocktype"><a href="#commandregistry-defaultidconverter-enum-structureblocktype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum StructureBlockType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum StructureBlockType&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-structureredstonesavemode"><a href="#commandregistry-defaultidconverter-enum-structureredstonesavemode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum StructureRedstoneSaveMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum StructureRedstoneSaveMode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-mirror"><a href="#commandregistry-defaultidconverter-enum-mirror" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum Mirror&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum Mirror&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-animationmode"><a href="#commandregistry-defaultidconverter-enum-animationmode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum AnimationMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum AnimationMode&gt;
{
};

</code></pre></div><h3 id="commandresponse"><a href="#commandresponse" class="header-anchor">#</a> <code>CommandResponse</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CommandResponse : EventResponse
{
  CurrentCmdVersion mCommandVersion;
  std::vector&lt;HashedString&gt; mRawCommands;
  _BYTE mTarget[2];
  std::vector&lt;Command *&gt; mCompiledCommands;
  bool mIsCompiled;
  bool mSuccess;
};

</code></pre></div><h3 id="commandresponse-vtbl"><a href="#commandresponse-vtbl" class="header-anchor">#</a> <code>CommandResponse_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandResponse_vtbl
{
  void (__fastcall *~EventResponse)(EventResponse *this);
  const std::string *(__fastcall *getName)(EventResponse *this);
  void (__fastcall *executeAction)(EventResponse *this, RenderParams *);
  void (__fastcall *buildSchema)(EventResponse *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,EventResponseCollection&gt; &gt; *, const Factory&lt;EventResponse&gt; *);
};

</code></pre></div><h3 id="commongamemodemessenger"><a href="#commongamemodemessenger" class="header-anchor">#</a> <code>CommonGameModeMessenger</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommonGameModeMessenger : IGameModeMessenger
{
  Player *mPlayer;
};

</code></pre></div><h3 id="clientgamemodemessenger"><a href="#clientgamemodemessenger" class="header-anchor">#</a> <code>ClientGameModeMessenger</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientGameModeMessenger : CommonGameModeMessenger
{
};

</code></pre></div><h3 id="commongamemodemessenger-createblockbreakcapturescope-l2-lambda-66c7794cb235487fc6a2b9c057229d38"><a href="#commongamemodemessenger-createblockbreakcapturescope-l2-lambda-66c7794cb235487fc6a2b9c057229d38" class="header-anchor">#</a> <code>CommonGameModeMessenger::createBlockBreakCaptureScope::__l2::&lt;lambda_66c7794cb235487fc6a2b9c057229d38&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommonGameModeMessenger::createBlockBreakCaptureScope::__l2::&lt;lambda_66c7794cb235487fc6a2b9c057229d38&gt;
{
};

</code></pre></div><h3 id="clientgamemodetimer"><a href="#clientgamemodetimer" class="header-anchor">#</a> <code>ClientGameModeTimer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientGameModeTimer : ServerGameModeTimer
{
};

</code></pre></div><h3 id="crafthandlerbase"><a href="#crafthandlerbase" class="header-anchor">#</a> <code>CraftHandlerBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CraftHandlerBase
{
  CraftHandlerBase_vtbl *__vftable /*VFT*/;
  ItemStackRequestActionCraftHandler *mCraftRequestHandler;
  SparseContainer *mInputSparseContainer;
  _BYTE mCraftActionType[1];
  bool mNonImplementedTrustClientResults;
  std::vector&lt;CraftHandlerBase::ExpectedSlotConsume&gt; mExpectedSlotConsumes;
  std::vector&lt;ItemStack&gt; mExpectedAnywhereConsumes;
  std::vector&lt;CraftHandlerBase::AllowedAnywhereConsume&gt; mAllowedAnywhereConsumes;
  bool mIsCraftRequest;
};

</code></pre></div><h3 id="crafthandlerbase-vtbl"><a href="#crafthandlerbase-vtbl" class="header-anchor">#</a> <code>CraftHandlerBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftHandlerBase_vtbl
{
  void (__fastcall *~CraftHandlerBase)(CraftHandlerBase *this);
  void (__fastcall *endRequestBatch)(CraftHandlerBase *this);
  ItemStackNetResult (__fastcall *_handleCraftAction)(CraftHandlerBase *this, const ItemStackRequestActionCraftBase *);
  void (__fastcall *_postCraftRequest)(CraftHandlerBase *this, const bool);
};

</code></pre></div><h3 id="crafthandlerbase-expectedslotconsume"><a href="#crafthandlerbase-expectedslotconsume" class="header-anchor">#</a> <code>CraftHandlerBase::ExpectedSlotConsume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftHandlerBase::ExpectedSlotConsume
{
  const ContainerEnumName mOpenContainerNetId;
  const unsigned __int8 mSlot;
  ItemStack mItem;
};

</code></pre></div><h3 id="crafthandlerbase-allowedanywhereconsume"><a href="#crafthandlerbase-allowedanywhereconsume" class="header-anchor">#</a> <code>CraftHandlerBase::AllowedAnywhereConsume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftHandlerBase::AllowedAnywhereConsume
{
  const ContainerEnumName mOpenContainerNetId;
  const unsigned __int8 mMinSlot;
  const unsigned __int8 mMaxSlot;
};

</code></pre></div><h3 id="crafthandleranvil"><a href="#crafthandleranvil" class="header-anchor">#</a> <code>CraftHandlerAnvil</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftHandlerAnvil : CraftHandlerBase
{
  Player *mPlayer;
};

</code></pre></div><h3 id="crafthandleranvil-vtbl"><a href="#crafthandleranvil-vtbl" class="header-anchor">#</a> <code>CraftHandlerAnvil_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftHandlerAnvil_vtbl
{
  void (__fastcall *~CraftHandlerBase)(CraftHandlerBase *this);
  void (__fastcall *endRequestBatch)(CraftHandlerBase *this);
  ItemStackNetResult (__fastcall *_handleCraftAction)(CraftHandlerBase *this, const ItemStackRequestActionCraftBase *);
  void (__fastcall *_postCraftRequest)(CraftHandlerBase *this, const bool);
};

</code></pre></div><h3 id="crafthandlermap"><a href="#crafthandlermap" class="header-anchor">#</a> <code>CraftHandlerMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftHandlerMap : CraftHandlerBase
{
  Player *mPlayer;
};

</code></pre></div><h3 id="crafthandlermap-vtbl"><a href="#crafthandlermap-vtbl" class="header-anchor">#</a> <code>CraftHandlerMap_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftHandlerMap_vtbl
{
  void (__fastcall *~CraftHandlerBase)(CraftHandlerBase *this);
  void (__fastcall *endRequestBatch)(CraftHandlerBase *this);
  ItemStackNetResult (__fastcall *_handleCraftAction)(CraftHandlerBase *this, const ItemStackRequestActionCraftBase *);
  void (__fastcall *_postCraftRequest)(CraftHandlerBase *this, const bool);
};

</code></pre></div><h3 id="cerealitemcomponentfactory-constructor"><a href="#cerealitemcomponentfactory-constructor" class="header-anchor">#</a> <code>CerealItemComponentFactory::Constructor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::Constructor
{
  std::function&lt;entt::meta_any __cdecl(void)&gt; construct;
  std::function&lt;entt::meta_any __cdecl(void *)&gt; getAny;
  std::function&lt;entt::meta_type __cdecl(void)&gt; getType;
};

</code></pre></div><h3 id="cerealitemcomponentfactory"><a href="#cerealitemcomponentfactory" class="header-anchor">#</a> <code>CerealItemComponentFactory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-06719c6a2c3b5d51959bc3a07ea538ca"><a href="#componentitem-builditemsfileschema-l4-lambda-06719c6a2c3b5d51959bc3a07ea538ca" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_06719c6a2c3b5d51959bc3a07ea538ca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_06719c6a2c3b5d51959bc3a07ea538ca&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-2f2f706bcb3a0bf3e5f2a3c955f48295"><a href="#componentitem-builditemsfileschema-l4-lambda-2f2f706bcb3a0bf3e5f2a3c955f48295" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_2f2f706bcb3a0bf3e5f2a3c955f48295&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_2f2f706bcb3a0bf3e5f2a3c955f48295&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-5c6573b26e033d881519e3b9f4f05715"><a href="#componentitem-builditemsfileschema-l4-lambda-5c6573b26e033d881519e3b9f4f05715" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_5c6573b26e033d881519e3b9f4f05715&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_5c6573b26e033d881519e3b9f4f05715&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l6-lambda-ddbcbce84c840368bbdc237120389e41"><a href="#componentitem-builditemsfileschema-l6-lambda-ddbcbce84c840368bbdc237120389e41" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l6::&lt;lambda_ddbcbce84c840368bbdc237120389e41&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l6::&lt;lambda_ddbcbce84c840368bbdc237120389e41&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-d595495a43e94c05236da4b389810349"><a href="#componentitem-builditemsfileschema-l4-lambda-d595495a43e94c05236da4b389810349" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_d595495a43e94c05236da4b389810349&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_d595495a43e94c05236da4b389810349&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-38eb25fea691ab1406c1acf589edd873"><a href="#componentitem-builditemsfileschema-l4-lambda-38eb25fea691ab1406c1acf589edd873" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_38eb25fea691ab1406c1acf589edd873&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_38eb25fea691ab1406c1acf589edd873&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-175802e7894a92641c534a19c33e6c10"><a href="#componentitem-builditemsfileschema-l4-lambda-175802e7894a92641c534a19c33e6c10" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_175802e7894a92641c534a19c33e6c10&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_175802e7894a92641c534a19c33e6c10&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-02aae47743cbb042add0642122d8874f"><a href="#componentitem-builditemsfileschema-l4-lambda-02aae47743cbb042add0642122d8874f" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_02aae47743cbb042add0642122d8874f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_02aae47743cbb042add0642122d8874f&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-691fbb34a5d50a8ceff68ca6921f75b0"><a href="#componentitem-builditemsfileschema-l4-lambda-691fbb34a5d50a8ceff68ca6921f75b0" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_691fbb34a5d50a8ceff68ca6921f75b0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_691fbb34a5d50a8ceff68ca6921f75b0&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-f4f9b1f7bb6b4cff9a073b26ea933c62"><a href="#componentitem-builditemsfileschema-l4-lambda-f4f9b1f7bb6b4cff9a073b26ea933c62" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_f4f9b1f7bb6b4cff9a073b26ea933c62&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_f4f9b1f7bb6b4cff9a073b26ea933c62&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-7f04d6eadcd817e72270603a73970837"><a href="#componentitem-builditemsfileschema-l4-lambda-7f04d6eadcd817e72270603a73970837" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_7f04d6eadcd817e72270603a73970837&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_7f04d6eadcd817e72270603a73970837&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-63390f89c85397294c20dc5febc0fd07"><a href="#componentitem-builditemsfileschema-l4-lambda-63390f89c85397294c20dc5febc0fd07" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_63390f89c85397294c20dc5febc0fd07&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_63390f89c85397294c20dc5febc0fd07&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l5-lambda-45ba7706ae68db39b00540d8e8b07001"><a href="#componentitem-builditemsfileschema-l5-lambda-45ba7706ae68db39b00540d8e8b07001" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l5::&lt;lambda_45ba7706ae68db39b00540d8e8b07001&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l5::&lt;lambda_45ba7706ae68db39b00540d8e8b07001&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l5-lambda-47d4656d06b81b5d646e9f09e5a91cca"><a href="#componentitem-builditemsfileschema-l5-lambda-47d4656d06b81b5d646e9f09e5a91cca" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l5::&lt;lambda_47d4656d06b81b5d646e9f09e5a91cca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l5::&lt;lambda_47d4656d06b81b5d646e9f09e5a91cca&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-18ba5b6c5d2ef7335fd7c0944ae1663c"><a href="#componentitem-builditemsfileschema-l4-lambda-18ba5b6c5d2ef7335fd7c0944ae1663c" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_18ba5b6c5d2ef7335fd7c0944ae1663c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_18ba5b6c5d2ef7335fd7c0944ae1663c&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-68857b4446a180a9dd9377d70bb1decc"><a href="#componentitem-builditemsfileschema-l4-lambda-68857b4446a180a9dd9377d70bb1decc" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_68857b4446a180a9dd9377d70bb1decc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_68857b4446a180a9dd9377d70bb1decc&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-f988d10cfe0adfd929abf86d1ed55814"><a href="#componentitem-builditemsfileschema-l4-lambda-f988d10cfe0adfd929abf86d1ed55814" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_f988d10cfe0adfd929abf86d1ed55814&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_f988d10cfe0adfd929abf86d1ed55814&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-83c5c68eb639a0276c8bdd2cc39e4b85"><a href="#componentitem-builditemsfileschema-l4-lambda-83c5c68eb639a0276c8bdd2cc39e4b85" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_83c5c68eb639a0276c8bdd2cc39e4b85&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_83c5c68eb639a0276c8bdd2cc39e4b85&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-595f5c6129412d68260c12d9dc061a20"><a href="#componentitem-builditemsfileschema-l4-lambda-595f5c6129412d68260c12d9dc061a20" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_595f5c6129412d68260c12d9dc061a20&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_595f5c6129412d68260c12d9dc061a20&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-bed6047fd0b105f88228decca5833859"><a href="#componentitem-builditemsfileschema-l4-lambda-bed6047fd0b105f88228decca5833859" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_bed6047fd0b105f88228decca5833859&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_bed6047fd0b105f88228decca5833859&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-32c11f6cbe6cbb01b97d5d3b7fb8f38d"><a href="#componentitem-builditemsfileschema-l4-lambda-32c11f6cbe6cbb01b97d5d3b7fb8f38d" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_32c11f6cbe6cbb01b97d5d3b7fb8f38d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_32c11f6cbe6cbb01b97d5d3b7fb8f38d&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-dcf311d7ddfc638357cf584c349eb24b"><a href="#componentitem-builditemsfileschema-l4-lambda-dcf311d7ddfc638357cf584c349eb24b" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_dcf311d7ddfc638357cf584c349eb24b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_dcf311d7ddfc638357cf584c349eb24b&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-b15cfde9356f80666ac379f076c67168"><a href="#componentitem-builditemsfileschema-l4-lambda-b15cfde9356f80666ac379f076c67168" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_b15cfde9356f80666ac379f076c67168&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_b15cfde9356f80666ac379f076c67168&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-39c57b403cacb9c9123dea5d9ec345ea"><a href="#componentitem-builditemsfileschema-l4-lambda-39c57b403cacb9c9123dea5d9ec345ea" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_39c57b403cacb9c9123dea5d9ec345ea&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_39c57b403cacb9c9123dea5d9ec345ea&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l4-lambda-9e5269047ca309f62857c34b50ac0adc"><a href="#componentitem-builditemsfileschema-l4-lambda-9e5269047ca309f62857c34b50ac0adc" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_9e5269047ca309f62857c34b50ac0adc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l4::&lt;lambda_9e5269047ca309f62857c34b50ac0adc&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l3-lambda-cd737d31e8e90d818a7f3f7365055e81"><a href="#componentitem-builditemsfileschema-l3-lambda-cd737d31e8e90d818a7f3f7365055e81" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l3::&lt;lambda_cd737d31e8e90d818a7f3f7365055e81&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l3::&lt;lambda_cd737d31e8e90d818a7f3f7365055e81&gt;
{
};

</code></pre></div><h3 id="componentitem-builditemsfileschema-l3-lambda-90a6baf7857883a194ebe77b1cedf1a3"><a href="#componentitem-builditemsfileschema-l3-lambda-90a6baf7857883a194ebe77b1cedf1a3" class="header-anchor">#</a> <code>ComponentItem::_buildItemsFileSchema::__l3::&lt;lambda_90a6baf7857883a194ebe77b1cedf1a3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem::_buildItemsFileSchema::__l3::&lt;lambda_90a6baf7857883a194ebe77b1cedf1a3&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-274ac7a05a64284cd76bbdba2c7f8818"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-274ac7a05a64284cd76bbdba2c7f8818" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_274ac7a05a64284cd76bbdba2c7f8818&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_274ac7a05a64284cd76bbdba2c7f8818&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-f2b378848c598de273abc9c9fc78bd8a"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-f2b378848c598de273abc9c9fc78bd8a" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_f2b378848c598de273abc9c9fc78bd8a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_f2b378848c598de273abc9c9fc78bd8a&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-068c29d7af14898cc0fe025dba9cd80d"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-068c29d7af14898cc0fe025dba9cd80d" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_068c29d7af14898cc0fe025dba9cd80d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_068c29d7af14898cc0fe025dba9cd80d&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-13e46b31aebc5784575abe801e3af68a"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-13e46b31aebc5784575abe801e3af68a" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_13e46b31aebc5784575abe801e3af68a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_13e46b31aebc5784575abe801e3af68a&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-df3e8be3050a2aaa62dd5a501ac25eab"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-df3e8be3050a2aaa62dd5a501ac25eab" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_df3e8be3050a2aaa62dd5a501ac25eab&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_df3e8be3050a2aaa62dd5a501ac25eab&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-a33d55fb459f2ffc1340888587c29201"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-a33d55fb459f2ffc1340888587c29201" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_a33d55fb459f2ffc1340888587c29201&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_a33d55fb459f2ffc1340888587c29201&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-ab71e30ee4148f3f451eec67bf750a2a"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-ab71e30ee4148f3f451eec67bf750a2a" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_ab71e30ee4148f3f451eec67bf750a2a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_ab71e30ee4148f3f451eec67bf750a2a&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-674fedb7f8f19d87e68157e57807c141"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-674fedb7f8f19d87e68157e57807c141" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_674fedb7f8f19d87e68157e57807c141&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_674fedb7f8f19d87e68157e57807c141&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-fbfcad4341a57d7201e8e716822f68fd"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-fbfcad4341a57d7201e8e716822f68fd" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_fbfcad4341a57d7201e8e716822f68fd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_fbfcad4341a57d7201e8e716822f68fd&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-180f5e3485a6ae91a471e500c4b06386"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-180f5e3485a6ae91a471e500c4b06386" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_180f5e3485a6ae91a471e500c4b06386&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_180f5e3485a6ae91a471e500c4b06386&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-0466c3aa4f74f39cd825466c6b6232bb"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-0466c3aa4f74f39cd825466c6b6232bb" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_0466c3aa4f74f39cd825466c6b6232bb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_0466c3aa4f74f39cd825466c6b6232bb&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-d1ecf083316e883ec51605168a7eebd9"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-d1ecf083316e883ec51605168a7eebd9" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_d1ecf083316e883ec51605168a7eebd9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_d1ecf083316e883ec51605168a7eebd9&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-7d6ae913546175ea9e8c64323acc6b29"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-7d6ae913546175ea9e8c64323acc6b29" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_7d6ae913546175ea9e8c64323acc6b29&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_7d6ae913546175ea9e8c64323acc6b29&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-18868e8156d02ca320cabd997fadca4d"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-18868e8156d02ca320cabd997fadca4d" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_18868e8156d02ca320cabd997fadca4d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_18868e8156d02ca320cabd997fadca4d&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-18dbba7b3937e5501854c33ea46448cd"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-18dbba7b3937e5501854c33ea46448cd" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_18dbba7b3937e5501854c33ea46448cd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_18dbba7b3937e5501854c33ea46448cd&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-978b09f9bb260f3641dbc8ad330d16a6"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-978b09f9bb260f3641dbc8ad330d16a6" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_978b09f9bb260f3641dbc8ad330d16a6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_978b09f9bb260f3641dbc8ad330d16a6&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-32c4955083c8066406161e037bbdcabf"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-32c4955083c8066406161e037bbdcabf" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_32c4955083c8066406161e037bbdcabf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_32c4955083c8066406161e037bbdcabf&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-219706fd4ead95d36c08ec2e1a4b52d4"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-219706fd4ead95d36c08ec2e1a4b52d4" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_219706fd4ead95d36c08ec2e1a4b52d4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_219706fd4ead95d36c08ec2e1a4b52d4&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-7ec79a3048194f193f9f4c10479687d3"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-7ec79a3048194f193f9f4c10479687d3" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_7ec79a3048194f193f9f4c10479687d3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_7ec79a3048194f193f9f4c10479687d3&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-e796f74887e92174f98aa55bfcc84fcc"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-e796f74887e92174f98aa55bfcc84fcc" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_e796f74887e92174f98aa55bfcc84fcc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_e796f74887e92174f98aa55bfcc84fcc&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-df89224ccc15be7f98b4780aadd49e98"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-df89224ccc15be7f98b4780aadd49e98" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_df89224ccc15be7f98b4780aadd49e98&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_df89224ccc15be7f98b4780aadd49e98&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-887e0dd9da64b3537ec167baeeba1337"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-887e0dd9da64b3537ec167baeeba1337" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_887e0dd9da64b3537ec167baeeba1337&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_887e0dd9da64b3537ec167baeeba1337&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-e7f83d2a8adfecc1c5879c15f8835d5a"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-e7f83d2a8adfecc1c5879c15f8835d5a" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_e7f83d2a8adfecc1c5879c15f8835d5a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_e7f83d2a8adfecc1c5879c15f8835d5a&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-90ba4857f30320eb34346e7df3764bd9"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-90ba4857f30320eb34346e7df3764bd9" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_90ba4857f30320eb34346e7df3764bd9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_90ba4857f30320eb34346e7df3764bd9&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-7f8ddde45b73dfa86374548a1a80a997"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-7f8ddde45b73dfa86374548a1a80a997" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_7f8ddde45b73dfa86374548a1a80a997&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_7f8ddde45b73dfa86374548a1a80a997&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-3522edb357a5909e1bb6b517ae8cb533"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-3522edb357a5909e1bb6b517ae8cb533" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_3522edb357a5909e1bb6b517ae8cb533&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_3522edb357a5909e1bb6b517ae8cb533&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-8a353af2dd3dc6319cbbc0c7b0a3766b"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-8a353af2dd3dc6319cbbc0c7b0a3766b" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_8a353af2dd3dc6319cbbc0c7b0a3766b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_8a353af2dd3dc6319cbbc0c7b0a3766b&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-9b7c706e28804ad377d0ee8443947800"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-9b7c706e28804ad377d0ee8443947800" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_9b7c706e28804ad377d0ee8443947800&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_9b7c706e28804ad377d0ee8443947800&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-ac4ba6fc863681825fa4db0d35c671d7"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-ac4ba6fc863681825fa4db0d35c671d7" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_ac4ba6fc863681825fa4db0d35c671d7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_ac4ba6fc863681825fa4db0d35c671d7&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-aba81f1d54d3bb08fee2ed02ad6fffae"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-aba81f1d54d3bb08fee2ed02ad6fffae" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_aba81f1d54d3bb08fee2ed02ad6fffae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_aba81f1d54d3bb08fee2ed02ad6fffae&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-4186695952b7d78e695ff84e2652712d"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-4186695952b7d78e695ff84e2652712d" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_4186695952b7d78e695ff84e2652712d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_4186695952b7d78e695ff84e2652712d&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-daa59455bd683dd97d2f167f0ad58c7b"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-daa59455bd683dd97d2f167f0ad58c7b" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_daa59455bd683dd97d2f167f0ad58c7b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_daa59455bd683dd97d2f167f0ad58c7b&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-22c8de57e442c7d89b27727ba0838b01"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-22c8de57e442c7d89b27727ba0838b01" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_22c8de57e442c7d89b27727ba0838b01&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_22c8de57e442c7d89b27727ba0838b01&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-6816e2193b5ae4f55d9eb32466d75189"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-6816e2193b5ae4f55d9eb32466d75189" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_6816e2193b5ae4f55d9eb32466d75189&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_6816e2193b5ae4f55d9eb32466d75189&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-e4abdff3da922cda48729af424f6f86f"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-e4abdff3da922cda48729af424f6f86f" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_e4abdff3da922cda48729af424f6f86f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_e4abdff3da922cda48729af424f6f86f&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-2beea1812a0d9e26506ca1bb96d659ef"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-2beea1812a0d9e26506ca1bb96d659ef" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_2beea1812a0d9e26506ca1bb96d659ef&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_2beea1812a0d9e26506ca1bb96d659ef&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-46270c3b5dc354e70ded28050f2ae6b3"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-46270c3b5dc354e70ded28050f2ae6b3" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_46270c3b5dc354e70ded28050f2ae6b3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_46270c3b5dc354e70ded28050f2ae6b3&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-ad0e56c51b79d56ee7f8d1e4164e9b54"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-ad0e56c51b79d56ee7f8d1e4164e9b54" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_ad0e56c51b79d56ee7f8d1e4164e9b54&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_ad0e56c51b79d56ee7f8d1e4164e9b54&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-b3418fd18d79b5cc2a2bef911e213e16"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-b3418fd18d79b5cc2a2bef911e213e16" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_b3418fd18d79b5cc2a2bef911e213e16&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_b3418fd18d79b5cc2a2bef911e213e16&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-a15ce7828021ee33b0cd034b834f8cfa"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-a15ce7828021ee33b0cd034b834f8cfa" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_a15ce7828021ee33b0cd034b834f8cfa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_a15ce7828021ee33b0cd034b834f8cfa&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-741c841a094c69589eb616a6110f5897"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-741c841a094c69589eb616a6110f5897" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_741c841a094c69589eb616a6110f5897&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_741c841a094c69589eb616a6110f5897&gt;
{
};

</code></pre></div><h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-f4c57fcb0432d7cf0fbaa82c6ed46045"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-f4c57fcb0432d7cf0fbaa82c6ed46045" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_f4c57fcb0432d7cf0fbaa82c6ed46045&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_f4c57fcb0432d7cf0fbaa82c6ed46045&gt;
{
};

</code></pre></div><h3 id="customitemregistry"><a href="#customitemregistry" class="header-anchor">#</a> <code>CustomItemRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomItemRegistry
{
};

</code></pre></div><h3 id="customcropblock"><a href="#customcropblock" class="header-anchor">#</a> <code>CustomCropBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomCropBlock : BushBlock
{
  std::vector&lt;std::string&gt; mTargetLandBlocks;
};

</code></pre></div><h3 id="customcropblock-vtbl"><a href="#customcropblock-vtbl" class="header-anchor">#</a> <code>CustomCropBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CustomCropBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="cappedsurfaceattributes-materiallayer"><a href="#cappedsurfaceattributes-materiallayer" class="header-anchor">#</a> <code>CappedSurfaceAttributes::MaterialLayer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CappedSurfaceAttributes::MaterialLayer
{
  const Block *block;
  std::unique_ptr&lt;PerlinNoise&gt; noise;
};

</code></pre></div><h3 id="chainblock"><a href="#chainblock" class="header-anchor">#</a> <code>ChainBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChainBlock : RotatedPillarBlock
{
};

</code></pre></div><h3 id="chainblock-vtbl"><a href="#chainblock-vtbl" class="header-anchor">#</a> <code>ChainBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChainBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="craftingtabledescription-buildschema-l2-lambda-1773ea65163fe404c4642fa29c8a4c51"><a href="#craftingtabledescription-buildschema-l2-lambda-1773ea65163fe404c4642fa29c8a4c51" class="header-anchor">#</a> <code>CraftingTableDescription::buildSchema::__l2::&lt;lambda_1773ea65163fe404c4642fa29c8a4c51&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingTableDescription::buildSchema::__l2::&lt;lambda_1773ea65163fe404c4642fa29c8a4c51&gt;
{
};

</code></pre></div><h3 id="craftingtabledescription-buildschema-l2-lambda-b763889acef0e918448df6dd9fd7b352"><a href="#craftingtabledescription-buildschema-l2-lambda-b763889acef0e918448df6dd9fd7b352" class="header-anchor">#</a> <code>CraftingTableDescription::buildSchema::__l2::&lt;lambda_b763889acef0e918448df6dd9fd7b352&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingTableDescription::buildSchema::__l2::&lt;lambda_b763889acef0e918448df6dd9fd7b352&gt;
{
};

</code></pre></div><h3 id="craftingtabledescription-buildschema-l2-lambda-e2edea0adeb4357ae1bf2247cf9bdf67"><a href="#craftingtabledescription-buildschema-l2-lambda-e2edea0adeb4357ae1bf2247cf9bdf67" class="header-anchor">#</a> <code>CraftingTableDescription::buildSchema::__l2::&lt;lambda_e2edea0adeb4357ae1bf2247cf9bdf67&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingTableDescription::buildSchema::__l2::&lt;lambda_e2edea0adeb4357ae1bf2247cf9bdf67&gt;
{
};

</code></pre></div><h3 id="craftingtabledescription-buildschema-l2-lambda-06044debff39258f61c94d740dbe2662"><a href="#craftingtabledescription-buildschema-l2-lambda-06044debff39258f61c94d740dbe2662" class="header-anchor">#</a> <code>CraftingTableDescription::buildSchema::__l2::&lt;lambda_06044debff39258f61c94d740dbe2662&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingTableDescription::buildSchema::__l2::&lt;lambda_06044debff39258f61c94d740dbe2662&gt;
{
};

</code></pre></div><h3 id="cryingobsidianblock"><a href="#cryingobsidianblock" class="header-anchor">#</a> <code>CryingObsidianBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CryingObsidianBlock : BlockLegacy
{
};

</code></pre></div><h3 id="cryingobsidianblock-vtbl"><a href="#cryingobsidianblock-vtbl" class="header-anchor">#</a> <code>CryingObsidianBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CryingObsidianBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="chunkloadactionlist-tickrequests-l2-lambda-f0a922715729ac9e2b1311f233617b6a"><a href="#chunkloadactionlist-tickrequests-l2-lambda-f0a922715729ac9e2b1311f233617b6a" class="header-anchor">#</a> <code>ChunkLoadActionList::tickRequests::__l2::&lt;lambda_f0a922715729ac9e2b1311f233617b6a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkLoadActionList::tickRequests::__l2::&lt;lambda_f0a922715729ac9e2b1311f233617b6a&gt;
{
  ChunkLoadActionList *const __this;
  ServerLevel *serverLevel;
  Dimension *dimension;
  const unsigned __int64 currentTick;
};

</code></pre></div><h3 id="chunkloadactionlist-loadrequests-l2-lambda-c3a549743ae164c4a4c4097772148871"><a href="#chunkloadactionlist-loadrequests-l2-lambda-c3a549743ae164c4a4c4097772148871" class="header-anchor">#</a> <code>ChunkLoadActionList::_loadRequests::__l2::&lt;lambda_c3a549743ae164c4a4c4097772148871&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkLoadActionList::_loadRequests::__l2::&lt;lambda_c3a549743ae164c4a4c4097772148871&gt;
{
  ChunkLoadActionList *const __this;
  const std::string *dimensionPrefix;
};

</code></pre></div><h3 id="chunkloadedactionloader"><a href="#chunkloadedactionloader" class="header-anchor">#</a> <code>ChunkLoadedActionLoader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkLoadedActionLoader
{
};

</code></pre></div><h3 id="chunkloadpriority"><a href="#chunkloadpriority" class="header-anchor">#</a> <code>ChunkLoadPriority</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkLoadPriority
{
};

</code></pre></div><h3 id="commandresponse-compilecommands-l2-lambda-f50b98393645becdcdd14a0f2234d9a9"><a href="#commandresponse-compilecommands-l2-lambda-f50b98393645becdcdd14a0f2234d9a9" class="header-anchor">#</a> <code>CommandResponse::_compileCommands::__l2::&lt;lambda_f50b98393645becdcdd14a0f2234d9a9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandResponse::_compileCommands::__l2::&lt;lambda_f50b98393645becdcdd14a0f2234d9a9&gt;
{
};

</code></pre></div><h3 id="commandresponse-buildschema-l2-lambda-20a26bb05a82189a789594e7341fca1d"><a href="#commandresponse-buildschema-l2-lambda-20a26bb05a82189a789594e7341fca1d" class="header-anchor">#</a> <code>CommandResponse::buildSchema::__l2::&lt;lambda_20a26bb05a82189a789594e7341fca1d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandResponse::buildSchema::__l2::&lt;lambda_20a26bb05a82189a789594e7341fca1d&gt;
{
  const Factory&lt;EventResponse&gt; *factory;
};

</code></pre></div><h3 id="classid"><a href="#classid" class="header-anchor">#</a> <code>ClassID</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClassID
{
};

</code></pre></div><h3 id="celebratehuntdefinition"><a href="#celebratehuntdefinition" class="header-anchor">#</a> <code>CelebrateHuntDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CelebrateHuntDefinition
{
  bool mBroadcast;
  float mRadius;
  int mDuration;
  ActorFilterGroup mCelebrationTargets;
  std::string mCelebrateSound;
  FloatRange mSoundInterval;
};

</code></pre></div><h3 id="celebratehuntcomponent"><a href="#celebratehuntcomponent" class="header-anchor">#</a> <code>CelebrateHuntComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CelebrateHuntComponent : IEntityComponent
{
  bool mCelebrating;
  Tick mCelebrateUntil;
  Tick mNextSoundEventTick;
};

</code></pre></div><h3 id="campfireblock"><a href="#campfireblock" class="header-anchor">#</a> <code>CampfireBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CampfireBlock : ActorBlock
{
  bool mSpawnRandomParticles;
};

</code></pre></div><h3 id="campfireblock-vtbl"><a href="#campfireblock-vtbl" class="header-anchor">#</a> <code>CampfireBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CampfireBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="catchfiresubcomponent-doonhiteffect-l32-lambda-98d1a10c913b18fb7c66b4e14b62149d"><a href="#catchfiresubcomponent-doonhiteffect-l32-lambda-98d1a10c913b18fb7c66b4e14b62149d" class="header-anchor">#</a> <code>CatchFireSubcomponent::doOnHitEffect::__l32::&lt;lambda_98d1a10c913b18fb7c66b4e14b62149d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CatchFireSubcomponent::doOnHitEffect::__l32::&lt;lambda_98d1a10c913b18fb7c66b4e14b62149d&gt;
{
  Actor **projectileSourceActor;
  BlockPos *blockPos;
  BlockSource *region;
};

</code></pre></div><h3 id="contextaccessor-typederived-entitycontext"><a href="#contextaccessor-typederived-entitycontext" class="header-anchor">#</a> <code>ContextAccessor::TypeDerived&lt;EntityContext&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContextAccessor::TypeDerived&lt;EntityContext&gt; : ContextAccessor::TypeBase
{
  EntityContext mData;
};

</code></pre></div><h3 id="contextaccessor-typederived-entitycontext-vtbl"><a href="#contextaccessor-typederived-entitycontext-vtbl" class="header-anchor">#</a> <code>ContextAccessor::TypeDerived&lt;EntityContext&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContextAccessor::TypeDerived&lt;EntityContext&gt;_vtbl
{
  void (__fastcall *~TypeBase)(ContextAccessor::TypeBase *this);
};

</code></pre></div><h3 id="celebratehuntsystem"><a href="#celebratehuntsystem" class="header-anchor">#</a> <code>CelebrateHuntSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CelebrateHuntSystem : ITickingSystem
{
};

</code></pre></div><h3 id="celebratehuntsystem-vtbl"><a href="#celebratehuntsystem-vtbl" class="header-anchor">#</a> <code>CelebrateHuntSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CelebrateHuntSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="commandblocksystem"><a href="#commandblocksystem" class="header-anchor">#</a> <code>CommandBlockSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandBlockSystem : ITickingSystem
{
};

</code></pre></div><h3 id="commandblocksystem-vtbl"><a href="#commandblocksystem-vtbl" class="header-anchor">#</a> <code>CommandBlockSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandBlockSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="cropblock"><a href="#cropblock" class="header-anchor">#</a> <code>CropBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CropBlock : BushBlock
{
};

</code></pre></div><h3 id="cropblock-vtbl"><a href="#cropblock-vtbl" class="header-anchor">#</a> <code>CropBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CropBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
  const ItemInstance *(__fastcall *getBaseSeed)(CropBlock *this, const ItemInstance *result);
  const ItemInstance *(__fastcall *getBaseCrop)(CropBlock *this, const ItemInstance *result);
  int (__fastcall *getSeedNum)(CropBlock *this, Random *, int, int, bool);
  int (__fastcall *getCropNum)(CropBlock *this, Random *, int, int, bool);
};

</code></pre></div><h3 id="core-memoryfilesystementry"><a href="#core-memoryfilesystementry" class="header-anchor">#</a> <code>Core::MemoryFileSystemEntry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::MemoryFileSystemEntry
{
  Core::MemoryFileSystemEntry_vtbl *__vftable /*VFT*/;
  _BYTE mFileType[4];
  Core::MemoryFileSystemEntryDir *mpParentDir;
  Core::PathBuffer&lt;std::string &gt; mName;
};

</code></pre></div><h3 id="core-memoryfilesystementry-vtbl"><a href="#core-memoryfilesystementry-vtbl" class="header-anchor">#</a> <code>Core::MemoryFileSystemEntry_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::MemoryFileSystemEntry_vtbl
{
  void (__fastcall *~MemoryFileSystemEntry)(Core::MemoryFileSystemEntry *this);
  unsigned __int64 (__fastcall *getNumOpenFiles)(Core::MemoryFileSystemEntry *this);
  Core::Result *(__fastcall *canRemove)(Core::MemoryFileSystemEntry *this, Core::Result *result);
  unsigned __int64 (__fastcall *getSize)(Core::MemoryFileSystemEntry *this);
};

</code></pre></div><h3 id="core-memoryfilesystementrydir-memoryfilesystementryitem"><a href="#core-memoryfilesystementrydir-memoryfilesystementryitem" class="header-anchor">#</a> <code>Core::MemoryFileSystemEntryDir::MemoryFileSystemEntryItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::MemoryFileSystemEntryDir::MemoryFileSystemEntryItem
{
  unsigned int entryId;
  std::unique_ptr&lt;Core::MemoryFileSystemEntry&gt; entry;
};

</code></pre></div><h3 id="core-memoryfilesystementrydir"><a href="#core-memoryfilesystementrydir" class="header-anchor">#</a> <code>Core::MemoryFileSystemEntryDir</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::MemoryFileSystemEntryDir : Core::MemoryFileSystemEntry
{
  std::vector&lt;std::shared_ptr&lt;Core::MemoryFileSystemEntryDir::MemoryFileSystemEntryItem&gt;&gt; mEntryItems;
  unsigned int mOpenFileCount;
};

</code></pre></div><h3 id="core-memoryfilesystementrydir-vtbl"><a href="#core-memoryfilesystementrydir-vtbl" class="header-anchor">#</a> <code>Core::MemoryFileSystemEntryDir_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::MemoryFileSystemEntryDir_vtbl
{
  void (__fastcall *~MemoryFileSystemEntry)(Core::MemoryFileSystemEntry *this);
  unsigned __int64 (__fastcall *getNumOpenFiles)(Core::MemoryFileSystemEntry *this);
  Core::Result *(__fastcall *canRemove)(Core::MemoryFileSystemEntry *this, Core::Result *result);
  unsigned __int64 (__fastcall *getSize)(Core::MemoryFileSystemEntry *this);
};

</code></pre></div><h3 id="core-memoryfilesystementryfile"><a href="#core-memoryfilesystementryfile" class="header-anchor">#</a> <code>Core::MemoryFileSystemEntryFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::MemoryFileSystemEntryFile : Core::MemoryFileSystemEntry
{
  std::vector&lt;char&gt; mData;
  std::vector&lt;Core::MemoryFileSystemFile *&gt; mOpenFiles;
};

</code></pre></div><h3 id="core-memoryfilesystemfile"><a href="#core-memoryfilesystemfile" class="header-anchor">#</a> <code>Core::MemoryFileSystemFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::MemoryFileSystemFile : Core::FileImpl
{
  Core::MemoryFileSystemEntryFile *mpEntry;
  unsigned __int64 mPosition;
  Core::FileOpenMode mFileOpenMode;
};

</code></pre></div><h3 id="core-memoryfilesystemfile-vtbl"><a href="#core-memoryfilesystemfile-vtbl" class="header-anchor">#</a> <code>Core::MemoryFileSystemFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::MemoryFileSystemFile_vtbl
{
  void (__fastcall *~FileImpl)(Core::FileImpl *this);
  Core::PathBuffer&lt;std::string &gt; *(__fastcall *_getPath)(Core::FileImpl *this, Core::PathBuffer&lt;std::string &gt; *result);
  unsigned __int64 (__fastcall *_getBlockSize)(Core::FileImpl *this);
  bool (__fastcall *_isOpen)(Core::FileImpl *this);
  Core::Result *(__fastcall *_close)(Core::FileImpl *this, Core::Result *result);
  Core::Result *(__fastcall *_read)(Core::FileImpl *this, Core::Result *result, void *, unsigned __int64, unsigned __int64 *);
  Core::Result *(__fastcall *_readExactly)(Core::FileImpl *this, Core::Result *result, void *, unsigned __int64);
  Core::Result *(__fastcall *_skip)(Core::FileImpl *this, Core::Result *result, unsigned __int64);
  Core::Result *(__fastcall *_readAtPosition)(Core::FileImpl *this, Core::Result *result, unsigned __int64, void *, unsigned __int64, unsigned __int64 *);
  Core::Result *(__fastcall *_getPosition)(Core::FileImpl *this, Core::Result *result, unsigned __int64 *);
  Core::Result *(__fastcall *_setPosition)(Core::FileImpl *this, Core::Result *result, unsigned __int64);
  Core::Result *(__fastcall *_write)(Core::FileImpl *this, Core::Result *result, const void *, unsigned __int64);
  Core::Result *(__fastcall *_flush)(Core::FileImpl *this, Core::Result *result);
  Core::Result *(__fastcall *_getSize)(Core::FileImpl *this, Core::Result *result, unsigned __int64 *);
  Core::Result *(__fastcall *_getRemainingSize)(Core::FileImpl *this, Core::Result *result, unsigned __int64 *);
};

</code></pre></div><h3 id="core-memoryfilesystementryfile-vtbl"><a href="#core-memoryfilesystementryfile-vtbl" class="header-anchor">#</a> <code>Core::MemoryFileSystemEntryFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::MemoryFileSystemEntryFile_vtbl
{
  void (__fastcall *~MemoryFileSystemEntry)(Core::MemoryFileSystemEntry *this);
  unsigned __int64 (__fastcall *getNumOpenFiles)(Core::MemoryFileSystemEntry *this);
  Core::Result *(__fastcall *canRemove)(Core::MemoryFileSystemEntry *this, Core::Result *result);
  unsigned __int64 (__fastcall *getSize)(Core::MemoryFileSystemEntry *this);
};

</code></pre></div><h3 id="core-memoryfilesystem-writeop"><a href="#core-memoryfilesystem-writeop" class="header-anchor">#</a> <code>Core::MemoryFileSystem::WriteOp</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::MemoryFileSystem::WriteOp
{
  Core::PathBuffer&lt;std::string &gt; writePath;
  unsigned __int64 writeSize;
};

</code></pre></div><h3 id="core-memoryfilesystem"><a href="#core-memoryfilesystem" class="header-anchor">#</a> <code>Core::MemoryFileSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::MemoryFileSystem : Core::FileSystemImpl
{
  std::recursive_mutex mMutex;
  Core::MemoryFileSystemEntryDir mRootDir;
  std::mutex mWriteOpMutex;
  std::vector&lt;Core::MemoryFileSystem::WriteOp&gt; mWriteOps;
  std::vector&lt;Core::PathBuffer&lt;std::string &gt;&gt; mFilesMarkedForRemoval;
};

</code></pre></div><h3 id="controlleddiskaccess-core-filesystem-windows-controlleddiskaccessentry"><a href="#controlleddiskaccess-core-filesystem-windows-controlleddiskaccessentry" class="header-anchor">#</a> <code>ControlledDiskAccess&lt;Core::FileSystem_windows&gt;::ControlledDiskAccessEntry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ControlledDiskAccess&lt;Core::FileSystem_windows&gt;::ControlledDiskAccessEntry
{
  unsigned int priority;
  ControlledDiskAccess&lt;Core::FileSystem_windows&gt;::CDA_Command command;
  Core::PathBuffer&lt;std::string &gt; sourcePath;
  Core::PathBuffer&lt;std::string &gt; targetPath;
};

</code></pre></div><h3 id="controlleddiskaccess-core-filesystem-windows"><a href="#controlleddiskaccess-core-filesystem-windows" class="header-anchor">#</a> <code>ControlledDiskAccess&lt;Core::FileSystem_windows&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ControlledDiskAccess&lt;Core::FileSystem_windows&gt;
{
  unsigned __int64 mMaxWriteAmountPerSecond;
  unsigned int mMaxNumberOfWritesPerMinute;
  Core::MemoryFileSystem *mFSSource;
  Core::FileSystemImpl *mFSTarget;
  std::atomic&lt;bool&gt; mCommandExecutionInProgress;
  std::unique_ptr&lt;TaskGroup&gt; mIOTaskGroup;
  bool mPartialFileWrite;
  unsigned __int64 mPartialFilePosition;
  std::mutex mMutex;
  std::queue&lt;std::unique_ptr&lt;ControlledDiskAccess&lt;Core::FileSystem_windows&gt;::ControlledDiskAccessEntry,std::default_delete&lt;ControlledDiskAccess&lt;Core::FileSystem_windows&gt;::ControlledDiskAccessEntry&gt; &gt;&gt; mQueue;
  std::unique_ptr&lt;ControlledDiskAccess&lt;Core::FileSystem_windows&gt;::ControlledDiskAccessEntry,std::default_delete&lt;ControlledDiskAccess&lt;Core::FileSystem_windows&gt;::ControlledDiskAccessEntry&gt; &gt; mCurrentEntry;
  std::shared_ptr&lt;Core::ZipUtils::ZipProgress&gt; mProgressTracker;
};

</code></pre></div><h3 id="core-storagebackedmemoryfilesystem"><a href="#core-storagebackedmemoryfilesystem" class="header-anchor">#</a> <code>Core::StorageBackedMemoryFileSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::StorageBackedMemoryFileSystem : Core::FileSystemImpl
{
  std::unique_ptr&lt;Core::FileSystem_windows&gt; mFileSystem;
  std::unique_ptr&lt;Core::MemoryFileSystem&gt; mMemoryFileSystem;
  std::shared_ptr&lt;ControlledDiskAccess&lt;Core::FileSystem_windows&gt; &gt; mControlledDiskAccess;
  bool mShouldFlushToDisk;
  std::atomic&lt;bool&gt; mShouldCommit;
  unsigned __int64 mWriteVolumeLimitInBytesPerSecond;
  unsigned int mWriteQuantityLimitInCountPerMinute;
};

</code></pre></div><h3 id="core-storagebackedmemoryfilesystem-directoryitem"><a href="#core-storagebackedmemoryfilesystem-directoryitem" class="header-anchor">#</a> <code>Core::StorageBackedMemoryFileSystem::DirectoryItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::StorageBackedMemoryFileSystem::DirectoryItem
{
  Core::PathBuffer&lt;Core::StackString&lt;char,1024&gt; &gt; fullPathStr;
  unsigned __int64 fileSize;
  _BYTE fileType[4];
  Core::PathBuffer&lt;Core::StackString&lt;char,1024&gt; &gt; name;
};

</code></pre></div><h3 id="core-flatfileoperations"><a href="#core-flatfileoperations" class="header-anchor">#</a> <code>Core::FlatFileOperations</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FlatFileOperations
{
};

</code></pre></div><h3 id="core-storagebackedmemoryfilesystem-iterateoverdirectory-l2-lambda-c6419e72899cf220491cef01ab66c9a5"><a href="#core-storagebackedmemoryfilesystem-iterateoverdirectory-l2-lambda-c6419e72899cf220491cef01ab66c9a5" class="header-anchor">#</a> <code>Core::StorageBackedMemoryFileSystem::_iterateOverDirectory::__l2::&lt;lambda_c6419e72899cf220491cef01ab66c9a5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::StorageBackedMemoryFileSystem::_iterateOverDirectory::__l2::&lt;lambda_c6419e72899cf220491cef01ab66c9a5&gt;
{
  Core::DirectoryIterationFlags *flags;
  std::vector&lt;Core::StorageBackedMemoryFileSystem::DirectoryItem&gt; *directoryItems;
};

</code></pre></div><h3 id="core-storagebackedmemoryfilesystemproxy"><a href="#core-storagebackedmemoryfilesystemproxy" class="header-anchor">#</a> <code>Core::StorageBackedMemoryFileSystemProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::StorageBackedMemoryFileSystemProxy : Core::FileSystemImpl
{
  std::shared_ptr&lt;Core::FileSystemImpl&gt; mImpl;
  std::vector&lt;Core::PathBuffer&lt;std::string &gt;&gt; mOpenWrites;
};

</code></pre></div><h3 id="compressednetworkpeer"><a href="#compressednetworkpeer" class="header-anchor">#</a> <code>CompressedNetworkPeer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompressedNetworkPeer : NetworkPeer
{
  std::string mSendBuffer;
  std::string mReceiveBuffer;
};

</code></pre></div><h3 id="compressednetworkpeer-vtbl"><a href="#compressednetworkpeer-vtbl" class="header-anchor">#</a> <code>CompressedNetworkPeer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CompressedNetworkPeer_vtbl
{
  void (__fastcall *~NetworkPeer)(NetworkPeer *this);
  void (__fastcall *sendPacket)(NetworkPeer *this, const std::string *, NetworkPeer::Reliability, int, unsigned __int16, Compressibility);
  NetworkPeer::DataStatus (__fastcall *receivePacket)(NetworkPeer *this, std::string *);
  NetworkPeer::NetworkStatus *(__fastcall *getNetworkStatus)(NetworkPeer *this, NetworkPeer::NetworkStatus *result);
  void (__fastcall *addIncomingData)(NetworkPeer *this, std::string);
  void (__fastcall *update)(NetworkPeer *this);
  void (__fastcall *flush)(NetworkPeer *this, std::function&lt;void __cdecl(void)&gt; *);
};

</code></pre></div><h3 id="crypto-hash-hash-vtbl"><a href="#crypto-hash-hash-vtbl" class="header-anchor">#</a> <code>Crypto::Hash::Hash_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Crypto::Hash::Hash_vtbl
{
  void (__fastcall *~IHash)(Crypto::Hash::IHash *this);
  void (__fastcall *reset)(Crypto::Hash::IHash *this);
  void (__fastcall *update)(Crypto::Hash::IHash *this, const void *, unsigned int);
  void (__fastcall *final)(Crypto::Hash::IHash *this, unsigned __int8 *);
  unsigned __int64 (__fastcall *resultSize)(Crypto::Hash::IHash *this);
};

</code></pre></div><h3 id="commandoutputpacket-read-l2-lambda-04a2fcb1d096da0a1dd9aa4cbad0e15c"><a href="#commandoutputpacket-read-l2-lambda-04a2fcb1d096da0a1dd9aa4cbad0e15c" class="header-anchor">#</a> <code>CommandOutputPacket::read::__l2::&lt;lambda_04a2fcb1d096da0a1dd9aa4cbad0e15c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandOutputPacket::read::__l2::&lt;lambda_04a2fcb1d096da0a1dd9aa4cbad0e15c&gt;
{
};

</code></pre></div><h3 id="commandoutputpacket-read-l2-lambda-04a2fcb1d096da0a1dd9aa4cbad0e15c-l2-lambda-111bef47aba037e64e2de7ab058b2546"><a href="#commandoutputpacket-read-l2-lambda-04a2fcb1d096da0a1dd9aa4cbad0e15c-l2-lambda-111bef47aba037e64e2de7ab058b2546" class="header-anchor">#</a> <code>CommandOutputPacket::read::__l2::&lt;lambda_04a2fcb1d096da0a1dd9aa4cbad0e15c&gt;::()::__l2::&lt;lambda_111bef47aba037e64e2de7ab058b2546&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandOutputPacket::read::__l2::&lt;lambda_04a2fcb1d096da0a1dd9aa4cbad0e15c&gt;::()::__l2::&lt;lambda_111bef47aba037e64e2de7ab058b2546&gt;
{
};

</code></pre></div><h3 id="commandoutputpacket-write-l2-lambda-5c0d0a82998e37e66147a0d26f6f41e9"><a href="#commandoutputpacket-write-l2-lambda-5c0d0a82998e37e66147a0d26f6f41e9" class="header-anchor">#</a> <code>CommandOutputPacket::write::__l2::&lt;lambda_5c0d0a82998e37e66147a0d26f6f41e9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandOutputPacket::write::__l2::&lt;lambda_5c0d0a82998e37e66147a0d26f6f41e9&gt;
{
};

</code></pre></div><h3 id="commandoutputpacket-write-l2-lambda-5c0d0a82998e37e66147a0d26f6f41e9-l2-lambda-08a2613ea832ae6e1c316072b3dcf92d"><a href="#commandoutputpacket-write-l2-lambda-5c0d0a82998e37e66147a0d26f6f41e9-l2-lambda-08a2613ea832ae6e1c316072b3dcf92d" class="header-anchor">#</a> <code>CommandOutputPacket::write::__l2::&lt;lambda_5c0d0a82998e37e66147a0d26f6f41e9&gt;::()::__l2::&lt;lambda_08a2613ea832ae6e1c316072b3dcf92d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandOutputPacket::write::__l2::&lt;lambda_5c0d0a82998e37e66147a0d26f6f41e9&gt;::()::__l2::&lt;lambda_08a2613ea832ae6e1c316072b3dcf92d&gt;
{
};

</code></pre></div><h3 id="clientboundmapitemdatapacket-write-l14-lambda-c1e7efae3b5dc21032bb93b639f0a656"><a href="#clientboundmapitemdatapacket-write-l14-lambda-c1e7efae3b5dc21032bb93b639f0a656" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket::write::__l14::&lt;lambda_c1e7efae3b5dc21032bb93b639f0a656&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientboundMapItemDataPacket::write::__l14::&lt;lambda_c1e7efae3b5dc21032bb93b639f0a656&gt;
{
};

</code></pre></div><h3 id="clientboundmapitemdatapacket-write-l11-lambda-461be92f04b6766159e2a14649e21c49"><a href="#clientboundmapitemdatapacket-write-l11-lambda-461be92f04b6766159e2a14649e21c49" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket::write::__l11::&lt;lambda_461be92f04b6766159e2a14649e21c49&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientboundMapItemDataPacket::write::__l11::&lt;lambda_461be92f04b6766159e2a14649e21c49&gt;
{
};

</code></pre></div><h3 id="clientboundmapitemdatapacket-write-l11-lambda-fac84794c48ef9a05c921b62900cfc23"><a href="#clientboundmapitemdatapacket-write-l11-lambda-fac84794c48ef9a05c921b62900cfc23" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket::write::__l11::&lt;lambda_fac84794c48ef9a05c921b62900cfc23&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientboundMapItemDataPacket::write::__l11::&lt;lambda_fac84794c48ef9a05c921b62900cfc23&gt;
{
};

</code></pre></div><h3 id="clientboundmapitemdatapacket-write-l5-lambda-b4233823788b03f84b72100ad9164053"><a href="#clientboundmapitemdatapacket-write-l5-lambda-b4233823788b03f84b72100ad9164053" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket::write::__l5::&lt;lambda_b4233823788b03f84b72100ad9164053&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientboundMapItemDataPacket::write::__l5::&lt;lambda_b4233823788b03f84b72100ad9164053&gt;
{
};

</code></pre></div><h3 id="clientboundmapitemdatapacket-read-l11-lambda-299406233ccff525293e6b278e5e2143"><a href="#clientboundmapitemdatapacket-read-l11-lambda-299406233ccff525293e6b278e5e2143" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket::read::__l11::&lt;lambda_299406233ccff525293e6b278e5e2143&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientboundMapItemDataPacket::read::__l11::&lt;lambda_299406233ccff525293e6b278e5e2143&gt;
{
};

</code></pre></div><h3 id="clientboundmapitemdatapacket-read-l11-lambda-4627a9aa0712be76211aa31f1c634fab"><a href="#clientboundmapitemdatapacket-read-l11-lambda-4627a9aa0712be76211aa31f1c634fab" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket::read::__l11::&lt;lambda_4627a9aa0712be76211aa31f1c634fab&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientboundMapItemDataPacket::read::__l11::&lt;lambda_4627a9aa0712be76211aa31f1c634fab&gt;
{
};

</code></pre></div><h3 id="clientboundmapitemdatapacket-read-l5-lambda-a6c59ce5d5173a7b49ebcbdb4d1edebc"><a href="#clientboundmapitemdatapacket-read-l5-lambda-a6c59ce5d5173a7b49ebcbdb4d1edebc" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket::read::__l5::&lt;lambda_a6c59ce5d5173a7b49ebcbdb4d1edebc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientboundMapItemDataPacket::read::__l5::&lt;lambda_a6c59ce5d5173a7b49ebcbdb4d1edebc&gt;
{
};

</code></pre></div><h3 id="creativecontentpacket-read-l2-lambda-96e9e64950119d68213f99866c7e0253"><a href="#creativecontentpacket-read-l2-lambda-96e9e64950119d68213f99866c7e0253" class="header-anchor">#</a> <code>CreativeContentPacket::read::__l2::&lt;lambda_96e9e64950119d68213f99866c7e0253&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreativeContentPacket::read::__l2::&lt;lambda_96e9e64950119d68213f99866c7e0253&gt;
{
  unsigned int *i;
};

</code></pre></div><h3 id="creativecontentpacket-write-l5-lambda-45d3c2d0ca3ded40260607e2e7c69dc2"><a href="#creativecontentpacket-write-l5-lambda-45d3c2d0ca3ded40260607e2e7c69dc2" class="header-anchor">#</a> <code>CreativeContentPacket::write::__l5::&lt;lambda_45d3c2d0ca3ded40260607e2e7c69dc2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreativeContentPacket::write::__l5::&lt;lambda_45d3c2d0ca3ded40260607e2e7c69dc2&gt;
{
};

</code></pre></div><h3 id="craftingeventpacket-read-l2-lambda-3623cfbc0b234474e5a7a6043a32091c"><a href="#craftingeventpacket-read-l2-lambda-3623cfbc0b234474e5a7a6043a32091c" class="header-anchor">#</a> <code>CraftingEventPacket::read::__l2::&lt;lambda_3623cfbc0b234474e5a7a6043a32091c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingEventPacket::read::__l2::&lt;lambda_3623cfbc0b234474e5a7a6043a32091c&gt;
{
};

</code></pre></div><h3 id="craftingeventpacket-read-l2-lambda-6b5d3f89745eb1b42b1abcdc2cfecf6e"><a href="#craftingeventpacket-read-l2-lambda-6b5d3f89745eb1b42b1abcdc2cfecf6e" class="header-anchor">#</a> <code>CraftingEventPacket::read::__l2::&lt;lambda_6b5d3f89745eb1b42b1abcdc2cfecf6e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingEventPacket::read::__l2::&lt;lambda_6b5d3f89745eb1b42b1abcdc2cfecf6e&gt;
{
};

</code></pre></div><h3 id="craftingeventpacket-write-l2-lambda-8d95ef7248562c60723dda14c08a47de"><a href="#craftingeventpacket-write-l2-lambda-8d95ef7248562c60723dda14c08a47de" class="header-anchor">#</a> <code>CraftingEventPacket::write::__l2::&lt;lambda_8d95ef7248562c60723dda14c08a47de&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingEventPacket::write::__l2::&lt;lambda_8d95ef7248562c60723dda14c08a47de&gt;
{
};

</code></pre></div><h3 id="craftingeventpacket-write-l2-lambda-8cfbdd6deaa5624e9cb513c03578c983"><a href="#craftingeventpacket-write-l2-lambda-8cfbdd6deaa5624e9cb513c03578c983" class="header-anchor">#</a> <code>CraftingEventPacket::write::__l2::&lt;lambda_8cfbdd6deaa5624e9cb513c03578c983&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingEventPacket::write::__l2::&lt;lambda_8cfbdd6deaa5624e9cb513c03578c983&gt;
{
};

</code></pre></div><h3 id="craftingdatapacket-read-l21-lambda-0281d7cf4dad9b4308c03ae95eb3a525"><a href="#craftingdatapacket-read-l21-lambda-0281d7cf4dad9b4308c03ae95eb3a525" class="header-anchor">#</a> <code>CraftingDataPacket::read::__l21::&lt;lambda_0281d7cf4dad9b4308c03ae95eb3a525&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingDataPacket::read::__l21::&lt;lambda_0281d7cf4dad9b4308c03ae95eb3a525&gt;
{
};

</code></pre></div><h3 id="craftingdatapacket-read-l2-lambda-1b84a61e5063cd2a0e9cc8970d0b665a"><a href="#craftingdatapacket-read-l2-lambda-1b84a61e5063cd2a0e9cc8970d0b665a" class="header-anchor">#</a> <code>CraftingDataPacket::read::__l2::&lt;lambda_1b84a61e5063cd2a0e9cc8970d0b665a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingDataPacket::read::__l2::&lt;lambda_1b84a61e5063cd2a0e9cc8970d0b665a&gt;
{
};

</code></pre></div><h3 id="craftingdatapacket-read-l2-lambda-54bc7cd634b04089ec4ff322c27cddbb"><a href="#craftingdatapacket-read-l2-lambda-54bc7cd634b04089ec4ff322c27cddbb" class="header-anchor">#</a> <code>CraftingDataPacket::read::__l2::&lt;lambda_54bc7cd634b04089ec4ff322c27cddbb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingDataPacket::read::__l2::&lt;lambda_54bc7cd634b04089ec4ff322c27cddbb&gt;
{
};

</code></pre></div><h3 id="craftingdatapacket-read-l2-lambda-03aa26e243735ee9ece5930a778e19bb"><a href="#craftingdatapacket-read-l2-lambda-03aa26e243735ee9ece5930a778e19bb" class="header-anchor">#</a> <code>CraftingDataPacket::read::__l2::&lt;lambda_03aa26e243735ee9ece5930a778e19bb&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingDataPacket::read::__l2::&lt;lambda_03aa26e243735ee9ece5930a778e19bb&gt;
{
};

</code></pre></div><h3 id="craftingdatapacket-write-l2-lambda-e5ff81a04513ae571fd2ed01ede86d57"><a href="#craftingdatapacket-write-l2-lambda-e5ff81a04513ae571fd2ed01ede86d57" class="header-anchor">#</a> <code>CraftingDataPacket::write::__l2::&lt;lambda_e5ff81a04513ae571fd2ed01ede86d57&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingDataPacket::write::__l2::&lt;lambda_e5ff81a04513ae571fd2ed01ede86d57&gt;
{
};

</code></pre></div><h3 id="craftingdatapacket-write-l2-lambda-f66ca93671b251d3fd735aa0bf744948"><a href="#craftingdatapacket-write-l2-lambda-f66ca93671b251d3fd735aa0bf744948" class="header-anchor">#</a> <code>CraftingDataPacket::write::__l2::&lt;lambda_f66ca93671b251d3fd735aa0bf744948&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingDataPacket::write::__l2::&lt;lambda_f66ca93671b251d3fd735aa0bf744948&gt;
{
};

</code></pre></div><h3 id="craftingdatapacket-write-l2-lambda-b8b5ea0a1f44ec41ec43cb7cf66d6afd"><a href="#craftingdatapacket-write-l2-lambda-b8b5ea0a1f44ec41ec43cb7cf66d6afd" class="header-anchor">#</a> <code>CraftingDataPacket::write::__l2::&lt;lambda_b8b5ea0a1f44ec41ec43cb7cf66d6afd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingDataPacket::write::__l2::&lt;lambda_b8b5ea0a1f44ec41ec43cb7cf66d6afd&gt;
{
};

</code></pre></div><h3 id="craftingdatapacket-write-l2-lambda-f0c4f01fa12286088002e5b7913413d8"><a href="#craftingdatapacket-write-l2-lambda-f0c4f01fa12286088002e5b7913413d8" class="header-anchor">#</a> <code>CraftingDataPacket::write::__l2::&lt;lambda_f0c4f01fa12286088002e5b7913413d8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingDataPacket::write::__l2::&lt;lambda_f0c4f01fa12286088002e5b7913413d8&gt;
{
};

</code></pre></div><h3 id="crypto-encryptedfileheader-unnamed-type-efheader"><a href="#crypto-encryptedfileheader-unnamed-type-efheader" class="header-anchor">#</a> <code>Crypto::encryptedFileHeader::&lt;unnamed_type__efheader&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct Crypto::encryptedFileHeader::&lt;unnamed_type__efheader&gt;
{
  unsigned int _version;
  Crypto::signatureValue _efsignature;
  unsigned int _data1;
  unsigned int _data2;
  unsigned __int8 _IdSize;
  char _IdName[239];
};

</code></pre></div><h3 id="compositepacksource-foreachpack-l6-lambda-367a75bf960abb288ec97e873c12428a"><a href="#compositepacksource-foreachpack-l6-lambda-367a75bf960abb288ec97e873c12428a" class="header-anchor">#</a> <code>CompositePackSource::forEachPack::__l6::&lt;lambda_367a75bf960abb288ec97e873c12428a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompositePackSource::forEachPack::__l6::&lt;lambda_367a75bf960abb288ec97e873c12428a&gt;
{
  std::vector&lt;PackIdVersion&gt; *visitedPacks;
  std::function&lt;void __cdecl(Pack &amp;)&gt; *callback;
};

</code></pre></div><h3 id="compositepacksource-foreachpackconst-l6-lambda-559bc3fba05953cf51044a45a84dcf0d"><a href="#compositepacksource-foreachpackconst-l6-lambda-559bc3fba05953cf51044a45a84dcf0d" class="header-anchor">#</a> <code>CompositePackSource::forEachPackConst::__l6::&lt;lambda_559bc3fba05953cf51044a45a84dcf0d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompositePackSource::forEachPackConst::__l6::&lt;lambda_559bc3fba05953cf51044a45a84dcf0d&gt;
{
  std::vector&lt;PackIdVersion&gt; *visitedPacks;
  std::function&lt;void __cdecl(Pack const &amp;)&gt; *callback;
};

</code></pre></div><h3 id="core-unzipinternals"><a href="#core-unzipinternals" class="header-anchor">#</a> <code>Core::UnzipInternals</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::UnzipInternals
{
  void *mZipFile;
};

</code></pre></div><h3 id="commandmessage-messagecomponent"><a href="#commandmessage-messagecomponent" class="header-anchor">#</a> <code>CommandMessage::MessageComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandMessage::MessageComponent
{
  std::string string;
  std::unique_ptr&lt;CommandSelector&lt;Actor&gt;&gt; selection;
};

</code></pre></div><h3 id="commandmessage"><a href="#commandmessage" class="header-anchor">#</a> <code>CommandMessage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandMessage
{
  std::vector&lt;CommandMessage::MessageComponent&gt; mData;
};

</code></pre></div><h3 id="commandrawtext"><a href="#commandrawtext" class="header-anchor">#</a> <code>CommandRawText</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRawText
{
  std::string mText;
};

</code></pre></div><h3 id="commandwildcardint"><a href="#commandwildcardint" class="header-anchor">#</a> <code>CommandWildcardInt</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandWildcardInt
{
  bool mIsWildcard;
  int mValue;
};

</code></pre></div><h3 id="clientautomationcommandorigin"><a href="#clientautomationcommandorigin" class="header-anchor">#</a> <code>ClientAutomationCommandOrigin</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientAutomationCommandOrigin : CommandOrigin
{
  std::string mRequestId;
};

</code></pre></div><h3 id="clientautomationcommandorigin-vtbl"><a href="#clientautomationcommandorigin-vtbl" class="header-anchor">#</a> <code>ClientAutomationCommandOrigin_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientAutomationCommandOrigin_vtbl
{
  void (__fastcall *~CommandOrigin)(CommandOrigin *this);
  const std::string *(__fastcall *getRequestId)(CommandOrigin *this);
  std::string *(__fastcall *getName)(CommandOrigin *this, std::string *result);
  BlockPos *(__fastcall *getBlockPosition)(CommandOrigin *this, BlockPos *result);
  Vec3 *(__fastcall *getWorldPosition)(CommandOrigin *this, Vec3 *result);
  Level *(__fastcall *getLevel)(CommandOrigin *this);
  Dimension *(__fastcall *getDimension)(CommandOrigin *this);
  Actor *(__fastcall *getEntity)(CommandOrigin *this);
  CommandPermissionLevel (__fastcall *getPermissionsLevel)(CommandOrigin *this);
  std::unique_ptr&lt;CommandOrigin&gt; *(__fastcall *clone)(CommandOrigin *this, std::unique_ptr&lt;CommandOrigin&gt; *result);
  std::optional&lt;BlockPos&gt; *(__fastcall *getCursorHitBlockPos)(CommandOrigin *this, std::optional&lt;BlockPos&gt; *result);
  std::optional&lt;Vec3&gt; *(__fastcall *getCursorHitPos)(CommandOrigin *this, std::optional&lt;Vec3&gt; *result);
  bool (__fastcall *hasChatPerms)(CommandOrigin *this);
  bool (__fastcall *hasTellPerms)(CommandOrigin *this);
  bool (__fastcall *canUseAbility)(CommandOrigin *this, AbilitiesIndex);
  bool (__fastcall *isWorldBuilder)(CommandOrigin *this);
  bool (__fastcall *canUseCommandsWithoutCheatsEnabled)(CommandOrigin *this);
  bool (__fastcall *isSelectorExpansionAllowed)(CommandOrigin *this);
  const NetworkIdentifier *(__fastcall *getSourceId)(CommandOrigin *this);
  unsigned __int8 (__fastcall *getSourceSubId)(CommandOrigin *this);
  const CommandOrigin *(__fastcall *getOutputReceiver)(CommandOrigin *this);
  CommandOriginType (__fastcall *getOriginType)(CommandOrigin *this);
  CommandOriginData *(__fastcall *toCommandOriginData)(CommandOrigin *this, CommandOriginData *result);
  const mce::UUID *(__fastcall *getUUID)(CommandOrigin *this);
  void (__fastcall *handleCommandOutputCallback)(CommandOrigin *this, Json::Value *);
  void (__fastcall *_setUUID)(CommandOrigin *this, const mce::UUID *);
};

</code></pre></div><h3 id="clientblobcache-server-activetransfersmanager-rememberblob-l13-lambda-cbe0fac81da36102ba2c1cdce3ecd16e"><a href="#clientblobcache-server-activetransfersmanager-rememberblob-l13-lambda-cbe0fac81da36102ba2c1cdce3ecd16e" class="header-anchor">#</a> <code>ClientBlobCache::Server::ActiveTransfersManager::rememberBlob::__l13::&lt;lambda_cbe0fac81da36102ba2c1cdce3ecd16e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlobCache::Server::ActiveTransfersManager::rememberBlob::__l13::&lt;lambda_cbe0fac81da36102ba2c1cdce3ecd16e&gt;
{
  ClientBlobCache::Server::ActiveTransfersManager *const __this;
};

</code></pre></div><h3 id="commandorigin-fromcommandorigindata-l5-lambda-c4f9d28d0d1549595c039f306673e27c"><a href="#commandorigin-fromcommandorigindata-l5-lambda-c4f9d28d0d1549595c039f306673e27c" class="header-anchor">#</a> <code>CommandOrigin::fromCommandOriginData::__l5::&lt;lambda_c4f9d28d0d1549595c039f306673e27c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CommandOrigin::fromCommandOriginData::__l5::&lt;lambda_c4f9d28d0d1549595c039f306673e27c&gt;
{
  const NetworkIdentifier *sourceId;
  unsigned __int8 sourceSubId;
};

</code></pre></div><h3 id="commandareafactory-getarea-l23-lambda-0efece9ce348f4d9959d0fd4083ac376"><a href="#commandareafactory-getarea-l23-lambda-0efece9ce348f4d9959d0fd4083ac376" class="header-anchor">#</a> <code>CommandAreaFactory::_getArea::__l23::&lt;lambda_0efece9ce348f4d9959d0fd4083ac376&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandAreaFactory::_getArea::__l23::&lt;lambda_0efece9ce348f4d9959d0fd4083ac376&gt;
{
  ChunkPos *cp;
};

</code></pre></div><h3 id="commandareafactory-getarea-l2-lambda-2c28d13bbbdff35c73a055f9292bfe19"><a href="#commandareafactory-getarea-l2-lambda-2c28d13bbbdff35c73a055f9292bfe19" class="header-anchor">#</a> <code>CommandAreaFactory::_getArea::__l2::&lt;lambda_2c28d13bbbdff35c73a055f9292bfe19&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandAreaFactory::_getArea::__l2::&lt;lambda_2c28d13bbbdff35c73a055f9292bfe19&gt;
{
  const Bounds *requiredArea;
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-commanditem"><a href="#commandregistry-defaultidconverter-commanditem" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;CommandItem&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;CommandItem&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-block-const"><a href="#commandregistry-defaultidconverter-block-const" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;Block const *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;Block const *&gt;
{
};

</code></pre></div><h3 id="commandregistry-getautocompleteoptions-l2-lambda-08d88ad7b4a5d4fe270c8aaf4025af0d"><a href="#commandregistry-getautocompleteoptions-l2-lambda-08d88ad7b4a5d4fe270c8aaf4025af0d" class="header-anchor">#</a> <code>CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_08d88ad7b4a5d4fe270c8aaf4025af0d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_08d88ad7b4a5d4fe270c8aaf4025af0d&gt;
{
};

</code></pre></div><h3 id="commandregistry-getautocompleteoptions-l2-lambda-54885e06ac509493fd3c71e97ba31bd5"><a href="#commandregistry-getautocompleteoptions-l2-lambda-54885e06ac509493fd3c71e97ba31bd5" class="header-anchor">#</a> <code>CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_54885e06ac509493fd3c71e97ba31bd5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_54885e06ac509493fd3c71e97ba31bd5&gt;
{
};

</code></pre></div><h3 id="commandregistry-getautocompleteoptions-l2-lambda-ae8832d910885e324562d537f39d8b6e"><a href="#commandregistry-getautocompleteoptions-l2-lambda-ae8832d910885e324562d537f39d8b6e" class="header-anchor">#</a> <code>CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_ae8832d910885e324562d537f39d8b6e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_ae8832d910885e324562d537f39d8b6e&gt;
{
  CommandRegistry::SemanticInfo *semanticInfo;
  const CommandRegistry *const __this;
  std::string *unparsedText;
  bool *newWord;
  const CommandOrigin *origin;
  std::unique_ptr&lt;AutoCompleteInformation&gt; *result;
  const CommandRegistry::ParseTable *table;
};

</code></pre></div><h3 id="commandregistry-parsetreevisitor-lambda-08d88ad7b4a5d4fe270c8aaf4025af0d-lambda-54885e06ac509493fd3c71e97ba31bd5-lambda-ae8832d910885e324562d537f39d8b6e"><a href="#commandregistry-parsetreevisitor-lambda-08d88ad7b4a5d4fe270c8aaf4025af0d-lambda-54885e06ac509493fd3c71e97ba31bd5-lambda-ae8832d910885e324562d537f39d8b6e" class="header-anchor">#</a> <code>CommandRegistry::ParseTreeVisitor&lt;&lt;lambda_08d88ad7b4a5d4fe270c8aaf4025af0d&gt;,&lt;lambda_54885e06ac509493fd3c71e97ba31bd5&gt;,&lt;lambda_ae8832d910885e324562d537f39d8b6e&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::ParseTreeVisitor&lt;&lt;lambda_08d88ad7b4a5d4fe270c8aaf4025af0d&gt;,&lt;lambda_54885e06ac509493fd3c71e97ba31bd5&gt;,&lt;lambda_ae8832d910885e324562d537f39d8b6e&gt; &gt; : CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_08d88ad7b4a5d4fe270c8aaf4025af0d&gt;, CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_54885e06ac509493fd3c71e97ba31bd5&gt;, CommandRegistry::getAutoCompleteOptions::__l2::&lt;lambda_ae8832d910885e324562d537f39d8b6e&gt;
{
  _BYTE gap0;
};

</code></pre></div><h3 id="commandregistry-getoverloadsyntaxinformation-l5-lambda-0ee50b28ac559fb7167610861c82c3b8"><a href="#commandregistry-getoverloadsyntaxinformation-l5-lambda-0ee50b28ac559fb7167610861c82c3b8" class="header-anchor">#</a> <code>CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_0ee50b28ac559fb7167610861c82c3b8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_0ee50b28ac559fb7167610861c82c3b8&gt;
{
};

</code></pre></div><h3 id="commandregistry-getoverloadsyntaxinformation-l5-lambda-19d920e626aebe51e6ca8191f97cc035"><a href="#commandregistry-getoverloadsyntaxinformation-l5-lambda-19d920e626aebe51e6ca8191f97cc035" class="header-anchor">#</a> <code>CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_19d920e626aebe51e6ca8191f97cc035&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_19d920e626aebe51e6ca8191f97cc035&gt;
{
  std::vector&lt;OverloadSyntaxInformation&gt; *possibilities;
};

</code></pre></div><h3 id="commandregistry-getoverloadsyntaxinformation-l5-lambda-0ce6a8587e76f234789878ea4f4227fa"><a href="#commandregistry-getoverloadsyntaxinformation-l5-lambda-0ce6a8587e76f234789878ea4f4227fa" class="header-anchor">#</a> <code>CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_0ce6a8587e76f234789878ea4f4227fa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_0ce6a8587e76f234789878ea4f4227fa&gt;
{
  std::vector&lt;OverloadSyntaxInformation&gt; *possibilities;
  const CommandRegistry *const __this;
};

</code></pre></div><h3 id="commandregistry-parsetreevisitor-lambda-0ee50b28ac559fb7167610861c82c3b8-lambda-19d920e626aebe51e6ca8191f97cc035-lambda-0ce6a8587e76f234789878ea4f4227fa"><a href="#commandregistry-parsetreevisitor-lambda-0ee50b28ac559fb7167610861c82c3b8-lambda-19d920e626aebe51e6ca8191f97cc035-lambda-0ce6a8587e76f234789878ea4f4227fa" class="header-anchor">#</a> <code>CommandRegistry::ParseTreeVisitor&lt;&lt;lambda_0ee50b28ac559fb7167610861c82c3b8&gt;,&lt;lambda_19d920e626aebe51e6ca8191f97cc035&gt;,&lt;lambda_0ce6a8587e76f234789878ea4f4227fa&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::ParseTreeVisitor&lt;&lt;lambda_0ee50b28ac559fb7167610861c82c3b8&gt;,&lt;lambda_19d920e626aebe51e6ca8191f97cc035&gt;,&lt;lambda_0ce6a8587e76f234789878ea4f4227fa&gt; &gt; : CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_0ee50b28ac559fb7167610861c82c3b8&gt;, CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_19d920e626aebe51e6ca8191f97cc035&gt;, CommandRegistry::getOverloadSyntaxInformation::__l5::&lt;lambda_0ce6a8587e76f234789878ea4f4227fa&gt;
{
};

</code></pre></div><h3 id="codebuildercommand"><a href="#codebuildercommand" class="header-anchor">#</a> <code>CodeBuilderCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CodeBuilderCommand : Command
{
  _BYTE mAction[4];
  __declspec(align(8)) CommandSelector&lt;Player&gt; mPlayerTargets;
  CommandRawText mURL;
  bool mShouldOpenWindow;
};

</code></pre></div><h3 id="codebuildercommand-vtbl"><a href="#codebuildercommand-vtbl" class="header-anchor">#</a> <code>CodeBuilderCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CodeBuilderCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-gametype"><a href="#commandregistry-defaultidconverter-enum-gametype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum GameType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum GameType&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-bool"><a href="#commandregistry-defaultidconverter-bool" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;bool&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-int"><a href="#commandregistry-defaultidconverter-int" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;int&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-agentcommands-direction"><a href="#commandregistry-defaultidconverter-enum-agentcommands-direction" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum AgentCommands::Direction&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum AgentCommands::Direction&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-agentcommand-mode"><a href="#commandregistry-defaultidconverter-enum-agentcommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum AgentCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum AgentCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-agentcommands-collectcommand-collectionspecification"><a href="#commandregistry-defaultidconverter-enum-agentcommands-collectcommand-collectionspecification" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum AgentCommands::CollectCommand::CollectionSpecification&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum AgentCommands::CollectCommand::CollectionSpecification&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-codebuildercommand-action"><a href="#commandregistry-defaultidconverter-enum-codebuildercommand-action" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum CodeBuilderCommand::Action&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum CodeBuilderCommand::Action&gt;
{
};

</code></pre></div><h3 id="commandselectorbase-newresults-l54-lambda-22f7ffa562b6d789d635310378f0cdae"><a href="#commandselectorbase-newresults-l54-lambda-22f7ffa562b6d789d635310378f0cdae" class="header-anchor">#</a> <code>CommandSelectorBase::newResults::__l54::&lt;lambda_22f7ffa562b6d789d635310378f0cdae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelectorBase::newResults::__l54::&lt;lambda_22f7ffa562b6d789d635310378f0cdae&gt;
{
  const CommandSelectorBase *const __this;
  std::function&lt;void __cdecl(Actor &amp;)&gt; *addEntity;
};

</code></pre></div><h3 id="commandselectorbase-newresults-l52-lambda-6f8eabf9af8392d984153e547b4fd261"><a href="#commandselectorbase-newresults-l52-lambda-6f8eabf9af8392d984153e547b4fd261" class="header-anchor">#</a> <code>CommandSelectorBase::newResults::__l52::&lt;lambda_6f8eabf9af8392d984153e547b4fd261&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelectorBase::newResults::__l52::&lt;lambda_6f8eabf9af8392d984153e547b4fd261&gt;
{
  const CommandSelectorBase *const __this;
  std::function&lt;void __cdecl(Actor &amp;)&gt; *addEntity;
};

</code></pre></div><h3 id="commandselectorbase-newresults-l44-lambda-70a396ffbdb6e1b92161cf002e1e6fae"><a href="#commandselectorbase-newresults-l44-lambda-70a396ffbdb6e1b92161cf002e1e6fae" class="header-anchor">#</a> <code>CommandSelectorBase::newResults::__l44::&lt;lambda_70a396ffbdb6e1b92161cf002e1e6fae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelectorBase::newResults::__l44::&lt;lambda_70a396ffbdb6e1b92161cf002e1e6fae&gt;
{
  const CommandSelectorBase *const __this;
  const CommandOrigin *origin;
  std::function&lt;void __cdecl(Actor &amp;)&gt; *addEntity;
  const ActorUniqueID *originAgentID;
};

</code></pre></div><h3 id="commandregistry-ctor-l2-lambda-361045df7e3bde2e5a2028877afb9a53"><a href="#commandregistry-ctor-l2-lambda-361045df7e3bde2e5a2028877afb9a53" class="header-anchor">#</a> <code>CommandRegistry::{ctor}::__l2::&lt;lambda_361045df7e3bde2e5a2028877afb9a53&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::{ctor}::__l2::&lt;lambda_361045df7e3bde2e5a2028877afb9a53&gt;
{
};

</code></pre></div><h3 id="commandregistry-ctor-l2-lambda-7f6b17ab23224a5d644798305b18dea4"><a href="#commandregistry-ctor-l2-lambda-7f6b17ab23224a5d644798305b18dea4" class="header-anchor">#</a> <code>CommandRegistry::{ctor}::__l2::&lt;lambda_7f6b17ab23224a5d644798305b18dea4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::{ctor}::__l2::&lt;lambda_7f6b17ab23224a5d644798305b18dea4&gt;
{
  const CommandRegistry::Symbol Arg;
  const CommandRegistry::Symbol Args;
};

</code></pre></div><h3 id="commandregistry-ctor-l2-lambda-414f2af8519f0713a5e0c677db6bb898"><a href="#commandregistry-ctor-l2-lambda-414f2af8519f0713a5e0c677db6bb898" class="header-anchor">#</a> <code>CommandRegistry::{ctor}::__l2::&lt;lambda_414f2af8519f0713a5e0c677db6bb898&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::{ctor}::__l2::&lt;lambda_414f2af8519f0713a5e0c677db6bb898&gt;
{
  const CommandRegistry::Symbol Arg;
  const CommandRegistry::Symbol Comma;
};

</code></pre></div><h3 id="commandregistry-ctor-l5-lambda-cf1a3bc1337d755975289f3f698b3589"><a href="#commandregistry-ctor-l5-lambda-cf1a3bc1337d755975289f3f698b3589" class="header-anchor">#</a> <code>CommandRegistry::{ctor}::__l5::&lt;lambda_cf1a3bc1337d755975289f3f698b3589&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::{ctor}::__l5::&lt;lambda_cf1a3bc1337d755975289f3f698b3589&gt;
{
  const CommandRegistry::Symbol OpenBrace;
  const CommandRegistry::Symbol CloseBrace;
};

</code></pre></div><h3 id="commandregistry-ctor-l5-lambda-f5186b54b476c2be3f76bb2a1af8b06a"><a href="#commandregistry-ctor-l5-lambda-f5186b54b476c2be3f76bb2a1af8b06a" class="header-anchor">#</a> <code>CommandRegistry::{ctor}::__l5::&lt;lambda_f5186b54b476c2be3f76bb2a1af8b06a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::{ctor}::__l5::&lt;lambda_f5186b54b476c2be3f76bb2a1af8b06a&gt;
{
  const CommandRegistry::Symbol ScoresArg;
  const CommandRegistry::Symbol Comma;
};

</code></pre></div><h3 id="commandregistry-ctor-l2-lambda-605018ec809aeceb683bc762484a9d96"><a href="#commandregistry-ctor-l2-lambda-605018ec809aeceb683bc762484a9d96" class="header-anchor">#</a> <code>CommandRegistry::{ctor}::__l2::&lt;lambda_605018ec809aeceb683bc762484a9d96&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::{ctor}::__l2::&lt;lambda_605018ec809aeceb683bc762484a9d96&gt;
{
  std::vector&lt;std::pair&lt;std::string,int&gt;&gt; *typeNames;
  std::vector&lt;enum ActorType&gt; *invalidEntities;
};

</code></pre></div><h3 id="commandregistry-parseselector-l249-lambda-d62e97e7a0676903544f97c1fc2704a6"><a href="#commandregistry-parseselector-l249-lambda-d62e97e7a0676903544f97c1fc2704a6" class="header-anchor">#</a> <code>CommandRegistry::parseSelector::__l249::&lt;lambda_d62e97e7a0676903544f97c1fc2704a6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::parseSelector::__l249::&lt;lambda_d62e97e7a0676903544f97c1fc2704a6&gt;
{
  std::pair&lt;int,int&gt; level;
};

</code></pre></div><h3 id="commandregistry-parseselector-l246-lambda-28bcc386864748a0e234273411c43c59"><a href="#commandregistry-parseselector-l246-lambda-28bcc386864748a0e234273411c43c59" class="header-anchor">#</a> <code>CommandRegistry::parseSelector::__l246::&lt;lambda_28bcc386864748a0e234273411c43c59&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::parseSelector::__l246::&lt;lambda_28bcc386864748a0e234273411c43c59&gt;
{
  std::pair&lt;float,float&gt; yRotation;
};

</code></pre></div><h3 id="commandregistry-parseselector-l237-lambda-63db28ceedc03525f27c514cb8cf71ac"><a href="#commandregistry-parseselector-l237-lambda-63db28ceedc03525f27c514cb8cf71ac" class="header-anchor">#</a> <code>CommandRegistry::parseSelector::__l237::&lt;lambda_63db28ceedc03525f27c514cb8cf71ac&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::parseSelector::__l237::&lt;lambda_63db28ceedc03525f27c514cb8cf71ac&gt;
{
  CommandIntegerRange range;
  std::string objName;
  const std::function&lt;int __cdecl(bool &amp;,std::string const &amp;,Actor const &amp;)&gt; *callback;
};

</code></pre></div><h3 id="commandregistry-parseselector-l67-lambda-4e234e3626d90af13bf77dbb36bd4669"><a href="#commandregistry-parseselector-l67-lambda-4e234e3626d90af13bf77dbb36bd4669" class="header-anchor">#</a> <code>CommandRegistry::parseSelector::__l67::&lt;lambda_4e234e3626d90af13bf77dbb36bd4669&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) CommandRegistry::parseSelector::__l67::&lt;lambda_4e234e3626d90af13bf77dbb36bd4669&gt;
{
  GameType type;
  bool inverted;
};

</code></pre></div><h3 id="commandoutputsender-sendtoadmins-l23-lambda-038d1a6e7bb914ec0d3b2509a54419db"><a href="#commandoutputsender-sendtoadmins-l23-lambda-038d1a6e7bb914ec0d3b2509a54419db" class="header-anchor">#</a> <code>CommandOutputSender::sendToAdmins::__l23::&lt;lambda_038d1a6e7bb914ec0d3b2509a54419db&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CommandOutputSender::sendToAdmins::__l23::&lt;lambda_038d1a6e7bb914ec0d3b2509a54419db&gt;
{
  TextObjectRoot *textObjectRoot;
  ActorUniqueID *playerId;
  _BYTE opPermLevel[1];
};

</code></pre></div><h3 id="commandoutputsender-sendtoadmins-l26-lambda-3349d776e79858640ef0ba11afaa57fd"><a href="#commandoutputsender-sendtoadmins-l26-lambda-3349d776e79858640ef0ba11afaa57fd" class="header-anchor">#</a> <code>CommandOutputSender::sendToAdmins::__l26::&lt;lambda_3349d776e79858640ef0ba11afaa57fd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandOutputSender::sendToAdmins::__l26::&lt;lambda_3349d776e79858640ef0ba11afaa57fd&gt;
{
  const CommandOutputMessage *message;
};

</code></pre></div><h3 id="commandoutputsender-send-l20-lambda-2ce2c90252fa1240d87f82a6879ddf14"><a href="#commandoutputsender-send-l20-lambda-2ce2c90252fa1240d87f82a6879ddf14" class="header-anchor">#</a> <code>CommandOutputSender::send::__l20::&lt;lambda_2ce2c90252fa1240d87f82a6879ddf14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandOutputSender::send::__l20::&lt;lambda_2ce2c90252fa1240d87f82a6879ddf14&gt;
{
  const CommandOutputMessage *message;
};

</code></pre></div><h3 id="commandregistry-visitcommandparsetree-l38-lambda-392e9dd357a2416c9c1270d21bdf5be7"><a href="#commandregistry-visitcommandparsetree-l38-lambda-392e9dd357a2416c9c1270d21bdf5be7" class="header-anchor">#</a> <code>CommandRegistry::_visitCommandParseTree::__l38::&lt;lambda_392e9dd357a2416c9c1270d21bdf5be7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::_visitCommandParseTree::__l38::&lt;lambda_392e9dd357a2416c9c1270d21bdf5be7&gt;
{
  const CommandRegistry *const __this;
};

</code></pre></div><h3 id="commandregistry-visitcommandparsetree-l36-lambda-05f2e04d42b55be64a3cf7612824c8db"><a href="#commandregistry-visitcommandparsetree-l36-lambda-05f2e04d42b55be64a3cf7612824c8db" class="header-anchor">#</a> <code>CommandRegistry::_visitCommandParseTree::__l36::&lt;lambda_05f2e04d42b55be64a3cf7612824c8db&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::_visitCommandParseTree::__l36::&lt;lambda_05f2e04d42b55be64a3cf7612824c8db&gt;
{
  const CommandRegistry *const __this;
  const CommandRegistry::ParseTreeVisitor&lt;&lt;lambda_0ee50b28ac559fb7167610861c82c3b8&gt;,&lt;lambda_19d920e626aebe51e6ca8191f97cc035&gt;,&lt;lambda_0ce6a8587e76f234789878ea4f4227fa&gt; &gt; *visitor;
};

</code></pre></div><h3 id="commandregistry-visitcommandparsetree-l24-lambda-edd84d20487ee55e23e25db858881012"><a href="#commandregistry-visitcommandparsetree-l24-lambda-edd84d20487ee55e23e25db858881012" class="header-anchor">#</a> <code>CommandRegistry::_visitCommandParseTree::__l24::&lt;lambda_edd84d20487ee55e23e25db858881012&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::_visitCommandParseTree::__l24::&lt;lambda_edd84d20487ee55e23e25db858881012&gt;
{
};

</code></pre></div><h3 id="commandregistry-visitcommandparsetree-l38-lambda-617a76d12e6d2a53077fb1597f7a3dd1"><a href="#commandregistry-visitcommandparsetree-l38-lambda-617a76d12e6d2a53077fb1597f7a3dd1" class="header-anchor">#</a> <code>CommandRegistry::_visitCommandParseTree::__l38::&lt;lambda_617a76d12e6d2a53077fb1597f7a3dd1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::_visitCommandParseTree::__l38::&lt;lambda_617a76d12e6d2a53077fb1597f7a3dd1&gt;
{
  const CommandRegistry *const __this;
};

</code></pre></div><h3 id="commandregistry-visitcommandparsetree-l36-lambda-1b330ce45f34653cad8c98af9609e36a"><a href="#commandregistry-visitcommandparsetree-l36-lambda-1b330ce45f34653cad8c98af9609e36a" class="header-anchor">#</a> <code>CommandRegistry::_visitCommandParseTree::__l36::&lt;lambda_1b330ce45f34653cad8c98af9609e36a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::_visitCommandParseTree::__l36::&lt;lambda_1b330ce45f34653cad8c98af9609e36a&gt;
{
  const CommandRegistry *const __this;
  const CommandRegistry::ParseTreeVisitor&lt;&lt;lambda_08d88ad7b4a5d4fe270c8aaf4025af0d&gt;,&lt;lambda_54885e06ac509493fd3c71e97ba31bd5&gt;,&lt;lambda_ae8832d910885e324562d537f39d8b6e&gt; &gt; *visitor;
};

</code></pre></div><h3 id="commandregistry-visitcommandparsetree-l24-lambda-a600244a6bf1c54ab33531b7c0f5fcee"><a href="#commandregistry-visitcommandparsetree-l24-lambda-a600244a6bf1c54ab33531b7c0f5fcee" class="header-anchor">#</a> <code>CommandRegistry::_visitCommandParseTree::__l24::&lt;lambda_a600244a6bf1c54ab33531b7c0f5fcee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::_visitCommandParseTree::__l24::&lt;lambda_a600244a6bf1c54ab33531b7c0f5fcee&gt;
{
};

</code></pre></div><h3 id="commandselectorbase-newresults-l46-lambda-c263e4b3886672215959338cc46972af"><a href="#commandselectorbase-newresults-l46-lambda-c263e4b3886672215959338cc46972af" class="header-anchor">#</a> <code>CommandSelectorBase::newResults::__l46::&lt;lambda_c263e4b3886672215959338cc46972af&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelectorBase::newResults::__l46::&lt;lambda_c263e4b3886672215959338cc46972af&gt;
{
  std::function&lt;void __cdecl(Actor &amp;)&gt; *addEntity;
};

</code></pre></div><h3 id="commandselectorbase-newresults-l41-lambda-48a585b10008cbd8b875398ee88491b1"><a href="#commandselectorbase-newresults-l41-lambda-48a585b10008cbd8b875398ee88491b1" class="header-anchor">#</a> <code>CommandSelectorBase::newResults::__l41::&lt;lambda_48a585b10008cbd8b875398ee88491b1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelectorBase::newResults::__l41::&lt;lambda_48a585b10008cbd8b875398ee88491b1&gt;
{
  const CommandSelectorBase *const __this;
  Vec3 source;
  const CommandOrigin *origin;
  std::set&lt;std::pair&lt;float,Actor *&gt;&gt; *entities;
  unsigned __int64 *count;
};

</code></pre></div><h3 id="commandselectorbase-newresults-l39-lambda-c1528fafb0866bfed861d2fb0d691fd4"><a href="#commandselectorbase-newresults-l39-lambda-c1528fafb0866bfed861d2fb0d691fd4" class="header-anchor">#</a> <code>CommandSelectorBase::newResults::__l39::&lt;lambda_c1528fafb0866bfed861d2fb0d691fd4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelectorBase::newResults::__l39::&lt;lambda_c1528fafb0866bfed861d2fb0d691fd4&gt;
{
  const CommandSelectorBase *const __this;
  std::vector&lt;Actor *&gt; *entitiesFlat;
  const CommandOrigin *origin;
};

</code></pre></div><h3 id="commandselectorbase-newresults-l37-lambda-3273758fa95c626e53ac475073e44526"><a href="#commandselectorbase-newresults-l37-lambda-3273758fa95c626e53ac475073e44526" class="header-anchor">#</a> <code>CommandSelectorBase::newResults::__l37::&lt;lambda_3273758fa95c626e53ac475073e44526&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelectorBase::newResults::__l37::&lt;lambda_3273758fa95c626e53ac475073e44526&gt;
{
  const CommandSelectorBase *const __this;
  Vec3 source;
  std::vector&lt;Actor *&gt; *entitiesFlat;
  const CommandOrigin *origin;
};

</code></pre></div><h3 id="commanddispatcher"><a href="#commanddispatcher" class="header-anchor">#</a> <code>CommandDispatcher</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandDispatcher : ICommandDispatcher
{
};

</code></pre></div><h3 id="commanddispatcher-vtbl"><a href="#commanddispatcher-vtbl" class="header-anchor">#</a> <code>CommandDispatcher_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandDispatcher_vtbl
{
  void (__fastcall *~ICommandDispatcher)(ICommandDispatcher *this);
  int (__fastcall *performCommand)(ICommandDispatcher *this, const CommandOrigin *, Command *);
};

</code></pre></div><h3 id="commandfunctionentry"><a href="#commandfunctionentry" class="header-anchor">#</a> <code>CommandFunctionEntry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandFunctionEntry : IFunctionEntry
{
  std::unique_ptr&lt;Command&gt; mCommand;
};

</code></pre></div><h3 id="commandfunctionentry-vtbl"><a href="#commandfunctionentry-vtbl" class="header-anchor">#</a> <code>CommandFunctionEntry_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandFunctionEntry_vtbl
{
  void (__fastcall *~IFunctionEntry)(IFunctionEntry *this);
  void (__fastcall *execute)(IFunctionEntry *this, FunctionManager *, const CommandOrigin *);
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-ifeature-const"><a href="#commandregistry-defaultidconverter-ifeature-const" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;IFeature const *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;IFeature const *&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-actordefinitionidentifier-const"><a href="#commandregistry-defaultidconverter-actordefinitionidentifier-const" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;ActorDefinitionIdentifier const *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;ActorDefinitionIdentifier const *&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-structurefeaturetype"><a href="#commandregistry-defaultidconverter-enum-structurefeaturetype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum StructureFeatureType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum StructureFeatureType&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-enchant-type"><a href="#commandregistry-defaultidconverter-enum-enchant-type" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum Enchant::Type&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum Enchant::Type&gt;
{
};

</code></pre></div><h3 id="clearcommand"><a href="#clearcommand" class="header-anchor">#</a> <code>ClearCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClearCommand : Command
{
  CommandSelector&lt;Player&gt; mTargets;
  CommandItem mItem;
  int mData;
  int mMaxCount;
};

</code></pre></div><h3 id="clearcommand-vtbl"><a href="#clearcommand-vtbl" class="header-anchor">#</a> <code>ClearCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClearCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="clonecommand"><a href="#clonecommand" class="header-anchor">#</a> <code>CloneCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CloneCommand : Command
{
  CommandPosition mBegin;
  CommandPosition mEnd;
  CommandPosition mDestination;
  CloneCommand::MaskMode mMaskMode;
  CloneCommand::CloneMode mCloneMode;
  const Block *mBlock;
  int mData;
};

</code></pre></div><h3 id="clonecommand-vtbl"><a href="#clonecommand-vtbl" class="header-anchor">#</a> <code>CloneCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CloneCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="commandpositionfloat"><a href="#commandpositionfloat" class="header-anchor">#</a> <code>CommandPositionFloat</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandPositionFloat : CommandPosition
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-rotation"><a href="#commandregistry-defaultidconverter-enum-rotation" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum Rotation&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum Rotation&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-bossbarcommand-bossbaraction"><a href="#commandregistry-defaultidconverter-enum-bossbarcommand-bossbaraction" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum BossbarCommand::BossbarAction&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum BossbarCommand::BossbarAction&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-bossbarcommand-bossbargetoption"><a href="#commandregistry-defaultidconverter-enum-bossbarcommand-bossbargetoption" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum BossbarCommand::BossbarGetOption&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum BossbarCommand::BossbarGetOption&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-bossbarcommand-bossbarsetoption"><a href="#commandregistry-defaultidconverter-enum-bossbarcommand-bossbarsetoption" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum BossbarCommand::BossbarSetOption&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum BossbarCommand::BossbarSetOption&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-bossbarcolor"><a href="#commandregistry-defaultidconverter-enum-bossbarcolor" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum BossBarColor&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum BossBarColor&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-clonecommand-maskmode"><a href="#commandregistry-defaultidconverter-enum-clonecommand-maskmode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum CloneCommand::MaskMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum CloneCommand::MaskMode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-clonecommand-clonemode"><a href="#commandregistry-defaultidconverter-enum-clonecommand-clonemode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum CloneCommand::CloneMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum CloneCommand::CloneMode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-difficulty"><a href="#commandregistry-defaultidconverter-enum-difficulty" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum Difficulty&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum Difficulty&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-effectcommand-mode"><a href="#commandregistry-defaultidconverter-enum-effectcommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum EffectCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum EffectCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-mobeffect-const"><a href="#commandregistry-defaultidconverter-mobeffect-const" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;MobEffect const *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;MobEffect const *&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-executecommand-mode"><a href="#commandregistry-defaultidconverter-enum-executecommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ExecuteCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ExecuteCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-fillcommand-fillmode"><a href="#commandregistry-defaultidconverter-enum-fillcommand-fillmode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum FillCommand::FillMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum FillCommand::FillMode&gt;
{
};

</code></pre></div><h3 id="clearcommand-execute-l24-lambda-a1fc2660f4ed9e2cc3d3b9bb3bd21c50"><a href="#clearcommand-execute-l24-lambda-a1fc2660f4ed9e2cc3d3b9bb3bd21c50" class="header-anchor">#</a> <code>ClearCommand::execute::__l24::&lt;lambda_a1fc2660f4ed9e2cc3d3b9bb3bd21c50&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClearCommand::execute::__l24::&lt;lambda_a1fc2660f4ed9e2cc3d3b9bb3bd21c50&gt;
{
  const ItemDescriptor *descriptor;
  const __int16 damage;
  const bool compareDamageValue;
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-listdcommand-detailmode"><a href="#commandregistry-defaultidconverter-enum-listdcommand-detailmode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ListDCommand::DetailMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ListDCommand::DetailMode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-permissioncommand-action"><a href="#commandregistry-defaultidconverter-enum-permissioncommand-action" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum PermissionCommand::Action&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum PermissionCommand::Action&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-permissioncommand-availablecommandpermissionpresets"><a href="#commandregistry-defaultidconverter-enum-permissioncommand-availablecommandpermissionpresets" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum PermissionCommand::AvailableCommandPermissionPresets&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum PermissionCommand::AvailableCommandPermissionPresets&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-blockslot"><a href="#commandregistry-defaultidconverter-enum-blockslot" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum BlockSlot&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum BlockSlot&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-equipmentslot"><a href="#commandregistry-defaultidconverter-enum-equipmentslot" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum EquipmentSlot&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum EquipmentSlot&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-replaceitemcommand-targettype"><a href="#commandregistry-defaultidconverter-enum-replaceitemcommand-targettype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ReplaceItemCommand::TargetType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ReplaceItemCommand::TargetType&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-replaceitemcommand-replacemode"><a href="#commandregistry-defaultidconverter-enum-replaceitemcommand-replacemode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ReplaceItemCommand::ReplaceMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ReplaceItemCommand::ReplaceMode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-scoreboardcommand-category"><a href="#commandregistry-defaultidconverter-enum-scoreboardcommand-category" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ScoreboardCommand::Category&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ScoreboardCommand::Category&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-scoreboardcommand-action"><a href="#commandregistry-defaultidconverter-enum-scoreboardcommand-action" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ScoreboardCommand::Action&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ScoreboardCommand::Action&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-objectivesortorder"><a href="#commandregistry-defaultidconverter-enum-objectivesortorder" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum ObjectiveSortOrder&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum ObjectiveSortOrder&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-setblockcommand-setblockmode"><a href="#commandregistry-defaultidconverter-enum-setblockcommand-setblockmode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum SetBlockCommand::SetBlockMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum SetBlockCommand::SetBlockMode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-tagcommand-action"><a href="#commandregistry-defaultidconverter-enum-tagcommand-action" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TagCommand::Action&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TagCommand::Action&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-teleportcommand-facingresult"><a href="#commandregistry-defaultidconverter-enum-teleportcommand-facingresult" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TeleportCommand::FacingResult&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TeleportCommand::FacingResult&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-testforblockscommand-mode"><a href="#commandregistry-defaultidconverter-enum-testforblockscommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TestForBlocksCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TestForBlocksCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-tickingareacommand-mode"><a href="#commandregistry-defaultidconverter-enum-tickingareacommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TickingAreaCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TickingAreaCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-tickingareacommand-addareatype"><a href="#commandregistry-defaultidconverter-enum-tickingareacommand-addareatype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TickingAreaCommand::AddAreaType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TickingAreaCommand::AddAreaType&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-tickingareacommand-targetdimensions"><a href="#commandregistry-defaultidconverter-enum-tickingareacommand-targetdimensions" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TickingAreaCommand::TargetDimensions&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TickingAreaCommand::TargetDimensions&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-timecommand-mode"><a href="#commandregistry-defaultidconverter-enum-timecommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TimeCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TimeCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-timecommand-query"><a href="#commandregistry-defaultidconverter-enum-timecommand-query" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TimeCommand::Query&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TimeCommand::Query&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-timecommand-timespec"><a href="#commandregistry-defaultidconverter-enum-timecommand-timespec" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TimeCommand::TimeSpec&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TimeCommand::TimeSpec&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-titlecommand-mode"><a href="#commandregistry-defaultidconverter-enum-titlecommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TitleCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TitleCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-titlerawcommand-mode"><a href="#commandregistry-defaultidconverter-enum-titlerawcommand-mode" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum TitleRawCommand::Mode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum TitleRawCommand::Mode&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-weathercommand-weathertype"><a href="#commandregistry-defaultidconverter-enum-weathercommand-weathertype" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum WeatherCommand::WeatherType&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum WeatherCommand::WeatherType&gt;
{
};

</code></pre></div><h3 id="commandregistry-defaultidconverter-enum-weathercommand-weatherrequest"><a href="#commandregistry-defaultidconverter-enum-weathercommand-weatherrequest" class="header-anchor">#</a> <code>CommandRegistry::DefaultIdConverter&lt;enum WeatherCommand::WeatherRequest&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::DefaultIdConverter&lt;enum WeatherCommand::WeatherRequest&gt;
{
};

</code></pre></div><h3 id="contentkeysfile"><a href="#contentkeysfile" class="header-anchor">#</a> <code>ContentKeysFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentKeysFile
{
  const Core::PathBuffer&lt;std::string &gt; mFilePath;
  std::unordered_map&lt;std::string,std::string&gt; mKeyMap;
};

</code></pre></div><h3 id="core-profile-profilethread"><a href="#core-profile-profilethread" class="header-anchor">#</a> <code>Core::Profile::ProfileThread</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Profile::ProfileThread
{
};

</code></pre></div><h3 id="common-buildinfo"><a href="#common-buildinfo" class="header-anchor">#</a> <code>Common::BuildInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Common::BuildInfo
{
  std::string mBuildId;
  std::string mCommitId;
  std::string mBranchId;
  std::string mFlavor;
};

</code></pre></div><h3 id="chanceinformation"><a href="#chanceinformation" class="header-anchor">#</a> <code>ChanceInformation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChanceInformation
{
  std::variant&lt;float,std::pair&lt;unsigned int,unsigned int&gt; &gt; mChance;
};

</code></pre></div><h3 id="crcdatainput"><a href="#crcdatainput" class="header-anchor">#</a> <code>CRCDataInput</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CRCDataInput : ICRCDataInput
{
  unsigned int mCrc;
  std::unique_ptr&lt;IDataInput&gt; mStream;
};

</code></pre></div><h3 id="crcdatainput-vtbl"><a href="#crcdatainput-vtbl" class="header-anchor">#</a> <code>CRCDataInput_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CRCDataInput_vtbl
{
  void (__fastcall *~IDataInput)(IDataInput *this);
  std::string *(__fastcall *readString)(IDataInput *this, std::string *result);
  std::string *(__fastcall *readLongString)(IDataInput *this, std::string *result);
  float (__fastcall *readFloat)(IDataInput *this);
  long double (__fastcall *readDouble)(IDataInput *this);
  char (__fastcall *readByte)(IDataInput *this);
  __int16 (__fastcall *readShort)(IDataInput *this);
  int (__fastcall *readInt)(IDataInput *this);
  __int64 (__fastcall *readLongLong)(IDataInput *this);
  bool (__fastcall *readBytes)(IDataInput *this, void *, unsigned __int64);
  unsigned __int64 (__fastcall *numBytesLeft)(IDataInput *this);
  bool (__fastcall *isOk)(IDataInput *this);
  bool (__fastcall *seek)(IDataInput *this, unsigned __int64);
  unsigned int (__fastcall *getCRC)(ICRCDataInput *this);
};

</code></pre></div><h3 id="crcdataoutput"><a href="#crcdataoutput" class="header-anchor">#</a> <code>CRCDataOutput</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CRCDataOutput : ICRCDataOutput
{
  std::unique_ptr&lt;IDataOutput&gt; mStream;
  unsigned int mCrc;
};

</code></pre></div><h3 id="crcdataoutput-vtbl"><a href="#crcdataoutput-vtbl" class="header-anchor">#</a> <code>CRCDataOutput_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CRCDataOutput_vtbl
{
  void (__fastcall *~IDataOutput)(IDataOutput *this);
  void (__fastcall *writeString)(IDataOutput *this, gsl::basic_string_span&lt;char const ,-1&gt;);
  void (__fastcall *writeLongString)(IDataOutput *this, gsl::basic_string_span&lt;char const ,-1&gt;);
  void (__fastcall *writeFloat)(IDataOutput *this, float);
  void (__fastcall *writeDouble)(IDataOutput *this, long double);
  void (__fastcall *writeByte)(IDataOutput *this, char);
  void (__fastcall *writeShort)(IDataOutput *this, __int16);
  void (__fastcall *writeInt)(IDataOutput *this, int);
  void (__fastcall *writeLongLong)(IDataOutput *this, __int64);
  void (__fastcall *writeBytes)(IDataOutput *this, const void *, unsigned __int64);
  bool (__fastcall *isOk)(IDataOutput *this);
  unsigned int (__fastcall *getCRC)(ICRCDataOutput *this);
  void (__fastcall *setCRCSeed)(ICRCDataOutput *this, unsigned int);
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-rename-l2-lambda-d106db2de3b6b6e6de326311fa5fb1d9"><a href="#compoundtagupdaterbuilder-rename-l2-lambda-d106db2de3b6b6e6de326311fa5fb1d9" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::rename::__l2::&lt;lambda_d106db2de3b6b6e6de326311fa5fb1d9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::rename::__l2::&lt;lambda_d106db2de3b6b6e6de326311fa5fb1d9&gt;
{
  const std::string tagName;
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-remove-l2-lambda-34a013135a39fc1d9dd5a5b78a6ccc8a"><a href="#compoundtagupdaterbuilder-remove-l2-lambda-34a013135a39fc1d9dd5a5b78a6ccc8a" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::remove::__l2::&lt;lambda_34a013135a39fc1d9dd5a5b78a6ccc8a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::remove::__l2::&lt;lambda_34a013135a39fc1d9dd5a5b78a6ccc8a&gt;
{
  const std::string tagName;
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-remove-l2-lambda-9bf85ca8f27b27e71d561c4189565661"><a href="#compoundtagupdaterbuilder-remove-l2-lambda-9bf85ca8f27b27e71d561c4189565661" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::remove::__l2::&lt;lambda_9bf85ca8f27b27e71d561c4189565661&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::remove::__l2::&lt;lambda_9bf85ca8f27b27e71d561c4189565661&gt;
{
  const std::string tagName;
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-edit-l2-lambda-bad5b299bb6422fa44f16a14d28fd631"><a href="#compoundtagupdaterbuilder-edit-l2-lambda-bad5b299bb6422fa44f16a14d28fd631" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::edit::__l2::&lt;lambda_bad5b299bb6422fa44f16a14d28fd631&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::edit::__l2::&lt;lambda_bad5b299bb6422fa44f16a14d28fd631&gt;
{
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-edit-l2-lambda-4566ce3f28a6fca1a020328f1b5bf986"><a href="#compoundtagupdaterbuilder-edit-l2-lambda-4566ce3f28a6fca1a020328f1b5bf986" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::edit::__l2::&lt;lambda_4566ce3f28a6fca1a020328f1b5bf986&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::edit::__l2::&lt;lambda_4566ce3f28a6fca1a020328f1b5bf986&gt;
{
  const std::string tagName;
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-edit-l2-lambda-f5f8445f343ec4ca9f1ae6c366fde01d"><a href="#compoundtagupdaterbuilder-edit-l2-lambda-f5f8445f343ec4ca9f1ae6c366fde01d" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::edit::__l2::&lt;lambda_f5f8445f343ec4ca9f1ae6c366fde01d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::edit::__l2::&lt;lambda_f5f8445f343ec4ca9f1ae6c366fde01d&gt;
{
  const std::string tagName;
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-popvisit-l2-lambda-982407142d7d5112fbad9f0663beebac"><a href="#compoundtagupdaterbuilder-popvisit-l2-lambda-982407142d7d5112fbad9f0663beebac" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::popVisit::__l2::&lt;lambda_982407142d7d5112fbad9f0663beebac&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::popVisit::__l2::&lt;lambda_982407142d7d5112fbad9f0663beebac&gt;
{
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-popvisit-l2-lambda-2d39432ab1e8c62c46cf985cf99723dd"><a href="#compoundtagupdaterbuilder-popvisit-l2-lambda-2d39432ab1e8c62c46cf985cf99723dd" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::popVisit::__l2::&lt;lambda_2d39432ab1e8c62c46cf985cf99723dd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::popVisit::__l2::&lt;lambda_2d39432ab1e8c62c46cf985cf99723dd&gt;
{
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-visit-l2-lambda-1b95be20721d5b0d9ad9446ef678356b"><a href="#compoundtagupdaterbuilder-visit-l2-lambda-1b95be20721d5b0d9ad9446ef678356b" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::visit::__l2::&lt;lambda_1b95be20721d5b0d9ad9446ef678356b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::visit::__l2::&lt;lambda_1b95be20721d5b0d9ad9446ef678356b&gt;
{
  const std::string tagName;
};

</code></pre></div><h3 id="compoundtagupdaterbuilder-visit-l2-lambda-a2ba0478e2148f8507ead2b53b60900f"><a href="#compoundtagupdaterbuilder-visit-l2-lambda-a2ba0478e2148f8507ead2b53b60900f" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::visit::__l2::&lt;lambda_a2ba0478e2148f8507ead2b53b60900f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundTagUpdaterBuilder::visit::__l2::&lt;lambda_a2ba0478e2148f8507ead2b53b60900f&gt;
{
  const std::string tagName;
};

</code></pre></div><h3 id="colordefinition"><a href="#colordefinition" class="header-anchor">#</a> <code>ColorDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ColorDefinition
{
  _BYTE mColorChoice[1];
};

</code></pre></div><h3 id="color2definition"><a href="#color2definition" class="header-anchor">#</a> <code>Color2Definition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Color2Definition : ColorDefinition
{
};

</code></pre></div><h3 id="canclimbdefinition"><a href="#canclimbdefinition" class="header-anchor">#</a> <code>CanClimbDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CanClimbDefinition
{
};

</code></pre></div><h3 id="canflydefinition"><a href="#canflydefinition" class="header-anchor">#</a> <code>CanFlyDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CanFlyDefinition
{
};

</code></pre></div><h3 id="canpowerjumpdefinition"><a href="#canpowerjumpdefinition" class="header-anchor">#</a> <code>CanPowerJumpDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CanPowerJumpDefinition
{
};

</code></pre></div><h3 id="collisionboxdefinition"><a href="#collisionboxdefinition" class="header-anchor">#</a> <code>CollisionBoxDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CollisionBoxDefinition
{
  Vec2 mBBDim;
};

</code></pre></div><h3 id="cavespider"><a href="#cavespider" class="header-anchor">#</a> <code>CaveSpider</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CaveSpider : Spider
{
};

</code></pre></div><h3 id="customentitytypecomponent"><a href="#customentitytypecomponent" class="header-anchor">#</a> <code>CustomEntityTypeComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomEntityTypeComponent
{
  Actor *mEntity;
  std::string mCustomEntityType;
};

</code></pre></div><h3 id="chargehelditemdefinition"><a href="#chargehelditemdefinition" class="header-anchor">#</a> <code>ChargeHeldItemDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChargeHeldItemDefinition : BaseGoalDefinition
{
  std::vector&lt;ItemDescriptor&gt; mChargeItemList;
};

</code></pre></div><h3 id="chargehelditemdefinition-vtbl"><a href="#chargehelditemdefinition-vtbl" class="header-anchor">#</a> <code>ChargeHeldItemDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChargeHeldItemDefinition_vtbl
{
  void (__fastcall *~BaseGoalDefinition)(BaseGoalDefinition *this);
  bool (__fastcall *validateMobType)(BaseGoalDefinition *this, Mob *);
  bool (__fastcall *validate)(BaseGoalDefinition *this, Mob *);
};

</code></pre></div><h3 id="chargehelditemgoal"><a href="#chargehelditemgoal" class="header-anchor">#</a> <code>ChargeHeldItemGoal</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChargeHeldItemGoal : Goal
{
  Mob *mMob;
  int mUsingTime;
  std::vector&lt;ItemDescriptor&gt; mChargeItemList;
};

</code></pre></div><h3 id="chargehelditemgoal-vtbl"><a href="#chargehelditemgoal-vtbl" class="header-anchor">#</a> <code>ChargeHeldItemGoal_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChargeHeldItemGoal_vtbl
{
  void (__fastcall *~Goal)(Goal *this);
  bool (__fastcall *canUse)(Goal *this);
  bool (__fastcall *canContinueToUse)(Goal *this);
  bool (__fastcall *canBeInterrupted)(Goal *this);
  void (__fastcall *start)(Goal *this);
  void (__fastcall *stop)(Goal *this);
  void (__fastcall *tick)(Goal *this);
  void (__fastcall *appendDebugInfo)(Goal *this, std::string *);
  bool (__fastcall *isTargetGoal)(Goal *this);
  void (__fastcall *onPlayerDimensionChanged)(Goal *this, Player *, AutomaticID&lt;Dimension,int&gt;);
};

</code></pre></div><h3 id="chargehelditemdefinition-buildschema-l2-lambda-d321ada88c0fdca2ff94e3a1fa49eb64"><a href="#chargehelditemdefinition-buildschema-l2-lambda-d321ada88c0fdca2ff94e3a1fa49eb64" class="header-anchor">#</a> <code>ChargeHeldItemDefinition::buildSchema::__l2::&lt;lambda_d321ada88c0fdca2ff94e3a1fa49eb64&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChargeHeldItemDefinition::buildSchema::__l2::&lt;lambda_d321ada88c0fdca2ff94e3a1fa49eb64&gt;
{
};

</code></pre></div><h3 id="chargehelditemdefinition-buildschema-l2-lambda-2b6125119ea09ae250fa822690004f9d"><a href="#chargehelditemdefinition-buildschema-l2-lambda-2b6125119ea09ae250fa822690004f9d" class="header-anchor">#</a> <code>ChargeHeldItemDefinition::buildSchema::__l2::&lt;lambda_2b6125119ea09ae250fa822690004f9d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChargeHeldItemDefinition::buildSchema::__l2::&lt;lambda_2b6125119ea09ae250fa822690004f9d&gt;
{
};

</code></pre></div><h3 id="cat"><a href="#cat" class="header-anchor">#</a> <code>Cat</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Cat : Animal
{
  float mLieDownAmount;
  float mLieDownAmountLast;
  float mLieDownAmountTail;
  float mLieDownAmountTailLast;
};

</code></pre></div><h3 id="chicken"><a href="#chicken" class="header-anchor">#</a> <code>Chicken</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Chicken : Animal
{
  float mFlap;
  float mOFlap;
  float mFlapSpeed;
  float mOFlapSpeed;
  float mFlapping;
};

</code></pre></div><h3 id="compositedefinition"><a href="#compositedefinition" class="header-anchor">#</a> <code>CompositeDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompositeDefinition : BehaviorDefinition
{
  std::vector&lt;std::unique_ptr&lt;BehaviorDefinition&gt;&gt; mChildren;
};

</code></pre></div><h3 id="compositedefinition-vtbl"><a href="#compositedefinition-vtbl" class="header-anchor">#</a> <code>CompositeDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CompositeDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="consumeitemnode"><a href="#consumeitemnode" class="header-anchor">#</a> <code>ConsumeItemNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ConsumeItemNode : BehaviorNode
{
  bool mRightMouseDown;
  int mDelayTicks;
  int mDelayCounter;
};

</code></pre></div><h3 id="consumeitemnode-vtbl"><a href="#consumeitemnode-vtbl" class="header-anchor">#</a> <code>ConsumeItemNode_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConsumeItemNode_vtbl
{
  void (__fastcall *~BehaviorNode)(BehaviorNode *this);
  BehaviorStatus (__fastcall *tick)(BehaviorNode *this, Actor *);
  void (__fastcall *initializeFromDefinition)(BehaviorNode *this, Actor *);
};

</code></pre></div><h3 id="consumeitemdefinition"><a href="#consumeitemdefinition" class="header-anchor">#</a> <code>ConsumeItemDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConsumeItemDefinition : BehaviorDefinition
{
};

</code></pre></div><h3 id="consumeitemdefinition-vtbl"><a href="#consumeitemdefinition-vtbl" class="header-anchor">#</a> <code>ConsumeItemDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConsumeItemDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="checkdistnode"><a href="#checkdistnode" class="header-anchor">#</a> <code>CheckDistNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CheckDistNode : BehaviorNode
{
  std::string mOperation;
  float mDist;
  Vec3 mTargetPos;
};

</code></pre></div><h3 id="checkdistnode-vtbl"><a href="#checkdistnode-vtbl" class="header-anchor">#</a> <code>CheckDistNode_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CheckDistNode_vtbl
{
  void (__fastcall *~BehaviorNode)(BehaviorNode *this);
  BehaviorStatus (__fastcall *tick)(BehaviorNode *this, Actor *);
  void (__fastcall *initializeFromDefinition)(BehaviorNode *this, Actor *);
};

</code></pre></div><h3 id="checkdistdefinition"><a href="#checkdistdefinition" class="header-anchor">#</a> <code>CheckDistDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CheckDistDefinition : BehaviorDefinition
{
  std::string mOperation;
  std::string mOperationId;
  float mDist;
  std::string mDistId;
  Vec3 mTargetPos;
  std::string mTargetPosId;
};

</code></pre></div><h3 id="checkdistdefinition-vtbl"><a href="#checkdistdefinition-vtbl" class="header-anchor">#</a> <code>CheckDistDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CheckDistDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="checkharvestconditiondefinition"><a href="#checkharvestconditiondefinition" class="header-anchor">#</a> <code>CheckHarvestConditionDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CheckHarvestConditionDefinition : BehaviorDefinition
{
  std::string mBlockName;
  std::string mBlockNameId;
};

</code></pre></div><h3 id="checkharvestconditiondefinition-vtbl"><a href="#checkharvestconditiondefinition-vtbl" class="header-anchor">#</a> <code>CheckHarvestConditionDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CheckHarvestConditionDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="craftitemdefinition"><a href="#craftitemdefinition" class="header-anchor">#</a> <code>CraftItemDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftItemDefinition : BehaviorDefinition
{
  std::string mItemName;
  std::string mItemNameId;
};

</code></pre></div><h3 id="craftitemdefinition-vtbl"><a href="#craftitemdefinition-vtbl" class="header-anchor">#</a> <code>CraftItemDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftItemDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="craftingcontainercontroller"><a href="#craftingcontainercontroller" class="header-anchor">#</a> <code>CraftingContainerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerController : ContainerController
{
  const Recipe *mCurrentRecipe;
  int mGridSize;
  bool mDisplayOnlyGhostItems;
  std::vector&lt;ItemInstance&gt; mGhostItems;
};

</code></pre></div><h3 id="craftingcontainercontroller-vtbl"><a href="#craftingcontainercontroller-vtbl" class="header-anchor">#</a> <code>CraftingContainerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftingContainerController_vtbl
{
  void (__fastcall *~ContainerController)(ContainerController *this);
  bool (__fastcall *canRemove)(ContainerController *this, int, int);
  bool (__fastcall *isItemAllowed)(ContainerController *this, const ItemStackBase *);
  bool (__fastcall *isItemFiltered)(ContainerController *this, const Recipes *, const ItemStackBase *);
  int (__fastcall *getBackgroundStyle)(ContainerController *this, int, bool);
  ItemSetType (__fastcall *_canSet)(ContainerController *this, int, const ItemStackBase *, ItemTransferAmount);
  int (__fastcall *_getAvailableSetCount)(ContainerController *this, int, const ItemStackBase *);
  bool (__fastcall *_canRemove)(ContainerController *this, int, int);
  void (__fastcall *_onItemChanged)(ContainerController *this, int);
  void (__fastcall *onRecipeSelected)(CraftingContainerController *this, const Recipe *, unsigned __int64, bool);
  const ItemInstance *(__fastcall *getRecipeItem)(CraftingContainerController *this, int);
  void (__fastcall *clearSelectedRecipe)(CraftingContainerController *this);
  const Recipe *(__fastcall *getSelectedRecipe)(CraftingContainerController *this);
  void (__fastcall *setGhostItem)(CraftingContainerController *this, const ItemInstance *, int, bool);
  const ItemInstance *(__fastcall *getGhostItem)(CraftingContainerController *this, int);
};

</code></pre></div><h3 id="craftinginputcontainercontroller"><a href="#craftinginputcontainercontroller" class="header-anchor">#</a> <code>CraftingInputContainerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingInputContainerController : CraftingContainerController
{
  std::vector&lt;ItemInstance&gt; mRecipeItems;
};

</code></pre></div><h3 id="craftinginputcontainercontroller-vtbl"><a href="#craftinginputcontainercontroller-vtbl" class="header-anchor">#</a> <code>CraftingInputContainerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftingInputContainerController_vtbl
{
  void (__fastcall *~ContainerController)(ContainerController *this);
  bool (__fastcall *canRemove)(ContainerController *this, int, int);
  bool (__fastcall *isItemAllowed)(ContainerController *this, const ItemStackBase *);
  bool (__fastcall *isItemFiltered)(ContainerController *this, const Recipes *, const ItemStackBase *);
  int (__fastcall *getBackgroundStyle)(ContainerController *this, int, bool);
  ItemSetType (__fastcall *_canSet)(ContainerController *this, int, const ItemStackBase *, ItemTransferAmount);
  int (__fastcall *_getAvailableSetCount)(ContainerController *this, int, const ItemStackBase *);
  bool (__fastcall *_canRemove)(ContainerController *this, int, int);
  void (__fastcall *_onItemChanged)(ContainerController *this, int);
  void (__fastcall *onRecipeSelected)(CraftingContainerController *this, const Recipe *, unsigned __int64, bool);
  const ItemInstance *(__fastcall *getRecipeItem)(CraftingContainerController *this, int);
  void (__fastcall *clearSelectedRecipe)(CraftingContainerController *this);
  const Recipe *(__fastcall *getSelectedRecipe)(CraftingContainerController *this);
  void (__fastcall *setGhostItem)(CraftingContainerController *this, const ItemInstance *, int, bool);
  const ItemInstance *(__fastcall *getGhostItem)(CraftingContainerController *this, int);
};

</code></pre></div><h3 id="craftingoutputcontainercontroller"><a href="#craftingoutputcontainercontroller" class="header-anchor">#</a> <code>CraftingOutputContainerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CraftingOutputContainerController : CraftingContainerController
{
  ItemInstance mRecipeItem;
  bool mIsRecipeCraftable;
};

</code></pre></div><h3 id="craftingoutputcontainercontroller-vtbl"><a href="#craftingoutputcontainercontroller-vtbl" class="header-anchor">#</a> <code>CraftingOutputContainerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftingOutputContainerController_vtbl
{
  void (__fastcall *~ContainerController)(ContainerController *this);
  bool (__fastcall *canRemove)(ContainerController *this, int, int);
  bool (__fastcall *isItemAllowed)(ContainerController *this, const ItemStackBase *);
  bool (__fastcall *isItemFiltered)(ContainerController *this, const Recipes *, const ItemStackBase *);
  int (__fastcall *getBackgroundStyle)(ContainerController *this, int, bool);
  ItemSetType (__fastcall *_canSet)(ContainerController *this, int, const ItemStackBase *, ItemTransferAmount);
  int (__fastcall *_getAvailableSetCount)(ContainerController *this, int, const ItemStackBase *);
  bool (__fastcall *_canRemove)(ContainerController *this, int, int);
  void (__fastcall *_onItemChanged)(ContainerController *this, int);
  void (__fastcall *onRecipeSelected)(CraftingContainerController *this, const Recipe *, unsigned __int64, bool);
  const ItemInstance *(__fastcall *getRecipeItem)(CraftingContainerController *this, int);
  void (__fastcall *clearSelectedRecipe)(CraftingContainerController *this);
  const Recipe *(__fastcall *getSelectedRecipe)(CraftingContainerController *this);
  void (__fastcall *setGhostItem)(CraftingContainerController *this, const ItemInstance *, int, bool);
  const ItemInstance *(__fastcall *getGhostItem)(CraftingContainerController *this, int);
};

</code></pre></div><h3 id="creativecontainercontroller"><a href="#creativecontainercontroller" class="header-anchor">#</a> <code>CreativeContainerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreativeContainerController : CraftingContainerController
{
};

</code></pre></div><h3 id="creativecontainercontroller-vtbl"><a href="#creativecontainercontroller-vtbl" class="header-anchor">#</a> <code>CreativeContainerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CreativeContainerController_vtbl
{
  void (__fastcall *~ContainerController)(ContainerController *this);
  bool (__fastcall *canRemove)(ContainerController *this, int, int);
  bool (__fastcall *isItemAllowed)(ContainerController *this, const ItemStackBase *);
  bool (__fastcall *isItemFiltered)(ContainerController *this, const Recipes *, const ItemStackBase *);
  int (__fastcall *getBackgroundStyle)(ContainerController *this, int, bool);
  ItemSetType (__fastcall *_canSet)(ContainerController *this, int, const ItemStackBase *, ItemTransferAmount);
  int (__fastcall *_getAvailableSetCount)(ContainerController *this, int, const ItemStackBase *);
  bool (__fastcall *_canRemove)(ContainerController *this, int, int);
  void (__fastcall *_onItemChanged)(ContainerController *this, int);
  void (__fastcall *onRecipeSelected)(CraftingContainerController *this, const Recipe *, unsigned __int64, bool);
  const ItemInstance *(__fastcall *getRecipeItem)(CraftingContainerController *this, int);
  void (__fastcall *clearSelectedRecipe)(CraftingContainerController *this);
  const Recipe *(__fastcall *getSelectedRecipe)(CraftingContainerController *this);
  void (__fastcall *setGhostItem)(CraftingContainerController *this, const ItemInstance *, int, bool);
  const ItemInstance *(__fastcall *getGhostItem)(CraftingContainerController *this, int);
};

</code></pre></div><h3 id="compounditem"><a href="#compounditem" class="header-anchor">#</a> <code>CompoundItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompoundItem : ChemistryItem
{
};

</code></pre></div><h3 id="containervalidation"><a href="#containervalidation" class="header-anchor">#</a> <code>ContainerValidation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation
{
};

</code></pre></div><h3 id="containervalidation-assignallowedincontainerdelegate-l4-lambda-ca14cee2759167866a14f98c13ae1b05"><a href="#containervalidation-assignallowedincontainerdelegate-l4-lambda-ca14cee2759167866a14f98c13ae1b05" class="header-anchor">#</a> <code>ContainerValidation::_assignAllowedInContainerDelegate::__l4::&lt;lambda_ca14cee2759167866a14f98c13ae1b05&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::_assignAllowedInContainerDelegate::__l4::&lt;lambda_ca14cee2759167866a14f98c13ae1b05&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-a94226eda5fc26b1cbfbc88e36506e72"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-a94226eda5fc26b1cbfbc88e36506e72" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_a94226eda5fc26b1cbfbc88e36506e72&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_a94226eda5fc26b1cbfbc88e36506e72&gt;
{
  const ContainerScreenContext screenContext;
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-d5ee424f0847ea65030b7c6f6c1b586d"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-d5ee424f0847ea65030b7c6f6c1b586d" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_d5ee424f0847ea65030b7c6f6c1b586d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_d5ee424f0847ea65030b7c6f6c1b586d&gt;
{
  const ContainerScreenContext screenContext;
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l18-lambda-0ebe49e2c95965dee3ca7618c3b9009e"><a href="#containervalidation-assignvalidationdelegates-l18-lambda-0ebe49e2c95965dee3ca7618c3b9009e" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l18::&lt;lambda_0ebe49e2c95965dee3ca7618c3b9009e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l18::&lt;lambda_0ebe49e2c95965dee3ca7618c3b9009e&gt;
{
  HorseEquipValidationState state;
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-13fb63bd1fb91e659eed4da5282b6372"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-13fb63bd1fb91e659eed4da5282b6372" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_13fb63bd1fb91e659eed4da5282b6372&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_13fb63bd1fb91e659eed4da5282b6372&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-e569b0479cf2828d4244f0b5c7303b23"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-e569b0479cf2828d4244f0b5c7303b23" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_e569b0479cf2828d4244f0b5c7303b23&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_e569b0479cf2828d4244f0b5c7303b23&gt;
{
  const ContainerScreenContext screenContext;
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-ff26520e30a38044df172b5778af010a"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-ff26520e30a38044df172b5778af010a" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_ff26520e30a38044df172b5778af010a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_ff26520e30a38044df172b5778af010a&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-d032c3e0a9f5cb65ef6b2067239804b5"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-d032c3e0a9f5cb65ef6b2067239804b5" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_d032c3e0a9f5cb65ef6b2067239804b5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_d032c3e0a9f5cb65ef6b2067239804b5&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-571cf091bef6dba301b8f8dc63bbd974"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-571cf091bef6dba301b8f8dc63bbd974" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_571cf091bef6dba301b8f8dc63bbd974&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_571cf091bef6dba301b8f8dc63bbd974&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-29b95d068c06a7e703fe9d21cb73de5e"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-29b95d068c06a7e703fe9d21cb73de5e" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_29b95d068c06a7e703fe9d21cb73de5e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_29b95d068c06a7e703fe9d21cb73de5e&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-9b3a8e0d18f88b6b2f36e5ab819ecc64"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-9b3a8e0d18f88b6b2f36e5ab819ecc64" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_9b3a8e0d18f88b6b2f36e5ab819ecc64&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_9b3a8e0d18f88b6b2f36e5ab819ecc64&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-c57785192ac75762ce53fbae61c013ae"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-c57785192ac75762ce53fbae61c013ae" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_c57785192ac75762ce53fbae61c013ae&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_c57785192ac75762ce53fbae61c013ae&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-18bb92ef1ae5f58703be325415154ee1"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-18bb92ef1ae5f58703be325415154ee1" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_18bb92ef1ae5f58703be325415154ee1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_18bb92ef1ae5f58703be325415154ee1&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-015afaa8d4ac12f7081f67fc3327889e"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-015afaa8d4ac12f7081f67fc3327889e" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_015afaa8d4ac12f7081f67fc3327889e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_015afaa8d4ac12f7081f67fc3327889e&gt;
{
  const ContainerScreenContext screenContext;
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-28c1d666805352606ecc6aa691bede5a"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-28c1d666805352606ecc6aa691bede5a" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_28c1d666805352606ecc6aa691bede5a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_28c1d666805352606ecc6aa691bede5a&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-3737fd909942acaf574821aaa99cf1ad"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-3737fd909942acaf574821aaa99cf1ad" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_3737fd909942acaf574821aaa99cf1ad&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_3737fd909942acaf574821aaa99cf1ad&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-6a3d1f33c6cbf3efe5f892e64fe9f692"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-6a3d1f33c6cbf3efe5f892e64fe9f692" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_6a3d1f33c6cbf3efe5f892e64fe9f692&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_6a3d1f33c6cbf3efe5f892e64fe9f692&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-80788f509c3a4df1534e8891dcda3096"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-80788f509c3a4df1534e8891dcda3096" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_80788f509c3a4df1534e8891dcda3096&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_80788f509c3a4df1534e8891dcda3096&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-561de59b7805bdb21e2646c582f78dfe"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-561de59b7805bdb21e2646c582f78dfe" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_561de59b7805bdb21e2646c582f78dfe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_561de59b7805bdb21e2646c582f78dfe&gt;
{
};

</code></pre></div><h3 id="containervalidation-assignvalidationdelegates-l12-lambda-cab0653dadf048ef221190874c930768"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-cab0653dadf048ef221190874c930768" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_cab0653dadf048ef221190874c930768&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_cab0653dadf048ef221190874c930768&gt;
{
};

</code></pre></div><h3 id="container-sameitemandauxcomparator-l2-lambda-bc92f6dd1e60a290da569381c0bbc2a9"><a href="#container-sameitemandauxcomparator-l2-lambda-bc92f6dd1e60a290da569381c0bbc2a9" class="header-anchor">#</a> <code>Container::sameItemAndAuxComparator::__l2::&lt;lambda_bc92f6dd1e60a290da569381c0bbc2a9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Container::sameItemAndAuxComparator::__l2::&lt;lambda_bc92f6dd1e60a290da569381c0bbc2a9&gt;
{
  const ItemDescriptor descriptor;
};

</code></pre></div><h3 id="craftableelements"><a href="#craftableelements" class="header-anchor">#</a> <code>CraftableElements</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftableElements
{
  CraftableElements_vtbl *__vftable /*VFT*/;
  std::unordered_map&lt;unsigned int,enum ElementType&gt; mCraftableElements;
  std::unordered_map&lt;unsigned char,unsigned int&gt; mElementKeyToParticleKey;
};

</code></pre></div><h3 id="craftableelements-vtbl"><a href="#craftableelements-vtbl" class="header-anchor">#</a> <code>CraftableElements_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftableElements_vtbl
{
  void (__fastcall *~CraftableElements)(CraftableElements *this);
  void (__fastcall *registerElements)(CraftableElements *this);
  void (__fastcall *_registerElement)(CraftableElements *this, int, int, ElementType);
};

</code></pre></div><h3 id="craftingcontainermanagercontroller-getrecipesforitem-l2-lambda-6caeab14354bdd5c84e4ab8c2ea764bf"><a href="#craftingcontainermanagercontroller-getrecipesforitem-l2-lambda-6caeab14354bdd5c84e4ab8c2ea764bf" class="header-anchor">#</a> <code>CraftingContainerManagerController::_getRecipesForItem::__l2::&lt;lambda_6caeab14354bdd5c84e4ab8c2ea764bf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerController::_getRecipesForItem::__l2::&lt;lambda_6caeab14354bdd5c84e4ab8c2ea764bf&gt;
{
  std::vector&lt;std::reference_wrapper&lt;Recipe const &gt;&gt; *allRecipesForItem;
};

</code></pre></div><h3 id="craftingcontainermanagercontroller-filterrecipes-l2-lambda-cdb5314bee1f97240ba0cd908eecf8e9"><a href="#craftingcontainermanagercontroller-filterrecipes-l2-lambda-cdb5314bee1f97240ba0cd908eecf8e9" class="header-anchor">#</a> <code>CraftingContainerManagerController::_filterRecipes::__l2::&lt;lambda_cdb5314bee1f97240ba0cd908eecf8e9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerController::_filterRecipes::__l2::&lt;lambda_cdb5314bee1f97240ba0cd908eecf8e9&gt;
{
  std::vector&lt;std::reference_wrapper&lt;Recipe const &gt;&gt; *allRecipes;
};

</code></pre></div><h3 id="craftingcontainermanagercontroller-craftitem-l21-lambda-3c63015ccb477dfee5c6c66864ee0dc0"><a href="#craftingcontainermanagercontroller-craftitem-l21-lambda-3c63015ccb477dfee5c6c66864ee0dc0" class="header-anchor">#</a> <code>CraftingContainerManagerController::_craftItem::__l21::&lt;lambda_3c63015ccb477dfee5c6c66864ee0dc0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerController::_craftItem::__l21::&lt;lambda_3c63015ccb477dfee5c6c66864ee0dc0&gt;
{
  std::string *craftedRecipeIdentifier;
};

</code></pre></div><h3 id="craftingcontainermanagercontroller-getcraftablecount-l2-lambda-aa96b04be3948fd8222e3f0611ad44d0"><a href="#craftingcontainermanagercontroller-getcraftablecount-l2-lambda-aa96b04be3948fd8222e3f0611ad44d0" class="header-anchor">#</a> <code>CraftingContainerManagerController::getCraftableCount::__l2::&lt;lambda_aa96b04be3948fd8222e3f0611ad44d0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerController::getCraftableCount::__l2::&lt;lambda_aa96b04be3948fd8222e3f0611ad44d0&gt;
{
  std::vector&lt;std::reference_wrapper&lt;Recipe const &gt;&gt; *recipes;
};

</code></pre></div><h3 id="craftingcontainermanagercontroller-setupcallbacks-l2-lambda-d90798886221ba8ec068417f5dff86e6"><a href="#craftingcontainermanagercontroller-setupcallbacks-l2-lambda-d90798886221ba8ec068417f5dff86e6" class="header-anchor">#</a> <code>CraftingContainerManagerController::_setupCallbacks::__l2::&lt;lambda_d90798886221ba8ec068417f5dff86e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerController::_setupCallbacks::__l2::&lt;lambda_d90798886221ba8ec068417f5dff86e6&gt;
{
  CraftingContainerManagerController *const __this;
};

</code></pre></div><h3 id="craftingcontainermanagercontroller-ctor-l2-lambda-800ba8d7ddb3e3161c5f891001bcfb9c"><a href="#craftingcontainermanagercontroller-ctor-l2-lambda-800ba8d7ddb3e3161c5f891001bcfb9c" class="header-anchor">#</a> <code>CraftingContainerManagerController::{ctor}::__l2::&lt;lambda_800ba8d7ddb3e3161c5f891001bcfb9c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerController::{ctor}::__l2::&lt;lambda_800ba8d7ddb3e3161c5f891001bcfb9c&gt;
{
  CraftingContainerManagerController *const __this;
};

</code></pre></div><h3 id="containermanagercontroller-registercontainercallbacks-l12-lambda-ffe46bfded42ef6cce34996a89535ed2"><a href="#containermanagercontroller-registercontainercallbacks-l12-lambda-ffe46bfded42ef6cce34996a89535ed2" class="header-anchor">#</a> <code>ContainerManagerController::registerContainerCallbacks::__l12::&lt;lambda_ffe46bfded42ef6cce34996a89535ed2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerManagerController::registerContainerCallbacks::__l12::&lt;lambda_ffe46bfded42ef6cce34996a89535ed2&gt;
{
  std::weak_ptr&lt;ContainerManagerController&gt; weak_this;
};

</code></pre></div><h3 id="containermanagercontroller-registercontainercallbacks-l9-lambda-dc250ab7902177dc8a7fb2a2aa1b1d5e"><a href="#containermanagercontroller-registercontainercallbacks-l9-lambda-dc250ab7902177dc8a7fb2a2aa1b1d5e" class="header-anchor">#</a> <code>ContainerManagerController::registerContainerCallbacks::__l9::&lt;lambda_dc250ab7902177dc8a7fb2a2aa1b1d5e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerManagerController::registerContainerCallbacks::__l9::&lt;lambda_dc250ab7902177dc8a7fb2a2aa1b1d5e&gt;
{
  std::weak_ptr&lt;ContainerManagerController&gt; weak_this;
};

</code></pre></div><h3 id="craftinginputuicontainermodel"><a href="#craftinginputuicontainermodel" class="header-anchor">#</a> <code>CraftingInputUIContainerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CraftingInputUIContainerModel : PlayerUIContainerModelBase
{
  const bool mWorkBench;
};

</code></pre></div><h3 id="craftinginputuicontainermodel-vtbl"><a href="#craftinginputuicontainermodel-vtbl" class="header-anchor">#</a> <code>CraftingInputUIContainerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftingInputUIContainerModel_vtbl
{
  void (__fastcall *containerContentChanged)(ContainerContentChangeListener *this, int);
  void (__fastcall *~ContainerContentChangeListener)(ContainerContentChangeListener *this);
  void (__fastcall *containerAddCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *containerRemoveCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *postInit)(ContainerModel *this);
  void (__fastcall *releaseResources)(ContainerModel *this);
  int (__fastcall *getContainerSize)(ContainerModel *this);
  int (__fastcall *getFilteredContainerSize)(ContainerModel *this);
  void (__fastcall *tick)(ContainerModel *this, int);
  ContainerWeakRef *(__fastcall *getContainerWeakRef)(ContainerModel *this, ContainerWeakRef *result);
  const ItemStack *(__fastcall *getItemStack)(ContainerModel *this, int);
  const std::vector&lt;ItemStack&gt; *(__fastcall *getItems)(ContainerModel *this);
  const ItemInstance *(__fastcall *getItemInstance)(ContainerModel *this, int);
  const ItemStackBase *(__fastcall *getItemStackBase)(ContainerModel *this, int);
  bool (__fastcall *isItemInstanceBased)(ContainerModel *this);
  void (__fastcall *setItem)(ContainerModel *this, int, const ItemStack *);
  bool (__fastcall *isValid)(ContainerModel *this);
  bool (__fastcall *isItemFiltered)(ContainerModel *this, const ItemStackBase *);
  bool (__fastcall *isExpanableItemFiltered)(ContainerModel *this, int);
  ContainerExpandStatus (__fastcall *getItemExpandStatus)(ContainerModel *this, int);
  const std::string *(__fastcall *getItemGroupName)(ContainerModel *this, int);
  void (__fastcall *switchItemExpando)(ContainerModel *this, int);
  Container *(__fastcall *_getContainer)(ContainerModel *this);
  int (__fastcall *_getContainerOffset)(ContainerModel *this);
  void (__fastcall *_onItemChanged)(ContainerModel *this, int, const ItemStack *, const ItemStack *);
};

</code></pre></div><h3 id="containermodel-serverinititemstackids-l5-lambda-3ceb7baffe147371abb8ef0876d49f62"><a href="#containermodel-serverinititemstackids-l5-lambda-3ceb7baffe147371abb8ef0876d49f62" class="header-anchor">#</a> <code>ContainerModel::serverInitItemStackIds::__l5::&lt;lambda_3ceb7baffe147371abb8ef0876d49f62&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerModel::serverInitItemStackIds::__l5::&lt;lambda_3ceb7baffe147371abb8ef0876d49f62&gt;
{
  ContainerModel *const __this;
  Container **container;
};

</code></pre></div><h3 id="craftingcontainermanagermodel-setisfiltering-l2-lambda-aa6cdefd030e9b17f5bf31429c7faed4"><a href="#craftingcontainermanagermodel-setisfiltering-l2-lambda-aa6cdefd030e9b17f5bf31429c7faed4" class="header-anchor">#</a> <code>CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_aa6cdefd030e9b17f5bf31429c7faed4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_aa6cdefd030e9b17f5bf31429c7faed4&gt;
{
  CraftingContainerManagerModel *const __this;
};

</code></pre></div><h3 id="craftingcontainermanagermodel-setisfiltering-l2-lambda-aa6cdefd030e9b17f5bf31429c7faed4-l5-lambda-fcf8e0e085a275fe1caed95ccdf54f52"><a href="#craftingcontainermanagermodel-setisfiltering-l2-lambda-aa6cdefd030e9b17f5bf31429c7faed4-l5-lambda-fcf8e0e085a275fe1caed95ccdf54f52" class="header-anchor">#</a> <code>CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_aa6cdefd030e9b17f5bf31429c7faed4&gt;::()::__l5::&lt;lambda_fcf8e0e085a275fe1caed95ccdf54f52&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_aa6cdefd030e9b17f5bf31429c7faed4&gt;::()::__l5::&lt;lambda_fcf8e0e085a275fe1caed95ccdf54f52&gt;
{
  std::vector&lt;std::reference_wrapper&lt;Recipe const &gt;&gt; *recipes;
};

</code></pre></div><h3 id="craftingcontainermanagermodel-setisfiltering-l2-lambda-67395b7a0ffee627249620bb17590dfa"><a href="#craftingcontainermanagermodel-setisfiltering-l2-lambda-67395b7a0ffee627249620bb17590dfa" class="header-anchor">#</a> <code>CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_67395b7a0ffee627249620bb17590dfa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_67395b7a0ffee627249620bb17590dfa&gt;
{
  CraftingContainerManagerModel *const __this;
};

</code></pre></div><h3 id="craftingcontainermanagermodel-setisfiltering-l2-lambda-d23c8612754ab7d5d860be95d2731fb5"><a href="#craftingcontainermanagermodel-setisfiltering-l2-lambda-d23c8612754ab7d5d860be95d2731fb5" class="header-anchor">#</a> <code>CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_d23c8612754ab7d5d860be95d2731fb5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_d23c8612754ab7d5d860be95d2731fb5&gt;
{
  CraftingContainerManagerModel *const __this;
};

</code></pre></div><h3 id="craftingcontainermanagermodel-setisfiltering-l2-lambda-d23c8612754ab7d5d860be95d2731fb5-l5-lambda-1ce802a31af62b630ae423dca09bea4a"><a href="#craftingcontainermanagermodel-setisfiltering-l2-lambda-d23c8612754ab7d5d860be95d2731fb5-l5-lambda-1ce802a31af62b630ae423dca09bea4a" class="header-anchor">#</a> <code>CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_d23c8612754ab7d5d860be95d2731fb5&gt;::()::__l5::&lt;lambda_1ce802a31af62b630ae423dca09bea4a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_d23c8612754ab7d5d860be95d2731fb5&gt;::()::__l5::&lt;lambda_1ce802a31af62b630ae423dca09bea4a&gt;
{
  std::vector&lt;std::reference_wrapper&lt;Recipe const &gt;&gt; *recipes;
};

</code></pre></div><h3 id="craftingcontainermanagermodel-setisfiltering-l2-lambda-d013e68ca17835317031a2aeceb600f4"><a href="#craftingcontainermanagermodel-setisfiltering-l2-lambda-d013e68ca17835317031a2aeceb600f4" class="header-anchor">#</a> <code>CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_d013e68ca17835317031a2aeceb600f4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerModel::setIsFiltering::__l2::&lt;lambda_d013e68ca17835317031a2aeceb600f4&gt;
{
  CraftingContainerManagerModel *const __this;
};

</code></pre></div><h3 id="craftingcontainermanagermodel-filterbyinventory-l5-lambda-f6b29bd3f04dbc18ccf3d2fd33e47d6c"><a href="#craftingcontainermanagermodel-filterbyinventory-l5-lambda-f6b29bd3f04dbc18ccf3d2fd33e47d6c" class="header-anchor">#</a> <code>CraftingContainerManagerModel::_filterByInventory::__l5::&lt;lambda_f6b29bd3f04dbc18ccf3d2fd33e47d6c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerModel::_filterByInventory::__l5::&lt;lambda_f6b29bd3f04dbc18ccf3d2fd33e47d6c&gt;
{
  std::vector&lt;std::reference_wrapper&lt;Recipe const &gt;&gt; *allRecipesForItem;
};

</code></pre></div><h3 id="craftingcontainermanagermodel-postinit-l2-lambda-f9fa4eb62304d0425ba9cc315955a7b9"><a href="#craftingcontainermanagermodel-postinit-l2-lambda-f9fa4eb62304d0425ba9cc315955a7b9" class="header-anchor">#</a> <code>CraftingContainerManagerModel::_postInit::__l2::&lt;lambda_f9fa4eb62304d0425ba9cc315955a7b9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftingContainerManagerModel::_postInit::__l2::&lt;lambda_f9fa4eb62304d0425ba9cc315955a7b9&gt;
{
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendplayercreated-l2-lambda-cbb646d286c056753ea8bb17996e0baf"><a href="#clientplayereventcoordinator-sendplayercreated-l2-lambda-cbb646d286c056753ea8bb17996e0baf" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendPlayerCreated::__l2::&lt;lambda_cbb646d286c056753ea8bb17996e0baf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendPlayerCreated::__l2::&lt;lambda_cbb646d286c056753ea8bb17996e0baf&gt;
{
  LocalPlayer *player;
  const std::string *personaSlot;
  const std::string *classicSkinId;
  bool *usingClassicSkin;
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendplayerstopriding-l2-lambda-d603610a604c5d778adc893eadca2b75"><a href="#clientplayereventcoordinator-sendplayerstopriding-l2-lambda-d603610a604c5d778adc893eadca2b75" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendPlayerStopRiding::__l2::&lt;lambda_d603610a604c5d778adc893eadca2b75&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendPlayerStopRiding::__l2::&lt;lambda_d603610a604c5d778adc893eadca2b75&gt;
{
  Player *player;
  bool *exitFromRider;
  bool *entityIsBeingDestroyed;
  bool *switchingRides;
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendplayerstartriding-l2-lambda-4f6468d189e6f140542d3caf9506a7b4"><a href="#clientplayereventcoordinator-sendplayerstartriding-l2-lambda-4f6468d189e6f140542d3caf9506a7b4" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendPlayerStartRiding::__l2::&lt;lambda_4f6468d189e6f140542d3caf9506a7b4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendPlayerStartRiding::__l2::&lt;lambda_4f6468d189e6f140542d3caf9506a7b4&gt;
{
  Player *player;
  Actor *ride;
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendlocalplayerrespawn-l2-lambda-13e49c72a3fd0c359103c3c3e8752bfe"><a href="#clientplayereventcoordinator-sendlocalplayerrespawn-l2-lambda-13e49c72a3fd0c359103c3c3e8752bfe" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendLocalPlayerRespawn::__l2::&lt;lambda_13e49c72a3fd0c359103c3c3e8752bfe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendLocalPlayerRespawn::__l2::&lt;lambda_13e49c72a3fd0c359103c3c3e8752bfe&gt;
{
  IClientInstance *client;
  LocalPlayer *player;
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendlocalplayerdeath-l2-lambda-957d1afedc287aa655fd9d822a5c66fd"><a href="#clientplayereventcoordinator-sendlocalplayerdeath-l2-lambda-957d1afedc287aa655fd9d822a5c66fd" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendLocalPlayerDeath::__l2::&lt;lambda_957d1afedc287aa655fd9d822a5c66fd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendLocalPlayerDeath::__l2::&lt;lambda_957d1afedc287aa655fd9d822a5c66fd&gt;
{
  IClientInstance *client;
  LocalPlayer *player;
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendplayerdestroyedblock-l2-lambda-7de0e8b341ebea8a59785104915845ed"><a href="#clientplayereventcoordinator-sendplayerdestroyedblock-l2-lambda-7de0e8b341ebea8a59785104915845ed" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendPlayerDestroyedBlock::__l2::&lt;lambda_7de0e8b341ebea8a59785104915845ed&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendPlayerDestroyedBlock::__l2::&lt;lambda_7de0e8b341ebea8a59785104915845ed&gt;
{
  Player *player;
  const BlockLegacy *blockType;
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendstartdestroyblock-l2-lambda-306705e6c21dd23dbe7a62e736a559a5"><a href="#clientplayereventcoordinator-sendstartdestroyblock-l2-lambda-306705e6c21dd23dbe7a62e736a559a5" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendStartDestroyBlock::__l2::&lt;lambda_306705e6c21dd23dbe7a62e736a559a5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendStartDestroyBlock::__l2::&lt;lambda_306705e6c21dd23dbe7a62e736a559a5&gt;
{
  Player *player;
  const BlockPos *pos;
  unsigned __int8 *face;
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendplayerturn-l2-lambda-928c0980f93f358810417fb87f5a4a69"><a href="#clientplayereventcoordinator-sendplayerturn-l2-lambda-928c0980f93f358810417fb87f5a4a69" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendPlayerTurn::__l2::&lt;lambda_928c0980f93f358810417fb87f5a4a69&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendPlayerTurn::__l2::&lt;lambda_928c0980f93f358810417fb87f5a4a69&gt;
{
  Player *player;
  Vec2 *turnDelta;
};

</code></pre></div><h3 id="clientplayereventcoordinator-sendplayerinput-l2-lambda-4b6575f26cb031f0d5a8936a9950dab3"><a href="#clientplayereventcoordinator-sendplayerinput-l2-lambda-4b6575f26cb031f0d5a8936a9950dab3" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator::sendPlayerInput::__l2::&lt;lambda_4b6575f26cb031f0d5a8936a9950dab3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator::sendPlayerInput::__l2::&lt;lambda_4b6575f26cb031f0d5a8936a9950dab3&gt;
{
  IPlayerMovementProxy *player;
  MoveInputHandler *input;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendstartleavegame-l2-lambda-8a82e27afbaa5b3ed078861894dbbaf7"><a href="#clientinstanceeventcoordinator-sendstartleavegame-l2-lambda-8a82e27afbaa5b3ed078861894dbbaf7" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendStartLeaveGame::__l2::&lt;lambda_8a82e27afbaa5b3ed078861894dbbaf7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendStartLeaveGame::__l2::&lt;lambda_8a82e27afbaa5b3ed078861894dbbaf7&gt;
{
  ClientInstance *instance;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendcliententeredworld-l2-lambda-aa8bf0031d48e9bb7466024d647d8181"><a href="#clientinstanceeventcoordinator-sendcliententeredworld-l2-lambda-aa8bf0031d48e9bb7466024d647d8181" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendClientEnteredWorld::__l2::&lt;lambda_aa8bf0031d48e9bb7466024d647d8181&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendClientEnteredWorld::__l2::&lt;lambda_aa8bf0031d48e9bb7466024d647d8181&gt;
{
  ClientInstance *instance;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendclientsuspend-l2-lambda-3a59cd1777c222e9b7d72fcb4828994d"><a href="#clientinstanceeventcoordinator-sendclientsuspend-l2-lambda-3a59cd1777c222e9b7d72fcb4828994d" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendClientSuspend::__l2::&lt;lambda_3a59cd1777c222e9b7d72fcb4828994d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendClientSuspend::__l2::&lt;lambda_3a59cd1777c222e9b7d72fcb4828994d&gt;
{
  ClientInstance *instance;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendclientupdateend-l2-lambda-5547db528708a9f123e39e444b1ce0c4"><a href="#clientinstanceeventcoordinator-sendclientupdateend-l2-lambda-5547db528708a9f123e39e444b1ce0c4" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendClientUpdateEnd::__l2::&lt;lambda_5547db528708a9f123e39e444b1ce0c4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendClientUpdateEnd::__l2::&lt;lambda_5547db528708a9f123e39e444b1ce0c4&gt;
{
  ClientInstance *instance;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendclientupdatestart-l2-lambda-7fb2a44e2ccf295a22fc580a9edaa1e6"><a href="#clientinstanceeventcoordinator-sendclientupdatestart-l2-lambda-7fb2a44e2ccf295a22fc580a9edaa1e6" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendClientUpdateStart::__l2::&lt;lambda_7fb2a44e2ccf295a22fc580a9edaa1e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendClientUpdateStart::__l2::&lt;lambda_7fb2a44e2ccf295a22fc580a9edaa1e6&gt;
{
  ClientInstance *instance;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendclientcreatedlevel-l2-lambda-82e58d8e24e455a327e677fd8c43ed78"><a href="#clientinstanceeventcoordinator-sendclientcreatedlevel-l2-lambda-82e58d8e24e455a327e677fd8c43ed78" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendClientCreatedLevel::__l2::&lt;lambda_82e58d8e24e455a327e677fd8c43ed78&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendClientCreatedLevel::__l2::&lt;lambda_82e58d8e24e455a327e677fd8c43ed78&gt;
{
  ClientInstance *instance;
  Level *level;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendclientminecraftinitialized-l2-lambda-ded5d68558497ba91b283686b43c5afc"><a href="#clientinstanceeventcoordinator-sendclientminecraftinitialized-l2-lambda-ded5d68558497ba91b283686b43c5afc" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendClientMinecraftInitialized::__l2::&lt;lambda_ded5d68558497ba91b283686b43c5afc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendClientMinecraftInitialized::__l2::&lt;lambda_ded5d68558497ba91b283686b43c5afc&gt;
{
  ClientInstance *instance;
  Minecraft *minecraft;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendclientinitializeend-l2-lambda-fae6b47936c8bd0d3d88c82eb8ab6250"><a href="#clientinstanceeventcoordinator-sendclientinitializeend-l2-lambda-fae6b47936c8bd0d3d88c82eb8ab6250" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendClientInitializeEnd::__l2::&lt;lambda_fae6b47936c8bd0d3d88c82eb8ab6250&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendClientInitializeEnd::__l2::&lt;lambda_fae6b47936c8bd0d3d88c82eb8ab6250&gt;
{
  ClientInstance *instance;
};

</code></pre></div><h3 id="clientinstanceeventcoordinator-sendclientinitializestart-l2-lambda-86c15645a56632f21ecc7d1e02c49df7"><a href="#clientinstanceeventcoordinator-sendclientinitializestart-l2-lambda-86c15645a56632f21ecc7d1e02c49df7" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator::sendClientInitializeStart::__l2::&lt;lambda_86c15645a56632f21ecc7d1e02c49df7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator::sendClientInitializeStart::__l2::&lt;lambda_86c15645a56632f21ecc7d1e02c49df7&gt;
{
  ClientInstance *instance;
};

</code></pre></div><h3 id="clienthitdetectcoordinator-sendcontinuouspickhitresult-l2-lambda-4cf05be3c943c8f3543e21b9a5f563b8"><a href="#clienthitdetectcoordinator-sendcontinuouspickhitresult-l2-lambda-4cf05be3c943c8f3543e21b9a5f563b8" class="header-anchor">#</a> <code>ClientHitDetectCoordinator::sendContinuousPickHitResult::__l2::&lt;lambda_4cf05be3c943c8f3543e21b9a5f563b8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientHitDetectCoordinator::sendContinuousPickHitResult::__l2::&lt;lambda_4cf05be3c943c8f3543e21b9a5f563b8&gt;
{
  HitResult *hitResult;
};

</code></pre></div><h3 id="clienthitdetectcoordinator-sendchangedpickhitresult-l2-lambda-b21f51f0655eacdc77738b23dbe4a069"><a href="#clienthitdetectcoordinator-sendchangedpickhitresult-l2-lambda-b21f51f0655eacdc77738b23dbe4a069" class="header-anchor">#</a> <code>ClientHitDetectCoordinator::sendChangedPickHitResult::__l2::&lt;lambda_b21f51f0655eacdc77738b23dbe4a069&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientHitDetectCoordinator::sendChangedPickHitResult::__l2::&lt;lambda_b21f51f0655eacdc77738b23dbe4a069&gt;
{
  HitResult *hitResult;
};

</code></pre></div><h3 id="clienthitdetectcoordinator-sendcontinuoushitresult-l2-lambda-c2529579edb7345e3bf2ed9ad53c8428"><a href="#clienthitdetectcoordinator-sendcontinuoushitresult-l2-lambda-c2529579edb7345e3bf2ed9ad53c8428" class="header-anchor">#</a> <code>ClientHitDetectCoordinator::sendContinuousHitResult::__l2::&lt;lambda_c2529579edb7345e3bf2ed9ad53c8428&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientHitDetectCoordinator::sendContinuousHitResult::__l2::&lt;lambda_c2529579edb7345e3bf2ed9ad53c8428&gt;
{
  HitResult *hitResult;
};

</code></pre></div><h3 id="clienthitdetectcoordinator-sendchangedhitresult-l2-lambda-3d6978abe3b73298ad5ac47b140c6cb9"><a href="#clienthitdetectcoordinator-sendchangedhitresult-l2-lambda-3d6978abe3b73298ad5ac47b140c6cb9" class="header-anchor">#</a> <code>ClientHitDetectCoordinator::sendChangedHitResult::__l2::&lt;lambda_3d6978abe3b73298ad5ac47b140c6cb9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientHitDetectCoordinator::sendChangedHitResult::__l2::&lt;lambda_3d6978abe3b73298ad5ac47b140c6cb9&gt;
{
  HitResult *hitResult;
};

</code></pre></div><h3 id="containermenu"><a href="#containermenu" class="header-anchor">#</a> <code>ContainerMenu</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ContainerMenu : BaseContainerMenu
{
  ActorUniqueID mEntityUniqueId;
  BlockPos mPos;
};

</code></pre></div><h3 id="containermenu-vtbl"><a href="#containermenu-vtbl" class="header-anchor">#</a> <code>ContainerMenu_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerMenu_vtbl
{
  void (__fastcall *containerContentChanged)(ContainerContentChangeListener *this, int);
  void (__fastcall *~ContainerContentChangeListener)(ContainerContentChangeListener *this);
  void (__fastcall *containerAddCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *containerRemoveCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *removeSlot)(BaseContainerMenu *this, int, int);
  bool (__fastcall *isSlotDirty)(BaseContainerMenu *this, int);
  bool (__fastcall *isResultSlot)(BaseContainerMenu *this, int);
  Container *(__fastcall *_getContainer)(BaseContainerMenu *this);
};

</code></pre></div><h3 id="crafthandlenonimplemented-deprecatedasktylaing"><a href="#crafthandlenonimplemented-deprecatedasktylaing" class="header-anchor">#</a> <code>CraftHandleNonImplemented_DEPRECATEDASKTYLAING</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftHandleNonImplemented_DEPRECATEDASKTYLAING : CraftHandlerBase
{
};

</code></pre></div><h3 id="crafthandlenonimplemented-deprecatedasktylaing-vtbl"><a href="#crafthandlenonimplemented-deprecatedasktylaing-vtbl" class="header-anchor">#</a> <code>CraftHandleNonImplemented_DEPRECATEDASKTYLAING_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftHandleNonImplemented_DEPRECATEDASKTYLAING_vtbl
{
  void (__fastcall *~CraftHandlerBase)(CraftHandlerBase *this);
  void (__fastcall *endRequestBatch)(CraftHandlerBase *this);
  ItemStackNetResult (__fastcall *_handleCraftAction)(CraftHandlerBase *this, const ItemStackRequestActionCraftBase *);
  void (__fastcall *_postCraftRequest)(CraftHandlerBase *this, const bool);
};

</code></pre></div><h3 id="crafthandlercrafting"><a href="#crafthandlercrafting" class="header-anchor">#</a> <code>CraftHandlerCrafting</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CraftHandlerCrafting : CraftHandlerBase
{
  bool mWorkbench;
  Player *mPlayer;
};

</code></pre></div><h3 id="crafthandlercrafting-vtbl"><a href="#crafthandlercrafting-vtbl" class="header-anchor">#</a> <code>CraftHandlerCrafting_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftHandlerCrafting_vtbl
{
  void (__fastcall *~CraftHandlerBase)(CraftHandlerBase *this);
  void (__fastcall *endRequestBatch)(CraftHandlerBase *this);
  ItemStackNetResult (__fastcall *_handleCraftAction)(CraftHandlerBase *this, const ItemStackRequestActionCraftBase *);
  void (__fastcall *_postCraftRequest)(CraftHandlerBase *this, const bool);
};

</code></pre></div><h3 id="crafthandlerenchant"><a href="#crafthandlerenchant" class="header-anchor">#</a> <code>CraftHandlerEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CraftHandlerEnchant : CraftHandlerBase
{
  int mEnchantCost;
  Player *mPlayer;
  bool mRecalculateOptions;
};

</code></pre></div><h3 id="crafthandlerenchant-vtbl"><a href="#crafthandlerenchant-vtbl" class="header-anchor">#</a> <code>CraftHandlerEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftHandlerEnchant_vtbl
{
  void (__fastcall *~CraftHandlerBase)(CraftHandlerBase *this);
  void (__fastcall *endRequestBatch)(CraftHandlerBase *this);
  ItemStackNetResult (__fastcall *_handleCraftAction)(CraftHandlerBase *this, const ItemStackRequestActionCraftBase *);
  void (__fastcall *_postCraftRequest)(CraftHandlerBase *this, const bool);
};

</code></pre></div><h3 id="crafthandlertrade"><a href="#crafthandlertrade" class="header-anchor">#</a> <code>CraftHandlerTrade</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CraftHandlerTrade : CraftHandlerBase
{
  const ContainerScreenContext *mScreenContext;
  bool mIsTrade2;
};

</code></pre></div><h3 id="crafthandlertrade-vtbl"><a href="#crafthandlertrade-vtbl" class="header-anchor">#</a> <code>CraftHandlerTrade_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftHandlerTrade_vtbl
{
  void (__fastcall *~CraftHandlerBase)(CraftHandlerBase *this);
  void (__fastcall *endRequestBatch)(CraftHandlerBase *this);
  ItemStackNetResult (__fastcall *_handleCraftAction)(CraftHandlerBase *this, const ItemStackRequestActionCraftBase *);
  void (__fastcall *_postCraftRequest)(CraftHandlerBase *this, const bool);
};

</code></pre></div><h3 id="carrotonastickitem"><a href="#carrotonastickitem" class="header-anchor">#</a> <code>CarrotOnAStickItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CarrotOnAStickItem : Item
{
};

</code></pre></div><h3 id="chemistryblockitem"><a href="#chemistryblockitem" class="header-anchor">#</a> <code>ChemistryBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChemistryBlockItem : BlockItem
{
};

</code></pre></div><h3 id="chemistryauxdatablockitem"><a href="#chemistryauxdatablockitem" class="header-anchor">#</a> <code>ChemistryAuxDataBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChemistryAuxDataBlockItem : AuxDataBlockItem
{
};

</code></pre></div><h3 id="coralfanblockitem"><a href="#coralfanblockitem" class="header-anchor">#</a> <code>CoralFanBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CoralFanBlockItem : BlockItem
{
};

</code></pre></div><h3 id="coralfanblockitem-useon-l72-lambda-1e855bb0deac619b44ec09dd5754848c"><a href="#coralfanblockitem-useon-l72-lambda-1e855bb0deac619b44ec09dd5754848c" class="header-anchor">#</a> <code>CoralFanBlockItem::_useOn::__l72::&lt;lambda_1e855bb0deac619b44ec09dd5754848c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CoralFanBlockItem::_useOn::__l72::&lt;lambda_1e855bb0deac619b44ec09dd5754848c&gt;
{
  BlockPos *pos;
  const Block **finalBlock;
  const CompoundTag *dataID;
  Actor *entity;
  unsigned __int8 *face;
  bool *canceled;
};

</code></pre></div><h3 id="chemistryrecipes"><a href="#chemistryrecipes" class="header-anchor">#</a> <code>ChemistryRecipes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChemistryRecipes
{
};

</code></pre></div><h3 id="coloredtorchblock"><a href="#coloredtorchblock" class="header-anchor">#</a> <code>ColoredTorchBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ColoredTorchBlock : TorchBlock
{
  ColoredTorchColor mBaseColor;
};

</code></pre></div><h3 id="coloredtorchblock-vtbl"><a href="#coloredtorchblock-vtbl" class="header-anchor">#</a> <code>ColoredTorchBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ColoredTorchBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="cocoablock"><a href="#cocoablock" class="header-anchor">#</a> <code>CocoaBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CocoaBlock : BlockLegacy
{
};

</code></pre></div><h3 id="cocoablock-vtbl"><a href="#cocoablock-vtbl" class="header-anchor">#</a> <code>CocoaBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CocoaBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="crossbowenchant"><a href="#crossbowenchant" class="header-anchor">#</a> <code>CrossbowEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CrossbowEnchant : Enchant
{
};

</code></pre></div><h3 id="crossbowenchant-vtbl"><a href="#crossbowenchant-vtbl" class="header-anchor">#</a> <code>CrossbowEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CrossbowEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="cursebindingenchant"><a href="#cursebindingenchant" class="header-anchor">#</a> <code>CurseBindingEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CurseBindingEnchant : Enchant
{
};

</code></pre></div><h3 id="cursebindingenchant-vtbl"><a href="#cursebindingenchant-vtbl" class="header-anchor">#</a> <code>CurseBindingEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CurseBindingEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="cursevanishingenchant"><a href="#cursevanishingenchant" class="header-anchor">#</a> <code>CurseVanishingEnchant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CurseVanishingEnchant : Enchant
{
};

</code></pre></div><h3 id="cursevanishingenchant-vtbl"><a href="#cursevanishingenchant-vtbl" class="header-anchor">#</a> <code>CurseVanishingEnchant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CurseVanishingEnchant_vtbl
{
  void (__fastcall *~Enchant)(Enchant *this);
  bool (__fastcall *isCompatibleWith)(Enchant *this, Enchant::Type);
  int (__fastcall *getMinCost)(Enchant *this, int);
  int (__fastcall *getMaxCost)(Enchant *this, int);
  int (__fastcall *getMinLevel)(Enchant *this);
  int (__fastcall *getMaxLevel)(Enchant *this);
  int (__fastcall *getDamageProtection)(Enchant *this, int, const ActorDamageSource *);
  float (__fastcall *getDamageBonus)(Enchant *this, int, const Actor *);
  void (__fastcall *doPostAttack)(Enchant *this, Actor *, Actor *, int);
  void (__fastcall *doPostHurt)(Enchant *this, ItemInstance *, Actor *, Actor *, int);
  bool (__fastcall *isMeleeDamageEnchant)(Enchant *this);
  bool (__fastcall *isProtectionEnchant)(Enchant *this);
  bool (__fastcall *isTreasureOnly)(Enchant *this);
  bool (__fastcall *isDiscoverable)(Enchant *this);
};

</code></pre></div><h3 id="cameraitem"><a href="#cameraitem" class="header-anchor">#</a> <code>CameraItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraItem : Item
{
};

</code></pre></div><h3 id="clothblockitem"><a href="#clothblockitem" class="header-anchor">#</a> <code>ClothBlockItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClothBlockItem : BlockItem
{
};

</code></pre></div><h3 id="coalitem"><a href="#coalitem" class="header-anchor">#</a> <code>CoalItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CoalItem : Item
{
  TextureUVCoordinateSet m_charoalUV;
  CoalItem::Type mType;
};

</code></pre></div><h3 id="chemistrytableblock"><a href="#chemistrytableblock" class="header-anchor">#</a> <code>ChemistryTableBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChemistryTableBlock : ActorBlock
{
};

</code></pre></div><h3 id="chemistrytableblock-vtbl"><a href="#chemistrytableblock-vtbl" class="header-anchor">#</a> <code>ChemistryTableBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChemistryTableBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="customskycolorattributes"><a href="#customskycolorattributes" class="header-anchor">#</a> <code>CustomSkyColorAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomSkyColorAttributes
{
  mce::Color mSkyColor;
};

</code></pre></div><h3 id="customfoliagecolorattributes"><a href="#customfoliagecolorattributes" class="header-anchor">#</a> <code>CustomFoliageColorAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CustomFoliageColorAttributes
{
  int mFoliageColor;
};

</code></pre></div><h3 id="colorpaletteattributes"><a href="#colorpaletteattributes" class="header-anchor">#</a> <code>ColorPaletteAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct ColorPaletteAttributes
{
  _BYTE mPaletteName[8];
};

</code></pre></div><h3 id="custommapfoliagecolorattributes"><a href="#custommapfoliagecolorattributes" class="header-anchor">#</a> <code>CustomMapFoliageColorAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CustomMapFoliageColorAttributes
{
  int mMapFoliageColor;
};

</code></pre></div><h3 id="customgrasscolorattributes"><a href="#customgrasscolorattributes" class="header-anchor">#</a> <code>CustomGrassColorAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CustomGrassColorAttributes
{
  int mGrassColor;
};

</code></pre></div><h3 id="custommapgrasscolorattributes"><a href="#custommapgrasscolorattributes" class="header-anchor">#</a> <code>CustomMapGrassColorAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CustomMapGrassColorAttributes
{
  int mMapGrassColor;
};

</code></pre></div><h3 id="customdebugmapcolorattributes"><a href="#customdebugmapcolorattributes" class="header-anchor">#</a> <code>CustomDebugMapColorAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CustomDebugMapColorAttributes
{
  int mDebugMapColor;
};

</code></pre></div><h3 id="customdebugmapcoloroddattributes"><a href="#customdebugmapcoloroddattributes" class="header-anchor">#</a> <code>CustomDebugMapColorOddAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CustomDebugMapColorOddAttributes
{
  int mDebugMapOddColor;
};

</code></pre></div><h3 id="customtemperaturecategoryattributes"><a href="#customtemperaturecategoryattributes" class="header-anchor">#</a> <code>CustomTemperatureCategoryAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CustomTemperatureCategoryAttributes
{
  Biome::BiomeTempCategory mTemperatureCategory;
};

</code></pre></div><h3 id="customhumidityattributes"><a href="#customhumidityattributes" class="header-anchor">#</a> <code>CustomHumidityAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CustomHumidityAttributes
{
  bool mIsHumid;
};

</code></pre></div><h3 id="comparatorblockactor"><a href="#comparatorblockactor" class="header-anchor">#</a> <code>ComparatorBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ComparatorBlockActor : BlockActor
{
  int mOutput;
};

</code></pre></div><h3 id="comparatorblockactor-vtbl"><a href="#comparatorblockactor-vtbl" class="header-anchor">#</a> <code>ComparatorBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ComparatorBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
  int (__fastcall *getOutputSignal)(ComparatorBlockActor *this);
  void (__fastcall *setOutputSignal)(ComparatorBlockActor *this, int);
};

</code></pre></div><h3 id="chestblock"><a href="#chestblock" class="header-anchor">#</a> <code>ChestBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ChestBlock : ActorBlock
{
  ChestBlock::ChestType mType;
};

</code></pre></div><h3 id="chestblock-vtbl"><a href="#chestblock-vtbl" class="header-anchor">#</a> <code>ChestBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChestBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="capacitorcomponent"><a href="#capacitorcomponent" class="header-anchor">#</a> <code>CapacitorComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CapacitorComponent : ProducerComponent
{
};

</code></pre></div><h3 id="capacitorcomponent-vtbl"><a href="#capacitorcomponent-vtbl" class="header-anchor">#</a> <code>CapacitorComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CapacitorComponent_vtbl
{
  void (__fastcall *~BaseCircuitComponent)(BaseCircuitComponent *this);
  int (__fastcall *getStrength)(BaseCircuitComponent *this);
  int (__fastcall *getDirection)(BaseCircuitComponent *this);
  void (__fastcall *setStrength)(BaseCircuitComponent *this, int);
  void (__fastcall *setDirection)(BaseCircuitComponent *this, unsigned __int8);
  bool (__fastcall *consumePowerAnyDirection)(BaseCircuitComponent *this);
  bool (__fastcall *canConsumerPower)(BaseCircuitComponent *this);
  bool (__fastcall *canStopPower)(BaseCircuitComponent *this);
  void (__fastcall *setStopPower)(BaseCircuitComponent *this, bool);
  unsigned __int64 (__fastcall *getBaseType)(BaseCircuitComponent *this);
  unsigned __int64 (__fastcall *getInstanceType)(BaseCircuitComponent *this);
  bool (__fastcall *removeSource)(BaseCircuitComponent *this, const BlockPos *, const BaseCircuitComponent *);
  bool (__fastcall *addSource)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, int *, bool *);
  bool (__fastcall *allowConnection)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, bool *);
  void (__fastcall *checkLock)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  bool (__fastcall *evaluate)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *cacheValues)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *updateDependencies)(BaseCircuitComponent *this, CircuitSceneGraph *, const BlockPos *);
  bool (__fastcall *allowIndirect)(BaseCircuitComponent *this);
  bool (__fastcall *isHalfPulse)(BaseCircuitComponent *this);
  bool (__fastcall *hasSource)(BaseCircuitComponent *this, BaseCircuitComponent *);
  bool (__fastcall *hasChildrenSource)(BaseCircuitComponent *this);
  bool (__fastcall *isSecondaryPowered)(BaseCircuitComponent *this);
  unsigned __int8 (__fastcall *getPoweroutDirection)(CapacitorComponent *this);
};

</code></pre></div><h3 id="comparatorcapacitor"><a href="#comparatorcapacitor" class="header-anchor">#</a> <code>ComparatorCapacitor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComparatorCapacitor : CapacitorComponent
{
  int mRearAnalogStrength;
  int mSideAnalogStrengthRight;
  int mSideAnalogStrengthLeft;
  int mOldStrength;
  ComparatorCapacitor::Mode mMode;
  int mRearStrength;
  int mSideStrengths;
  bool mHasAnalogBeenSet;
  CircuitComponentList mSideComponents;
};

</code></pre></div><h3 id="comparatorcapacitor-vtbl"><a href="#comparatorcapacitor-vtbl" class="header-anchor">#</a> <code>ComparatorCapacitor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ComparatorCapacitor_vtbl
{
  void (__fastcall *~BaseCircuitComponent)(BaseCircuitComponent *this);
  int (__fastcall *getStrength)(BaseCircuitComponent *this);
  int (__fastcall *getDirection)(BaseCircuitComponent *this);
  void (__fastcall *setStrength)(BaseCircuitComponent *this, int);
  void (__fastcall *setDirection)(BaseCircuitComponent *this, unsigned __int8);
  bool (__fastcall *consumePowerAnyDirection)(BaseCircuitComponent *this);
  bool (__fastcall *canConsumerPower)(BaseCircuitComponent *this);
  bool (__fastcall *canStopPower)(BaseCircuitComponent *this);
  void (__fastcall *setStopPower)(BaseCircuitComponent *this, bool);
  unsigned __int64 (__fastcall *getBaseType)(BaseCircuitComponent *this);
  unsigned __int64 (__fastcall *getInstanceType)(BaseCircuitComponent *this);
  bool (__fastcall *removeSource)(BaseCircuitComponent *this, const BlockPos *, const BaseCircuitComponent *);
  bool (__fastcall *addSource)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, int *, bool *);
  bool (__fastcall *allowConnection)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, bool *);
  void (__fastcall *checkLock)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  bool (__fastcall *evaluate)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *cacheValues)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *updateDependencies)(BaseCircuitComponent *this, CircuitSceneGraph *, const BlockPos *);
  bool (__fastcall *allowIndirect)(BaseCircuitComponent *this);
  bool (__fastcall *isHalfPulse)(BaseCircuitComponent *this);
  bool (__fastcall *hasSource)(BaseCircuitComponent *this, BaseCircuitComponent *);
  bool (__fastcall *hasChildrenSource)(BaseCircuitComponent *this);
  bool (__fastcall *isSecondaryPowered)(BaseCircuitComponent *this);
  unsigned __int8 (__fastcall *getPoweroutDirection)(CapacitorComponent *this);
};

</code></pre></div><h3 id="conduitblockactor-applyeffects-l8-lambda-b0b76dacb6f6d005bd21b9d622471658"><a href="#conduitblockactor-applyeffects-l8-lambda-b0b76dacb6f6d005bd21b9d622471658" class="header-anchor">#</a> <code>ConduitBlockActor::_applyEffects::__l8::&lt;lambda_b0b76dacb6f6d005bd21b9d622471658&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConduitBlockActor::_applyEffects::__l8::&lt;lambda_b0b76dacb6f6d005bd21b9d622471658&gt;
{
  const Vec3 *posNautilus;
  const float *halfExtent;
  const MobEffectInstance *effectInst;
};

</code></pre></div><h3 id="conduitblockactor-checkshape-l71-lambda-b28f6ce02576140d0e92aeec4d4fffc7"><a href="#conduitblockactor-checkshape-l71-lambda-b28f6ce02576140d0e92aeec4d4fffc7" class="header-anchor">#</a> <code>ConduitBlockActor::_checkShape::__l71::&lt;lambda_b28f6ce02576140d0e92aeec4d4fffc7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConduitBlockActor::_checkShape::__l71::&lt;lambda_b28f6ce02576140d0e92aeec4d4fffc7&gt;
{
  const Vec3 *posNautilus;
  const float *halfExtent;
};

</code></pre></div><h3 id="chestblockactor-serverinititemstackids-l40-lambda-2e8d0c4f468d46e7194921aff72bdf51"><a href="#chestblockactor-serverinititemstackids-l40-lambda-2e8d0c4f468d46e7194921aff72bdf51" class="header-anchor">#</a> <code>ChestBlockActor::serverInitItemStackIds::__l40::&lt;lambda_2e8d0c4f468d46e7194921aff72bdf51&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChestBlockActor::serverInitItemStackIds::__l40::&lt;lambda_2e8d0c4f468d46e7194921aff72bdf51&gt;
{
  std::function&lt;void __cdecl(int,ItemStack const &amp;)&gt; *onNetIdChanged;
};

</code></pre></div><h3 id="consumercomponent"><a href="#consumercomponent" class="header-anchor">#</a> <code>ConsumerComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) ConsumerComponent : BaseCircuitComponent
{
  bool mSecondaryPowered;
  bool mPropagatePower;
  bool mPromotedToProducer;
  bool mAcceptHalfPulse;
  bool mAcceptSameDirection;
};

</code></pre></div><h3 id="consumercomponent-vtbl"><a href="#consumercomponent-vtbl" class="header-anchor">#</a> <code>ConsumerComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConsumerComponent_vtbl
{
  void (__fastcall *~BaseCircuitComponent)(BaseCircuitComponent *this);
  int (__fastcall *getStrength)(BaseCircuitComponent *this);
  int (__fastcall *getDirection)(BaseCircuitComponent *this);
  void (__fastcall *setStrength)(BaseCircuitComponent *this, int);
  void (__fastcall *setDirection)(BaseCircuitComponent *this, unsigned __int8);
  bool (__fastcall *consumePowerAnyDirection)(BaseCircuitComponent *this);
  bool (__fastcall *canConsumerPower)(BaseCircuitComponent *this);
  bool (__fastcall *canStopPower)(BaseCircuitComponent *this);
  void (__fastcall *setStopPower)(BaseCircuitComponent *this, bool);
  unsigned __int64 (__fastcall *getBaseType)(BaseCircuitComponent *this);
  unsigned __int64 (__fastcall *getInstanceType)(BaseCircuitComponent *this);
  bool (__fastcall *removeSource)(BaseCircuitComponent *this, const BlockPos *, const BaseCircuitComponent *);
  bool (__fastcall *addSource)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, int *, bool *);
  bool (__fastcall *allowConnection)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, bool *);
  void (__fastcall *checkLock)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  bool (__fastcall *evaluate)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *cacheValues)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *updateDependencies)(BaseCircuitComponent *this, CircuitSceneGraph *, const BlockPos *);
  bool (__fastcall *allowIndirect)(BaseCircuitComponent *this);
  bool (__fastcall *isHalfPulse)(BaseCircuitComponent *this);
  bool (__fastcall *hasSource)(BaseCircuitComponent *this, BaseCircuitComponent *);
  bool (__fastcall *hasChildrenSource)(BaseCircuitComponent *this);
  bool (__fastcall *isSecondaryPowered)(BaseCircuitComponent *this);
};

</code></pre></div><h3 id="connectioncomponentdescription"><a href="#connectioncomponentdescription" class="header-anchor">#</a> <code>ConnectionComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConnectionComponentDescription : BlockComponentDescription
{
  std::vector&lt;std::string&gt; mConnection;
};

</code></pre></div><h3 id="connectioncomponentdescription-vtbl"><a href="#connectioncomponentdescription-vtbl" class="header-anchor">#</a> <code>ConnectionComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConnectionComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="cactusblock"><a href="#cactusblock" class="header-anchor">#</a> <code>CactusBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CactusBlock : BlockLegacy
{
};

</code></pre></div><h3 id="cactusblock-vtbl"><a href="#cactusblock-vtbl" class="header-anchor">#</a> <code>CactusBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CactusBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="cakeblock"><a href="#cakeblock" class="header-anchor">#</a> <code>CakeBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CakeBlock : BlockLegacy
{
};

</code></pre></div><h3 id="cakeblock-vtbl"><a href="#cakeblock-vtbl" class="header-anchor">#</a> <code>CakeBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CakeBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="camerablock"><a href="#camerablock" class="header-anchor">#</a> <code>CameraBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraBlock : BlockLegacy
{
};

</code></pre></div><h3 id="camerablock-vtbl"><a href="#camerablock-vtbl" class="header-anchor">#</a> <code>CameraBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="carrotblock"><a href="#carrotblock" class="header-anchor">#</a> <code>CarrotBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CarrotBlock : CropBlock
{
};

</code></pre></div><h3 id="carrotblock-vtbl"><a href="#carrotblock-vtbl" class="header-anchor">#</a> <code>CarrotBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CarrotBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
  const ItemInstance *(__fastcall *getBaseSeed)(CropBlock *this, const ItemInstance *result);
  const ItemInstance *(__fastcall *getBaseCrop)(CropBlock *this, const ItemInstance *result);
  int (__fastcall *getSeedNum)(CropBlock *this, Random *, int, int, bool);
  int (__fastcall *getCropNum)(CropBlock *this, Random *, int, int, bool);
};

</code></pre></div><h3 id="cartographytableblock"><a href="#cartographytableblock" class="header-anchor">#</a> <code>CartographyTableBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CartographyTableBlock : BlockLegacy
{
};

</code></pre></div><h3 id="cartographytableblock-vtbl"><a href="#cartographytableblock-vtbl" class="header-anchor">#</a> <code>CartographyTableBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CartographyTableBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="chemicalheatblock"><a href="#chemicalheatblock" class="header-anchor">#</a> <code>ChemicalHeatBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChemicalHeatBlock : BlockLegacy
{
};

</code></pre></div><h3 id="chemicalheatblock-vtbl"><a href="#chemicalheatblock-vtbl" class="header-anchor">#</a> <code>ChemicalHeatBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChemicalHeatBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="clayblock"><a href="#clayblock" class="header-anchor">#</a> <code>ClayBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClayBlock : BlockLegacy
{
};

</code></pre></div><h3 id="clayblock-vtbl"><a href="#clayblock-vtbl" class="header-anchor">#</a> <code>ClayBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClayBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="clothblock"><a href="#clothblock" class="header-anchor">#</a> <code>ClothBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClothBlock : BlockLegacy
{
};

</code></pre></div><h3 id="clothblock-vtbl"><a href="#clothblock-vtbl" class="header-anchor">#</a> <code>ClothBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClothBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="coloredblock"><a href="#coloredblock" class="header-anchor">#</a> <code>ColoredBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ColoredBlock : BlockLegacy
{
};

</code></pre></div><h3 id="coloredblock-vtbl"><a href="#coloredblock-vtbl" class="header-anchor">#</a> <code>ColoredBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ColoredBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="commandblock-updateblock-l8-lambda-6680b22252abc8a807bb3d1916695fb2"><a href="#commandblock-updateblock-l8-lambda-6680b22252abc8a807bb3d1916695fb2" class="header-anchor">#</a> <code>CommandBlock::updateBlock::__l8::&lt;lambda_6680b22252abc8a807bb3d1916695fb2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandBlock::updateBlock::__l8::&lt;lambda_6680b22252abc8a807bb3d1916695fb2&gt;
{
  gsl::not_null&lt;Block const *&gt; *newBlock;
  const Block *currentBlock;
};

</code></pre></div><h3 id="comparatorblock"><a href="#comparatorblock" class="header-anchor">#</a> <code>ComparatorBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ComparatorBlock : ActorBlock
{
  bool mOn;
};

</code></pre></div><h3 id="comparatorblock-vtbl"><a href="#comparatorblock-vtbl" class="header-anchor">#</a> <code>ComparatorBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ComparatorBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="concreteblock"><a href="#concreteblock" class="header-anchor">#</a> <code>ConcreteBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConcreteBlock : BlockLegacy
{
};

</code></pre></div><h3 id="concreteblock-vtbl"><a href="#concreteblock-vtbl" class="header-anchor">#</a> <code>ConcreteBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConcreteBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="concretepowderblock"><a href="#concretepowderblock" class="header-anchor">#</a> <code>ConcretePowderBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConcretePowderBlock : HeavyBlock
{
};

</code></pre></div><h3 id="concretepowderblock-vtbl"><a href="#concretepowderblock-vtbl" class="header-anchor">#</a> <code>ConcretePowderBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConcretePowderBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  mce::Color *(__fastcall *getDustColor)(HeavyBlock *this, mce::Color *result, const Block *);
  std::string *(__fastcall *getDustParticleName)(HeavyBlock *this, std::string *result, const Block *);
  bool (__fastcall *falling)(HeavyBlock *this);
  void (__fastcall *onLand)(HeavyBlock *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isFreeToFall)(HeavyBlock *this, BlockSource *, const BlockPos *);
  void (__fastcall *startFalling)(HeavyBlock *this, BlockSource *, const BlockPos *, const Block *, bool);
};

</code></pre></div><h3 id="conduitblock"><a href="#conduitblock" class="header-anchor">#</a> <code>ConduitBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConduitBlock : ActorBlock
{
};

</code></pre></div><h3 id="conduitblock-vtbl"><a href="#conduitblock-vtbl" class="header-anchor">#</a> <code>ConduitBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConduitBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mcstructure/1.16.201/structure/C~1.html" class="prev">
        C~1
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/C~3.html">
        C~3
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.4c02fc69.js" defer></script><script src="/mcstructure/assets/js/2.ab15d2b7.js" defer></script><script src="/mcstructure/assets/js/1.9734fe39.js" defer></script><script src="/mcstructure/assets/js/110.86d45285.js" defer></script>
  </body>
</html>
