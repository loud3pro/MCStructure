<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.0484522b.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.4c02fc69.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.ab15d2b7.js" as="script"><link rel="preload" href="/mcstructure/assets/js/1.9734fe39.js" as="script"><link rel="preload" href="/mcstructure/assets/js/108.289ea0ab.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.102fb00e.js"><link rel="prefetch" href="/mcstructure/assets/js/100.9f4887ee.js"><link rel="prefetch" href="/mcstructure/assets/js/101.38d4e8ed.js"><link rel="prefetch" href="/mcstructure/assets/js/102.4cf4c505.js"><link rel="prefetch" href="/mcstructure/assets/js/103.254bae32.js"><link rel="prefetch" href="/mcstructure/assets/js/104.3a611fe2.js"><link rel="prefetch" href="/mcstructure/assets/js/105.a60ad729.js"><link rel="prefetch" href="/mcstructure/assets/js/106.a9dadd40.js"><link rel="prefetch" href="/mcstructure/assets/js/107.1cdafa8f.js"><link rel="prefetch" href="/mcstructure/assets/js/109.35965d89.js"><link rel="prefetch" href="/mcstructure/assets/js/11.1efdebfb.js"><link rel="prefetch" href="/mcstructure/assets/js/110.86d45285.js"><link rel="prefetch" href="/mcstructure/assets/js/111.bce93ce8.js"><link rel="prefetch" href="/mcstructure/assets/js/112.b1df2988.js"><link rel="prefetch" href="/mcstructure/assets/js/113.a8d28c8d.js"><link rel="prefetch" href="/mcstructure/assets/js/114.2f28a2d8.js"><link rel="prefetch" href="/mcstructure/assets/js/115.0b9455a1.js"><link rel="prefetch" href="/mcstructure/assets/js/116.54d2cbea.js"><link rel="prefetch" href="/mcstructure/assets/js/117.84dece67.js"><link rel="prefetch" href="/mcstructure/assets/js/118.fd23f544.js"><link rel="prefetch" href="/mcstructure/assets/js/119.0c82af99.js"><link rel="prefetch" href="/mcstructure/assets/js/12.1500ecd9.js"><link rel="prefetch" href="/mcstructure/assets/js/120.df319818.js"><link rel="prefetch" href="/mcstructure/assets/js/121.fe8d085a.js"><link rel="prefetch" href="/mcstructure/assets/js/122.380a2c51.js"><link rel="prefetch" href="/mcstructure/assets/js/123.a24da413.js"><link rel="prefetch" href="/mcstructure/assets/js/124.c2532fc0.js"><link rel="prefetch" href="/mcstructure/assets/js/125.2985dc5d.js"><link rel="prefetch" href="/mcstructure/assets/js/126.6ba94262.js"><link rel="prefetch" href="/mcstructure/assets/js/127.735fef00.js"><link rel="prefetch" href="/mcstructure/assets/js/128.f3e3fa5d.js"><link rel="prefetch" href="/mcstructure/assets/js/129.0d417975.js"><link rel="prefetch" href="/mcstructure/assets/js/13.f04054ca.js"><link rel="prefetch" href="/mcstructure/assets/js/130.0b77cd0e.js"><link rel="prefetch" href="/mcstructure/assets/js/131.2254c64b.js"><link rel="prefetch" href="/mcstructure/assets/js/132.935cc4b6.js"><link rel="prefetch" href="/mcstructure/assets/js/133.0ecb333e.js"><link rel="prefetch" href="/mcstructure/assets/js/134.5715673e.js"><link rel="prefetch" href="/mcstructure/assets/js/135.0027dfea.js"><link rel="prefetch" href="/mcstructure/assets/js/136.42d83b87.js"><link rel="prefetch" href="/mcstructure/assets/js/137.da3ee6d4.js"><link rel="prefetch" href="/mcstructure/assets/js/138.e266fbe7.js"><link rel="prefetch" href="/mcstructure/assets/js/139.c24aa491.js"><link rel="prefetch" href="/mcstructure/assets/js/14.20d1c79c.js"><link rel="prefetch" href="/mcstructure/assets/js/140.88d83e32.js"><link rel="prefetch" href="/mcstructure/assets/js/141.ea97500c.js"><link rel="prefetch" href="/mcstructure/assets/js/142.12103437.js"><link rel="prefetch" href="/mcstructure/assets/js/143.073b2a3f.js"><link rel="prefetch" href="/mcstructure/assets/js/144.5de16957.js"><link rel="prefetch" href="/mcstructure/assets/js/145.6bbe053a.js"><link rel="prefetch" href="/mcstructure/assets/js/146.85aca5e2.js"><link rel="prefetch" href="/mcstructure/assets/js/147.4bca9cc3.js"><link rel="prefetch" href="/mcstructure/assets/js/148.37d63b3a.js"><link rel="prefetch" href="/mcstructure/assets/js/149.222704e4.js"><link rel="prefetch" href="/mcstructure/assets/js/15.9d8ff414.js"><link rel="prefetch" href="/mcstructure/assets/js/150.c5e7d45c.js"><link rel="prefetch" href="/mcstructure/assets/js/151.2ee19433.js"><link rel="prefetch" href="/mcstructure/assets/js/152.933845cb.js"><link rel="prefetch" href="/mcstructure/assets/js/153.f005156d.js"><link rel="prefetch" href="/mcstructure/assets/js/154.6fc09a83.js"><link rel="prefetch" href="/mcstructure/assets/js/155.b6c305d1.js"><link rel="prefetch" href="/mcstructure/assets/js/156.0910151a.js"><link rel="prefetch" href="/mcstructure/assets/js/157.5dab16c5.js"><link rel="prefetch" href="/mcstructure/assets/js/158.de7f170f.js"><link rel="prefetch" href="/mcstructure/assets/js/159.a5c718e7.js"><link rel="prefetch" href="/mcstructure/assets/js/16.9d3aa9da.js"><link rel="prefetch" href="/mcstructure/assets/js/160.38fc5a00.js"><link rel="prefetch" href="/mcstructure/assets/js/161.493ae65d.js"><link rel="prefetch" href="/mcstructure/assets/js/162.2b7257ff.js"><link rel="prefetch" href="/mcstructure/assets/js/163.24187ca7.js"><link rel="prefetch" href="/mcstructure/assets/js/164.560a9bc3.js"><link rel="prefetch" href="/mcstructure/assets/js/17.0889d1c8.js"><link rel="prefetch" href="/mcstructure/assets/js/18.df0372db.js"><link rel="prefetch" href="/mcstructure/assets/js/19.af158d36.js"><link rel="prefetch" href="/mcstructure/assets/js/20.97f59a2a.js"><link rel="prefetch" href="/mcstructure/assets/js/21.5962fd4e.js"><link rel="prefetch" href="/mcstructure/assets/js/22.4d3522c5.js"><link rel="prefetch" href="/mcstructure/assets/js/23.3537cb24.js"><link rel="prefetch" href="/mcstructure/assets/js/24.c75bf0ca.js"><link rel="prefetch" href="/mcstructure/assets/js/25.24e24560.js"><link rel="prefetch" href="/mcstructure/assets/js/26.7766e0fb.js"><link rel="prefetch" href="/mcstructure/assets/js/27.e9f6074c.js"><link rel="prefetch" href="/mcstructure/assets/js/28.fa15c259.js"><link rel="prefetch" href="/mcstructure/assets/js/29.618d33e1.js"><link rel="prefetch" href="/mcstructure/assets/js/3.78f10f89.js"><link rel="prefetch" href="/mcstructure/assets/js/30.6cf1500b.js"><link rel="prefetch" href="/mcstructure/assets/js/31.22856a35.js"><link rel="prefetch" href="/mcstructure/assets/js/32.bffe7ab8.js"><link rel="prefetch" href="/mcstructure/assets/js/33.7806de32.js"><link rel="prefetch" href="/mcstructure/assets/js/34.c50997a1.js"><link rel="prefetch" href="/mcstructure/assets/js/35.50d88856.js"><link rel="prefetch" href="/mcstructure/assets/js/36.0a3b9225.js"><link rel="prefetch" href="/mcstructure/assets/js/37.892173e1.js"><link rel="prefetch" href="/mcstructure/assets/js/38.faa710ad.js"><link rel="prefetch" href="/mcstructure/assets/js/39.08679ec0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.891576c8.js"><link rel="prefetch" href="/mcstructure/assets/js/40.1b76e3aa.js"><link rel="prefetch" href="/mcstructure/assets/js/41.ab86d7dd.js"><link rel="prefetch" href="/mcstructure/assets/js/42.5f6b9020.js"><link rel="prefetch" href="/mcstructure/assets/js/43.74c52cc7.js"><link rel="prefetch" href="/mcstructure/assets/js/44.29f933bd.js"><link rel="prefetch" href="/mcstructure/assets/js/45.89046872.js"><link rel="prefetch" href="/mcstructure/assets/js/46.927693bf.js"><link rel="prefetch" href="/mcstructure/assets/js/47.6c5e2eb5.js"><link rel="prefetch" href="/mcstructure/assets/js/48.fc418a99.js"><link rel="prefetch" href="/mcstructure/assets/js/49.ab1bff3b.js"><link rel="prefetch" href="/mcstructure/assets/js/5.12550f3f.js"><link rel="prefetch" href="/mcstructure/assets/js/50.34a77e29.js"><link rel="prefetch" href="/mcstructure/assets/js/51.cdab9fd0.js"><link rel="prefetch" href="/mcstructure/assets/js/52.eabfd13f.js"><link rel="prefetch" href="/mcstructure/assets/js/53.f32740a7.js"><link rel="prefetch" href="/mcstructure/assets/js/54.fcfdf201.js"><link rel="prefetch" href="/mcstructure/assets/js/55.dd20532e.js"><link rel="prefetch" href="/mcstructure/assets/js/56.a78e3680.js"><link rel="prefetch" href="/mcstructure/assets/js/57.89305262.js"><link rel="prefetch" href="/mcstructure/assets/js/58.35b65b37.js"><link rel="prefetch" href="/mcstructure/assets/js/59.3817674a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.436e88f9.js"><link rel="prefetch" href="/mcstructure/assets/js/60.2398d268.js"><link rel="prefetch" href="/mcstructure/assets/js/61.61cad8b5.js"><link rel="prefetch" href="/mcstructure/assets/js/62.c2d852d2.js"><link rel="prefetch" href="/mcstructure/assets/js/63.168d8107.js"><link rel="prefetch" href="/mcstructure/assets/js/64.db4e10ba.js"><link rel="prefetch" href="/mcstructure/assets/js/65.17e2ed8f.js"><link rel="prefetch" href="/mcstructure/assets/js/66.0ad691e0.js"><link rel="prefetch" href="/mcstructure/assets/js/67.1e9ccecd.js"><link rel="prefetch" href="/mcstructure/assets/js/68.3d418c4b.js"><link rel="prefetch" href="/mcstructure/assets/js/69.bf6a0b1f.js"><link rel="prefetch" href="/mcstructure/assets/js/7.c2acc470.js"><link rel="prefetch" href="/mcstructure/assets/js/70.f9e2f365.js"><link rel="prefetch" href="/mcstructure/assets/js/71.d7256b61.js"><link rel="prefetch" href="/mcstructure/assets/js/72.0282cd39.js"><link rel="prefetch" href="/mcstructure/assets/js/73.b28cf744.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0aab40c1.js"><link rel="prefetch" href="/mcstructure/assets/js/75.11a8476b.js"><link rel="prefetch" href="/mcstructure/assets/js/76.234564da.js"><link rel="prefetch" href="/mcstructure/assets/js/77.89613781.js"><link rel="prefetch" href="/mcstructure/assets/js/78.8cbc90e7.js"><link rel="prefetch" href="/mcstructure/assets/js/79.8dec18f0.js"><link rel="prefetch" href="/mcstructure/assets/js/80.bc89e0ad.js"><link rel="prefetch" href="/mcstructure/assets/js/81.46cda844.js"><link rel="prefetch" href="/mcstructure/assets/js/82.b1dae669.js"><link rel="prefetch" href="/mcstructure/assets/js/83.3a44a1c4.js"><link rel="prefetch" href="/mcstructure/assets/js/84.9604e4ea.js"><link rel="prefetch" href="/mcstructure/assets/js/85.0b6985d2.js"><link rel="prefetch" href="/mcstructure/assets/js/86.0a705d22.js"><link rel="prefetch" href="/mcstructure/assets/js/87.7d036791.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f4f57b27.js"><link rel="prefetch" href="/mcstructure/assets/js/89.d107adcd.js"><link rel="prefetch" href="/mcstructure/assets/js/90.c6964cf1.js"><link rel="prefetch" href="/mcstructure/assets/js/91.461e7454.js"><link rel="prefetch" href="/mcstructure/assets/js/92.ea6588b8.js"><link rel="prefetch" href="/mcstructure/assets/js/93.12f08abd.js"><link rel="prefetch" href="/mcstructure/assets/js/94.ec163f63.js"><link rel="prefetch" href="/mcstructure/assets/js/95.898bdf72.js"><link rel="prefetch" href="/mcstructure/assets/js/96.63aead8b.js"><link rel="prefetch" href="/mcstructure/assets/js/97.e24085ec.js"><link rel="prefetch" href="/mcstructure/assets/js/98.8e55a83d.js"><link rel="prefetch" href="/mcstructure/assets/js/99.8ccfc759.js"><link rel="prefetch" href="/mcstructure/assets/js/vendors~docsearch.d856fa52.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.0484522b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" class="sidebar-link">B</a></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" class="sidebar-link">B~1</a></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" aria-current="page" class="active sidebar-link">C</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" class="sidebar-link">C~2</a></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" class="sidebar-link">D~6</a></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" class="sidebar-link">H</a></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" class="sidebar-link">L</a></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" class="sidebar-link">S~3</a></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" class="sidebar-link">T~1</a></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c"><a href="#c" class="header-anchor">#</a> C</h1> <h3 id="core-profile-grouptoken"><a href="#core-profile-grouptoken" class="header-anchor">#</a> <code>Core::Profile::GroupToken</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const Core::Profile::ProfileGroup *</code></td> <td>mGroup</td></tr> <tr><td>8</td> <td>(80) <code>std::mutex</code></td> <td>mTokenCreationMutex</td></tr> <tr><td>88</td> <td>(16) <code>Core::Profile::CPUProfileTokenMicroProfile</code></td> <td>mToken</td></tr> <tr><td>104</td> <td>(8) <code>const char *</code></td> <td>mLabel</td></tr> <tr><td>112</td> <td>(4) <code>unsigned int</code></td> <td>mCustomColor</td></tr></tbody></table> <h3 id="core-profile-cpuprofiletokenmicroprofile"><a href="#core-profile-cpuprofiletokenmicroprofile" class="header-anchor">#</a> <code>Core::Profile::CPUProfileTokenMicroProfile</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mColor</td></tr> <tr><td>8</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mMicroProfileToken</td></tr></tbody></table> <h3 id="clientblockpipeline-smoothlightbakingstep-computelightbrightness-l2-lambda-44f4050c3c928648c37d299e6a06abad"><a href="#clientblockpipeline-smoothlightbakingstep-computelightbrightness-l2-lambda-44f4050c3c928648c37d299e6a06abad" class="header-anchor">#</a> <code>ClientBlockPipeline::SmoothLightBakingStep::_computeLightBrightness::__l2::&lt;lambda_44f4050c3c928648c37d299e6a06abad&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="core-pathbuffer-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#core-pathbuffer-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>Core::PathBuffer&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mContainer</td></tr></tbody></table> <h3 id="core-path"><a href="#core-path" class="header-anchor">#</a> <code>Core::Path</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>Core::PathPart</code></td> <td>mPathPart</td></tr></tbody></table> <h3 id="core-pathpart"><a href="#core-pathpart" class="header-anchor">#</a> <code>Core::PathPart</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mUtf8StdString</td></tr></tbody></table> <h3 id="contentidentity"><a href="#contentidentity" class="header-anchor">#</a> <code>ContentIdentity</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>mce::UUID</code></td> <td>mUUID</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>mValid</td></tr></tbody></table> <h3 id="clientblobcache-cache-trimifneeded-l5-lambda-cfc6481d33223e5533d33a80b1ed8b6a"><a href="#clientblobcache-cache-trimifneeded-l5-lambda-cfc6481d33223e5533d33a80b1ed8b6a" class="header-anchor">#</a> <code>ClientBlobCache::Cache::_trimIfNeeded::__l5::&lt;lambda_cfc6481d33223e5533d33a80b1ed8b6a&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="chunkpos"><a href="#chunkpos" class="header-anchor">#</a> <code>ChunkPos</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>$9E42F9C9F7B1A17B3F4FC42C25BE33AF</code></td> <td>___u0</td></tr></tbody></table> <h3 id="core-pathbuffer-core-stackstring-char-1024"><a href="#core-pathbuffer-core-stackstring-char-1024" class="header-anchor">#</a> <code>Core::PathBuffer&lt;Core::StackString&lt;char,1024&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1040) <code>Core::StackString&lt;char,1024&gt;</code></td> <td>mContainer</td></tr></tbody></table> <h3 id="core-stackstring-char-1024"><a href="#core-stackstring-char-1024" class="header-anchor">#</a> <code>Core::StackString&lt;char,1024&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const unsigned __int64</code></td> <td>MAX_LENGTH</td></tr> <tr><td>8</td> <td>(1024) <code>std::array&lt;char,1024&gt;</code></td> <td>mBuf</td></tr> <tr><td>1032</td> <td>(8) <code>unsigned __int64</code></td> <td>mLength</td></tr></tbody></table> <h3 id="contentacquisition-sortcontenttrackersbypriority-l2-lambda-9747ad26564c82a94e7199d71afa4537"><a href="#contentacquisition-sortcontenttrackersbypriority-l2-lambda-9747ad26564c82a94e7199d71afa4537" class="header-anchor">#</a> <code>ContentAcquisition::_sortContentTrackersByPriority::__l2::&lt;lambda_9747ad26564c82a94e7199d71afa4537&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="commondocument"><a href="#commondocument" class="header-anchor">#</a> <code>CommonDocument</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mProductId</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>mContentType</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mCreatorId</td></tr> <tr><td>96</td> <td>(32) <code>std::string</code></td> <td>mStartDate</td></tr> <tr><td>128</td> <td>(32) <code>std::string</code></td> <td>mCreationDate</td></tr> <tr><td>160</td> <td>(32) <code>std::string</code></td> <td>mLastModifiedDate</td></tr> <tr><td>192</td> <td>(64) <code>CommonLocTextPair</code></td> <td>mTitle</td></tr> <tr><td>256</td> <td>(64) <code>CommonLocTextPair</code></td> <td>mDescription</td></tr> <tr><td>320</td> <td>(64) <code>std::unordered_map&lt;std::string,std::string&gt;</code></td> <td>mTitleDictionary</td></tr> <tr><td>384</td> <td>(64) <code>std::unordered_map&lt;std::string,std::string&gt;</code></td> <td>mDescriptionDictionary</td></tr> <tr><td>448</td> <td>(28) <code>RatingData</code></td> <td>mRatingData</td></tr> <tr><td>476</td> <td>(1) <code>bool</code></td> <td>mIsSemVersionValid</td></tr> <tr><td>477</td> <td>(1) <code>bool</code></td> <td>mIsTitleLocked</td></tr> <tr><td>480</td> <td>(32) <code>std::string</code></td> <td>mThumbnailUrl</td></tr> <tr><td>512</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mTags</td></tr> <tr><td>536</td> <td>(24) <code>std::vector&lt;CommonContent&gt;</code></td> <td>mContents</td></tr> <tr><td>560</td> <td>(24) <code>std::vector&lt;CommonImage&gt;</code></td> <td>mImages</td></tr></tbody></table> <h3 id="commonloctextpair"><a href="#commonloctextpair" class="header-anchor">#</a> <code>CommonLocTextPair</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>langCode</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>locText</td></tr></tbody></table> <h3 id="contenttiermanager-validatorregistry-validatorregisterer"><a href="#contenttiermanager-validatorregistry-validatorregisterer" class="header-anchor">#</a> <code>ContentTierManager::ValidatorRegistry::ValidatorRegisterer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="contenttiermanager-validatorregistry"><a href="#contenttiermanager-validatorregistry" class="header-anchor">#</a> <code>ContentTierManager::ValidatorRegistry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>Bedrock::EnableNonOwnerReferences</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(64) <code>std::unordered_map&lt;std::string,ContentTierManager::ValidatorRegistry::ValidatorRegistryValidators&gt;</code></td> <td>mValidatorList</td></tr></tbody></table> <h3 id="commandflag"><a href="#commandflag" class="header-anchor">#</a> <code>CommandFlag</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>flag</td></tr></tbody></table> <h3 id="commandorigin"><a href="#commandorigin" class="header-anchor">#</a> <code>CommandOrigin</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CommandOrigin_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(16) <code>mce::UUID</code></td> <td>mUUID</td></tr></tbody></table> <h3 id="core-random"><a href="#core-random" class="header-anchor">#</a> <code>Core::Random</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mSeed</td></tr> <tr><td>4</td> <td>(2496) <code>unsigned int[624]</code></td> <td>_mt</td></tr> <tr><td>2500</td> <td>(4) <code>int</code></td> <td>_mti</td></tr> <tr><td>2504</td> <td>(1) <code>bool</code></td> <td>mHaveNextNextGaussian</td></tr> <tr><td>2508</td> <td>(4) <code>float</code></td> <td>mNextNextGaussian</td></tr> <tr><td>2512</td> <td>(4) <code>int</code></td> <td>mInitedIdx</td></tr></tbody></table> <h3 id="componentdescription"><a href="#componentdescription" class="header-anchor">#</a> <code>ComponentDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Description</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="compoundtag"><a href="#compoundtag" class="header-anchor">#</a> <code>CompoundTag</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Tag</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(16) <code>std::map&lt;std::string,CompoundTagVariant&gt;</code></td> <td>mTags</td></tr></tbody></table> <h3 id="craftablecompounds-getcompoundid-l2-lambda-cb3f8bb483eddc0a11d03ac37babd3ba"><a href="#craftablecompounds-getcompoundid-l2-lambda-cb3f8bb483eddc0a11d03ac37babd3ba" class="header-anchor">#</a> <code>CraftableCompounds::_getCompoundId::__l2::&lt;lambda_cb3f8bb483eddc0a11d03ac37babd3ba&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="containerpopulationdata"><a href="#containerpopulationdata" class="header-anchor">#</a> <code>ContainerPopulationData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>ContainerEnumName</code></td> <td>containerName</td></tr> <tr><td>4</td> <td>(4) <code>CreativeItemCategory</code></td> <td>itemCategory</td></tr></tbody></table> <h3 id="containerscreencontext"><a href="#containerscreencontext" class="header-anchor">#</a> <code>ContainerScreenContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Player *</code></td> <td>mPlayer</td></tr> <tr><td>8</td> <td>(1) <code>ContainerType</code></td> <td>mScreenContainerType</td></tr> <tr><td>16</td> <td>(24) <code>std::variant&lt;std::monostate,ActorUniqueID,BlockPos&gt;</code></td> <td>mOwner</td></tr></tbody></table> <h3 id="chemicalheatblock-getrelativeoffsets-l5-lambda-b0dd78f1bda910ef2822257e4eb6eb5b"><a href="#chemicalheatblock-getrelativeoffsets-l5-lambda-b0dd78f1bda910ef2822257e4eb6eb5b" class="header-anchor">#</a> <code>ChemicalHeatBlock::_getRelativeOffsets::__l5::&lt;lambda_b0dd78f1bda910ef2822257e4eb6eb5b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="chunklocalheight"><a href="#chunklocalheight" class="header-anchor">#</a> <code>ChunkLocalHeight</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>__int16</code></td> <td>mVal</td></tr></tbody></table> <h3 id="chunksource-spawnchunkgenerationtasks-l3-lambda-7e0f765fe899e3b8d51a4ee6497a8231"><a href="#chunksource-spawnchunkgenerationtasks-l3-lambda-7e0f765fe899e3b8d51a4ee6497a8231" class="header-anchor">#</a> <code>ChunkSource::_spawnChunkGenerationTasks::__l3::&lt;lambda_7e0f765fe899e3b8d51a4ee6497a8231&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cst-diphone-entry-struct"><a href="#cst-diphone-entry-struct" class="header-anchor">#</a> <code>cst_diphone_entry_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>start_pm</td></tr> <tr><td>10</td> <td>(1) <code>unsigned __int8</code></td> <td>pb_pm</td></tr> <tr><td>11</td> <td>(1) <code>unsigned __int8</code></td> <td>end_pm</td></tr></tbody></table> <h3 id="cst-dur-stats-struct"><a href="#cst-dur-stats-struct" class="header-anchor">#</a> <code>cst_dur_stats_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>char *</code></td> <td>phone</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mean</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>stddev</td></tr></tbody></table> <h3 id="cst-val-struct"><a href="#cst-val-struct" class="header-anchor">#</a> <code>cst_val_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>union {cst_val_cons_struct cc;cst_val_atom_struct a;}</code></td> <td>c</td></tr></tbody></table> <h3 id="cst-val-cons-struct"><a href="#cst-val-cons-struct" class="header-anchor">#</a> <code>cst_val_cons_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>cst_val_struct *</code></td> <td>car</td></tr> <tr><td>8</td> <td>(8) <code>cst_val_struct *</code></td> <td>cdr</td></tr></tbody></table> <h3 id="cst-val-atom-struct"><a href="#cst-val-atom-struct" class="header-anchor">#</a> <code>cst_val_atom_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>type</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>ref_count</td></tr> <tr><td>8</td> <td>(8) <code>cst_val_atom_struct::&lt;unnamed_type_v&gt;</code></td> <td>v</td></tr></tbody></table> <h3 id="cst-val-atom-struct-unnamed-type-v"><a href="#cst-val-atom-struct-unnamed-type-v" class="header-anchor">#</a> <code>cst_val_atom_struct::&lt;unnamed_type_v&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>long double</code></td> <td>fval</td></tr> <tr><td>1</td> <td>(8) <code>__int64</code></td> <td>ival</td></tr> <tr><td>2</td> <td>(8) <code>void *</code></td> <td>vval</td></tr></tbody></table> <h3 id="cst-cart-node-struct"><a href="#cst-cart-node-struct" class="header-anchor">#</a> <code>cst_cart_node_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>feat</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>op</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>no_node</td></tr> <tr><td>8</td> <td>(8) <code>const cst_val_struct *</code></td> <td>val</td></tr></tbody></table> <h3 id="cst-regex-struct"><a href="#cst-regex-struct" class="header-anchor">#</a> <code>cst_regex_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>char</code></td> <td>regstart</td></tr> <tr><td>1</td> <td>(1) <code>char</code></td> <td>reganch</td></tr> <tr><td>8</td> <td>(8) <code>char *</code></td> <td>regmust</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>regmlen</td></tr> <tr><td>20</td> <td>(4) <code>int</code></td> <td>regsize</td></tr> <tr><td>24</td> <td>(8) <code>char *</code></td> <td>program</td></tr></tbody></table> <h3 id="cst-synth-module-struct"><a href="#cst-synth-module-struct" class="header-anchor">#</a> <code>cst_synth_module_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>hookname</td></tr> <tr><td>8</td> <td>(8) <code>cst_utterance_struct *(__fastcall *)(cst_utterance_struct *)</code></td> <td>defhook</td></tr></tbody></table> <h3 id="config-s"><a href="#config-s" class="header-anchor">#</a> <code>config_s</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>good_length</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>max_lazy</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>nice_length</td></tr> <tr><td>6</td> <td>(2) <code>unsigned __int16</code></td> <td>max_chain</td></tr> <tr><td>8</td> <td>(8) <code>block_state (__fastcall *)(internal_state *, int)</code></td> <td>func</td></tr></tbody></table> <h3 id="code"><a href="#code" class="header-anchor">#</a> <code>code</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>op</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>bits</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>val</td></tr></tbody></table> <h3 id="ct-data-s"><a href="#ct-data-s" class="header-anchor">#</a> <code>ct_data_s</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>union {unsigned __int16 freq;unsigned __int16 code;}</code></td> <td>fc</td></tr> <tr><td>2</td> <td>(2) <code>union {unsigned __int16 dad;unsigned __int16 len;}</code></td> <td>_dl</td></tr></tbody></table> <h3 id="core-fileopenmode"><a href="#core-fileopenmode" class="header-anchor">#</a> <code>Core::FileOpenMode</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>__int8</code></td> <td>_bf_0</td></tr></tbody></table> <h3 id="comparescheduledcallback"><a href="#comparescheduledcallback" class="header-anchor">#</a> <code>CompareScheduledCallback</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cff-field-handler"><a href="#cff-field-handler" class="header-anchor">#</a> <code>CFF_Field_Handler_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>kind</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>code</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>offset</td></tr> <tr><td>12</td> <td>(1) <code>unsigned __int8</code></td> <td>size</td></tr> <tr><td>16</td> <td>(8) <code>int (__fastcall *)(CFF_ParserRec_ *)</code></td> <td>reader</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>array_max</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>count_offset</td></tr></tbody></table> <h3 id="core-profile-profilegroupmanager"><a href="#core-profile-profilegroupmanager" class="header-anchor">#</a> <code>Core::Profile::ProfileGroupManager</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;Core::Profile::ProfileGroupManager::Impl&gt;</code></td> <td>mImpl</td></tr></tbody></table> <h3 id="core-profile-countertokenmicroprofile"><a href="#core-profile-countertokenmicroprofile" class="header-anchor">#</a> <code>Core::Profile::CounterTokenMicroProfile</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>mMicroProfileToken</td></tr></tbody></table> <h3 id="colorchannel"><a href="#colorchannel" class="header-anchor">#</a> <code>ColorChannel</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mValue</td></tr></tbody></table> <h3 id="catalogpropertybag"><a href="#catalogpropertybag" class="header-anchor">#</a> <code>CatalogPropertyBag</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>PropertyBag</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="compassspritecalculator"><a href="#compassspritecalculator" class="header-anchor">#</a> <code>CompassSpriteCalculator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mFrame</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mRot</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mRotA</td></tr></tbody></table> <h3 id="cst-lang-struct"><a href="#cst-lang-struct" class="header-anchor">#</a> <code>cst_lang_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>lang</td></tr> <tr><td>8</td> <td>(8) <code>void (__fastcall *)(cst_voice_struct *)</code></td> <td>lang_init</td></tr> <tr><td>16</td> <td>(8) <code>lexicon_struct *(*)(...)</code></td> <td>lex_init</td></tr></tbody></table> <h3 id="crashdumpformatentryimpl"><a href="#crashdumpformatentryimpl" class="header-anchor">#</a> <code>CrashDumpFormatEntryImpl</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>CrashDumpLogFieldFormat</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="crashdumplogfieldformat"><a href="#crashdumplogfieldformat" class="header-anchor">#</a> <code>CrashDumpLogFieldFormat</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>char[24]</code></td> <td>mMemberName</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>mMemberSize</td></tr> <tr><td>28</td> <td>(4) <code>_BYTE[4]</code></td> <td>mMemberFormatCode</td></tr></tbody></table> <h3 id="cst-cart-struct"><a href="#cst-cart-struct" class="header-anchor">#</a> <code>cst_cart_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const cst_cart_node_struct *</code></td> <td>rule_table</td></tr> <tr><td>8</td> <td>(8) <code>const char *const *</code></td> <td>feat_table</td></tr></tbody></table> <h3 id="core-subject-i18nobserver-core-singlethreadedlock"><a href="#core-subject-i18nobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;I18nObserver,Core::SingleThreadedLock&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>8</td> <td>(24) <code>std::vector&lt;gsl::not_null&lt;I18nObserver *&gt;&gt;</code></td> <td>mObservers</td></tr></tbody></table> <h3 id="core-singlethreadedlock"><a href="#core-singlethreadedlock" class="header-anchor">#</a> <code>Core::SingleThreadedLock</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="core-storageareastree"><a href="#core-storageareastree" class="header-anchor">#</a> <code>Core::StorageAreasTree</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>Core::StorageAreasTree::TreeNode</code></td> <td>mRoot</td></tr> <tr><td>32</td> <td>(24) <code>std::vector&lt;Core::FileStorageArea *&gt;</code></td> <td>mStorageAreas</td></tr></tbody></table> <h3 id="core-storageareastree-treenode"><a href="#core-storageareastree-treenode" class="header-anchor">#</a> <code>Core::StorageAreasTree::TreeNode</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;Core::StorageAreasTree::TreeChild&gt;</code></td> <td>mChildren</td></tr> <tr><td>24</td> <td>(8) <code>Core::FileStorageArea *</code></td> <td>mStorageArea</td></tr></tbody></table> <h3 id="cst-lts-rules-struct"><a href="#cst-lts-rules-struct" class="header-anchor">#</a> <code>cst_lts_rules_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(8) <code>const unsigned __int16 *</code></td> <td>letter_index</td></tr> <tr><td>16</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>models</td></tr> <tr><td>24</td> <td>(8) <code>const char *const *</code></td> <td>phone_table</td></tr> <tr><td>32</td> <td>(4) <code>int</code></td> <td>context_window_size</td></tr> <tr><td>36</td> <td>(4) <code>int</code></td> <td>context_extra_feats</td></tr> <tr><td>40</td> <td>(8) <code>const char *const *</code></td> <td>letter_table</td></tr></tbody></table> <h3 id="core-outputfilestream"><a href="#core-outputfilestream" class="header-anchor">#</a> <code>Core::OutputFileStream</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(296) <code>Core::FileStream</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="core-filestream"><a href="#core-filestream" class="header-anchor">#</a> <code>Core::FileStream</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(128) <code>std::iostream</code></td> <td>baseclass_0</td></tr> <tr><td>128</td> <td>(56) <code>_BYTE[56]</code></td> <td>mStreamBuffer</td></tr> <tr><td>184</td> <td>(1) <code>bool</code></td> <td>mLoggingEnabled</td></tr> <tr><td>185</td> <td>(111) <code>_BYTE[111]</code></td> <td>gapB9</td></tr></tbody></table> <h3 id="commandregistry-symbol"><a href="#commandregistry-symbol" class="header-anchor">#</a> <code>CommandRegistry::Symbol</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mValue</td></tr></tbody></table> <h3 id="cff-decoder-funcsrec"><a href="#cff-decoder-funcsrec" class="header-anchor">#</a> <code>CFF_Decoder_FuncsRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void (__fastcall *)(CFF_Decoder_ *, TT_FaceRec_ *, CFF_SizeRec_ *, CFF_GlyphSlotRec_ *, unsigned __int8, FT_Render_Mode_, int (__fastcall *)(TT_FaceRec_ *, unsigned int, unsigned __int8 **, unsigned int *), void (__fastcall *)(TT_FaceRec_ *, unsigned __int8 **, unsigned int))</code></td> <td>init</td></tr> <tr><td>8</td> <td>(8) <code>int (__fastcall *)(CFF_Decoder_ *, CFF_SizeRec_ *, unsigned int)</code></td> <td>prepare</td></tr> <tr><td>16</td> <td>(8) <code>int (__fastcall *)(PS_Decoder_ *, unsigned __int8 *, unsigned int)</code></td> <td>parse_charstrings</td></tr></tbody></table> <h3 id="core-filestats"><a href="#core-filestats" class="header-anchor">#</a> <code>Core::FileStats</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mNumSuccessfulWriteOperations</td></tr> <tr><td>8</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mNumBytesWritten</td></tr> <tr><td>16</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mNumFailedWriteOperations</td></tr> <tr><td>24</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mNumSuccessfulReadOperations</td></tr> <tr><td>32</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mNumBytesRead</td></tr> <tr><td>40</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mNumFailedReadOperations</td></tr> <tr><td>48</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mFileSystemSize</td></tr> <tr><td>56</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mFileSystemAllocatedSize</td></tr></tbody></table> <h3 id="cst-sts-list-struct"><a href="#cst-sts-list-struct" class="header-anchor">#</a> <code>cst_sts_list_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const cst_sts_struct *</code></td> <td>sts</td></tr> <tr><td>8</td> <td>(8) <code>const cst_sts_paged_struct *</code></td> <td>sts_paged</td></tr> <tr><td>16</td> <td>(8) <code>const unsigned __int16 *</code></td> <td>frames</td></tr> <tr><td>24</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>residuals</td></tr> <tr><td>32</td> <td>(8) <code>const unsigned int *</code></td> <td>resoffs</td></tr> <tr><td>40</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>ressizes</td></tr> <tr><td>48</td> <td>(4) <code>int</code></td> <td>num_sts</td></tr> <tr><td>52</td> <td>(4) <code>int</code></td> <td>num_channels</td></tr> <tr><td>56</td> <td>(4) <code>int</code></td> <td>sample_rate</td></tr> <tr><td>60</td> <td>(4) <code>float</code></td> <td>coeff_min</td></tr> <tr><td>64</td> <td>(4) <code>float</code></td> <td>coeff_range</td></tr> <tr><td>72</td> <td>(8) <code>const char *</code></td> <td>codec</td></tr></tbody></table> <h3 id="cst-phoneset-struct"><a href="#cst-phoneset-struct" class="header-anchor">#</a> <code>cst_phoneset_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(8) <code>const char *const *</code></td> <td>featnames</td></tr> <tr><td>16</td> <td>(8) <code>const cst_val_struct *const *</code></td> <td>featvals</td></tr> <tr><td>24</td> <td>(8) <code>const char *const *</code></td> <td>phonenames</td></tr> <tr><td>32</td> <td>(8) <code>const char *</code></td> <td>silence</td></tr> <tr><td>40</td> <td>(4) <code>const int</code></td> <td>num_phones</td></tr> <tr><td>48</td> <td>(8) <code>const int *const *</code></td> <td>fvtable</td></tr> <tr><td>56</td> <td>(4) <code>int</code></td> <td>freeable</td></tr></tbody></table> <h3 id="cff-builder-funcsrec"><a href="#cff-builder-funcsrec" class="header-anchor">#</a> <code>CFF_Builder_FuncsRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void (__fastcall *)(CFF_Builder_ *, TT_FaceRec_ *, CFF_SizeRec_ *, CFF_GlyphSlotRec_ *, unsigned __int8)</code></td> <td>init</td></tr> <tr><td>8</td> <td>(8) <code>void (__fastcall *)(CFF_Builder_ *)</code></td> <td>done</td></tr> <tr><td>16</td> <td>(8) <code>int (__fastcall *)(CFF_Builder_ *, int)</code></td> <td>check_points</td></tr> <tr><td>24</td> <td>(8) <code>void (__fastcall *)(CFF_Builder_ *, int, int, unsigned __int8)</code></td> <td>add_point</td></tr> <tr><td>32</td> <td>(8) <code>int (__fastcall *)(CFF_Builder_ *, int, int)</code></td> <td>add_point1</td></tr> <tr><td>40</td> <td>(8) <code>int (__fastcall *)(CFF_Builder_ *)</code></td> <td>add_contour</td></tr> <tr><td>48</td> <td>(8) <code>int (__fastcall *)(CFF_Builder_ *, int, int)</code></td> <td>start_point</td></tr> <tr><td>56</td> <td>(8) <code>void (__fastcall *)(CFF_Builder_ *)</code></td> <td>close_contour</td></tr></tbody></table> <h3 id="cst-val-def-struct"><a href="#cst-val-def-struct" class="header-anchor">#</a> <code>cst_val_def_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(8) <code>void (__fastcall *)(void *)</code></td> <td>delete_function</td></tr></tbody></table> <h3 id="cg-texturedescription"><a href="#cg-texturedescription" class="header-anchor">#</a> <code>cg::TextureDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>cg::ImageDescription</code></td> <td>baseclass_0</td></tr> <tr><td>64</td> <td>(4) <code>unsigned int</code></td> <td>mMipCount</td></tr></tbody></table> <h3 id="cg-imagedescription"><a href="#cg-imagedescription" class="header-anchor">#</a> <code>cg::ImageDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mWidth</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>mHeight</td></tr> <tr><td>8</td> <td>(4) <code>mce::TextureFormat</code></td> <td>mTextureFormat</td></tr> <tr><td>12</td> <td>(1) <code>cg::ColorSpace</code></td> <td>mColorSpace</td></tr> <tr><td>13</td> <td>(1) <code>bool</code></td> <td>mIsCubemap</td></tr> <tr><td>16</td> <td>(40) <code>KTX::KTXInfo</code></td> <td>mKTXInfo</td></tr> <tr><td>56</td> <td>(4) <code>unsigned int</code></td> <td>mArraySize</td></tr></tbody></table> <h3 id="cg-texturesetimagedescription"><a href="#cg-texturesetimagedescription" class="header-anchor">#</a> <code>cg::TextureSetImageDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;cg::TextureSetImageDescription::LayerInfoVar&gt;</code></td> <td>mLayerInfo</td></tr></tbody></table> <h3 id="cst-diphone-db-struct"><a href="#cst-diphone-db-struct" class="header-anchor">#</a> <code>cst_diphone_db_struct</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>num_entries</td></tr> <tr><td>16</td> <td>(8) <code>const cst_diphone_entry_struct *</code></td> <td>diphones</td></tr> <tr><td>24</td> <td>(8) <code>const cst_sts_list_struct *</code></td> <td>sts</td></tr></tbody></table> <h3 id="contenttierincompatiblereason"><a href="#contenttierincompatiblereason" class="header-anchor">#</a> <code>ContentTierIncompatibleReason</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mError</td></tr></tbody></table> <h3 id="c-scope-table"><a href="#c-scope-table" class="header-anchor">#</a> <code>C_SCOPE_TABLE</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) ``</td> <td>Begin</td></tr> <tr><td>4</td> <td>(4) ``</td> <td>End</td></tr> <tr><td>8</td> <td>(4) ``</td> <td>Handler</td></tr> <tr><td>12</td> <td>(4) ``</td> <td>Target</td></tr></tbody></table> <h3 id="core-filestdstreambuf"><a href="#core-filestdstreambuf" class="header-anchor">#</a> <code>Core::FileStdStreamBuf</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(104) <code>std::streambuf</code></td> <td>baseclass_0</td></tr> <tr><td>104</td> <td>(16) <code>Core::File</code></td> <td>mFile</td></tr> <tr><td>120</td> <td>(1) <code>Core::FileOpenMode</code></td> <td>mFileOpenMode</td></tr> <tr><td>128</td> <td>(24) <code>std::vector&lt;char&gt;</code></td> <td>mBuffer</td></tr> <tr><td>152</td> <td>(8) <code>unsigned __int64</code></td> <td>mBufferSize</td></tr></tbody></table> <h3 id="core-file"><a href="#core-file" class="header-anchor">#</a> <code>Core::File</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;Core::FileImpl&gt;</code></td> <td>muptFile</td></tr> <tr><td>8</td> <td>(8) <code>std::unique_ptr&lt;Core::FileSystemImpl&gt;</code></td> <td>muptTransaction</td></tr></tbody></table> <h3 id="cg-typeflagpair"><a href="#cg-typeflagpair" class="header-anchor">#</a> <code>cg::TypeFlagPair</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>cg::TextureSetLayerType</code></td> <td>type</td></tr> <tr><td>8</td> <td>(8) <code>const char *</code></td> <td>desc</td></tr></tbody></table> <h3 id="camerashakecomponent"><a href="#camerashakecomponent" class="header-anchor">#</a> <code>CameraShakeComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;CameraShakeEvent&gt;</code></td> <td>mShakeEvents</td></tr> <tr><td>24</td> <td>(8) <code>std::unique_ptr&lt;SimplexNoise&gt;</code></td> <td>xAxisNoise</td></tr> <tr><td>32</td> <td>(8) <code>std::unique_ptr&lt;SimplexNoise&gt;</code></td> <td>yAxisNoise</td></tr> <tr><td>40</td> <td>(8) <code>std::unique_ptr&lt;SimplexNoise&gt;</code></td> <td>zAxisNoise</td></tr> <tr><td>48</td> <td>(8) <code>long double</code></td> <td>mLastUpdatedTime</td></tr> <tr><td>56</td> <td>(4) <code>float</code></td> <td>mNoiseTime</td></tr> <tr><td>60</td> <td>(4) <code>float</code></td> <td>mShakeIntensity</td></tr> <tr><td>64</td> <td>(4) <code>float</code></td> <td>mDecayRate</td></tr> <tr><td>68</td> <td>(1) <code>CameraShakeType</code></td> <td>mShakeType</td></tr> <tr><td>69</td> <td>(1) <code>bool</code></td> <td>mWasShaking</td></tr></tbody></table> <h3 id="complexinventorytransaction"><a href="#complexinventorytransaction" class="header-anchor">#</a> <code>ComplexInventoryTransaction</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ComplexInventoryTransaction_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(4) <code>ComplexInventoryTransaction::Type</code></td> <td>mType</td></tr> <tr><td>16</td> <td>(88) <code>InventoryTransaction</code></td> <td>mTransaction</td></tr></tbody></table> <h3 id="clientblockpipeline-inputs"><a href="#clientblockpipeline-inputs" class="header-anchor">#</a> <code>ClientBlockPipeline::Inputs</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;std::any&gt;</code></td> <td>mInputs</td></tr></tbody></table> <h3 id="core-profile-profilesectiongroup"><a href="#core-profile-profilesectiongroup" class="header-anchor">#</a> <code>Core::Profile::ProfileSectionGroup</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::Profile::GroupToken *</code></td> <td>mToken</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>mEntered</td></tr></tbody></table> <h3 id="core-profile-profilegroup"><a href="#core-profile-profilegroup" class="header-anchor">#</a> <code>Core::Profile::ProfileGroup</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>32</td> <td>(4) <code>unsigned int</code></td> <td>mColor</td></tr> <tr><td>36</td> <td>(4) <code>int</code></td> <td>mGroupIndex</td></tr> <tr><td>40</td> <td>(1) <code>bool</code></td> <td>mEnabled</td></tr></tbody></table> <h3 id="clientblockpipeline-volumeviewof-brightnesspair-const"><a href="#clientblockpipeline-volumeviewof-brightnesspair-const" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;BrightnessPair const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Pos</code></td> <td>mMin</td></tr> <tr><td>12</td> <td>(12) <code>Pos</code></td> <td>mMax</td></tr> <tr><td>24</td> <td>(16) <code>buffer_span_mut&lt;BrightnessPair const &gt;</code></td> <td>mView</td></tr></tbody></table> <h3 id="clientblockpipeline-uvtransform"><a href="#clientblockpipeline-uvtransform" class="header-anchor">#</a> <code>ClientBlockPipeline::UvTransform</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Vec2</code></td> <td>mStart</td></tr> <tr><td>8</td> <td>(8) <code>Vec2</code></td> <td>mSize</td></tr></tbody></table> <h3 id="clientblockpipeline-volumeviewof-clientblockpipeline-blockschematiccell-const"><a href="#clientblockpipeline-volumeviewof-clientblockpipeline-blockschematiccell-const" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockSchematicCell const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Pos</code></td> <td>mMin</td></tr> <tr><td>12</td> <td>(12) <code>Pos</code></td> <td>mMax</td></tr> <tr><td>24</td> <td>(16) <code>buffer_span_mut&lt;ClientBlockPipeline::BlockSchematicCell const &gt;</code></td> <td>mView</td></tr></tbody></table> <h3 id="clientblockpipeline-boxschematicinstance"><a href="#clientblockpipeline-boxschematicinstance" class="header-anchor">#</a> <code>ClientBlockPipeline::BoxSchematicInstance</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>std::bitset&lt;6&gt;</code></td> <td>mFaceMask</td></tr> <tr><td>4</td> <td>(64) <code>Matrix</code></td> <td>mLocalToGridTransform</td></tr></tbody></table> <h3 id="clientblockpipeline-schematicsjoiningstep-staticstepdata"><a href="#clientblockpipeline-schematicsjoiningstep-staticstepdata" class="header-anchor">#</a> <code>ClientBlockPipeline::SchematicsJoiningStep::StaticStepData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::OwnedBlockVolume const *&gt;</code></td> <td>mBlockVolume</td></tr> <tr><td>8</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::BlockSchematicVolume const *&gt;</code></td> <td>mInputSchematicVolume</td></tr> <tr><td>16</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::BoxSchematicAttributes const *&gt;</code></td> <td>mInputBoxes</td></tr> <tr><td>24</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::FaceSchematicAttributes const *&gt;</code></td> <td>mInputFaces</td></tr> <tr><td>32</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::SolidOpaqueBlockVolume const *&gt;</code></td> <td>mSolidOpaqueBlockVolume</td></tr> <tr><td>40</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::BlockSchematicVolume *&gt;</code></td> <td>mOutputSchematicVolume</td></tr> <tr><td>48</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::BoxSchematicAttributes *&gt;</code></td> <td>mOutputBoxes</td></tr> <tr><td>56</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::FaceSchematicAttributes *&gt;</code></td> <td>mOutputFaces</td></tr></tbody></table> <h3 id="clientblockpipeline-volumeviewof-clientblockpipeline-blockcell-const"><a href="#clientblockpipeline-volumeviewof-clientblockpipeline-blockcell-const" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockCell const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Pos</code></td> <td>mMin</td></tr> <tr><td>12</td> <td>(12) <code>Pos</code></td> <td>mMax</td></tr> <tr><td>24</td> <td>(16) <code>buffer_span_mut&lt;ClientBlockPipeline::BlockCell const &gt;</code></td> <td>mView</td></tr></tbody></table> <h3 id="clientblockpipeline-schematicsjoiningstep-blockcellstepdata"><a href="#clientblockpipeline-schematicsjoiningstep-blockcellstepdata" class="header-anchor">#</a> <code>ClientBlockPipeline::SchematicsJoiningStep::BlockCellStepData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Pos</code></td> <td>mBlockPos</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>mBlockIndex</td></tr> <tr><td>24</td> <td>(8) <code>unsigned __int64</code></td> <td>mLayer</td></tr> <tr><td>32</td> <td>(8) <code>gsl::not_null&lt;Block const *&gt;</code></td> <td>mInputBlock</td></tr> <tr><td>40</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::BlockSchematicInstance const *&gt;</code></td> <td>mInputSchematic</td></tr> <tr><td>48</td> <td>(8) <code>gsl::not_null&lt;ClientBlockPipeline::BlockSchematicInstance *&gt;</code></td> <td>mOutputSchematic</td></tr></tbody></table> <h3 id="clientblockpipeline-volumeviewof-clientblockpipeline-blockopacitydata-const"><a href="#clientblockpipeline-volumeviewof-clientblockpipeline-blockopacitydata-const" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockOpacityData const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Pos</code></td> <td>mMin</td></tr> <tr><td>12</td> <td>(12) <code>Pos</code></td> <td>mMax</td></tr> <tr><td>24</td> <td>(16) <code>buffer_span_mut&lt;ClientBlockPipeline::BlockOpacityData const &gt;</code></td> <td>mView</td></tr></tbody></table> <h3 id="clientblockpipeline-boxfaceschematic"><a href="#clientblockpipeline-boxfaceschematic" class="header-anchor">#</a> <code>ClientBlockPipeline::BoxFaceSchematic</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mExists</td></tr> <tr><td>4</td> <td>(16) <code>ClientBlockPipeline::UvTransform</code></td> <td>mUvTransform</td></tr> <tr><td>20</td> <td>(4) <code>int</code></td> <td>mMaterialInstanceId</td></tr></tbody></table> <h3 id="clientblockpipeline-boxschematic"><a href="#clientblockpipeline-boxschematic" class="header-anchor">#</a> <code>ClientBlockPipeline::BoxSchematic</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>Matrix</code></td> <td>mLocalToModelTransform</td></tr> <tr><td>64</td> <td>(144) <code>std::array&lt;ClientBlockPipeline::BoxFaceSchematic,6&gt;</code></td> <td>mFaces</td></tr></tbody></table> <h3 id="clientblockpipeline-smoothlightbakingstep-sampledlightvalues"><a href="#clientblockpipeline-smoothlightbakingstep-sampledlightvalues" class="header-anchor">#</a> <code>ClientBlockPipeline::SmoothLightBakingStep::SampledLightValues</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Vec2</code></td> <td>mLightUvs</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mAoValue</td></tr></tbody></table> <h3 id="clientblockpipeline-volumeviewof-float-const"><a href="#clientblockpipeline-volumeviewof-float-const" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;float const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Pos</code></td> <td>mMin</td></tr> <tr><td>12</td> <td>(12) <code>Pos</code></td> <td>mMax</td></tr> <tr><td>24</td> <td>(16) <code>buffer_span_mut&lt;float const &gt;</code></td> <td>mView</td></tr></tbody></table> <h3 id="clientblockpipeline-bakedmaterialmap"><a href="#clientblockpipeline-bakedmaterialmap" class="header-anchor">#</a> <code>ClientBlockPipeline::BakedMaterialMap</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;std::shared_ptr&lt;ClientBlockPipeline::Material const &gt;&gt;</code></td> <td>mResolvedMaterials</td></tr> <tr><td>24</td> <td>(1) <code>bool</code></td> <td>mIsOpaqueForOccluding</td></tr></tbody></table> <h3 id="clientblockpipeline-dimensiondimmingscalars"><a href="#clientblockpipeline-dimensiondimmingscalars" class="header-anchor">#</a> <code>ClientBlockPipeline::DimensionDimmingScalars</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::array&lt;float,6&gt;</code></td> <td>mScalars</td></tr></tbody></table> <h3 id="clientblockpipeline-description-bakedstep"><a href="#clientblockpipeline-description-bakedstep" class="header-anchor">#</a> <code>ClientBlockPipeline::Description::BakedStep</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>mStepId</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;unsigned __int64&gt;</code></td> <td>mDependencies</td></tr> <tr><td>32</td> <td>(24) <code>std::vector&lt;unsigned __int64&gt;</code></td> <td>mDependants</td></tr></tbody></table> <h3 id="clientblockpipeline-blockcell"><a href="#clientblockpipeline-blockcell" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockCell</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::array&lt;Block const *,2&gt;</code></td> <td>mBlocks</td></tr></tbody></table> <h3 id="contentsource"><a href="#contentsource" class="header-anchor">#</a> <code>ContentSource</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentSource_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;ContentItem *&gt;</code></td> <td>mLoadedItems</td></tr> <tr><td>32</td> <td>(4) <code>_BYTE[4]</code></td> <td>mType</td></tr> <tr><td>40</td> <td>(8) <code>ContentManager *</code></td> <td>mContentManager</td></tr></tbody></table> <h3 id="core-result"><a href="#core-result" class="header-anchor">#</a> <code>Core::Result</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;char const * __cdecl(std::string *)&gt;</code></td> <td>mMessageResolver</td></tr> <tr><td>64</td> <td>(1) <code>__int8</code></td> <td>_bf_40</td></tr></tbody></table> <h3 id="cg-imagebuffer"><a href="#cg-imagebuffer" class="header-anchor">#</a> <code>cg::ImageBuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>mce::Blob</code></td> <td>mStorage</td></tr> <tr><td>24</td> <td>(64) <code>cg::ImageDescription</code></td> <td>mImageDescription</td></tr></tbody></table> <h3 id="core-splitpatht-1024-64"><a href="#core-splitpatht-1024-64" class="header-anchor">#</a> <code>Core::SplitPathT&lt;1024,64&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2048) <code>std::array&lt;Core::Path,64&gt;</code></td> <td>mParts</td></tr> <tr><td>2048</td> <td>(8) <code>unsigned __int64</code></td> <td>mNumParts</td></tr></tbody></table> <h3 id="camerablendsettings"><a href="#camerablendsettings" class="header-anchor">#</a> <code>CameraBlendSettings</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;float __cdecl(float,float,float)&gt;</code></td> <td>mEaseFunction</td></tr> <tr><td>64</td> <td>(4) <code>float</code></td> <td>mBlendTime</td></tr> <tr><td>68</td> <td>(1) <code>bool</code></td> <td>mCameraFromAcceptsInput</td></tr> <tr><td>69</td> <td>(1) <code>bool</code></td> <td>mCameraToAcceptsInput</td></tr></tbody></table> <h3 id="cameradirector"><a href="#cameradirector" class="header-anchor">#</a> <code>CameraDirector</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(312) <code>Camera</code></td> <td>mCamera</td></tr> <tr><td>312</td> <td>(24) <code>std::vector&lt;std::unique_ptr&lt;ICameraBehavior&gt;&gt;</code></td> <td>mBehaviors</td></tr> <tr><td>336</td> <td>(8) <code>std::unique_ptr&lt;ActivationRule&gt;</code></td> <td>mActivationRule</td></tr></tbody></table> <h3 id="camera"><a href="#camera" class="header-anchor">#</a> <code>Camera</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(48) <code>HashedString</code></td> <td>mId</td></tr> <tr><td>48</td> <td>(4) <code>int</code></td> <td>mPriority</td></tr> <tr><td>56</td> <td>(72) <code>CameraBlendSettings</code></td> <td>mBlendInDefault</td></tr> <tr><td>128</td> <td>(1) <code>bool</code></td> <td>mRenderPlayerModel</td></tr> <tr><td>129</td> <td>(1) <code>bool</code></td> <td>mShouldRenderFirstPersonObjects</td></tr> <tr><td>136</td> <td>(8) <code>ActorUniqueID</code></td> <td>mLookTarget</td></tr> <tr><td>144</td> <td>(8) <code>ActorUniqueID</code></td> <td>mFollowTarget</td></tr> <tr><td>152</td> <td>(4) <code>float</code></td> <td>mAspectRatio</td></tr> <tr><td>156</td> <td>(4) <code>float</code></td> <td>mFieldOfView</td></tr> <tr><td>160</td> <td>(4) <code>float</code></td> <td>mNearPlane</td></tr> <tr><td>164</td> <td>(4) <code>float</code></td> <td>mFarPlane</td></tr> <tr><td>168</td> <td>(16) <code>glm::tquat&lt;float,0&gt;</code></td> <td>mOrientation</td></tr> <tr><td>184</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>mPosition</td></tr> <tr><td>196</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>mScale</td></tr> <tr><td>208</td> <td>(64) <code>Matrix</code></td> <td>mPostViewTransform</td></tr> <tr><td>272</td> <td>(1) <code>bool</code></td> <td>mFacesPlayerFront</td></tr> <tr><td>273</td> <td>(1) <code>bool</code></td> <td>mPlayerRotateWithCamera</td></tr> <tr><td>276</td> <td>(8) <code>glm::tvec2&lt;float,0&gt;</code></td> <td>mPlayerRotationOffset</td></tr> <tr><td>284</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>mLiquidOffset</td></tr> <tr><td>296</td> <td>(4) <code>float</code></td> <td>mRideRotationOffset</td></tr> <tr><td>300</td> <td>(4) <code>float</code></td> <td>mPlayerSneakOffset</td></tr> <tr><td>304</td> <td>(4) <code>float</code></td> <td>mPlayerGlideOffset</td></tr></tbody></table> <h3 id="commandversion"><a href="#commandversion" class="header-anchor">#</a> <code>CommandVersion</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mFrom</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mTo</td></tr></tbody></table> <h3 id="contextmessagelogger"><a href="#contextmessagelogger" class="header-anchor">#</a> <code>ContextMessageLogger</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContextMessageLogger_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;ContextMessage&gt;</code></td> <td>mMessageBufferArray</td></tr> <tr><td>32</td> <td>(5) <code>bool[5]</code></td> <td>mReceivedMessages</td></tr> <tr><td>37</td> <td>(14) <code>ContextMessageLoggerOptions</code></td> <td>mOptions</td></tr></tbody></table> <h3 id="contextmessageloggeroptions"><a href="#contextmessageloggeroptions" class="header-anchor">#</a> <code>ContextMessageLoggerOptions</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bool[4]</code></td> <td>mStoreMessages</td></tr> <tr><td>4</td> <td>(4) <code>bool[4]</code></td> <td>mAssertIfMessageTypeWasReceived</td></tr> <tr><td>8</td> <td>(4) <code>bool[4]</code></td> <td>mAssertInDestructorIfMessageTypeWasReceived</td></tr> <tr><td>12</td> <td>(1) <code>bool</code></td> <td>mAllowMessagesToPostToParentMessageLoggers</td></tr> <tr><td>13</td> <td>(1) <code>bool</code></td> <td>mOutputAllMessagesOnDestruction</td></tr></tbody></table> <h3 id="config"><a href="#config" class="header-anchor">#</a> <code>Config</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mWidth</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mHeight</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mGuiScale</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mInvGuiScale</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>mGuiWidth</td></tr> <tr><td>20</td> <td>(4) <code>int</code></td> <td>mGuiHeight</td></tr> <tr><td>24</td> <td>(8) <code>PixelCalc</code></td> <td>mDpadScale</td></tr> <tr><td>32</td> <td>(8) <code>IMinecraftGame *</code></td> <td>mMinecraft</td></tr> <tr><td>40</td> <td>(16) <code>std::shared_ptr&lt;Options&gt;</code></td> <td>mOptions</td></tr> <tr><td>56</td> <td>(4) <code>InputMode</code></td> <td>mCurrentInputMode</td></tr></tbody></table> <h3 id="crashdumpgameplaydata"><a href="#crashdumpgameplaydata" class="header-anchor">#</a> <code>CrashDumpGameplayData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>_BYTE[2]</code></td> <td>mFunc</td></tr> <tr><td>2</td> <td>(2) <code>_BYTE[2]</code></td> <td>mTag</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mClientId</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mBuildActionIntention</td></tr></tbody></table> <h3 id="clientinstance-leavegameonunrecoverableerror-l11-lambda-9e193ddaee367b7b7b07833f6136df6c"><a href="#clientinstance-leavegameonunrecoverableerror-l11-lambda-9e193ddaee367b7b7b07833f6136df6c" class="header-anchor">#</a> <code>ClientInstance::_leaveGameOnUnrecoverableError::__l11::&lt;lambda_9e193ddaee367b7b7b07833f6136df6c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;ClientInstance&gt;</code></td> <td>weakThis</td></tr> <tr><td>16</td> <td>(32) <code>const std::string</code></td> <td>titleMessage</td></tr> <tr><td>48</td> <td>(32) <code>const std::string</code></td> <td>displayMessage</td></tr></tbody></table> <h3 id="clientframeupdatecontext"><a href="#clientframeupdatecontext" class="header-anchor">#</a> <code>ClientFrameUpdateContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>FrameUpdateContext</code></td> <td>baseclass_0</td></tr> <tr><td>32</td> <td>(4) <code>float</code></td> <td>a</td></tr> <tr><td>36</td> <td>(1) <code>bool</code></td> <td>stereoRendering</td></tr></tbody></table> <h3 id="clientinstance-update-l42-lambda-2eadb951cae52f74e068bad3dd7fa7f4"><a href="#clientinstance-update-l42-lambda-2eadb951cae52f74e068bad3dd7fa7f4" class="header-anchor">#</a> <code>ClientInstance::update::__l42::&lt;lambda_2eadb951cae52f74e068bad3dd7fa7f4&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;ClientInstance&gt;</code></td> <td>weakPtr</td></tr></tbody></table> <h3 id="clientinstance-setupclientgame-l8-lambda-f8252ab8124c045f24524d1760b419d8"><a href="#clientinstance-setupclientgame-l8-lambda-f8252ab8124c045f24524d1760b419d8" class="header-anchor">#</a> <code>ClientInstance::setupClientGame::__l8::&lt;lambda_f8252ab8124c045f24524d1760b419d8&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;ClientInstance&gt;</code></td> <td>weakThis</td></tr> <tr><td>16</td> <td>(64) <code>std::function&lt;void __cdecl(enum ClientGameSetupResult)&gt;</code></td> <td>callback</td></tr> <tr><td>80</td> <td>(1) <code>bool</code></td> <td>joiningLocalServer</td></tr></tbody></table> <h3 id="clientinstance-startexternalnetworkworld-l2-lambda-2f4e89c11809877f171d784f43a2bb0a"><a href="#clientinstance-startexternalnetworkworld-l2-lambda-2f4e89c11809877f171d784f43a2bb0a" class="header-anchor">#</a> <code>ClientInstance::_startExternalNetworkWorld::__l2::&lt;lambda_2f4e89c11809877f171d784f43a2bb0a&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ClientInstance *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(256) <code>Social::GameConnectionInfo</code></td> <td>connection</td></tr> <tr><td>264</td> <td>(32) <code>const std::string</code></td> <td>serverName</td></tr></tbody></table> <h3 id="clientinstance-startexternalnetworkworld-l2-lambda-2f4e89c11809877f171d784f43a2bb0a-l25-lambda-89f9ae71cef463ef90f3d3d6d3c5a294"><a href="#clientinstance-startexternalnetworkworld-l2-lambda-2f4e89c11809877f171d784f43a2bb0a-l25-lambda-89f9ae71cef463ef90f3d3d6d3c5a294" class="header-anchor">#</a> <code>ClientInstance::_startExternalNetworkWorld::__l2::&lt;lambda_2f4e89c11809877f171d784f43a2bb0a&gt;::()::__l25::&lt;lambda_89f9ae71cef463ef90f3d3d6d3c5a294&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ClientInstance *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(256) <code>Social::GameConnectionInfo</code></td> <td>connectionInfo</td></tr></tbody></table> <h3 id="constcompositescenestackview"><a href="#constcompositescenestackview" class="header-anchor">#</a> <code>ConstCompositeSceneStackView</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const SceneStack *</code></td> <td>mMainStack</td></tr> <tr><td>8</td> <td>(8) <code>const SceneStack *</code></td> <td>mClientInstanceStack</td></tr></tbody></table> <h3 id="clientinstance-isshowingscreen-l2-lambda-851bb6c3689e76182cb941d3bd1036a4"><a href="#clientinstance-isshowingscreen-l2-lambda-851bb6c3689e76182cb941d3bd1036a4" class="header-anchor">#</a> <code>ClientInstance::_isShowingScreen::__l2::&lt;lambda_851bb6c3689e76182cb941d3bd1036a4&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bool *</code></td> <td>showingScreen</td></tr> <tr><td>8</td> <td>(32) <code>const std::string</code></td> <td>screenName</td></tr></tbody></table> <h3 id="clientinstance-navigatetocoinpurchasescreen-l2-lambda-e1cf1260acbd6347c10ba2122d74ca7a"><a href="#clientinstance-navigatetocoinpurchasescreen-l2-lambda-e1cf1260acbd6347c10ba2122d74ca7a" class="header-anchor">#</a> <code>ClientInstance::navigateToCoinPurchaseScreen::__l2::&lt;lambda_e1cf1260acbd6347c10ba2122d74ca7a&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;ClientInstance&gt;</code></td> <td>weakPtr</td></tr> <tr><td>16</td> <td>(16) <code>std::shared_ptr&lt;OfferRepository::ProductQueryAttemptResult&gt;</code></td> <td>queryAttemptFinished</td></tr> <tr><td>32</td> <td>(16) <code>std::shared_ptr&lt;AsyncTracker&gt;</code></td> <td>tracker</td></tr> <tr><td>48</td> <td>(4) <code>int</code></td> <td>neededCoins</td></tr> <tr><td>56</td> <td>(64) <code>std::function&lt;void __cdecl(bool)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="clientinstance-navigatetostoreseeallbycreatorscreen-l2-lambda-15d8531333f726aeede88a06a28b4fd0"><a href="#clientinstance-navigatetostoreseeallbycreatorscreen-l2-lambda-15d8531333f726aeede88a06a28b4fd0" class="header-anchor">#</a> <code>ClientInstance::navigateToStoreSeeAllByCreatorScreen::__l2::&lt;lambda_15d8531333f726aeede88a06a28b4fd0&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;ClientInstance&gt;</code></td> <td>weakThis</td></tr> <tr><td>16</td> <td>(32) <code>const std::string</code></td> <td>creatorId</td></tr> <tr><td>48</td> <td>(1) <code>const bool</code></td> <td>calledFromHyperlink</td></tr></tbody></table> <h3 id="clientinstance-clientdestroyblockstate"><a href="#clientinstance-clientdestroyblockstate" class="header-anchor">#</a> <code>ClientInstance::ClientDestroyBlockState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Player *</code></td> <td>mPlayer</td></tr> <tr><td>8</td> <td>(8) <code>GameMode *</code></td> <td>mGameMode</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>mDestroyButtonDown</td></tr> <tr><td>24</td> <td>(8) <code>const HitResult *</code></td> <td>mHit</td></tr> <tr><td>32</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>mClearInProgressBAI</td></tr> <tr><td>96</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>mStopDestroying</td></tr> <tr><td>160</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>mVibrate</td></tr></tbody></table> <h3 id="clientskin"><a href="#clientskin" class="header-anchor">#</a> <code>ClientSkin</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mInitialized</td></tr> <tr><td>1</td> <td>(1) <code>bool</code></td> <td>mIsLoadingGeometry</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mReferenceCount</td></tr> <tr><td>8</td> <td>(24) <code>OwnerPtrT&lt;EntityRefTraits&gt;</code></td> <td>mEntity</td></tr> <tr><td>32</td> <td>(776) <code>ClientSkinInfoData</code></td> <td>mSkinInfoData</td></tr> <tr><td>808</td> <td>(8) <code>std::unique_ptr&lt;GeometryGroup&gt;</code></td> <td>mClientSkinGeometryGroup</td></tr></tbody></table> <h3 id="clientskininfodata"><a href="#clientskininfodata" class="header-anchor">#</a> <code>ClientSkinInfoData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(688) <code>SkinInfoData</code></td> <td>baseclass_0</td></tr> <tr><td>688</td> <td>(1) <code>unsigned __int8</code></td> <td>mSubClientId</td></tr> <tr><td>696</td> <td>(16) <code>BedrockTexture</code></td> <td>mBloomTexture</td></tr> <tr><td>712</td> <td>(16) <code>BedrockTexture</code></td> <td>mSkinTexture</td></tr> <tr><td>728</td> <td>(24) <code>std::vector&lt;BedrockTexture&gt;</code></td> <td>mSkinAnimatedTextures</td></tr> <tr><td>752</td> <td>(16) <code>BedrockTexture</code></td> <td>mCapeTexture</td></tr> <tr><td>768</td> <td>(1) <code>bool</code></td> <td>mValid</td></tr></tbody></table> <h3 id="clientparticletrackingcomponent"><a href="#clientparticletrackingcomponent" class="header-anchor">#</a> <code>ClientParticleTrackingComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;HashedString,std::vector&lt;unsigned int&gt;&gt;</code></td> <td>mParticleEmitterLists</td></tr></tbody></table> <h3 id="cataloginfo"><a href="#cataloginfo" class="header-anchor">#</a> <code>CatalogInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;DateManager&gt;</code></td> <td>mDateManager</td></tr> <tr><td>16</td> <td>(20) <code>RetryDelay</code></td> <td>mSaveDelay</td></tr> <tr><td>36</td> <td>(4) <code>int</code></td> <td>mPropertyChangeVersion</td></tr></tbody></table> <h3 id="callbacktoken"><a href="#callbacktoken" class="header-anchor">#</a> <code>CallbackToken</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;CallbackTokenCancelState&gt;</code></td> <td>mCancelState</td></tr></tbody></table> <h3 id="cg-math-rect-float"><a href="#cg-math-rect-float" class="header-anchor">#</a> <code>cg::math::Rect&lt;float&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mX</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mY</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mWidth</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mHeight</td></tr></tbody></table> <h3 id="crashdumpkeyvaluedata"><a href="#crashdumpkeyvaluedata" class="header-anchor">#</a> <code>CrashDumpKeyValueData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>_BYTE[2]</code></td> <td>mTag0</td></tr> <tr><td>2</td> <td>(2) <code>_BYTE[2]</code></td> <td>mTag1</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mValue0</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>mValue1</td></tr></tbody></table> <h3 id="contentlog-contentlogendpointdata"><a href="#contentlog-contentlogendpointdata" class="header-anchor">#</a> <code>ContentLog::ContentLogEndPointData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>gsl::not_null&lt;ContentLogEndPoint *&gt;</code></td> <td>mContentLogEndPoint</td></tr></tbody></table> <h3 id="controllerdirectioneventdata"><a href="#controllerdirectioneventdata" class="header-anchor">#</a> <code>ControllerDirectionEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>DirectionId</code></td> <td>directionId</td></tr> <tr><td>4</td> <td>(8) <code>float[2]</code></td> <td>deltaPosition</td></tr></tbody></table> <h3 id="clippedcollectioneventdata"><a href="#clippedcollectioneventdata" class="header-anchor">#</a> <code>ClippedCollectionEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>collectionNameHash</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>startIndex</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>endIndex</td></tr> <tr><td>16</td> <td>(8) <code>UIPropertyBag *</code></td> <td>propertyBag</td></tr></tbody></table> <h3 id="clipstatechangeeventdata"><a href="#clipstatechangeeventdata" class="header-anchor">#</a> <code>ClipStateChangeEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>id</td></tr> <tr><td>8</td> <td>(8) <code>UIPropertyBag *</code></td> <td>propertyBag</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>isClipped</td></tr></tbody></table> <h3 id="customrenderereventdata"><a href="#customrenderereventdata" class="header-anchor">#</a> <code>CustomRendererEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>id</td></tr></tbody></table> <h3 id="collisiongrid-15"><a href="#collisiongrid-15" class="header-anchor">#</a> <code>CollisionGrid&lt;15&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mWidth</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mHeight</td></tr> <tr><td>8</td> <td>(32) <code>std::bitset&lt;225&gt;</code></td> <td>mGrid</td></tr></tbody></table> <h3 id="clientblockpipeline-tessellatorcontext"><a href="#clientblockpipeline-tessellatorcontext" class="header-anchor">#</a> <code>ClientBlockPipeline::TessellatorContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;ClientBlockPipeline::SchematicsRepository&gt;</code></td> <td>mSchematicsRepo</td></tr></tbody></table> <h3 id="commandlisttaskcontext"><a href="#commandlisttaskcontext" class="header-anchor">#</a> <code>CommandListTaskContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>mce::CommandList</code></td> <td>mCommandList</td></tr> <tr><td>64</td> <td>(8) <code>mce::RingBuffer *</code></td> <td>mCbUploadRingBuffer</td></tr> <tr><td>72</td> <td>(8) <code>mce::PerFrameConstants *</code></td> <td>mThreadedPerFrameConstants</td></tr> <tr><td>80</td> <td>(8) <code>mce::ShaderConstants *</code></td> <td>mThreadedShaderConstants</td></tr> <tr><td>88</td> <td>(8) <code>mce::RenderChunkConstants *</code></td> <td>mRenderChunkConstantBuffer</td></tr> <tr><td>96</td> <td>(8) <code>mce::WorldConstants *</code></td> <td>mThreadedWorldConstantBuffer</td></tr> <tr><td>104</td> <td>(8) ``</td> <td>gap68</td></tr></tbody></table> <h3 id="chunklayerrenderobject"><a href="#chunklayerrenderobject" class="header-anchor">#</a> <code>ChunkLayerRenderObject</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>mChunkIdx</td></tr> <tr><td>8</td> <td>(8) <code>const mce::MaterialPtr *</code></td> <td>mMaterial</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>mIndicesStart</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>mIndicesCount</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>mUnsortedIndicesStart</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>mUnsortedIndicesCount</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>mShouldFallBackToUnsorted</td></tr></tbody></table> <h3 id="contentlog-contentlogscope"><a href="#contentlog-contentlogscope" class="header-anchor">#</a> <code>ContentLog::ContentLogScope</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mPopScope</td></tr> <tr><td>8</td> <td>(16) <code>std::weak_ptr&lt;ContentLog::ScopeHandler&gt;</code></td> <td>mScopeHandler</td></tr></tbody></table> <h3 id="clientinstancescreenmodel"><a href="#clientinstancescreenmodel" class="header-anchor">#</a> <code>ClientInstanceScreenModel</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(216) <code>MinecraftScreenModel</code></td> <td>baseclass_0</td></tr> <tr><td>216</td> <td>(64) <code>std::unordered_map&lt;ActorUniqueID,BossInfo&gt;</code></td> <td>mBossInfo</td></tr></tbody></table> <h3 id="containerscreencontroller-registerstatemachine-l2-lambda-22ba86bea9db98d4be3d24a41addfd59"><a href="#containerscreencontroller-registerstatemachine-l2-lambda-22ba86bea9db98d4be3d24a41addfd59" class="header-anchor">#</a> <code>ContainerScreenController::_registerStateMachine::__l2::&lt;lambda_22ba86bea9db98d4be3d24a41addfd59&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContainerScreenController *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="controlssettingsscreencontroller-registercontrollercallbacks-l2-lambda-7847dc19740a716fdd766d12d5c86f1d-l2-lambda-e1ed6117cdc1faf979ad9c55cf15bfe3"><a href="#controlssettingsscreencontroller-registercontrollercallbacks-l2-lambda-7847dc19740a716fdd766d12d5c86f1d-l2-lambda-e1ed6117cdc1faf979ad9c55cf15bfe3" class="header-anchor">#</a> <code>ControlsSettingsScreenController::_registerControllerCallbacks::__l2::&lt;lambda_7847dc19740a716fdd766d12d5c86f1d&gt;::()::__l2::&lt;lambda_e1ed6117cdc1faf979ad9c55cf15bfe3&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Option *</code></td> <td>option</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>onToggle</td></tr></tbody></table> <h3 id="controlssettingsscreencontroller-keyboardlayoutinfo"><a href="#controlssettingsscreencontroller-keyboardlayoutinfo" class="header-anchor">#</a> <code>ControlsSettingsScreenController::KeyboardLayoutInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>const KeyboardType</code></td> <td>mType</td></tr> <tr><td>8</td> <td>(8) <code>KeyboardRemappingLayout *</code></td> <td>mLayout</td></tr> <tr><td>16</td> <td>(24) <code>std::vector&lt;ControlsSettingsScreenController::BindingInfo&gt;</code></td> <td>mBindings</td></tr> <tr><td>40</td> <td>(32) <code>const std::string</code></td> <td>mGridDimensionName</td></tr> <tr><td>72</td> <td>(32) <code>const std::string</code></td> <td>mCollectionName</td></tr></tbody></table> <h3 id="coursescreencontroller-setleavegameoverride-l2-lambda-b1807e78fd2d1443f9792a801376796c"><a href="#coursescreencontroller-setleavegameoverride-l2-lambda-b1807e78fd2d1443f9792a801376796c" class="header-anchor">#</a> <code>CourseScreenController::_setLeaveGameOverride::__l2::&lt;lambda_b1807e78fd2d1443f9792a801376796c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;TutorialCollection&gt;</code></td> <td>tutorialCollection</td></tr> <tr><td>16</td> <td>(16) <code>std::shared_ptr&lt;LibraryCollection&gt;</code></td> <td>libraryCollection</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>courseTitle</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>courseId</td></tr> <tr><td>96</td> <td>(4) <code>int</code></td> <td>activeItemIndex</td></tr></tbody></table> <h3 id="craftingscreencontrollerproxycallbacks"><a href="#craftingscreencontrollerproxycallbacks" class="header-anchor">#</a> <code>CraftingScreenControllerProxyCallbacks</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;ContainerController * __cdecl(std::string const &amp;)&gt;</code></td> <td>mGetContainerController</td></tr> <tr><td>64</td> <td>(64) <code>std::function&lt;void __cdecl(std::string const &amp;,int,enum ItemCraftType)&gt;</code></td> <td>mRecipeAutoCraft</td></tr> <tr><td>128</td> <td>(64) <code>std::function&lt;void __cdecl(std::string const &amp;,int)&gt;</code></td> <td>mHandleRecipeSelect</td></tr> <tr><td>192</td> <td>(64) <code>std::function&lt;void __cdecl(Recipe const *)&gt;</code></td> <td>mHandleRecipePlaceInputs</td></tr> <tr><td>256</td> <td>(64) <code>std::function&lt;void __cdecl(std::string const &amp;,int)&gt;</code></td> <td>mHandleAutoPlace</td></tr> <tr><td>320</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>mLeaveScreen</td></tr></tbody></table> <h3 id="craftablecountingdata"><a href="#craftablecountingdata" class="header-anchor">#</a> <code>CraftableCountingData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mTotalResultItems</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mAmountOfTimesRecipeIsCrafted</td></tr></tbody></table> <h3 id="craftingscreencontroller-registerstatemachine-l2-lambda-be0bf6bd90e4b29638d1008293b3501b"><a href="#craftingscreencontroller-registerstatemachine-l2-lambda-be0bf6bd90e4b29638d1008293b3501b" class="header-anchor">#</a> <code>CraftingScreenController::_registerStateMachine::__l2::&lt;lambda_be0bf6bd90e4b29638d1008293b3501b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>clearHotbarButtonOrDropId</td></tr></tbody></table> <h3 id="craftingscreencontroller-recipeautocraft-l2-lambda-6aa2f103e2c2f5d7d0fafc45ee252653"><a href="#craftingscreencontroller-recipeautocraft-l2-lambda-6aa2f103e2c2f5d7d0fafc45ee252653" class="header-anchor">#</a> <code>CraftingScreenController::_recipeAutoCraft::__l2::&lt;lambda_6aa2f103e2c2f5d7d0fafc45ee252653&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CraftingScreenController *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(32) <code>const std::string</code></td> <td>collectionName</td></tr> <tr><td>40</td> <td>(4) <code>int</code></td> <td>collectionIndex</td></tr></tbody></table> <h3 id="craftingtablecomponent"><a href="#craftingtablecomponent" class="header-anchor">#</a> <code>CraftingTableComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mGridSize</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>mCustomDescription</td></tr> <tr><td>40</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mCraftingTags</td></tr></tbody></table> <h3 id="customtemplatesscreencontroller-registerevents-l2-lambda-faa911ab3abefbbffed8c9d57cca4fc8-l8-lambda-855dc3b3dd5168adfa3023a3c097783b"><a href="#customtemplatesscreencontroller-registerevents-l2-lambda-faa911ab3abefbbffed8c9d57cca4fc8-l8-lambda-855dc3b3dd5168adfa3023a3c097783b" class="header-anchor">#</a> <code>CustomTemplatesScreenController::_registerEvents::__l2::&lt;lambda_faa911ab3abefbbffed8c9d57cca4fc8&gt;::()::__l8::&lt;lambda_855dc3b3dd5168adfa3023a3c097783b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;CustomTemplatesScreenController&gt;</code></td> <td>weakThis</td></tr> <tr><td>16</td> <td>(264) <code>const WorldTemplateInfo</code></td> <td>level</td></tr></tbody></table> <h3 id="customtemplatesscreencontroller-handleworldtemplateclicked-l2-lambda-0fd1354ad3496433dfc1a1fe4fe2b8a7"><a href="#customtemplatesscreencontroller-handleworldtemplateclicked-l2-lambda-0fd1354ad3496433dfc1a1fe4fe2b8a7" class="header-anchor">#</a> <code>CustomTemplatesScreenController::_handleWorldTemplateClicked::__l2::&lt;lambda_0fd1354ad3496433dfc1a1fe4fe2b8a7&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CustomTemplatesScreenController *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(136) <code>PackIdVersion</code></td> <td>packId</td></tr></tbody></table> <h3 id="customtemplatesscreencontroller-createworldtemplate-l5-lambda-bc20e33a775adc61e26b6412226bb3d7"><a href="#customtemplatesscreencontroller-createworldtemplate-l5-lambda-bc20e33a775adc61e26b6412226bb3d7" class="header-anchor">#</a> <code>CustomTemplatesScreenController::_createWorldTemplate::__l5::&lt;lambda_bc20e33a775adc61e26b6412226bb3d7&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CustomTemplatesScreenController *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(8) <code>const WorldTemplateInfo *</code></td> <td>level</td></tr> <tr><td>16</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>failureCallback</td></tr></tbody></table> <h3 id="customtemplatesscreencontroller-createworldtemplate-l5-lambda-bc20e33a775adc61e26b6412226bb3d7-l5-lambda-1e628f6eed268bb442e37bdf2a00b8a2"><a href="#customtemplatesscreencontroller-createworldtemplate-l5-lambda-bc20e33a775adc61e26b6412226bb3d7-l5-lambda-1e628f6eed268bb442e37bdf2a00b8a2" class="header-anchor">#</a> <code>CustomTemplatesScreenController::_createWorldTemplate::__l5::&lt;lambda_bc20e33a775adc61e26b6412226bb3d7&gt;::()::__l5::&lt;lambda_1e628f6eed268bb442e37bdf2a00b8a2&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>failureCallback</td></tr></tbody></table> <h3 id="clientinstancescreencontroller"><a href="#clientinstancescreencontroller" class="header-anchor">#</a> <code>ClientInstanceScreenController</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2648) <code>MinecraftScreenController</code></td> <td>baseclass_0</td></tr> <tr><td>2648</td> <td>(16) <code>std::shared_ptr&lt;ClientInstanceScreenModel&gt;</code></td> <td>mClientInstanceScreenModel</td></tr> <tr><td>2664</td> <td>(8) <code>std::unique_ptr&lt;PlatformMultiplayerRestrictions&gt;</code></td> <td>mPlatformMultiplayerRestrictions</td></tr></tbody></table> <h3 id="contenttierinfo"><a href="#contenttierinfo" class="header-anchor">#</a> <code>ContentTierInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mMemoryTier</td></tr> <tr><td>4</td> <td>(1) <code>bool</code></td> <td>mIsRayTracingCapable</td></tr></tbody></table> <h3 id="clubs-clubmodel"><a href="#clubs-clubmodel" class="header-anchor">#</a> <code>Clubs::ClubModel</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mClubID</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>mClubDescription</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mClubIcon</td></tr> <tr><td>96</td> <td>(32) <code>std::string</code></td> <td>mClubName</td></tr></tbody></table> <h3 id="controlscreenaction"><a href="#controlscreenaction" class="header-anchor">#</a> <code>ControlScreenAction</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ControlScreenAction_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="commandsyntaxinformation"><a href="#commandsyntaxinformation" class="header-anchor">#</a> <code>CommandSyntaxInformation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>isValid</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>description</td></tr> <tr><td>40</td> <td>(24) <code>std::vector&lt;OverloadSyntaxInformation&gt;</code></td> <td>possibilities</td></tr></tbody></table> <h3 id="core-ziputils-zipfilerestrictions"><a href="#core-ziputils-zipfilerestrictions" class="header-anchor">#</a> <code>Core::ZipUtils::ZipFileRestrictions</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::set&lt;std::string&gt;</code></td> <td>mForbiddenExtensions</td></tr> <tr><td>16</td> <td>(16) <code>std::set&lt;std::string&gt;</code></td> <td>mRestrictedExtensions</td></tr> <tr><td>32</td> <td>(16) <code>std::set&lt;std::string&gt;</code></td> <td>mForbiddenFilenames</td></tr></tbody></table> <h3 id="core-ziputils-zipprogress"><a href="#core-ziputils-zipprogress" class="header-anchor">#</a> <code>Core::ZipUtils::ZipProgress</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>std::atomic&lt;unsigned int&gt;</code></td> <td>mFilesDone</td></tr> <tr><td>4</td> <td>(4) <code>std::atomic&lt;unsigned int&gt;</code></td> <td>mFilesSkipped</td></tr> <tr><td>8</td> <td>(4) <code>std::atomic&lt;unsigned int&gt;</code></td> <td>mTotalFiles</td></tr></tbody></table> <h3 id="commandblockcomponent"><a href="#commandblockcomponent" class="header-anchor">#</a> <code>CommandBlockComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(152) <code>BaseCommandBlock</code></td> <td>mBaseCommandBlock</td></tr> <tr><td>152</td> <td>(4) <code>int</code></td> <td>mCurrentTickCount</td></tr> <tr><td>156</td> <td>(1) <code>bool</code></td> <td>mTicking</td></tr></tbody></table> <h3 id="commonsearchresults"><a href="#commonsearchresults" class="header-anchor">#</a> <code>CommonSearchResults</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mTotalCount</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mFilteredCount</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mUnfilteredDocumentCount</td></tr></tbody></table> <h3 id="clientinstancescreenmodel-navigatetoleavelevelscreen-l5-lambda-ef00954ff1e757a0ee5bf3eac0e1e9ef-l5-lambda-f55e9c9a0c9d5b1a28a0ec013240d974"><a href="#clientinstancescreenmodel-navigatetoleavelevelscreen-l5-lambda-ef00954ff1e757a0ee5bf3eac0e1e9ef-l5-lambda-f55e9c9a0c9d5b1a28a0ec013240d974" class="header-anchor">#</a> <code>ClientInstanceScreenModel::navigateToLeaveLevelScreen::__l5::&lt;lambda_ef00954ff1e757a0ee5bf3eac0e1e9ef&gt;::()::__l5::&lt;lambda_f55e9c9a0c9d5b1a28a0ec013240d974&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;ClientInstanceScreenModel&gt;</code></td> <td>weakThis</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>switchScreen</td></tr> <tr><td>24</td> <td>(384) <code>LevelSummary</code></td> <td>summary</td></tr></tbody></table> <h3 id="clientinstancescreenmodel-initiateglbfilesave-l5-lambda-18e2ef64fe5ed0094ca318e07172f502"><a href="#clientinstancescreenmodel-initiateglbfilesave-l5-lambda-18e2ef64fe5ed0094ca318e07172f502" class="header-anchor">#</a> <code>ClientInstanceScreenModel::initiateGLBFileSave::__l5::&lt;lambda_18e2ef64fe5ed0094ca318e07172f502&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>originPath</td></tr> <tr><td>32</td> <td>(64) <code>std::function&lt;void __cdecl(bool)&gt;</code></td> <td>onComplete</td></tr></tbody></table> <h3 id="crypto-hash-hash"><a href="#crypto-hash-hash" class="header-anchor">#</a> <code>Crypto::Hash::Hash</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Crypto::Hash::IHash</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>std::unique_ptr&lt;Crypto::Hash::IHash&gt;</code></td> <td>mHash</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>mUuidVersion</td></tr></tbody></table> <h3 id="crypto-hash-ihash"><a href="#crypto-hash-ihash" class="header-anchor">#</a> <code>Crypto::Hash::IHash</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Crypto::Hash::IHash_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="clipareas"><a href="#clipareas" class="header-anchor">#</a> <code>ClipAreas</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::set&lt;RectangleArea&gt;</code></td> <td>mAreas</td></tr></tbody></table> <h3 id="clippedcontrolmetadata"><a href="#clippedcontrolmetadata" class="header-anchor">#</a> <code>ClippedControlMetadata</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;RenderControlMetadata&gt;</code></td> <td>controlsToUpdate</td></tr> <tr><td>24</td> <td>(24) <code>std::vector&lt;std::shared_ptr&lt;UIControl&gt;&gt;</code></td> <td>clippedGrids</td></tr> <tr><td>48</td> <td>(24) <code>std::vector&lt;ScreenEvent&gt;</code></td> <td>clipStateChangeEvents</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l5-lambda-f4ef36c9c2241edd05e2049a4cc37d3c"><a href="#clientbindingfactory-getareabinding-l5-lambda-f4ef36c9c2241edd05e2049a4cc37d3c" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l5::&lt;lambda_f4ef36c9c2241edd05e2049a4cc37d3c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l9-lambda-86bc8e749623499401e3fdbcc7ae7f39"><a href="#clientbindingfactory-getareabinding-l9-lambda-86bc8e749623499401e3fdbcc7ae7f39" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l9::&lt;lambda_86bc8e749623499401e3fdbcc7ae7f39&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l13-lambda-dcb08eb3e54defb9e64370fd721b66b7"><a href="#clientbindingfactory-getareabinding-l13-lambda-dcb08eb3e54defb9e64370fd721b66b7" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l13::&lt;lambda_dcb08eb3e54defb9e64370fd721b66b7&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l17-lambda-6b703eda3e6b7618b784bcc537ad3c62"><a href="#clientbindingfactory-getareabinding-l17-lambda-6b703eda3e6b7618b784bcc537ad3c62" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l17::&lt;lambda_6b703eda3e6b7618b784bcc537ad3c62&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l21-lambda-363f1cc72b078a154ed0ead09b4d024d"><a href="#clientbindingfactory-getareabinding-l21-lambda-363f1cc72b078a154ed0ead09b4d024d" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l21::&lt;lambda_363f1cc72b078a154ed0ead09b4d024d&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l25-lambda-fa86098d63427aae10170ef55fc211e6"><a href="#clientbindingfactory-getareabinding-l25-lambda-fa86098d63427aae10170ef55fc211e6" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l25::&lt;lambda_fa86098d63427aae10170ef55fc211e6&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l29-lambda-4ad4abaf36d194589aeacc2087f8e5d8"><a href="#clientbindingfactory-getareabinding-l29-lambda-4ad4abaf36d194589aeacc2087f8e5d8" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l29::&lt;lambda_4ad4abaf36d194589aeacc2087f8e5d8&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l33-lambda-c124153a23bc74bb259e700314fabfe5"><a href="#clientbindingfactory-getareabinding-l33-lambda-c124153a23bc74bb259e700314fabfe5" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l33::&lt;lambda_c124153a23bc74bb259e700314fabfe5&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l37-lambda-ad03e7fd0cd44601e962483c0c526b9c"><a href="#clientbindingfactory-getareabinding-l37-lambda-ad03e7fd0cd44601e962483c0c526b9c" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l37::&lt;lambda_ad03e7fd0cd44601e962483c0c526b9c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l41-lambda-15d4d27fc3fab10c113ccc141c937ae8"><a href="#clientbindingfactory-getareabinding-l41-lambda-15d4d27fc3fab10c113ccc141c937ae8" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l41::&lt;lambda_15d4d27fc3fab10c113ccc141c937ae8&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l45-lambda-8ff1de1eef774dd1106ac7f5857e2d9b"><a href="#clientbindingfactory-getareabinding-l45-lambda-8ff1de1eef774dd1106ac7f5857e2d9b" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l45::&lt;lambda_8ff1de1eef774dd1106ac7f5857e2d9b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l49-lambda-b41f787d80d65477826583f3d77947ad"><a href="#clientbindingfactory-getareabinding-l49-lambda-b41f787d80d65477826583f3d77947ad" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l49::&lt;lambda_b41f787d80d65477826583f3d77947ad&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l53-lambda-02e65bc75bc403a0d5915dac1a58e8c2"><a href="#clientbindingfactory-getareabinding-l53-lambda-02e65bc75bc403a0d5915dac1a58e8c2" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l53::&lt;lambda_02e65bc75bc403a0d5915dac1a58e8c2&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l57-lambda-662ee5d55e561d65a044d078186e83d9"><a href="#clientbindingfactory-getareabinding-l57-lambda-662ee5d55e561d65a044d078186e83d9" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l57::&lt;lambda_662ee5d55e561d65a044d078186e83d9&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l65-lambda-11cb320c71eb9c2c133ff6d68d8de661"><a href="#clientbindingfactory-getareabinding-l65-lambda-11cb320c71eb9c2c133ff6d68d8de661" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l65::&lt;lambda_11cb320c71eb9c2c133ff6d68d8de661&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l69-lambda-9003cc46be8ff06e6019466117b648cb"><a href="#clientbindingfactory-getareabinding-l69-lambda-9003cc46be8ff06e6019466117b648cb" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l69::&lt;lambda_9003cc46be8ff06e6019466117b648cb&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l73-lambda-63d65d763c745e34cfd24e2ed9e972e9"><a href="#clientbindingfactory-getareabinding-l73-lambda-63d65d763c745e34cfd24e2ed9e972e9" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l73::&lt;lambda_63d65d763c745e34cfd24e2ed9e972e9&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l81-lambda-91076f5a9a3c55292508097fc4d6fac7"><a href="#clientbindingfactory-getareabinding-l81-lambda-91076f5a9a3c55292508097fc4d6fac7" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l81::&lt;lambda_91076f5a9a3c55292508097fc4d6fac7&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l85-lambda-feb1532674b9f50b160f3ecdb14b5bbc"><a href="#clientbindingfactory-getareabinding-l85-lambda-feb1532674b9f50b160f3ecdb14b5bbc" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l85::&lt;lambda_feb1532674b9f50b160f3ecdb14b5bbc&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l89-lambda-3045ae51b964740e158387af04a53e99"><a href="#clientbindingfactory-getareabinding-l89-lambda-3045ae51b964740e158387af04a53e99" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l89::&lt;lambda_3045ae51b964740e158387af04a53e99&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l93-lambda-98c915c68a450916aaedca71464fb20d"><a href="#clientbindingfactory-getareabinding-l93-lambda-98c915c68a450916aaedca71464fb20d" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l93::&lt;lambda_98c915c68a450916aaedca71464fb20d&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l97-lambda-30a6bbd5c8267ea08db9dc591f356dc6"><a href="#clientbindingfactory-getareabinding-l97-lambda-30a6bbd5c8267ea08db9dc591f356dc6" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l97::&lt;lambda_30a6bbd5c8267ea08db9dc591f356dc6&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l101-lambda-9dbc146f72c67fa5eb0eb81ee8beb838"><a href="#clientbindingfactory-getareabinding-l101-lambda-9dbc146f72c67fa5eb0eb81ee8beb838" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l101::&lt;lambda_9dbc146f72c67fa5eb0eb81ee8beb838&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l105-lambda-8236814038f22a3770d7eb365f42c1bb"><a href="#clientbindingfactory-getareabinding-l105-lambda-8236814038f22a3770d7eb365f42c1bb" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l105::&lt;lambda_8236814038f22a3770d7eb365f42c1bb&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory-getareabinding-l109-lambda-5be19c9e68037c701d60f79feeb8b6fc"><a href="#clientbindingfactory-getareabinding-l109-lambda-5be19c9e68037c701d60f79feeb8b6fc" class="header-anchor">#</a> <code>ClientBindingFactory::getAreaBinding::__l109::&lt;lambda_5be19c9e68037c701d60f79feeb8b6fc&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBindingFactory *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,bool&gt;</code></td> <td>map</td></tr></tbody></table> <h3 id="clientbindingfactory"><a href="#clientbindingfactory" class="header-anchor">#</a> <code>ClientBindingFactory</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BindingFactory</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>const ClientInputHandler *</code></td> <td>mClientInputHandler</td></tr> <tr><td>16</td> <td>(8) <code>IClientInstance *</code></td> <td>mClient</td></tr> <tr><td>24</td> <td>(16) <code>RectangleArea</code></td> <td>mEmpty</td></tr> <tr><td>40</td> <td>(16) <code>RectangleArea</code></td> <td>mTurnInteract</td></tr> <tr><td>56</td> <td>(16) <code>RectangleArea</code></td> <td>mDPadNoTurnInteractArea</td></tr> <tr><td>72</td> <td>(16) <code>RectangleArea</code></td> <td>mDisableJumpArea</td></tr> <tr><td>88</td> <td>(16) <code>RectangleArea</code></td> <td>mDisableSneakArea</td></tr> <tr><td>104</td> <td>(16) <code>RectangleArea</code></td> <td>mGuiPassthrough</td></tr> <tr><td>120</td> <td>(16) <code>RectangleArea</code></td> <td>mChangingFlightHeight</td></tr> <tr><td>136</td> <td>(16) <code>RectangleArea</code></td> <td>mLeft</td></tr> <tr><td>152</td> <td>(16) <code>RectangleArea</code></td> <td>mRight</td></tr> <tr><td>168</td> <td>(16) <code>RectangleArea</code></td> <td>mUpInvisible</td></tr> <tr><td>184</td> <td>(16) <code>RectangleArea</code></td> <td>mUp</td></tr> <tr><td>200</td> <td>(16) <code>RectangleArea</code></td> <td>mDown</td></tr> <tr><td>216</td> <td>(16) <code>RectangleArea</code></td> <td>mAscend</td></tr> <tr><td>232</td> <td>(16) <code>RectangleArea</code></td> <td>mMiddleRight</td></tr> <tr><td>248</td> <td>(16) <code>RectangleArea</code></td> <td>mDescend</td></tr> <tr><td>264</td> <td>(16) <code>RectangleArea</code></td> <td>mPause</td></tr> <tr><td>280</td> <td>(16) <code>RectangleArea</code></td> <td>mEmote</td></tr> <tr><td>296</td> <td>(16) <code>RectangleArea</code></td> <td>mChat</td></tr> <tr><td>312</td> <td>(16) <code>RectangleArea</code></td> <td>mJump</td></tr> <tr><td>328</td> <td>(16) <code>RectangleArea</code></td> <td>mUpLeft</td></tr> <tr><td>344</td> <td>(16) <code>RectangleArea</code></td> <td>mUpRight</td></tr> <tr><td>360</td> <td>(16) <code>RectangleArea</code></td> <td>mPlayerEffects</td></tr> <tr><td>376</td> <td>(16) <code>RectangleArea</code></td> <td>mPaddleRight</td></tr> <tr><td>392</td> <td>(16) <code>RectangleArea</code></td> <td>mPaddleLeft</td></tr> <tr><td>408</td> <td>(16) <code>RectangleArea</code></td> <td>mSneak</td></tr> <tr><td>424</td> <td>(16) <code>RectangleArea</code></td> <td>mMobEffects</td></tr> <tr><td>440</td> <td>(16) <code>RectangleArea</code></td> <td>mToastArea</td></tr> <tr><td>456</td> <td>(16) <code>RectangleArea</code></td> <td>mCodeBuilder</td></tr> <tr><td>472</td> <td>(16) <code>RectangleArea</code></td> <td>mImmersiveReader</td></tr> <tr><td>488</td> <td>(16) <code>RectangleArea</code></td> <td>mKeyJobArea</td></tr> <tr><td>504</td> <td>(16) <code>RectangleArea</code></td> <td>mSneakOnJK</td></tr> <tr><td>520</td> <td>(16) <code>RectangleArea</code></td> <td>mStoreArea</td></tr> <tr><td>536</td> <td>(16) <code>RectangleArea</code></td> <td>mWalkStateArea</td></tr> <tr><td>552</td> <td>(16) <code>RectangleArea</code></td> <td>mVState0</td></tr> <tr><td>568</td> <td>(16) <code>RectangleArea</code></td> <td>mMicrophone</td></tr> <tr><td>584</td> <td>(16) <code>RectangleArea</code></td> <td>mScreenshot</td></tr> <tr><td>600</td> <td>(16) <code>RectangleArea</code></td> <td>mVoiceTrans</td></tr> <tr><td>616</td> <td>(16) <code>RectangleArea</code></td> <td>mFoldMenuArea</td></tr> <tr><td>632</td> <td>(16) <code>RectangleArea</code></td> <td>mReportCheat</td></tr> <tr><td>648</td> <td>(4) <code>float</code></td> <td>mStoreAreaX</td></tr> <tr><td>652</td> <td>(4) <code>float</code></td> <td>mStoreAreaY</td></tr> <tr><td>656</td> <td>(8) <code>glm::tvec2&lt;float,0&gt;</code></td> <td>mInteractCreative</td></tr> <tr><td>664</td> <td>(8) <code>glm::tvec2&lt;float,0&gt;</code></td> <td>mInteractSurvival</td></tr></tbody></table> <h3 id="channellistquery"><a href="#channellistquery" class="header-anchor">#</a> <code>ChannelListQuery</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mSkip</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mCount</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>mChannelName</td></tr> <tr><td>40</td> <td>(1) <code>ChannelListQueryType</code></td> <td>mType</td></tr></tbody></table> <h3 id="cube"><a href="#cube" class="header-anchor">#</a> <code>Cube</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Vec3</code></td> <td>mOrigin</td></tr> <tr><td>12</td> <td>(12) <code>Vec3</code></td> <td>mSize</td></tr> <tr><td>24</td> <td>(12) <code>Vec3</code></td> <td>mRotation</td></tr> <tr><td>36</td> <td>(12) <code>Vec3</code></td> <td>mCubePivot</td></tr> <tr><td>48</td> <td>(24) <code>std::vector&lt;PolygonQuad&gt;</code></td> <td>mPolygons</td></tr> <tr><td>72</td> <td>(16) <code>mce::Color</code></td> <td>mColor</td></tr> <tr><td>88</td> <td>(1) <code>bool</code></td> <td>mMirrored</td></tr> <tr><td>92</td> <td>(144) <code>std::array&lt;Cube::FaceUVData,6&gt;</code></td> <td>mFaceData</td></tr></tbody></table> <h3 id="cube-faceuvdata"><a href="#cube-faceuvdata" class="header-anchor">#</a> <code>Cube::FaceUVData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Vec2</code></td> <td>mUV</td></tr> <tr><td>8</td> <td>(8) <code>Vec2</code></td> <td>mUVSize</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>mMaterialInstanceListIndex</td></tr> <tr><td>20</td> <td>(1) <code>bool</code></td> <td>mFaceValid</td></tr></tbody></table> <h3 id="clientnetworkhandler-handle-l2-lambda-3a932b1c4cad8a420efad8f5991d860f"><a href="#clientnetworkhandler-handle-l2-lambda-3a932b1c4cad8a420efad8f5991d860f" class="header-anchor">#</a> <code>ClientNetworkHandler::handle::__l2::&lt;lambda_3a932b1c4cad8a420efad8f5991d860f&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ResourcePackFileDownloaderManager *</code></td> <td>downloadManager</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>resourceName</td></tr> <tr><td>40</td> <td>(8) <code>ClientNetworkHandler *const</code></td> <td>__this</td></tr> <tr><td>48</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>weakValid</td></tr></tbody></table> <h3 id="clientnetworkhandler-handle-l2-lambda-57a8c0175a82e2b1f2fddb694a815e8f"><a href="#clientnetworkhandler-handle-l2-lambda-57a8c0175a82e2b1f2fddb694a815e8f" class="header-anchor">#</a> <code>ClientNetworkHandler::handle::__l2::&lt;lambda_57a8c0175a82e2b1f2fddb694a815e8f&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(152) <code>const NetworkIdentifier</code></td> <td>source</td></tr> <tr><td>152</td> <td>(32) <code>std::string</code></td> <td>resourceName</td></tr> <tr><td>184</td> <td>(8) <code>ClientNetworkHandler *const</code></td> <td>__this</td></tr> <tr><td>192</td> <td>(1) <code>_BYTE[1]</code></td> <td>packType</td></tr> <tr><td>200</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>weakValid</td></tr></tbody></table> <h3 id="clientnetworkhandler-handle-l2-lambda-f7c9cc170d1b2d687b5ef307e2dd2a5f"><a href="#clientnetworkhandler-handle-l2-lambda-f7c9cc170d1b2d687b5ef307e2dd2a5f" class="header-anchor">#</a> <code>ClientNetworkHandler::handle::__l2::&lt;lambda_f7c9cc170d1b2d687b5ef307e2dd2a5f&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ClientNetworkHandler *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(8) <code>ResourcePackFileDownloaderManager *</code></td> <td>downloadManager</td></tr> <tr><td>16</td> <td>(8) <code>const NetworkIdentifier *</code></td> <td>source</td></tr> <tr><td>24</td> <td>(128) <code>const ResourcePackDataInfoPacket</code></td> <td>packet</td></tr> <tr><td>152</td> <td>(32) <code>std::string</code></td> <td>resourceName</td></tr></tbody></table> <h3 id="clientnetworkhandler-handle-l2-lambda-f7c9cc170d1b2d687b5ef307e2dd2a5f-l5-lambda-c1b3156103bb292e2178303c3a153411"><a href="#clientnetworkhandler-handle-l2-lambda-f7c9cc170d1b2d687b5ef307e2dd2a5f-l5-lambda-c1b3156103bb292e2178303c3a153411" class="header-anchor">#</a> <code>ClientNetworkHandler::handle::__l2::&lt;lambda_f7c9cc170d1b2d687b5ef307e2dd2a5f&gt;::()::__l5::&lt;lambda_c1b3156103bb292e2178303c3a153411&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ClientNetworkHandler *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(8) <code>ResourcePackFileDownloaderManager *</code></td> <td>downloadManager</td></tr> <tr><td>16</td> <td>(128) <code>const ResourcePackDataInfoPacket</code></td> <td>packet</td></tr> <tr><td>144</td> <td>(32) <code>std::string</code></td> <td>resourceName</td></tr></tbody></table> <h3 id="clientnetworkhandler-handle-l2-lambda-d12db79ea14521c577faa9163e217abc"><a href="#clientnetworkhandler-handle-l2-lambda-d12db79ea14521c577faa9163e217abc" class="header-anchor">#</a> <code>ClientNetworkHandler::handle::__l2::&lt;lambda_d12db79ea14521c577faa9163e217abc&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>const LabTablePacket</code></td> <td>packet</td></tr></tbody></table> <h3 id="connectionrequest"><a href="#connectionrequest" class="header-anchor">#</a> <code>ConnectionRequest</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;UnverifiedCertificate&gt;</code></td> <td>mCertificateData</td></tr> <tr><td>8</td> <td>(8) <code>std::unique_ptr&lt;Certificate&gt;</code></td> <td>mCertificate</td></tr> <tr><td>16</td> <td>(8) <code>std::unique_ptr&lt;WebToken&gt;</code></td> <td>mRawToken</td></tr> <tr><td>24</td> <td>(1) <code>unsigned __int8</code></td> <td>mClientSubId</td></tr></tbody></table> <h3 id="containeropenpacket"><a href="#containeropenpacket" class="header-anchor">#</a> <code>ContainerOpenPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(1) <code>ContainerID</code></td> <td>mContainerId</td></tr> <tr><td>41</td> <td>(1) <code>ContainerType</code></td> <td>mType</td></tr> <tr><td>44</td> <td>(12) <code>NetworkBlockPosition</code></td> <td>mPos</td></tr> <tr><td>56</td> <td>(8) <code>ActorUniqueID</code></td> <td>mEntityUniqueID</td></tr></tbody></table> <h3 id="containercomponent"><a href="#containercomponent" class="header-anchor">#</a> <code>ContainerComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContainerContentChangeListener</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>std::unique_ptr&lt;Container&gt;</code></td> <td>mContainer</td></tr> <tr><td>16</td> <td>(8) <code>Mob *</code></td> <td>mListenerShim</td></tr> <tr><td>24</td> <td>(1) <code>bool</code></td> <td>mCanBeSiphonedFrom</td></tr> <tr><td>25</td> <td>(1) <code>bool</code></td> <td>mPrivate</td></tr> <tr><td>26</td> <td>(1) <code>bool</code></td> <td>mRestrictToOwner</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>mLootTable</td></tr> <tr><td>64</td> <td>(4) <code>int</code></td> <td>mLootTableSeed</td></tr></tbody></table> <h3 id="containercontentchangelistener"><a href="#containercontentchangelistener" class="header-anchor">#</a> <code>ContainerContentChangeListener</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContainerContentChangeListener_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="chatoptions-chatoption"><a href="#chatoptions-chatoption" class="header-anchor">#</a> <code>ChatOptions::ChatOption</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Option *</code></td> <td>option</td></tr> <tr><td>8</td> <td>(1) <code>const ChatCategory</code></td> <td>category</td></tr> <tr><td>16</td> <td>(32) <code>const std::string</code></td> <td>telemetryName</td></tr></tbody></table> <h3 id="constdeserializedataparams"><a href="#constdeserializedataparams" class="header-anchor">#</a> <code>ConstDeserializeDataParams</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const Json::Value *</code></td> <td>mValue</td></tr> <tr><td>8</td> <td>(112) <code>const SemVersion</code></td> <td>mPackVersion</td></tr></tbody></table> <h3 id="core-inputfilestream"><a href="#core-inputfilestream" class="header-anchor">#</a> <code>Core::InputFileStream</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(296) <code>Core::FileStream</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="commonresourcedefinitionmap"><a href="#commonresourcedefinitionmap" class="header-anchor">#</a> <code>CommonResourceDefinitionMap</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;HashedString,ActorSkeletalAnimationPtr&gt;</code></td> <td>mActorAnimationMap</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;HashedString,ActorAnimationControllerPtr&gt;</code></td> <td>mActorAnimationControllerMap</td></tr> <tr><td>128</td> <td>(24) <code>std::vector&lt;NamedMolangScript&gt;</code></td> <td>mActorAnimateScriptArray</td></tr> <tr><td>152</td> <td>(24) <code>std::vector&lt;MolangVariableSettings&gt;</code></td> <td>mVariableSettings</td></tr> <tr><td>176</td> <td>(24) <code>std::vector&lt;HashedString&gt;</code></td> <td>mQueryableGeometryBoneNames</td></tr></tbody></table> <h3 id="clientblockpipeline-transforms"><a href="#clientblockpipeline-transforms" class="header-anchor">#</a> <code>ClientBlockPipeline::Transforms</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>Matrix</code></td> <td>mPostTransform</td></tr></tbody></table> <h3 id="chalkboardblockactor-cachedmessagedata"><a href="#chalkboardblockactor-cachedmessagedata" class="header-anchor">#</a> <code>ChalkboardBlockActor::CachedMessageData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(640) <code>std::array&lt;ChalkboardBlockActor::CachedLineData,16&gt;</code></td> <td>lineData</td></tr> <tr><td>640</td> <td>(4) <code>unsigned int</code></td> <td>numLines</td></tr> <tr><td>648</td> <td>(32) <code>std::string</code></td> <td>filteredMessage</td></tr> <tr><td>680</td> <td>(8) <code>const void *</code></td> <td>cachedFontCompare</td></tr> <tr><td>688</td> <td>(1) <code>bool</code></td> <td>dirty</td></tr></tbody></table> <h3 id="chalkboardblockactor-cachedlinedata"><a href="#chalkboardblockactor-cachedlinedata" class="header-anchor">#</a> <code>ChalkboardBlockActor::CachedLineData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>text</td></tr> <tr><td>32</td> <td>(4) <code>int</code></td> <td>lineLength</td></tr></tbody></table> <h3 id="chunkblockpos"><a href="#chunkblockpos" class="header-anchor">#</a> <code>ChunkBlockPos</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>x</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>z</td></tr> <tr><td>2</td> <td>(2) <code>ChunkLocalHeight</code></td> <td>y</td></tr></tbody></table> <h3 id="chunksource"><a href="#chunksource" class="header-anchor">#</a> <code>ChunkSource</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ChunkSource_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mChunkSide</td></tr> <tr><td>16</td> <td>(8) <code>Level *</code></td> <td>mLevel</td></tr> <tr><td>24</td> <td>(8) <code>Dimension *</code></td> <td>mDimension</td></tr> <tr><td>32</td> <td>(8) <code>ChunkSource *</code></td> <td>mParent</td></tr> <tr><td>40</td> <td>(8) <code>std::unique_ptr&lt;ChunkSource&gt;</code></td> <td>mOwnedParent</td></tr> <tr><td>48</td> <td>(8) <code>LevelChunkBuilderData *</code></td> <td>mLevelChunkBuilderData</td></tr></tbody></table> <h3 id="cubemap-rendercubemap-l17-lambda-260eef0ecc0f3850dffbb1b638223cba"><a href="#cubemap-rendercubemap-l17-lambda-260eef0ecc0f3850dffbb1b638223cba" class="header-anchor">#</a> <code>CubeMap::renderCubeMap::__l17::&lt;lambda_260eef0ecc0f3850dffbb1b638223cba&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>const Matrix</code></td> <td>cubemapWorldMatrix</td></tr></tbody></table> <h3 id="clientrenderdata"><a href="#clientrenderdata" class="header-anchor">#</a> <code>ClientRenderData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>mClientSubId</td></tr></tbody></table> <h3 id="cloudrenderobject"><a href="#cloudrenderobject" class="header-anchor">#</a> <code>CloudRenderObject</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;mce::Mesh&gt;</code></td> <td>mCloudsMesh</td></tr> <tr><td>16</td> <td>(8) <code>const mce::MaterialPtr *</code></td> <td>mCloudMaterial</td></tr> <tr><td>24</td> <td>(16) <code>mce::Color</code></td> <td>mCloudColor</td></tr> <tr><td>40</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>mCloudDiff</td></tr> <tr><td>52</td> <td>(4) <code>float</code></td> <td>mYTranslation</td></tr></tbody></table> <h3 id="chunkrenderobjectcollection"><a href="#chunkrenderobjectcollection" class="header-anchor">#</a> <code>ChunkRenderObjectCollection</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;mce::ServerTexture&gt;</code></td> <td>mTextures</td></tr> <tr><td>24</td> <td>(24) <code>std::vector&lt;ChunkRenderData&gt;</code></td> <td>mChunkQueue</td></tr> <tr><td>48</td> <td>(1296) <code>std::vector&lt;ChunkLayerRenderObject&gt;[3][18]</code></td> <td>mTerrainLayerChunkQueue</td></tr> <tr><td>1344</td> <td>(4) <code>unsigned int</code></td> <td>mMaximumChunkVertexCount</td></tr></tbody></table> <h3 id="crackrenderobjectcollection"><a href="#crackrenderobjectcollection" class="header-anchor">#</a> <code>CrackRenderObjectCollection</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>std::vector&lt;CrackRenderObject,LinearAllocator&lt;CrackRenderObject&gt; &gt;</code></td> <td>mCracks</td></tr> <tr><td>40</td> <td>(72) <code>mce::TexturePtr</code></td> <td>mAtlasTexture</td></tr></tbody></table> <h3 id="crackrenderobject"><a href="#crackrenderobject" class="header-anchor">#</a> <code>CrackRenderObject</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;mce::Mesh&gt;</code></td> <td>mMesh</td></tr> <tr><td>16</td> <td>(8) <code>const mce::MaterialPtr *</code></td> <td>mCrackMat</td></tr> <tr><td>24</td> <td>(1) <code>bool</code></td> <td>mAlphaTest</td></tr></tbody></table> <h3 id="cg-bufferspan"><a href="#cg-bufferspan" class="header-anchor">#</a> <code>cg::BufferSpan</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>cg::BufferDescription</code></td> <td>mDescription</td></tr> <tr><td>8</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>mData</td></tr></tbody></table> <h3 id="cg-bufferdescription"><a href="#cg-bufferdescription" class="header-anchor">#</a> <code>cg::BufferDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mStride</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>mCount</td></tr></tbody></table> <h3 id="cg-rendermaterialgrouploader-std-unordered-map-hashedstring-std-shared-ptr-mce-rendermaterialinfo-std-hash-hashedstring-std-equal-to-hashedstring-std-allocator-std-pair-hashedstring-const-std-shared-ptr-mce-rendermaterialinfo-mce-rendermaterial-mce-rendermaterialinfo-resourcepackmanager"><a href="#cg-rendermaterialgrouploader-std-unordered-map-hashedstring-std-shared-ptr-mce-rendermaterialinfo-std-hash-hashedstring-std-equal-to-hashedstring-std-allocator-std-pair-hashedstring-const-std-shared-ptr-mce-rendermaterialinfo-mce-rendermaterial-mce-rendermaterialinfo-resourcepackmanager" class="header-anchor">#</a> <code>cg::RenderMaterialGroupLoader&lt;std::unordered_map&lt;HashedString,std::shared_ptr&lt;mce::RenderMaterialInfo&gt;,std::hash&lt;HashedString&gt;,std::equal_to&lt;HashedString&gt;,std::allocator&lt;std::pair&lt;HashedString const ,std::shared_ptr&lt;mce::RenderMaterialInfo&gt; &gt; &gt; &gt;,mce::RenderMaterial,mce::RenderMaterialInfo,ResourcePackManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cg-renderfeaturesconfiguration"><a href="#cg-renderfeaturesconfiguration" class="header-anchor">#</a> <code>cg::RenderFeaturesConfiguration</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>MSAAEnabled</td></tr> <tr><td>1</td> <td>(1) <code>bool</code></td> <td>TexelAAEnabled</td></tr> <tr><td>2</td> <td>(1) <code>bool</code></td> <td>HolographicMode</td></tr> <tr><td>3</td> <td>(1) <code>bool</code></td> <td>AlphaToCoverageSupported</td></tr> <tr><td>4</td> <td>(1) <code>bool</code></td> <td>VertexFormatRGBA8Supported</td></tr> <tr><td>5</td> <td>(1) <code>bool</code></td> <td>VertexShaderInstancingSupported</td></tr> <tr><td>6</td> <td>(1) <code>bool</code></td> <td>LargeVertexShaderUniforms</td></tr></tbody></table> <h3 id="cg-rendermaterialbase"><a href="#cg-rendermaterialbase" class="header-anchor">#</a> <code>cg::RenderMaterialBase</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>cg::RenderMaterialBase_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(16) <code>std::map&lt;std::string,std::shared_ptr&lt;cg::RenderMaterialBase&gt;&gt;</code></td> <td>mMaterialVariations</td></tr> <tr><td>24</td> <td>(32) <code>cg::VariationMap</code></td> <td>mVariationMap</td></tr> <tr><td>56</td> <td>(32) <code>std::string</code></td> <td>mFullMaterialName</td></tr> <tr><td>88</td> <td>(32) <code>std::string</code></td> <td>mVariantName</td></tr> <tr><td>120</td> <td>(32) <code>std::string</code></td> <td>mMaterialIdentifier</td></tr> <tr><td>152</td> <td>(16) <code>std::set&lt;std::string&gt;</code></td> <td>mDefines</td></tr> <tr><td>168</td> <td>(2) <code>_BYTE[2]</code></td> <td>mStateMask</td></tr> <tr><td>176</td> <td>(32) <code>std::string</code></td> <td>mShaderHeader</td></tr> <tr><td>208</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mVertexShader</td></tr> <tr><td>240</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mFragmentShader</td></tr> <tr><td>272</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mGeometryShader</td></tr> <tr><td>304</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mVRGeometryShader</td></tr> <tr><td>336</td> <td>(112) <code>SemVersion</code></td> <td>mVersion</td></tr></tbody></table> <h3 id="cg-variationmap"><a href="#cg-variationmap" class="header-anchor">#</a> <code>cg::VariationMap</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::map&lt;std::string,cg::VariationMap&gt;</code></td> <td>mMaterialJsonVariationMap</td></tr> <tr><td>16</td> <td>(16) <code>Json::Value</code></td> <td>mVariantJson</td></tr></tbody></table> <h3 id="cg-resourcemanager-std-shared-ptr-cg-imagebuffer-resourcelocation-sharedimagebuffertracker-std-shared-ptr-cg-imagebuffer-std-map"><a href="#cg-resourcemanager-std-shared-ptr-cg-imagebuffer-resourcelocation-sharedimagebuffertracker-std-shared-ptr-cg-imagebuffer-std-map" class="header-anchor">#</a> <code>cg::ResourceManager&lt;std::shared_ptr&lt;cg::ImageBuffer&gt;,ResourceLocation,SharedImageBufferTracker,std::shared_ptr&lt;cg::ImageBuffer&gt;,std::map&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::map&lt;ResourceLocation,std::shared_ptr&lt;cg::ImageBuffer&gt;&gt;</code></td> <td>mContainer</td></tr></tbody></table> <h3 id="contentcatalogpacksource-collectallcatalogitems-l2-lambda-baa95d9a96c4efb4ae292f92f510cc21"><a href="#contentcatalogpacksource-collectallcatalogitems-l2-lambda-baa95d9a96c4efb4ae292f92f510cc21" class="header-anchor">#</a> <code>ContentCatalogPackSource::_collectAllCatalogItems::__l2::&lt;lambda_baa95d9a96c4efb4ae292f92f510cc21&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentCatalogPackSource *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(576) <code>SearchQuery</code></td> <td>query</td></tr> <tr><td>584</td> <td>(16) <code>std::shared_ptr&lt;unsigned __int64&gt;</code></td> <td>documentsReceived</td></tr> <tr><td>600</td> <td>(16) <code>std::shared_ptr&lt;unsigned __int64&gt;</code></td> <td>documentsRemoved</td></tr> <tr><td>616</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>callback</td></tr> <tr><td>680</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>weakTracker</td></tr></tbody></table> <h3 id="contentcatalogpacksource-addcatalogitemsfromsearch-l9-lambda-6c2cc72359c8774f2a3e9185f6c63471"><a href="#contentcatalogpacksource-addcatalogitemsfromsearch-l9-lambda-6c2cc72359c8774f2a3e9185f6c63471" class="header-anchor">#</a> <code>ContentCatalogPackSource::_addCatalogItemsFromSearch::__l9::&lt;lambda_6c2cc72359c8774f2a3e9185f6c63471&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentCatalogPackSource *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(576) <code>SearchQuery</code></td> <td>nextQuery</td></tr> <tr><td>584</td> <td>(16) <code>std::shared_ptr&lt;unsigned __int64&gt;</code></td> <td>documentsReceived</td></tr> <tr><td>600</td> <td>(16) <code>std::shared_ptr&lt;unsigned __int64&gt;</code></td> <td>documentsRemoved</td></tr> <tr><td>616</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>callback</td></tr> <tr><td>680</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>weakTracker</td></tr></tbody></table> <h3 id="core-ziputils-unzipsettings"><a href="#core-ziputils-unzipsettings" class="header-anchor">#</a> <code>Core::ZipUtils::UnzipSettings</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(48) <code>Core::ZipUtils::ZipFileRestrictions</code></td> <td>mRestrictions</td></tr> <tr><td>48</td> <td>(1) <code>bool</code></td> <td>mDeleteZipOnSuccess</td></tr> <tr><td>49</td> <td>(1) <code>bool</code></td> <td>mPreventOverwrites</td></tr> <tr><td>56</td> <td>(8) <code>IFileAccess *</code></td> <td>mFileAccess</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mPassword</td></tr> <tr><td>96</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mSelectedPaths</td></tr></tbody></table> <h3 id="contentacquisition-searchfordlcidsbypackids-l11-lambda-b5e7ac097f87844b528ff4a5d3cae47b"><a href="#contentacquisition-searchfordlcidsbypackids-l11-lambda-b5e7ac097f87844b528ff4a5d3cae47b" class="header-anchor">#</a> <code>ContentAcquisition::searchForDlcIdsByPackIds::__l11::&lt;lambda_b5e7ac097f87844b528ff4a5d3cae47b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(136) <code>const PackIdVersion</code></td> <td>packId</td></tr> <tr><td>136</td> <td>(160) <code>ContentAcquisition::searchForDlcIdsByPackIds::__l6::&lt;lambda_1d55797dc2ac18165f6bbd44e10719d3&gt;</code></td> <td>onSearchComplete</td></tr></tbody></table> <h3 id="contentacquisition-searchfordlcidsbypackids-l6-lambda-1d55797dc2ac18165f6bbd44e10719d3"><a href="#contentacquisition-searchfordlcidsbypackids-l6-lambda-1d55797dc2ac18165f6bbd44e10719d3" class="header-anchor">#</a> <code>ContentAcquisition::searchForDlcIdsByPackIds::__l6::&lt;lambda_1d55797dc2ac18165f6bbd44e10719d3&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentAcquisition *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;</code>ContentAcquisition::searchForDlcIdsByPackIds'::<code>2'::SearchTracker&gt;</code></td> <td>tracker</td></tr> <tr><td>24</td> <td>(136) <code>const PackIdVersion</code></td> <td>packId</td></tr></tbody></table> <h3 id="contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5"><a href="#contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5" class="header-anchor">#</a> <code>ContentAcquisition::checkStorageRequirements::__l2::&lt;lambda_9e238074f4708f40d39951c6bbb8c3d5&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentAcquisition *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;</code>ContentAcquisition::checkStorageRequirements'::<code>2'::Totals&gt;</code></td> <td>sharedTotals</td></tr> <tr><td>24</td> <td>(24) <code>const std::vector&lt;DlcId&gt;</code></td> <td>dlcIds</td></tr> <tr><td>48</td> <td>(64) <code>std::function&lt;void __cdecl(bool,unsigned __int64)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l2-lambda-23d0a1b8fd39adaa4c0cd04cd9e72a88-l5-lambda-fb76be13b8fe047662fa721a3a77c9bb"><a href="#contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l2-lambda-23d0a1b8fd39adaa4c0cd04cd9e72a88-l5-lambda-fb76be13b8fe047662fa721a3a77c9bb" class="header-anchor">#</a> <code>ContentAcquisition::checkStorageRequirements::__l2::&lt;lambda_9e238074f4708f40d39951c6bbb8c3d5&gt;::()::__l2::&lt;lambda_23d0a1b8fd39adaa4c0cd04cd9e72a88&gt;::()::__l5::&lt;lambda_fb76be13b8fe047662fa721a3a77c9bb&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>dlcSize</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(bool,unsigned __int64)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l6-lambda-5be28da840c3ba3420f6b07d0ad08a78"><a href="#contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l6-lambda-5be28da840c3ba3420f6b07d0ad08a78" class="header-anchor">#</a> <code>ContentAcquisition::checkStorageRequirements::__l2::&lt;lambda_9e238074f4708f40d39951c6bbb8c3d5&gt;::()::__l6::&lt;lambda_5be28da840c3ba3420f6b07d0ad08a78&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentAcquisition *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(200) <code>const DlcId</code></td> <td>dlcId</td></tr> <tr><td>208</td> <td>(88) <code>ContentAcquisition::checkStorageRequirements::__l2::&lt;lambda_9e238074f4708f40d39951c6bbb8c3d5&gt;::()::__l2::&lt;lambda_23d0a1b8fd39adaa4c0cd04cd9e72a88&gt;</code></td> <td>onFileSizeFound</td></tr> <tr><td>296</td> <td>(8) <code>std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;std::pair&lt;DlcId const ,ContentAcquisition::DownloadHistory&gt; &gt; &gt; &gt;</code></td> <td>pairIt</td></tr></tbody></table> <h3 id="contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l2-lambda-23d0a1b8fd39adaa4c0cd04cd9e72a88"><a href="#contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l2-lambda-23d0a1b8fd39adaa4c0cd04cd9e72a88" class="header-anchor">#</a> <code>ContentAcquisition::checkStorageRequirements::__l2::&lt;lambda_9e238074f4708f40d39951c6bbb8c3d5&gt;::()::__l2::&lt;lambda_23d0a1b8fd39adaa4c0cd04cd9e72a88&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;</code>ContentAcquisition::checkStorageRequirements'::<code>2'::Totals&gt;</code></td> <td>sharedTotals</td></tr> <tr><td>16</td> <td>(4) <code>const int</code></td> <td>numRequested</td></tr> <tr><td>24</td> <td>(64) <code>std::function&lt;void __cdecl(bool,unsigned __int64)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="contenttracker-fetchfilesize-l7-lambda-aa9599aea01d6dd62378f60e02738f2f"><a href="#contenttracker-fetchfilesize-l7-lambda-aa9599aea01d6dd62378f60e02738f2f" class="header-anchor">#</a> <code>ContentTracker::fetchFileSize::__l7::&lt;lambda_aa9599aea01d6dd62378f60e02738f2f&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentTracker *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(unsigned __int64)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l2-lambda-23d0a1b8fd39adaa4c0cd04cd9e72a88-l5-lambda-fb76be13b8fe047662fa721a3a77c9bb-l5-lambda-5dde433396ba1836ea97aad5da28a35d"><a href="#contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l2-lambda-23d0a1b8fd39adaa4c0cd04cd9e72a88-l5-lambda-fb76be13b8fe047662fa721a3a77c9bb-l5-lambda-5dde433396ba1836ea97aad5da28a35d" class="header-anchor">#</a> <code>ContentAcquisition::checkStorageRequirements::__l2::&lt;lambda_9e238074f4708f40d39951c6bbb8c3d5&gt;::()::__l2::&lt;lambda_23d0a1b8fd39adaa4c0cd04cd9e72a88&gt;::()::__l5::&lt;lambda_fb76be13b8fe047662fa721a3a77c9bb&gt;::()::__l5::&lt;lambda_5dde433396ba1836ea97aad5da28a35d&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>dlcSize</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(bool,unsigned __int64)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l2-lambda-23d0a1b8fd39adaa4c0cd04cd9e72a88-l5-lambda-fb76be13b8fe047662fa721a3a77c9bb-l5-lambda-06fba6772e5a40319ba863ad66ed81c5"><a href="#contentacquisition-checkstoragerequirements-l2-lambda-9e238074f4708f40d39951c6bbb8c3d5-l2-lambda-23d0a1b8fd39adaa4c0cd04cd9e72a88-l5-lambda-fb76be13b8fe047662fa721a3a77c9bb-l5-lambda-06fba6772e5a40319ba863ad66ed81c5" class="header-anchor">#</a> <code>ContentAcquisition::checkStorageRequirements::__l2::&lt;lambda_9e238074f4708f40d39951c6bbb8c3d5&gt;::()::__l2::&lt;lambda_23d0a1b8fd39adaa4c0cd04cd9e72a88&gt;::()::__l5::&lt;lambda_fb76be13b8fe047662fa721a3a77c9bb&gt;::()::__l5::&lt;lambda_06fba6772e5a40319ba863ad66ed81c5&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>dlcSize</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(bool,unsigned __int64)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="contentacquisition-gettitles-l6-lambda-6b2ec6fd37d40446a41ee22bbc465839"><a href="#contentacquisition-gettitles-l6-lambda-6b2ec6fd37d40446a41ee22bbc465839" class="header-anchor">#</a> <code>ContentAcquisition::getTitles::__l6::&lt;lambda_6b2ec6fd37d40446a41ee22bbc465839&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentAcquisition *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(200) <code>const DlcId</code></td> <td>dlcId</td></tr> <tr><td>208</td> <td>(88) <code>ContentAcquisition::getTitles::__l2::&lt;lambda_c6179e0117411f607c7c2f5e595ff517&gt;</code></td> <td>onFileFound</td></tr> <tr><td>296</td> <td>(8) <code>std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;std::pair&lt;DlcId const ,ContentAcquisition::DownloadHistory&gt; &gt; &gt; &gt;</code></td> <td>pairIt</td></tr></tbody></table> <h3 id="contentacquisition-gettitles-l2-lambda-c6179e0117411f607c7c2f5e595ff517"><a href="#contentacquisition-gettitles-l2-lambda-c6179e0117411f607c7c2f5e595ff517" class="header-anchor">#</a> <code>ContentAcquisition::getTitles::__l2::&lt;lambda_c6179e0117411f607c7c2f5e595ff517&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>const int</code></td> <td>numRequested</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(std::vector&lt;std::string&gt; const &amp;)&gt;</code></td> <td>callback</td></tr> <tr><td>72</td> <td>(16) <code>std::shared_ptr&lt;std::vector&lt;std::string&gt; &gt;</code></td> <td>sharedTitles</td></tr></tbody></table> <h3 id="contenttracker-fetchtitle-l7-lambda-580c010aa240fa46c9d3dfd81e8f23e3"><a href="#contenttracker-fetchtitle-l7-lambda-580c010aa240fa46c9d3dfd81e8f23e3" class="header-anchor">#</a> <code>ContentTracker::fetchTitle::__l7::&lt;lambda_580c010aa240fa46c9d3dfd81e8f23e3&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentTracker *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(std::string const &amp;)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="contentacquisition-downloadcallback"><a href="#contentacquisition-downloadcallback" class="header-anchor">#</a> <code>ContentAcquisition::DownloadCallback</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mShouldCheckExistence</td></tr> <tr><td>8</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>mExistenceTracker</td></tr> <tr><td>24</td> <td>(64) <code>std::function&lt;void __cdecl(DownloadStateObject &amp;)&gt;</code></td> <td>mCallback</td></tr></tbody></table> <h3 id="contentacquisition-getavailablediskfreespaceasync-l2-lambda-450f8a999d305d9c737ff19408a1e820"><a href="#contentacquisition-getavailablediskfreespaceasync-l2-lambda-450f8a999d305d9c737ff19408a1e820" class="header-anchor">#</a> <code>ContentAcquisition::_getAvailableDiskFreeSpaceAsync::__l2::&lt;lambda_450f8a999d305d9c737ff19408a1e820&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(unsigned __int64)&gt;</code></td> <td>callback</td></tr> <tr><td>64</td> <td>(16) <code>std::shared_ptr&lt;unsigned __int64&gt;</code></td> <td>shared_size</td></tr></tbody></table> <h3 id="contenttracker-fetchfilesize-l7-lambda-aa9599aea01d6dd62378f60e02738f2f-l5-lambda-b649e17da3516653addd3c4881defd02"><a href="#contenttracker-fetchfilesize-l7-lambda-aa9599aea01d6dd62378f60e02738f2f-l5-lambda-b649e17da3516653addd3c4881defd02" class="header-anchor">#</a> <code>ContentTracker::fetchFileSize::__l7::&lt;lambda_aa9599aea01d6dd62378f60e02738f2f&gt;::()::__l5::&lt;lambda_b649e17da3516653addd3c4881defd02&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(unsigned __int64)&gt;</code></td> <td>callback</td></tr> <tr><td>64</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>weakExistence</td></tr></tbody></table> <h3 id="contenttracker-fetchcontentdetails-l2-lambda-852b98f00350dbcb07efe1ff2bc71eec"><a href="#contenttracker-fetchcontentdetails-l2-lambda-852b98f00350dbcb07efe1ff2bc71eec" class="header-anchor">#</a> <code>ContentTracker::_fetchContentDetails::__l2::&lt;lambda_852b98f00350dbcb07efe1ff2bc71eec&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentTracker *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(bool)&gt;</code></td> <td>callback</td></tr> <tr><td>72</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>weakExistence</td></tr></tbody></table> <h3 id="contenttracker-importlegacymusicpack-l2-lambda-e71312bd262726470a6492efa540d394"><a href="#contenttracker-importlegacymusicpack-l2-lambda-e71312bd262726470a6492efa540d394" class="header-anchor">#</a> <code>ContentTracker::_importLegacyMusicPack::__l2::&lt;lambda_e71312bd262726470a6492efa540d394&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContentTracker *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(1040) <code>const Core::PathBuffer&lt;Core::StackString&lt;char,1024&gt; &gt;</code></td> <td>musicTargetPath</td></tr> <tr><td>1048</td> <td>(16) <code>std::shared_ptr&lt;enum Core::ZipUtils::UnzipResult&gt;</code></td> <td>sharedErrorCode</td></tr></tbody></table> <h3 id="contenttracker-importlegacymusicpack-l2-lambda-4ae52eb2e663e20b64225feacde9ef21"><a href="#contenttracker-importlegacymusicpack-l2-lambda-4ae52eb2e663e20b64225feacde9ef21" class="header-anchor">#</a> <code>ContentTracker::_importLegacyMusicPack::__l2::&lt;lambda_4ae52eb2e663e20b64225feacde9ef21&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1040) <code>const Core::PathBuffer&lt;Core::StackString&lt;char,1024&gt; &gt;</code></td> <td>fileToImport</td></tr> <tr><td>1040</td> <td>(1040) <code>const Core::PathBuffer&lt;Core::StackString&lt;char,1024&gt; &gt;</code></td> <td>musicTargetPath</td></tr> <tr><td>2080</td> <td>(16) <code>std::shared_ptr&lt;enum Core::ZipUtils::UnzipResult&gt;</code></td> <td>sharedErrorCode</td></tr></tbody></table> <h3 id="contentacquisition-downloadhistory"><a href="#contentacquisition-downloadhistory" class="header-anchor">#</a> <code>ContentAcquisition::DownloadHistory</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>mDownloadSize</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>mHasDownloadSize</td></tr> <tr><td>12</td> <td>(4) <code>_BYTE[4]</code></td> <td>mStatus</td></tr> <tr><td>16</td> <td>(32) <code>std::string</code></td> <td>mTitle</td></tr> <tr><td>48</td> <td>(1) <code>bool</code></td> <td>mHasTitle</td></tr></tbody></table> <h3 id="core-callbacklisteners-int-enum-social-signinresult-listener"><a href="#core-callbacklisteners-int-enum-social-signinresult-listener" class="header-anchor">#</a> <code>Core::CallbackListeners&lt;int,enum Social::SignInResult&gt;::Listener</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;bool&gt;</code></td> <td>mExistenceTracker</td></tr> <tr><td>16</td> <td>(64) <code>std::function&lt;void __cdecl(int,enum Social::SignInResult)&gt;</code></td> <td>mCallback</td></tr> <tr><td>80</td> <td>(1) <code>bool</code></td> <td>mShouldCheckExistence</td></tr></tbody></table> <h3 id="csha1"><a href="#csha1" class="header-anchor">#</a> <code>CSHA1</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(20) <code>unsigned int[5]</code></td> <td>m_state</td></tr> <tr><td>20</td> <td>(8) <code>unsigned int[2]</code></td> <td>m_count</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int[1]</code></td> <td>m_reserved0</td></tr> <tr><td>32</td> <td>(64) <code>unsigned __int8[64]</code></td> <td>m_buffer</td></tr> <tr><td>96</td> <td>(20) <code>unsigned __int8[20]</code></td> <td>m_digest</td></tr> <tr><td>116</td> <td>(12) <code>unsigned int[3]</code></td> <td>m_reserved1</td></tr> <tr><td>128</td> <td>(64) <code>unsigned __int8[64]</code></td> <td>m_workspace</td></tr> <tr><td>192</td> <td>(8) <code>SHA1_WORKSPACE_BLOCK *</code></td> <td>m_block</td></tr></tbody></table> <h3 id="cloudsavesystemwrapper-issettingsoutofdate-l13-lambda-c97df555e43ec3a5e05f628f8af02513"><a href="#cloudsavesystemwrapper-issettingsoutofdate-l13-lambda-c97df555e43ec3a5e05f628f8af02513" class="header-anchor">#</a> <code>CloudSaveSystemWrapper::isSettingsOutOfDate::__l13::&lt;lambda_c97df555e43ec3a5e05f628f8af02513&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(Core::Result,bool)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="cloudsavesystemwrapper-acquiresettingsasync-l13-lambda-7bb126be8a3e79d11e6699d2a94b7bda"><a href="#cloudsavesystemwrapper-acquiresettingsasync-l13-lambda-7bb126be8a3e79d11e6699d2a94b7bda" class="header-anchor">#</a> <code>CloudSaveSystemWrapper::acquireSettingsAsync::__l13::&lt;lambda_7bb126be8a3e79d11e6699d2a94b7bda&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;Social::User&gt;</code></td> <td>weakUser</td></tr> <tr><td>16</td> <td>(64) <code>std::function&lt;void __cdecl(Core::Result)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="cdscopedevent"><a href="#cdscopedevent" class="header-anchor">#</a> <code>CDScopedEvent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>_BYTE[2]</code></td> <td>mTag</td></tr> <tr><td>2</td> <td>(2) <code>_BYTE[2]</code></td> <td>mTagEnd</td></tr></tbody></table> <h3 id="concurrency-details-makevoidtounitfunc-l2-lambda-052e919cc0e5399df76dff3972c0cac1"><a href="#concurrency-details-makevoidtounitfunc-l2-lambda-052e919cc0e5399df76dff3972c0cac1" class="header-anchor">#</a> <code>Concurrency::details::_MakeVoidToUnitFunc::__l2::&lt;lambda_052e919cc0e5399df76dff3972c0cac1&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>const std::function&lt;void __cdecl(void)&gt;</code></td> <td>_Func</td></tr></tbody></table> <h3 id="concurrency-details-defaultppltaskscheduler"><a href="#concurrency-details-defaultppltaskscheduler" class="header-anchor">#</a> <code>Concurrency::details::_DefaultPPLTaskScheduler</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Concurrency::scheduler_interface</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="concurrency-scheduler-interface"><a href="#concurrency-scheduler-interface" class="header-anchor">#</a> <code>Concurrency::scheduler_interface</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Concurrency::scheduler_interface_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="concurrency-details-task-impl-base-schedulecontinuationtask-l5-lambda-713ee8bbd6b08550d59c52695cab5ce3-l8-lambda-f25c37099038263181b5186a3fa41b37"><a href="#concurrency-details-task-impl-base-schedulecontinuationtask-l5-lambda-713ee8bbd6b08550d59c52695cab5ce3-l8-lambda-f25c37099038263181b5186a3fa41b37" class="header-anchor">#</a> <code>Concurrency::details::_Task_impl_base::_ScheduleContinuationTask::__l5::&lt;lambda_713ee8bbd6b08550d59c52695cab5ce3&gt;::()::__l8::&lt;lambda_f25c37099038263181b5186a3fa41b37&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Concurrency::details::_ContinuationTaskHandleBase *</code></td> <td>_PTaskHandle</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;Concurrency::details::_Task_impl_base&gt;</code></td> <td>_TaskImplPtr</td></tr></tbody></table> <h3 id="concurrency-invalid-operation"><a href="#concurrency-invalid-operation" class="header-anchor">#</a> <code>Concurrency::invalid_operation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::exception</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="cg-details-worktoken-aslifetime-l2-lambda-89b2dae39f23600ad3e66c7a2b82fa2b"><a href="#cg-details-worktoken-aslifetime-l2-lambda-89b2dae39f23600ad3e66c7a2b82fa2b" class="header-anchor">#</a> <code>cg::details::WorkToken::asLifetime::__l2::&lt;lambda_89b2dae39f23600ad3e66c7a2b82fa2b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;cg::details::WorkToken&gt;</code></td> <td>ptrHandle</td></tr> <tr><td>16</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>finalizeCallback</td></tr></tbody></table> <h3 id="commandlistqueue-generateasync-l5-lambda-7ffb9bb526d84acb0ee651a3ebd1913c"><a href="#commandlistqueue-generateasync-l5-lambda-7ffb9bb526d84acb0ee651a3ebd1913c" class="header-anchor">#</a> <code>CommandListQueue::generateAsync::__l5::&lt;lambda_7ffb9bb526d84acb0ee651a3ebd1913c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CommandListQueue *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(64) <code>std::function&lt;void __cdecl(CommandListTaskContext &amp;)&gt;</code></td> <td>func</td></tr></tbody></table> <h3 id="cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-execute-l2-lambda-2cf6a093770e7d9b1aecca19f5efb284"><a href="#cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-execute-l2-lambda-2cf6a093770e7d9b1aecca19f5efb284" class="header-anchor">#</a> <code>cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;::execute::__l2::&lt;lambda_2cf6a093770e7d9b1aecca19f5efb284&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;gsl::final_action&lt;std::function&lt;void __cdecl(void)&gt; &gt; &gt;</code></td> <td>token</td></tr> <tr><td>16</td> <td>(64) <code>const std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-ctor-l2-lambda-6874d52efc76d8cff42ccf8c811d2193"><a href="#cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-ctor-l2-lambda-6874d52efc76d8cff42ccf8c811d2193" class="header-anchor">#</a> <code>cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;::{ctor}::__l2::&lt;lambda_6874d52efc76d8cff42ccf8c811d2193&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt; *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-dragon-frameobject-prepareddraw-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-dragon-frameobject-prepareddraw-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::frameobject::PreparedDraw,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-dragon-materials-materialuniformoverrides-uniformpair-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-dragon-materials-materialuniformoverrides-uniformpair-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::materials::MaterialUniformOverrides::UniformPair,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-blittaskcontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-blittaskcontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::BlitTaskContext,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(224) <code>cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::BlitTaskContext&gt;</code></td> <td>baseclass_0</td></tr> <tr><td>224</td> <td>(24) <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>mDependencies</td></tr></tbody></table> <h3 id="cg-taskorder-taskbuilderwithaction-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-blittaskcontext"><a href="#cg-taskorder-taskbuilderwithaction-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-dragon-rendering-modules-blittaskcontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,dragon::rendering::modules::BlitTaskContext&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>cg::taskorder::TaskBuilder&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>baseclass_0</td></tr> <tr><td>32</td> <td>(128) <code>dragon::rendering::modules::BlitTaskContext</code></td> <td>mContext</td></tr> <tr><td>160</td> <td>(64) <code>std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;,dragon::rendering::modules::BlitTaskContext const &amp;)&gt;</code></td> <td>mAction</td></tr></tbody></table> <h3 id="cg-taskorder-taskbuilder-dragon-framegraph-executioncontext-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilder-dragon-framegraph-executioncontext-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilder&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr></tbody></table> <h3 id="cg-math-rect-unsigned-short"><a href="#cg-math-rect-unsigned-short" class="header-anchor">#</a> <code>cg::math::Rect&lt;unsigned short&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>mX</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>mY</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>mWidth</td></tr> <tr><td>6</td> <td>(2) <code>unsigned __int16</code></td> <td>mHeight</td></tr></tbody></table> <h3 id="cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::tuple&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>mDependencies</td></tr></tbody></table> <h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(96) <code>cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;</code></td> <td>baseclass_0</td></tr> <tr><td>96</td> <td>(56) <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>mDependencies</td></tr></tbody></table> <h3 id="cg-taskorder-taskbuilderwithaction-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void"><a href="#cg-taskorder-taskbuilderwithaction-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>cg::taskorder::TaskBuilder&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>baseclass_0</td></tr> <tr><td>32</td> <td>(64) <code>std::function&lt;void __cdecl(dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt; const &amp;)&gt;</code></td> <td>mAction</td></tr></tbody></table> <h3 id="cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(56) <code>std::tuple&lt;dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>mDependencies</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-std-pair-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-const-dragon-framegraph-detail-linkingcontext-dragon-rendering-rendercontext-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-std-pair-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-const-dragon-framegraph-detail-linkingcontext-dragon-rendering-rendercontext-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;std::pair&lt;dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt; const *,dragon::framegraph::detail::LinkingContext&lt;dragon::rendering::RenderContext&gt; *&gt;,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-glm-tvec4-float-0-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-glm-tvec4-float-0-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;glm::tvec4&lt;float,0&gt;,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-glm-tmat3x3-float-0-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-glm-tmat3x3-float-0-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;glm::tmat3x3&lt;float,0&gt;,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-glm-tmat4x4-float-0-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-glm-tmat4x4-float-0-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;glm::tmat4x4&lt;float,0&gt;,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(96) <code>cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;</code></td> <td>baseclass_0</td></tr> <tr><td>96</td> <td>(72) <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>mDependencies</td></tr></tbody></table> <h3 id="cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-dependencybuilder-dragon-framegraph-dependency-bindframebufferdepth-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindmaterialtexture-dragon-rendering-rendercontext-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(72) <code>std::tuple&lt;dragon::framegraph::dependency::BindFramebufferDepth&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindMaterialTexture&lt;dragon::rendering::RenderContext&gt;,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>mDependencies</td></tr></tbody></table> <h3 id="cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext"><a href="#cg-taskorder-taskbuilderwithactionanddependencies-dragon-framegraph-executioncontext-dragon-rendering-rendercontext-void-dragon-framegraph-dependency-bindframebuffercolor-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::taskorder::TaskBuilderWithActionAndDependencies&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void,dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(96) <code>cg::taskorder::TaskBuilderWithAction&lt;dragon::framegraph::ExecutionContext&lt;dragon::rendering::RenderContext&gt;,void&gt;</code></td> <td>baseclass_0</td></tr> <tr><td>96</td> <td>(24) <code>cg::taskorder::DependencyBuilder&lt;dragon::framegraph::dependency::BindFramebufferColor&lt;dragon::rendering::RenderContext&gt; &gt;</code></td> <td>mDependencies</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-dragon-frameobject-scenelightinginformation-pointlight-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-dragon-frameobject-scenelightinginformation-pointlight-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::frameobject::SceneLightingInformation::PointLight,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="cg-texturemetadata"><a href="#cg-texturemetadata" class="header-anchor">#</a> <code>cg::TextureMetaData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>cg::TextureMetaData::FilterMode</code></td> <td>mFilterMin</td></tr> <tr><td>4</td> <td>(4) <code>cg::TextureMetaData::FilterMode</code></td> <td>mFilterMag</td></tr> <tr><td>8</td> <td>(4) <code>cg::TextureMetaData::FilterMode</code></td> <td>mFilterMip</td></tr> <tr><td>12</td> <td>(4) <code>cg::TextureMetaData::ColorSpace</code></td> <td>mColorSpace</td></tr> <tr><td>16</td> <td>(4) <code>cg::TextureMetaData::Dimension</code></td> <td>mDimension</td></tr> <tr><td>20</td> <td>(4) <code>cg::TextureMetaData::WrapMode</code></td> <td>mWrapU</td></tr> <tr><td>24</td> <td>(4) <code>cg::TextureMetaData::WrapMode</code></td> <td>mWrapV</td></tr> <tr><td>28</td> <td>(4) <code>int</code></td> <td>mNumSlices</td></tr></tbody></table> <h3 id="chunkrenderobjectcollection-addtochunkqueue-l2-lambda-4669a033a94b2cbc882de43740c3bcf3"><a href="#chunkrenderobjectcollection-addtochunkqueue-l2-lambda-4669a033a94b2cbc882de43740c3bcf3" class="header-anchor">#</a> <code>ChunkRenderObjectCollection::addToChunkQueue::__l2::&lt;lambda_4669a033a94b2cbc882de43740c3bcf3&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="chunkrenderdata"><a href="#chunkrenderdata" class="header-anchor">#</a> <code>ChunkRenderData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>glm::tvec3&lt;int,0&gt;</code></td> <td>mPosition</td></tr> <tr><td>16</td> <td>(8) <code>long double</code></td> <td>mReadyTimeDiff</td></tr> <tr><td>24</td> <td>(24) <code>const std::variant&lt;std::monostate,std::shared_ptr&lt;mce::IndexBufferContainer&gt;,std::shared_ptr&lt;RenderChunkDirectIndexData&gt; &gt;</code></td> <td>mChunkIndices</td></tr> <tr><td>48</td> <td>(24) <code>const std::variant&lt;std::monostate,std::shared_ptr&lt;mce::Mesh&gt;,std::shared_ptr&lt;RenderChunkDirectVertexData&gt; &gt;</code></td> <td>mChunkMesh</td></tr> <tr><td>72</td> <td>(16) <code>gsl::span&lt;mce::PointLight const ,-1&gt;</code></td> <td>mPointLights</td></tr></tbody></table> <h3 id="camerashakeevent"><a href="#camerashakeevent" class="header-anchor">#</a> <code>CameraShakeEvent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mIntensity</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mDuration</td></tr></tbody></table> <h3 id="camerashakesystem-tick-l2-lambda-ff1179873d2d698a099b81d15231fa79"><a href="#camerashakesystem-tick-l2-lambda-ff1179873d2d698a099b81d15231fa79" class="header-anchor">#</a> <code>CameraShakeSystem::tick::__l2::&lt;lambda_ff1179873d2d698a099b81d15231fa79&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CameraShakeSystem *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="commandparameterdata"><a href="#commandparameterdata" class="header-anchor">#</a> <code>CommandParameterData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>typeid_t&lt;CommandRegistry&gt;</code></td> <td>mTypeIndex</td></tr> <tr><td>8</td> <td>(8) <code>bool (__fastcall *)(CommandRegistry *this, void *, const CommandRegistry::ParseToken *, const CommandOrigin *, int, std::string *, std::vector&lt;std::string&gt; *)</code></td> <td>mParse</td></tr> <tr><td>16</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>48</td> <td>(8) <code>const char *</code></td> <td>mEnumNameOrPostfix</td></tr> <tr><td>56</td> <td>(4) <code>int</code></td> <td>mEnumOrPostfixSymbol</td></tr> <tr><td>60</td> <td>(4) <code>CommandParameterDataType</code></td> <td>mParamType</td></tr> <tr><td>64</td> <td>(4) <code>int</code></td> <td>mOffset</td></tr> <tr><td>68</td> <td>(4) <code>int</code></td> <td>mSetOffset</td></tr> <tr><td>72</td> <td>(1) <code>bool</code></td> <td>mIsOptional</td></tr> <tr><td>73</td> <td>(1) <code>CommandParameterOption</code></td> <td>mOptions</td></tr></tbody></table> <h3 id="commandselectorresults-player"><a href="#commandselectorresults-player" class="header-anchor">#</a> <code>CommandSelectorResults&lt;Player&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;std::vector&lt;Actor *&gt; &gt;</code></td> <td>mTargets</td></tr></tbody></table> <h3 id="commandoutputparameter"><a href="#commandoutputparameter" class="header-anchor">#</a> <code>CommandOutputParameter</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mString</td></tr> <tr><td>32</td> <td>(4) <code>int</code></td> <td>mCount</td></tr></tbody></table> <h3 id="chunkloadedrequest"><a href="#chunkloadedrequest" class="header-anchor">#</a> <code>ChunkLoadedRequest</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>AreaType</code></td> <td>mAreaType</td></tr> <tr><td>4</td> <td>(48) <code>Bounds</code></td> <td>mBounds</td></tr> <tr><td>56</td> <td>(32) <code>std::string</code></td> <td>mTickingAreaName</td></tr> <tr><td>88</td> <td>(32) <code>std::string</code></td> <td>mSerializationId</td></tr> <tr><td>120</td> <td>(8) <code>std::unique_ptr&lt;IChunkLoadedAction&gt;</code></td> <td>mChunkLoadedAction</td></tr></tbody></table> <h3 id="commandareafactory"><a href="#commandareafactory" class="header-anchor">#</a> <code>CommandAreaFactory</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Dimension *</code></td> <td>mDimension</td></tr></tbody></table> <h3 id="cg-texturesetlayerdefinition"><a href="#cg-texturesetlayerdefinition" class="header-anchor">#</a> <code>cg::TextureSetLayerDefinition</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>Bedrock::EnableNonOwnerReferences</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(208) <code>std::variant&lt;ResourceLocationPair,ColorChannel,mce::Color&gt;</code></td> <td>mData</td></tr> <tr><td>224</td> <td>(4) <code>cg::TextureSetLayerType</code></td> <td>mLayerType</td></tr></tbody></table> <h3 id="componentitem-validateserverschemaandinititem-l2-lambda-8fbf7210d948bc9a2c7c196ed13498ff"><a href="#componentitem-validateserverschemaandinititem-l2-lambda-8fbf7210d948bc9a2c7c196ed13498ff" class="header-anchor">#</a> <code>ComponentItem::_validateServerSchemaAndInitItem::__l2::&lt;lambda_8fbf7210d948bc9a2c7c196ed13498ff&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ComponentItem *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(112) <code>SemVersion</code></td> <td>version</td></tr></tbody></table> <h3 id="componentitem-validateclientschemaandinititem-l2-lambda-e04caa0b9c3fce21a3adffae430565da"><a href="#componentitem-validateclientschemaandinititem-l2-lambda-e04caa0b9c3fce21a3adffae430565da" class="header-anchor">#</a> <code>ComponentItem::_validateClientSchemaAndInitItem::__l2::&lt;lambda_e04caa0b9c3fce21a3adffae430565da&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ComponentItem *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(112) <code>SemVersion</code></td> <td>version</td></tr></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-4b0d6bde792ed619e67322018f9b43c7"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-4b0d6bde792ed619e67322018f9b43c7" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_4b0d6bde792ed619e67322018f9b43c7&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-646300c760a21a5dee87bd50ffc76f84"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-646300c760a21a5dee87bd50ffc76f84" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_646300c760a21a5dee87bd50ffc76f84&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-bde458400d5e0c936f319b6fbc51f7ea"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-bde458400d5e0c936f319b6fbc51f7ea" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_bde458400d5e0c936f319b6fbc51f7ea&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-08a8fb2c819f7557ca2eb39a18b10555"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-08a8fb2c819f7557ca2eb39a18b10555" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_08a8fb2c819f7557ca2eb39a18b10555&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-7ac0608cb5cbb757eac814257996d998"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-7ac0608cb5cbb757eac814257996d998" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_7ac0608cb5cbb757eac814257996d998&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-27740b06e312776918dffed8bff42b16"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-27740b06e312776918dffed8bff42b16" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_27740b06e312776918dffed8bff42b16&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-6bba8aa0feff95e899fc6a8a254ef7bc"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-6bba8aa0feff95e899fc6a8a254ef7bc" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_6bba8aa0feff95e899fc6a8a254ef7bc&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-700e819f7949a3cf2c4a087a7587af4f"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-700e819f7949a3cf2c4a087a7587af4f" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_700e819f7949a3cf2c4a087a7587af4f&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-cb4ad2fefaa769f49c3ee0dd42da1168"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-cb4ad2fefaa769f49c3ee0dd42da1168" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_cb4ad2fefaa769f49c3ee0dd42da1168&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-5d561c02c26be577f9c5dd22c1d3cc29"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-5d561c02c26be577f9c5dd22c1d3cc29" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_5d561c02c26be577f9c5dd22c1d3cc29&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-d887d12a5e8c683324eafb3aff797194"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-d887d12a5e8c683324eafb3aff797194" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_d887d12a5e8c683324eafb3aff797194&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-2ae06341078d5910279305cbe94f0403"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-2ae06341078d5910279305cbe94f0403" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_2ae06341078d5910279305cbe94f0403&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-d430a32fa966086497fdee2689d5f072"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-d430a32fa966086497fdee2689d5f072" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_d430a32fa966086497fdee2689d5f072&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-2e61ce2ecee42b8c801d2a0fce372345"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-2e61ce2ecee42b8c801d2a0fce372345" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_2e61ce2ecee42b8c801d2a0fce372345&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-f11da43554209a966dd612f49a500c13"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-f11da43554209a966dd612f49a500c13" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_f11da43554209a966dd612f49a500c13&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-d138d2cc7881ec912693e17053aa36d3"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-d138d2cc7881ec912693e17053aa36d3" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_d138d2cc7881ec912693e17053aa36d3&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-08c154647375c28c098b616470505c81"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-08c154647375c28c098b616470505c81" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_08c154647375c28c098b616470505c81&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-8d2b9f4c977ef7bcf18b00933e8d133c"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-8d2b9f4c977ef7bcf18b00933e8d133c" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_8d2b9f4c977ef7bcf18b00933e8d133c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-720d686375472b328e72c11b0a4529c9"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-720d686375472b328e72c11b0a4529c9" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_720d686375472b328e72c11b0a4529c9&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-f00f608ba659db531edffcb30f33581b"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-f00f608ba659db531edffcb30f33581b" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_f00f608ba659db531edffcb30f33581b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cerealitemcomponentfactory-registercomponent-l2-lambda-4f2170e72cbb54e6a6a019874716cd58"><a href="#cerealitemcomponentfactory-registercomponent-l2-lambda-4f2170e72cbb54e6a6a019874716cd58" class="header-anchor">#</a> <code>CerealItemComponentFactory::registerComponent::__l2::&lt;lambda_4f2170e72cbb54e6a6a019874716cd58&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="cappedsurfaceattributes"><a href="#cappedsurfaceattributes" class="header-anchor">#</a> <code>CappedSurfaceAttributes</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;CappedSurfaceAttributes::MaterialLayer&gt;</code></td> <td>mFloorMaterials</td></tr> <tr><td>24</td> <td>(24) <code>std::vector&lt;CappedSurfaceAttributes::MaterialLayer&gt;</code></td> <td>mCeilingMaterials</td></tr> <tr><td>48</td> <td>(8) <code>const Block *</code></td> <td>mSeaMaterial</td></tr> <tr><td>56</td> <td>(8) <code>const Block *</code></td> <td>mFoundationMaterial</td></tr> <tr><td>64</td> <td>(8) <code>const Block *</code></td> <td>mBeachMaterial</td></tr> <tr><td>72</td> <td>(1) <code>bool</code></td> <td>mIsInitialized</td></tr></tbody></table> <h3 id="commandregistry-parser"><a href="#commandregistry-parser" class="header-anchor">#</a> <code>CommandRegistry::Parser</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const CommandRegistry *</code></td> <td>mRegistry</td></tr> <tr><td>8</td> <td>(8) <code>const CommandRegistry::ParseTable *</code></td> <td>mParseTable</td></tr> <tr><td>16</td> <td>(40) <code>std::deque&lt;std::pair&lt;CommandRegistry::Symbol,CommandRegistry::ParseToken *&gt;&gt;</code></td> <td>mStack</td></tr> <tr><td>56</td> <td>(32) <code>CommandRegistry::LexicalToken</code></td> <td>mNext</td></tr> <tr><td>88</td> <td>(32) <code>std::string</code></td> <td>mInput</td></tr> <tr><td>120</td> <td>(8) <code>std::unique_ptr&lt;CommandRegistry::ParseToken&gt;</code></td> <td>mRoot</td></tr> <tr><td>128</td> <td>(32) <code>std::string</code></td> <td>mError</td></tr> <tr><td>160</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mErrorParams</td></tr> <tr><td>184</td> <td>(4) <code>int</code></td> <td>mVersion</td></tr> <tr><td>188</td> <td>(1) <code>bool</code></td> <td>mGenerateParams</td></tr> <tr><td>189</td> <td>(1) <code>bool</code></td> <td>mBreakAtEnd</td></tr></tbody></table> <h3 id="commandregistry-lexicaltoken"><a href="#commandregistry-lexicaltoken" class="header-anchor">#</a> <code>CommandRegistry::LexicalToken</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>mText</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>mLength</td></tr> <tr><td>12</td> <td>(4) <code>CommandRegistry::Symbol</code></td> <td>mType</td></tr> <tr><td>16</td> <td>(4) <code>CommandRegistry::Symbol</code></td> <td>mIdentifierInfo</td></tr> <tr><td>24</td> <td>(8) <code>const CommandRegistry *</code></td> <td>mRegistry</td></tr></tbody></table> <h3 id="contextaccessor"><a href="#contextaccessor" class="header-anchor">#</a> <code>ContextAccessor</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>mTypeId</td></tr> <tr><td>8</td> <td>(8) <code>std::unique_ptr&lt;ContextAccessor::TypeBase&gt;</code></td> <td>mContext</td></tr></tbody></table> <h3 id="compoundtagvariant"><a href="#compoundtagvariant" class="header-anchor">#</a> <code>CompoundTagVariant</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(48) <code>std::variant&lt;EndTag,ByteTag,ShortTag,IntTag,Int64Tag,FloatTag,DoubleTag,ByteArrayTag,StringTag,ListTag,CompoundTag,IntArrayTag&gt;</code></td> <td>mTagStorage</td></tr></tbody></table> <h3 id="compoundtagvariant-copy-l2-lambda-847acbaa2673dfafb4b947487bdf32fd"><a href="#compoundtagvariant-copy-l2-lambda-847acbaa2673dfafb4b947487bdf32fd" class="header-anchor">#</a> <code>CompoundTagVariant::copy::__l2::&lt;lambda_847acbaa2673dfafb4b947487bdf32fd&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="classroommodenetworkhandler-onwebsocketrequest-l13-lambda-f8f06f33a691ac69d078ed77b77cf8f8"><a href="#classroommodenetworkhandler-onwebsocketrequest-l13-lambda-f8f06f33a691ac69d078ed77b77cf8f8" class="header-anchor">#</a> <code>ClassroomModeNetworkHandler::onWebsocketRequest::__l13::&lt;lambda_f8f06f33a691ac69d078ed77b77cf8f8&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ClassroomModeNetworkHandler *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(32) <code>const std::string</code></td> <td>serverAddress</td></tr> <tr><td>40</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>errorCallback</td></tr></tbody></table> <h3 id="classroommodenetworkhandler-connect-l2-lambda-4c552053559105a51c96d1cc72ebc426"><a href="#classroommodenetworkhandler-connect-l2-lambda-4c552053559105a51c96d1cc72ebc426" class="header-anchor">#</a> <code>ClassroomModeNetworkHandler::_connect::__l2::&lt;lambda_4c552053559105a51c96d1cc72ebc426&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ClassroomModeNetworkHandler *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(32) <code>const std::string</code></td> <td>address</td></tr></tbody></table> <h3 id="commandorigindata"><a href="#commandorigindata" class="header-anchor">#</a> <code>CommandOriginData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>CommandOriginType</code></td> <td>mType</td></tr> <tr><td>8</td> <td>(16) <code>mce::UUID</code></td> <td>mUUID</td></tr> <tr><td>24</td> <td>(32) <code>std::string</code></td> <td>mRequestId</td></tr> <tr><td>56</td> <td>(8) <code>__int64</code></td> <td>mPlayerId</td></tr></tbody></table> <h3 id="commandoutputmessage"><a href="#commandoutputmessage" class="header-anchor">#</a> <code>CommandOutputMessage</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>CommandOutputMessageType</code></td> <td>mType</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>mMessageId</td></tr> <tr><td>40</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mParams</td></tr></tbody></table> <h3 id="craftingdataentry"><a href="#craftingdataentry" class="header-anchor">#</a> <code>CraftingDataEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;Recipe&gt;</code></td> <td>mRecipe</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mItemData</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>mItemAux</td></tr> <tr><td>16</td> <td>(48) <code>HashedString</code></td> <td>mTag</td></tr> <tr><td>64</td> <td>(240) <code>ItemInstance</code></td> <td>mItemResult</td></tr> <tr><td>304</td> <td>(4) <code>CraftingDataEntryType</code></td> <td>mEntryType</td></tr></tbody></table> <h3 id="creativeitementry"><a href="#creativeitementry" class="header-anchor">#</a> <code>CreativeItemEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>Bedrock::EnableNonOwnerReferences</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(8) <code>CreativeItemRegistry *</code></td> <td>mRegistry</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>mGroupIndex</td></tr> <tr><td>28</td> <td>(4) <code>TypedServerNetId&lt;CreativeItemNetIdTag,unsigned int,0&gt;</code></td> <td>mCreativeNetId</td></tr> <tr><td>32</td> <td>(240) <code>ItemInstance</code></td> <td>mItemInstance</td></tr> <tr><td>272</td> <td>(4) <code>unsigned int</code></td> <td>mIndex</td></tr></tbody></table> <h3 id="connectiondefinition"><a href="#connectiondefinition" class="header-anchor">#</a> <code>ConnectionDefinition</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>ipv4Port</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>ipv6Port</td></tr> <tr><td>4</td> <td>(4) <code>ConnectionDefinition::PortBusyFallbackPolicy</code></td> <td>fallback</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>maxNumPlayers</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>maxNumConnections</td></tr></tbody></table> <h3 id="connector-natpunchinfo"><a href="#connector-natpunchinfo" class="header-anchor">#</a> <code>Connector::NatPunchInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>isValid</td></tr> <tr><td>1</td> <td>(1) <code>bool</code></td> <td>addressIsDirty</td></tr> <tr><td>2</td> <td>(1) <code>bool</code></td> <td>succeeded</td></tr> <tr><td>8</td> <td>(136) <code>RakNet::SystemAddress</code></td> <td>externalAddress</td></tr> <tr><td>144</td> <td>(4) <code>unsigned int</code></td> <td>startPingSentTime</td></tr> <tr><td>148</td> <td>(4) <code>unsigned int</code></td> <td>pingSentTime</td></tr> <tr><td>152</td> <td>(4) <code>unsigned int</code></td> <td>startPongReceivedTime</td></tr> <tr><td>156</td> <td>(4) <code>unsigned int</code></td> <td>pongReceivedTime</td></tr></tbody></table> <h3 id="commandblockupdatepacket"><a href="#commandblockupdatepacket" class="header-anchor">#</a> <code>CommandBlockUpdatePacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(12) <code>NetworkBlockPosition</code></td> <td>mBlockPos</td></tr> <tr><td>52</td> <td>(2) <code>_BYTE[2]</code></td> <td>mMode</td></tr> <tr><td>54</td> <td>(1) <code>bool</code></td> <td>mRedstoneMode</td></tr> <tr><td>55</td> <td>(1) <code>bool</code></td> <td>mIsConditional</td></tr> <tr><td>56</td> <td>(8) <code>ActorRuntimeID</code></td> <td>mEntityId</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mCommand</td></tr> <tr><td>96</td> <td>(32) <code>std::string</code></td> <td>mLastOutput</td></tr> <tr><td>128</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>160</td> <td>(4) <code>int</code></td> <td>mTickDelay</td></tr> <tr><td>164</td> <td>(1) <code>bool</code></td> <td>mTrackOutput</td></tr> <tr><td>165</td> <td>(1) <code>bool</code></td> <td>mExecuteOnFirstTick</td></tr> <tr><td>166</td> <td>(1) <code>bool</code></td> <td>mIsBlock</td></tr></tbody></table> <h3 id="clientboundmapitemdatapacket"><a href="#clientboundmapitemdatapacket" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(24) <code>std::vector&lt;ActorUniqueID&gt;</code></td> <td>mMapIds</td></tr> <tr><td>64</td> <td>(1) <code>char</code></td> <td>mScale</td></tr> <tr><td>72</td> <td>(24) <code>std::vector&lt;std::shared_ptr&lt;MapDecoration&gt;&gt;</code></td> <td>mDecorations</td></tr> <tr><td>96</td> <td>(24) <code>std::vector&lt;MapItemTrackedActor::UniqueId&gt;</code></td> <td>mUniqueIds</td></tr> <tr><td>120</td> <td>(4) <code>int</code></td> <td>mStartX</td></tr> <tr><td>124</td> <td>(4) <code>int</code></td> <td>mStartY</td></tr> <tr><td>128</td> <td>(1) <code>unsigned __int8</code></td> <td>mDimension</td></tr> <tr><td>132</td> <td>(4) <code>int</code></td> <td>mWidth</td></tr> <tr><td>136</td> <td>(4) <code>int</code></td> <td>mHeight</td></tr> <tr><td>140</td> <td>(4) <code>ClientboundMapItemDataPacket::Type</code></td> <td>mType</td></tr> <tr><td>144</td> <td>(24) <code>std::vector&lt;unsigned int&gt;</code></td> <td>mMapPixels</td></tr> <tr><td>168</td> <td>(1) <code>bool</code></td> <td>mLocked</td></tr></tbody></table> <h3 id="conditionalbandwidthoptimization"><a href="#conditionalbandwidthoptimization" class="header-anchor">#</a> <code>ConditionalBandwidthOptimization</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mMaxOptimizedDistance</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>mMaxDroppedTicks</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>mUseMotionPredictionHints</td></tr> <tr><td>24</td> <td>(64) <code>ActorFilterGroup</code></td> <td>mConditions</td></tr></tbody></table> <h3 id="conditionalbandwidthoptimizationcomponent"><a href="#conditionalbandwidthoptimizationcomponent" class="header-anchor">#</a> <code>ConditionalBandwidthOptimizationComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(88) <code>ConditionalBandwidthOptimization</code></td> <td>mDefaultValues</td></tr> <tr><td>88</td> <td>(24) <code>std::vector&lt;ConditionalBandwidthOptimization&gt;</code></td> <td>mConditionalValues</td></tr> <tr><td>112</td> <td>(8) <code>Tick</code></td> <td>mLastRequestedValuesTick</td></tr> <tr><td>120</td> <td>(88) <code>ConditionalBandwidthOptimization</code></td> <td>mCachedOptimizationValues</td></tr></tbody></table> <h3 id="contenttiermanager-validatorregistry-validatorregistryvalidators"><a href="#contenttiermanager-validatorregistry-validatorregistryvalidators" class="header-anchor">#</a> <code>ContentTierManager::ValidatorRegistry::ValidatorRegistryValidators</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;ContentTierIncompatibleReason __cdecl(PackInstance const &amp;,ContentTierInfo const &amp;)&gt;</code></td> <td>mFuncPackValidator</td></tr> <tr><td>64</td> <td>(64) <code>std::function&lt;ContentTierIncompatibleReason __cdecl(SubpackInfo const &amp;,ContentTierInfo const &amp;)&gt;</code></td> <td>mFuncSubpackValidator</td></tr></tbody></table> <h3 id="crypto-symmetric-symmetric"><a href="#crypto-symmetric-symmetric" class="header-anchor">#</a> <code>Crypto::Symmetric::Symmetric</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Crypto::Symmetric::ISystemInterface</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>std::unique_ptr&lt;Crypto::Symmetric::ISystemInterface&gt;</code></td> <td>mInterface</td></tr></tbody></table> <h3 id="crypto-symmetric-isysteminterface"><a href="#crypto-symmetric-isysteminterface" class="header-anchor">#</a> <code>Crypto::Symmetric::ISystemInterface</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Crypto::Symmetric::ISystemInterface_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="core-excludedpath"><a href="#core-excludedpath" class="header-anchor">#</a> <code>Core::ExcludedPath</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mPath</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>mCopyLooseFile</td></tr></tbody></table> <h3 id="core-ziputils-zipsettings"><a href="#core-ziputils-zipsettings" class="header-anchor">#</a> <code>Core::ZipUtils::ZipSettings</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(48) <code>Core::ZipUtils::ZipFileRestrictions</code></td> <td>mRestrictions</td></tr> <tr><td>48</td> <td>(1) <code>bool</code></td> <td>mZipDirectoryContents</td></tr> <tr><td>49</td> <td>(1) <code>bool</code></td> <td>mSkipInaccessibleFiles</td></tr> <tr><td>52</td> <td>(4) <code>int</code></td> <td>mCompressionLevel</td></tr> <tr><td>56</td> <td>(8) <code>IFileAccess *</code></td> <td>mFileAccess</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mPassword</td></tr> <tr><td>96</td> <td>(4) <code>int</code></td> <td>mZip64</td></tr></tbody></table> <h3 id="core-filesystem-copyfile-l2-lambda-98acb2cebb3139e7dcaf8bae69363f0a"><a href="#core-filesystem-copyfile-l2-lambda-98acb2cebb3139e7dcaf8bae69363f0a" class="header-anchor">#</a> <code>Core::FileSystem::copyFile::__l2::&lt;lambda_98acb2cebb3139e7dcaf8bae69363f0a&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="core-unzipfile"><a href="#core-unzipfile" class="header-anchor">#</a> <code>Core::UnzipFile</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::unique_ptr&lt;ZlibFileAccessWrapper&gt;</code></td> <td>mZipFileSystemWrapper</td></tr> <tr><td>8</td> <td>(8) <code>std::unique_ptr&lt;Core::UnzipInternals&gt;</code></td> <td>mZipFile</td></tr></tbody></table> <h3 id="clientblobcache-server-blob"><a href="#clientblobcache-server-blob" class="header-anchor">#</a> <code>ClientBlobCache::Server::Blob</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const unsigned __int64</code></td> <td>id</td></tr> <tr><td>8</td> <td>(32) <code>const std::string</code></td> <td>data</td></tr></tbody></table> <h3 id="commandintegerrange"><a href="#commandintegerrange" class="header-anchor">#</a> <code>CommandIntegerRange</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mMinValue</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mMaxValue</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>mInvert</td></tr></tbody></table> <h3 id="commandregistry-parseselector-l243-lambda-c6bfa6ab44c8dc5137236fba12271e1d"><a href="#commandregistry-parseselector-l243-lambda-c6bfa6ab44c8dc5137236fba12271e1d" class="header-anchor">#</a> <code>CommandRegistry::parseSelector::__l243::&lt;lambda_c6bfa6ab44c8dc5137236fba12271e1d&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::pair&lt;float,float&gt;</code></td> <td>xRotation</td></tr></tbody></table> <h3 id="commandregistry-signature"><a href="#commandregistry-signature" class="header-anchor">#</a> <code>CommandRegistry::Signature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>name</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>description</td></tr> <tr><td>64</td> <td>(24) <code>std::vector&lt;CommandRegistry::Overload&gt;</code></td> <td>overloads</td></tr> <tr><td>88</td> <td>(1) <code>_BYTE[1]</code></td> <td>permissionLevel</td></tr> <tr><td>92</td> <td>(4) <code>CommandRegistry::Symbol</code></td> <td>commandSymbol</td></tr> <tr><td>96</td> <td>(4) <code>CommandRegistry::Symbol</code></td> <td>commandAliasEnum</td></tr> <tr><td>100</td> <td>(1) <code>CommandFlag</code></td> <td>flags</td></tr> <tr><td>104</td> <td>(4) <code>int</code></td> <td>firstRule</td></tr> <tr><td>108</td> <td>(4) <code>int</code></td> <td>firstFactorization</td></tr> <tr><td>112</td> <td>(4) <code>int</code></td> <td>firstOptional</td></tr> <tr><td>116</td> <td>(1) <code>bool</code></td> <td>runnable</td></tr></tbody></table> <h3 id="commandlexer"><a href="#commandlexer" class="header-anchor">#</a> <code>CommandLexer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const std::string *</code></td> <td>mInput</td></tr> <tr><td>8</td> <td>(16) <code>CommandLexer::Token</code></td> <td>mToken</td></tr></tbody></table> <h3 id="commandlexer-token"><a href="#commandlexer-token" class="header-anchor">#</a> <code>CommandLexer::Token</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>text</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>length</td></tr> <tr><td>12</td> <td>(4) <code>CommandLexer::TokenType</code></td> <td>type</td></tr></tbody></table> <h3 id="commandregistry-registrystate"><a href="#commandregistry-registrystate" class="header-anchor">#</a> <code>CommandRegistry::RegistryState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>signatureCount</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>enumValueCount</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>postfixCount</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>enumCount</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>factorizationCount</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>optionalCount</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>ruleCount</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>softEnumCount</td></tr> <tr><td>32</td> <td>(4) <code>unsigned int</code></td> <td>constraintCount</td></tr> <tr><td>40</td> <td>(24) <code>std::vector&lt;unsigned int&gt;</code></td> <td>constrainedValueCount</td></tr> <tr><td>64</td> <td>(24) <code>std::vector&lt;unsigned int&gt;</code></td> <td>softEnumValuesCount</td></tr></tbody></table> <h3 id="commanditem"><a href="#commanditem" class="header-anchor">#</a> <code>CommandItem</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>$F8070BC88C1447D17F82F88E7F729FB1</code></td> <td>___u0</td></tr></tbody></table> <h3 id="clonecommand-execute-l2-cloneblockinfo"><a href="#clonecommand-execute-l2-cloneblockinfo" class="header-anchor">#</a> <code>CloneCommand::execute::__l2::CloneBlockInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>BlockPos</code></td> <td>mPos</td></tr> <tr><td>16</td> <td>(8) <code>const Block *</code></td> <td>mState</td></tr> <tr><td>24</td> <td>(8) <code>std::unique_ptr&lt;CompoundTag&gt;</code></td> <td>mTag</td></tr></tbody></table> <h3 id="clientblobcache-server-transferbuilder"><a href="#clientblobcache-server-transferbuilder" class="header-anchor">#</a> <code>ClientBlobCache::Server::TransferBuilder</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(224) <code>ClientBlobCache::Server::ActiveTransfer</code></td> <td>mTransfer</td></tr></tbody></table> <h3 id="clientblobcache-server-activetransfer"><a href="#clientblobcache-server-activetransfer" class="header-anchor">#</a> <code>ClientBlobCache::Server::ActiveTransfer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ClientBlobCache::Server::ActiveTransfersManager *</code></td> <td>mCache</td></tr> <tr><td>8</td> <td>(152) <code>NetworkIdentifier</code></td> <td>mOwner</td></tr> <tr><td>160</td> <td>(64) <code>std::unordered_map&lt;unsigned __int64,std::shared_ptr&lt;ClientBlobCache::Server::Blob&gt;&gt;</code></td> <td>mIdsWaitingForACK</td></tr></tbody></table> <h3 id="chunkpositionanddimension"><a href="#chunkpositionanddimension" class="header-anchor">#</a> <code>ChunkPositionAndDimension</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ChunkPos</code></td> <td>mPos</td></tr> <tr><td>8</td> <td>(4) <code>AutomaticID&lt;Dimension,int&gt;</code></td> <td>mType</td></tr></tbody></table> <h3 id="containerdescription"><a href="#containerdescription" class="header-anchor">#</a> <code>ContainerDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ComponentDescription</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mSize</td></tr> <tr><td>12</td> <td>(1) <code>bool</code></td> <td>mCanBesiphonedFrom</td></tr> <tr><td>13</td> <td>(1) <code>bool</code></td> <td>mPrivate</td></tr> <tr><td>14</td> <td>(1) <code>bool</code></td> <td>mRestrictToOwner</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>mSlotsPerStrength</td></tr> <tr><td>20</td> <td>(1) <code>ContainerType</code></td> <td>mContainerType</td></tr></tbody></table> <h3 id="crashdumpeventdata"><a href="#crashdumpeventdata" class="header-anchor">#</a> <code>CrashDumpEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>_BYTE[2]</code></td> <td>mTag0</td></tr> <tr><td>2</td> <td>(2) <code>_BYTE[2]</code></td> <td>mTag1</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mEventThreadId</td></tr></tbody></table> <h3 id="compoundtagupdaterbuilder-match-l2-lambda-d6e645fd0760b5869a1c1fbc97f375e0"><a href="#compoundtagupdaterbuilder-match-l2-lambda-d6e645fd0760b5869a1c1fbc97f375e0" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::match::__l2::&lt;lambda_d6e645fd0760b5869a1c1fbc97f375e0&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>const std::string</code></td> <td>tagName</td></tr> <tr><td>32</td> <td>(32) <code>std::string</code></td> <td>pattern</td></tr></tbody></table> <h3 id="compoundtagupdaterbuilder-tryedit-l2-lambda-331080c9253f49c0e39d20a115988e3c"><a href="#compoundtagupdaterbuilder-tryedit-l2-lambda-331080c9253f49c0e39d20a115988e3c" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::tryEdit::__l2::&lt;lambda_331080c9253f49c0e39d20a115988e3c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>const std::string</code></td> <td>tagName</td></tr> <tr><td>32</td> <td>(64) <code>std::function&lt;void __cdecl(CompoundTagEditHelper &amp;)&gt;</code></td> <td>update</td></tr></tbody></table> <h3 id="compoundtagupdaterbuilder-rename-l2-lambda-4bed7a15ca03b6882a582c4103e2a48e"><a href="#compoundtagupdaterbuilder-rename-l2-lambda-4bed7a15ca03b6882a582c4103e2a48e" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder::rename::__l2::&lt;lambda_4bed7a15ca03b6882a582c4103e2a48e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>const std::string</code></td> <td>tagName</td></tr> <tr><td>32</td> <td>(32) <code>const std::string</code></td> <td>newTagName</td></tr></tbody></table> <h3 id="core-ziputils-zipprogresslist"><a href="#core-ziputils-zipprogresslist" class="header-anchor">#</a> <code>Core::ZipUtils::ZipProgressList</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;std::shared_ptr&lt;Core::ZipUtils::ZipProgress&gt;&gt;</code></td> <td>mZipProgress</td></tr> <tr><td>24</td> <td>(80) <code>std::mutex</code></td> <td>mProgressLock</td></tr></tbody></table> <h3 id="clientparticleinitializationcomponent"><a href="#clientparticleinitializationcomponent" class="header-anchor">#</a> <code>ClientParticleInitializationComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;ParticleInitializationData&gt;</code></td> <td>mParticleInitializationData</td></tr></tbody></table> <h3 id="containervalidation-assignvalidationdelegates-l12-lambda-f3de1f01db6586c03466a09e7bf05768"><a href="#containervalidation-assignvalidationdelegates-l12-lambda-f3de1f01db6586c03466a09e7bf05768" class="header-anchor">#</a> <code>ContainerValidation::assignValidationDelegates::__l12::&lt;lambda_f3de1f01db6586c03466a09e7bf05768&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>const ContainerScreenContext</code></td> <td>screenContext</td></tr></tbody></table> <h3 id="craftablecompounds"><a href="#craftablecompounds" class="header-anchor">#</a> <code>CraftableCompounds</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CraftableCompounds_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;std::string,ItemStack&gt;</code></td> <td>mComponentsToCompound</td></tr> <tr><td>72</td> <td>(64) <code>std::unordered_map&lt;int,std::vector&lt;ItemStack&gt;&gt;</code></td> <td>mCompoundToComponents</td></tr> <tr><td>136</td> <td>(64) <code>std::unordered_map&lt;std::string,enum LabTableReactionType&gt;</code></td> <td>mComponentsToReaction</td></tr> <tr><td>200</td> <td>(64) <code>std::unordered_map&lt;std::string,enum CompoundContainerType&gt;</code></td> <td>mComponentsToContainerOverride</td></tr></tbody></table> <h3 id="chemistryingredient"><a href="#chemistryingredient" class="header-anchor">#</a> <code>ChemistryIngredient</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(240) <code>ItemInstance</code></td> <td>mItem</td></tr></tbody></table> <h3 id="createcontaineritemscope"><a href="#createcontaineritemscope" class="header-anchor">#</a> <code>CreateContainerItemScope</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const SlotData *const</code></td> <td>mSrcSlot</td></tr> <tr><td>8</td> <td>(16) <code>std::shared_ptr&lt;ContainerController&gt;</code></td> <td>mCreatedItemContainerController</td></tr> <tr><td>24</td> <td>(16) <code>ItemStackRequestScope</code></td> <td>mItemStackRequestScope</td></tr></tbody></table> <h3 id="container"><a href="#container" class="header-anchor">#</a> <code>Container</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Container_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(1) <code>ContainerType</code></td> <td>mContainerType</td></tr> <tr><td>9</td> <td>(1) <code>ContainerType</code></td> <td>mGameplayContainerType</td></tr> <tr><td>16</td> <td>(64) <code>std::unordered_set&lt;ContainerContentChangeListener *&gt;</code></td> <td>mContentChangeListeners</td></tr> <tr><td>80</td> <td>(64) <code>std::unordered_set&lt;ContainerSizeChangeListener *&gt;</code></td> <td>mSizeChangeListeners</td></tr> <tr><td>144</td> <td>(40) <code>std::deque&lt;std::function&lt;void __cdecl(Container &amp;,int,ItemStack const &amp;,ItemStack const &amp;)&gt;&gt;</code></td> <td>mTransactionContextStack</td></tr> <tr><td>184</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>216</td> <td>(1) <code>bool</code></td> <td>mCustomName</td></tr> <tr><td>220</td> <td>(4) <code>TypedRuntimeId&lt;ContainerRuntimeIdTag,unsigned int,0&gt;</code></td> <td>mContainerRuntimeId</td></tr></tbody></table> <h3 id="containermanagercontroller"><a href="#containermanagercontroller" class="header-anchor">#</a> <code>ContainerManagerController</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ContainerManagerController_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(16) <code>std::enable_shared_from_this&lt;ContainerManagerController&gt;</code></td> <td>baseclass_8</td></tr> <tr><td>24</td> <td>(16) <code>std::weak_ptr&lt;ContainerManagerModel&gt;</code></td> <td>mContainerManagerModel</td></tr> <tr><td>40</td> <td>(64) <code>std::unordered_map&lt;std::string,std::shared_ptr&lt;ContainerController&gt;&gt;</code></td> <td>mContainers</td></tr> <tr><td>104</td> <td>(24) <code>std::vector&lt;ContainerSplitControl&gt;</code></td> <td>mContainerSplitItemStackItems</td></tr> <tr><td>128</td> <td>(4) <code>int</code></td> <td>mSplitItemRemainder</td></tr> <tr><td>132</td> <td>(1) <code>bool</code></td> <td>mContainerDirty</td></tr> <tr><td>133</td> <td>(1) <code>bool</code></td> <td>mContainersClosed</td></tr></tbody></table> <h3 id="chestblocktrypairevent"><a href="#chestblocktrypairevent" class="header-anchor">#</a> <code>ChestBlockTryPairEvent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>const std::shared_ptr&lt;BlockSourceHandle&gt;</code></td> <td>mBlockSourceHandle</td></tr> <tr><td>16</td> <td>(12) <code>const Vec3</code></td> <td>mBlockPos</td></tr> <tr><td>28</td> <td>(12) <code>const Vec3</code></td> <td>mOtherBlockPos</td></tr></tbody></table> <h3 id="craftingcontainer"><a href="#craftingcontainer" class="header-anchor">#</a> <code>CraftingContainer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(224) <code>Container</code></td> <td>baseclass_0</td></tr> <tr><td>224</td> <td>(24) <code>std::vector&lt;ItemStack&gt;</code></td> <td>mItems</td></tr> <tr><td>248</td> <td>(4) <code>int</code></td> <td>mWidth</td></tr></tbody></table> <h3 id="containerweakref"><a href="#containerweakref" class="header-anchor">#</a> <code>ContainerWeakRef</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ActorUniqueID</code></td> <td>mContainerActor</td></tr> <tr><td>8</td> <td>(4) <code>ActorContainerType</code></td> <td>mActorContainerType</td></tr> <tr><td>12</td> <td>(12) <code>BlockPos</code></td> <td>mBlockPosition</td></tr> <tr><td>24</td> <td>(4) <code>TypedRuntimeId&lt;ContainerRuntimeIdTag,unsigned int,0&gt;</code></td> <td>mContainerRuntimeId</td></tr></tbody></table> <h3 id="containerweakrefdata"><a href="#containerweakrefdata" class="header-anchor">#</a> <code>ContainerWeakRefData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Container *</code></td> <td>mContainer</td></tr> <tr><td>8</td> <td>(8) <code>Actor *</code></td> <td>mActor</td></tr> <tr><td>16</td> <td>(8) <code>BlockActor *</code></td> <td>mBlockActor</td></tr></tbody></table> <h3 id="containerscreencontextcomponent"><a href="#containerscreencontextcomponent" class="header-anchor">#</a> <code>ContainerScreenContextComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>ContainerScreenContext</code></td> <td>mContext</td></tr></tbody></table> <h3 id="connectioncomponent"><a href="#connectioncomponent" class="header-anchor">#</a> <code>ConnectionComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::set&lt;HashedString&gt;</code></td> <td>mConnection</td></tr></tbody></table> <h3 id="compoundtagupdaterbuilder"><a href="#compoundtagupdaterbuilder" class="header-anchor">#</a> <code>CompoundTagUpdaterBuilder</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CompoundTagUpdater *</code></td> <td>mUpdater</td></tr></tbody></table> <h3 id="commandsoftenumregistry"><a href="#commandsoftenumregistry" class="header-anchor">#</a> <code>CommandSoftEnumRegistry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CommandRegistry *</code></td> <td>mRegistry</td></tr></tbody></table> <h3 id="cachedcomponentdata"><a href="#cachedcomponentdata" class="header-anchor">#</a> <code>CachedComponentData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mFriction</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mDestroySpeed</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mBurnOdds</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>mFlameOdds</td></tr> <tr><td>16</td> <td>(1) <code>Brightness</code></td> <td>mLight</td></tr> <tr><td>17</td> <td>(1) <code>Brightness</code></td> <td>mLightEmission</td></tr> <tr><td>18</td> <td>(1) <code>bool</code></td> <td>mIsSolid</td></tr></tbody></table> <h3 id="chunkviewsource"><a href="#chunkviewsource" class="header-anchor">#</a> <code>ChunkViewSource</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(56) <code>ChunkSource</code></td> <td>baseclass_0</td></tr> <tr><td>56</td> <td>(4) <code>_BYTE[4]</code></td> <td>mParentLoadMode</td></tr> <tr><td>64</td> <td>(296) <code>GridArea&lt;std::shared_ptr&lt;LevelChunk&gt; &gt;</code></td> <td>mArea</td></tr> <tr><td>360</td> <td>(8) <code>ChunkSource *</code></td> <td>mMainSource</td></tr></tbody></table> <h3 id="columncacheddata"><a href="#columncacheddata" class="header-anchor">#</a> <code>ColumnCachedData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>grassColor</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>waterColor</td></tr></tbody></table> <h3 id="consolechunkblender"><a href="#consolechunkblender" class="header-anchor">#</a> <code>ConsoleChunkBlender</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>SpinLock</code></td> <td>mSpinLock</td></tr> <tr><td>32</td> <td>(16) <code>float[2][2]</code></td> <td>mInterpCorners</td></tr> <tr><td>48</td> <td>(1024) <code>float[16][16]</code></td> <td>mInterpTable</td></tr></tbody></table> <h3 id="circuitcomponentlist-item"><a href="#circuitcomponentlist-item" class="header-anchor">#</a> <code>CircuitComponentList::Item</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BaseCircuitComponent *</code></td> <td>mComponent</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mDampening</td></tr> <tr><td>12</td> <td>(12) <code>BlockPos</code></td> <td>mPos</td></tr> <tr><td>24</td> <td>(1) <code>unsigned __int8</code></td> <td>mDirection</td></tr> <tr><td>25</td> <td>(1) <code>bool</code></td> <td>mDirectlyPowered</td></tr> <tr><td>28</td> <td>(4) <code>int</code></td> <td>mData</td></tr></tbody></table> <h3 id="circuitscenegraph-pendingentry"><a href="#circuitscenegraph-pendingentry" class="header-anchor">#</a> <code>CircuitSceneGraph::PendingEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BaseCircuitComponent *</code></td> <td>mRawComponentPtr</td></tr> <tr><td>8</td> <td>(8) <code>std::unique_ptr&lt;BaseCircuitComponent&gt;</code></td> <td>mComponent</td></tr> <tr><td>16</td> <td>(12) <code>BlockPos</code></td> <td>mPos</td></tr></tbody></table> <h3 id="circuittrackinginfo"><a href="#circuittrackinginfo" class="header-anchor">#</a> <code>CircuitTrackingInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>CircuitTrackingInfo::Entry</code></td> <td>mCurrent</td></tr> <tr><td>32</td> <td>(32) <code>CircuitTrackingInfo::Entry</code></td> <td>mPower</td></tr> <tr><td>64</td> <td>(32) <code>CircuitTrackingInfo::Entry</code></td> <td>mNearest</td></tr> <tr><td>96</td> <td>(32) <code>CircuitTrackingInfo::Entry</code></td> <td>m2ndNearest</td></tr> <tr><td>128</td> <td>(4) <code>int</code></td> <td>mDampening</td></tr> <tr><td>132</td> <td>(1) <code>bool</code></td> <td>mDirectlyPowered</td></tr> <tr><td>136</td> <td>(4) <code>int</code></td> <td>mData</td></tr></tbody></table> <h3 id="circuittrackinginfo-entry"><a href="#circuittrackinginfo-entry" class="header-anchor">#</a> <code>CircuitTrackingInfo::Entry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BaseCircuitComponent *</code></td> <td>mComponent</td></tr> <tr><td>8</td> <td>(12) <code>BlockPos</code></td> <td>mPos</td></tr> <tr><td>20</td> <td>(1) <code>unsigned __int8</code></td> <td>mDirection</td></tr> <tr><td>24</td> <td>(8) <code>unsigned __int64</code></td> <td>mTypeID</td></tr></tbody></table> <h3 id="circuitcomponentlist"><a href="#circuitcomponentlist" class="header-anchor">#</a> <code>CircuitComponentList</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;CircuitComponentList::Item&gt;</code></td> <td>mComponents</td></tr></tbody></table> <h3 id="concurrency-task-options"><a href="#concurrency-task-options" class="header-anchor">#</a> <code>Concurrency::task_options</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>Concurrency::scheduler_ptr</code></td> <td>_M_Scheduler</td></tr> <tr><td>24</td> <td>(8) <code>Concurrency::cancellation_token</code></td> <td>_M_CancellationToken</td></tr> <tr><td>32</td> <td>(16) <code>Concurrency::task_continuation_context</code></td> <td>_M_ContinuationContext</td></tr> <tr><td>48</td> <td>(40) <code>Concurrency::details::_Internal_task_options</code></td> <td>_M_InternalTaskOptions</td></tr> <tr><td>88</td> <td>(1) <code>bool</code></td> <td>_M_HasCancellationToken</td></tr> <tr><td>89</td> <td>(1) <code>bool</code></td> <td>_M_HasScheduler</td></tr></tbody></table> <h3 id="concurrency-scheduler-ptr"><a href="#concurrency-scheduler-ptr" class="header-anchor">#</a> <code>Concurrency::scheduler_ptr</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Concurrency::scheduler_interface&gt;</code></td> <td>_M_sharedScheduler</td></tr> <tr><td>16</td> <td>(8) <code>Concurrency::scheduler_interface *</code></td> <td>_M_scheduler</td></tr></tbody></table> <h3 id="concurrency-cancellation-token"><a href="#concurrency-cancellation-token" class="header-anchor">#</a> <code>Concurrency::cancellation_token</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Concurrency::details::_CancellationTokenState *</code></td> <td>_M_Impl</td></tr></tbody></table> <h3 id="concurrency-task-continuation-context"><a href="#concurrency-task-continuation-context" class="header-anchor">#</a> <code>Concurrency::task_continuation_context</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Concurrency::details::_ContextCallback</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>_M_RunInline</td></tr></tbody></table> <h3 id="concurrency-details-contextcallback"><a href="#concurrency-details-contextcallback" class="header-anchor">#</a> <code>Concurrency::details::_ContextCallback</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Concurrency::details::_ContextCallback::&lt;unnamed_type__M_context&gt;</code></td> <td>_M_context</td></tr></tbody></table> <h3 id="concurrency-details-contextcallback-unnamed-type-m-context"><a href="#concurrency-details-contextcallback-unnamed-type-m-context" class="header-anchor">#</a> <code>Concurrency::details::_ContextCallback::&lt;unnamed_type__M_context&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void *</code></td> <td>_M_pContextCallback</td></tr> <tr><td>1</td> <td>(8) <code>unsigned __int64</code></td> <td>_M_captureMethod</td></tr></tbody></table> <h3 id="concurrency-details-internal-task-options"><a href="#concurrency-details-internal-task-options" class="header-anchor">#</a> <code>Concurrency::details::_Internal_task_options</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>_M_hasPresetCreationCallstack</td></tr> <tr><td>8</td> <td>(32) <code>Concurrency::details::_TaskCreationCallstack</code></td> <td>_M_presetCreationCallstack</td></tr></tbody></table> <h3 id="concurrency-details-taskcreationcallstack"><a href="#concurrency-details-taskcreationcallstack" class="header-anchor">#</a> <code>Concurrency::details::_TaskCreationCallstack</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void *</code></td> <td>_M_SingleFrame</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;void *&gt;</code></td> <td>_M_frames</td></tr></tbody></table> <h3 id="changemodelpacket"><a href="#changemodelpacket" class="header-anchor">#</a> <code>ChangeModelPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(8) <code>ActorUniqueID</code></td> <td>mEntityId</td></tr> <tr><td>48</td> <td>(32) <code>std::string</code></td> <td>mModelName</td></tr></tbody></table> <h3 id="changemodeltexturepacket"><a href="#changemodeltexturepacket" class="header-anchor">#</a> <code>ChangeModelTexturePacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(8) <code>ActorUniqueID</code></td> <td>mEntityId</td></tr> <tr><td>48</td> <td>(32) <code>std::string</code></td> <td>mModelTexture</td></tr> <tr><td>80</td> <td>(8) <code>ActorUniqueID</code></td> <td>mSkinOwnerId</td></tr> <tr><td>88</td> <td>(1) <code>modelTextureType</code></td> <td>mType</td></tr></tbody></table> <h3 id="custompacket"><a href="#custompacket" class="header-anchor">#</a> <code>CustomPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(32) <code>std::string</code></td> <td>mContent</td></tr></tbody></table> <h3 id="crypto-hash-md5"><a href="#crypto-hash-md5" class="header-anchor">#</a> <code>Crypto::Hash::md5</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Crypto::Hash::IHash</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>_lo</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>_hi</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>_a</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>_b</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>_c</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>_d</td></tr> <tr><td>32</td> <td>(64) <code>unsigned __int8[64]</code></td> <td>_buffer</td></tr> <tr><td>96</td> <td>(64) <code>unsigned int[16]</code></td> <td>_block</td></tr></tbody></table> <h3 id="confirmskinpacket-confirmskinentry"><a href="#confirmskinpacket-confirmskinentry" class="header-anchor">#</a> <code>ConfirmSkinPacket::ConfirmSkinEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mValid</td></tr> <tr><td>8</td> <td>(16) <code>mce::UUID</code></td> <td>mUUID</td></tr> <tr><td>24</td> <td>(32) <code>std::string</code></td> <td>mSkinImageData</td></tr></tbody></table> <h3 id="core-filepathmanager"><a href="#core-filepathmanager" class="header-anchor">#</a> <code>Core::FilePathManager</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mIsDedicatedServer</td></tr> <tr><td>8</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mLibraryRoot</td></tr> <tr><td>40</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mDocumentRoot</td></tr> <tr><td>72</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mRoot</td></tr> <tr><td>104</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mPackagePath</td></tr> <tr><td>136</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mDataUrl</td></tr> <tr><td>168</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mExternalFilePath</td></tr> <tr><td>200</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mTemporaryFilePath</td></tr> <tr><td>232</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mCacheFilePath</td></tr> <tr><td>264</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mSettingsPath</td></tr></tbody></table> <h3 id="core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-cachedefaultfactory-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource"><a href="#core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-cachedefaultfactory-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource" class="header-anchor">#</a> <code>Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; &gt;::CacheDefaultFactory&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-cachedefaultfactory-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource"><a href="#core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-cachedefaultfactory-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource" class="header-anchor">#</a> <code>Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt; &gt;::CacheDefaultFactory&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="core-cpuringbufferallocator-std-tree-node-std-pair-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-const-const-std-unique-ptr-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-std-default-delete-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-void-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-std-tree-node-std-pair-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-const-const-std-unique-ptr-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-std-default-delete-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-void-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;std::_Tree_node&lt;std::pair&lt;dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt; const * const,std::unique_ptr&lt;dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt;,std::default_delete&lt;dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt; &gt; &gt; &gt;,void *&gt;,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-std-tree-node-int-void-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-std-tree-node-int-void-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;std::_Tree_node&lt;int,void *&gt;,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-const-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-dragon-framegraph-detail-abstractpass-dragon-rendering-rendercontext-const-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::framegraph::detail::AbstractPass&lt;dragon::rendering::RenderContext&gt; const *,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-std-tree-node-std-pair-dragon-framegraph-detail-abstractresource-dragon-rendering-rendercontext-const-const-dragon-res-servertexture-void-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-std-tree-node-std-pair-dragon-framegraph-detail-abstractresource-dragon-rendering-rendercontext-const-const-dragon-res-servertexture-void-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;std::_Tree_node&lt;std::pair&lt;dragon::framegraph::detail::AbstractResource&lt;dragon::rendering::RenderContext&gt; const * const,dragon::res::ServerTexture&gt;,void *&gt;,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="cg-details-scopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-basic-string-char-std-char-traits-char-std-allocator-char-const-std-vector-cg-grouppooldescription-std-allocator-cg-grouppooldescription-const-taskdispatcherexecution-0"><a href="#cg-details-scopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-basic-string-char-std-char-traits-char-std-allocator-char-const-std-vector-cg-grouppooldescription-std-allocator-cg-grouppooldescription-const-taskdispatcherexecution-0" class="header-anchor">#</a> <code>cg::details::ScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; const &amp;,std::vector&lt;cg::GroupPoolDescription,std::allocator&lt;cg::GroupPoolDescription&gt; &gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,0&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt; *</code></td> <td>mDispatcher</td></tr></tbody></table> <h3 id="cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-ctor-l2-lambda-38b95ff2bedc8501d3bbf586eabb0e1e"><a href="#cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-ctor-l2-lambda-38b95ff2bedc8501d3bbf586eabb0e1e" class="header-anchor">#</a> <code>cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;::{ctor}::__l2::&lt;lambda_38b95ff2bedc8501d3bbf586eabb0e1e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt; *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-cachedefaultfactory-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource"><a href="#core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-cachedefaultfactory-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource" class="header-anchor">#</a> <code>Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; &gt;::CacheDefaultFactory&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="climateattributes"><a href="#climateattributes" class="header-anchor">#</a> <code>ClimateAttributes</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mTemperature</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mDownfall</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mRedSporeDensity</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mBlueSporeDensity</td></tr> <tr><td>16</td> <td>(4) <code>float</code></td> <td>mAshDensity</td></tr> <tr><td>20</td> <td>(4) <code>float</code></td> <td>mWhiteAshDensity</td></tr> <tr><td>24</td> <td>(4) <code>float</code></td> <td>mSnowAccumulationMin</td></tr> <tr><td>28</td> <td>(4) <code>float</code></td> <td>mSnowAccumulationMax</td></tr></tbody></table> <h3 id="canopyvariantbuilder-buildcanopyvariant-l2-lambda-d70ff2a45c19225400bf0b1fd63f432d"><a href="#canopyvariantbuilder-buildcanopyvariant-l2-lambda-d70ff2a45c19225400bf0b1fd63f432d" class="header-anchor">#</a> <code>CanopyVariantBuilder::buildCanopyVariant::__l2::&lt;lambda_d70ff2a45c19225400bf0b1fd63f432d&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;ITreeCanopyWrapper &amp; __cdecl(FeatureLoading::ConcreteFeatureHolder&lt;VanillaTreeFeature&gt; *)&gt;</code></td> <td>canopyAccessor</td></tr></tbody></table> <h3 id="cachedbiomesource-vanillaoverworldbiomesource"><a href="#cachedbiomesource-vanillaoverworldbiomesource" class="header-anchor">#</a> <code>CachedBiomeSource&lt;VanillaOverworldBiomeSource&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>VanillaOverworldBiomeSource</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(16) <code>std::shared_ptr&lt;BiomeSourceGetBiomeCache&gt;</code></td> <td>mCache</td></tr></tbody></table> <h3 id="cameraitemcomponentlegacy"><a href="#cameraitemcomponentlegacy" class="header-anchor">#</a> <code>CameraItemComponentLegacy</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ICameraItemComponent</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mBlackBarsDuration</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mBlackBarsScreenRatio</td></tr> <tr><td>16</td> <td>(4) <code>float</code></td> <td>mShutterScreenRatio</td></tr> <tr><td>20</td> <td>(4) <code>float</code></td> <td>mShutterDuration</td></tr> <tr><td>24</td> <td>(4) <code>float</code></td> <td>mPictureDuration</td></tr> <tr><td>28</td> <td>(4) <code>float</code></td> <td>mSlideAwayDuration</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>mPlacingTripod</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>mPlacingTripodClientTick</td></tr> <tr><td>48</td> <td>(8) <code>unsigned __int64</code></td> <td>mPlacingTripodServerTick</td></tr> <tr><td>56</td> <td>(8) <code>CameraCallbacks *</code></td> <td>mCallbacks</td></tr></tbody></table> <h3 id="customblob"><a href="#customblob" class="header-anchor">#</a> <code>CustomBlob</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>IDxcBlob</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>void *</code></td> <td>data</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>size</td></tr></tbody></table> <h3 id="caretlocationdata"><a href="#caretlocationdata" class="header-anchor">#</a> <code>CaretLocationData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>location</td></tr></tbody></table> <h3 id="connectionstatedata"><a href="#connectionstatedata" class="header-anchor">#</a> <code>ConnectionStateData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>isConnected</td></tr></tbody></table> <h3 id="changeuserdata"><a href="#changeuserdata" class="header-anchor">#</a> <code>ChangeUserData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>restrictToControllerIdChange</td></tr></tbody></table> <h3 id="compression-state"><a href="#compression-state" class="header-anchor">#</a> <code>compression_state</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>input</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>input_len</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>output_len</td></tr> <tr><td>20</td> <td>(1024) <code>unsigned __int8[1024]</code></td> <td>output</td></tr></tbody></table> <h3 id="core-filestoragearea-begintransaction-l5-lambda-299c7b1db8373c80435acd53fe6c3bdb"><a href="#core-filestoragearea-begintransaction-l5-lambda-299c7b1db8373c80435acd53fe6c3bdb" class="header-anchor">#</a> <code>Core::FileStorageArea::_beginTransaction::__l5::&lt;lambda_299c7b1db8373c80435acd53fe6c3bdb&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::FileStorageArea *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="core-transactionframe"><a href="#core-transactionframe" class="header-anchor">#</a> <code>Core::TransactionFrame</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Core::FileSystemImpl&gt;</code></td> <td>msptTransaction</td></tr> <tr><td>16</td> <td>(1040) <code>Core::PathBuffer&lt;Core::StackString&lt;char,1024&gt; &gt;</code></td> <td>mCleanPath</td></tr> <tr><td>1056</td> <td>(72) <code>Core::Result</code></td> <td>mResult</td></tr></tbody></table> <h3 id="core-filesystemimpl-renamefileordirectory-l15-lambda-455282c5f2c9971e330b5e9517f1b8d0"><a href="#core-filesystemimpl-renamefileordirectory-l15-lambda-455282c5f2c9971e330b5e9517f1b8d0" class="header-anchor">#</a> <code>Core::FileSystemImpl::renameFileOrDirectory::__l15::&lt;lambda_455282c5f2c9971e330b5e9517f1b8d0&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>const Core::Path</code></td> <td>sourceEntryPath</td></tr> <tr><td>32</td> <td>(32) <code>const Core::Path</code></td> <td>targetEntryPath</td></tr></tbody></table> <h3 id="core-filesystemimpl-renamefileordirectory-l18-lambda-a88ce22f21287b4119b5de040b24fbd2"><a href="#core-filesystemimpl-renamefileordirectory-l18-lambda-a88ce22f21287b4119b5de040b24fbd2" class="header-anchor">#</a> <code>Core::FileSystemImpl::renameFileOrDirectory::__l18::&lt;lambda_a88ce22f21287b4119b5de040b24fbd2&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;Core::PathPart&gt;</code></td> <td>sourceDirectoryRelativeFiles</td></tr> <tr><td>24</td> <td>(32) <code>const Core::Path</code></td> <td>sourceEntryPath</td></tr> <tr><td>56</td> <td>(32) <code>const Core::Path</code></td> <td>targetEntryPath</td></tr></tbody></table> <h3 id="core-flatfilesearchresult"><a href="#core-flatfilesearchresult" class="header-anchor">#</a> <code>Core::FlatFileSearchResult</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Core::FlatFileManifest const &gt;</code></td> <td>mManifest</td></tr> <tr><td>16</td> <td>(8) <code>const Core::FlatFileManifestInfo *</code></td> <td>mManifestInfoEntry</td></tr></tbody></table> <h3 id="core-result-either-l2-lambda-febe3dbf8fbc4fa631ce502a657ef1ea"><a href="#core-result-either-l2-lambda-febe3dbf8fbc4fa631ce502a657ef1ea" class="header-anchor">#</a> <code>Core::Result::either::__l2::&lt;lambda_febe3dbf8fbc4fa631ce502a657ef1ea&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(72) <code>Core::Result</code></td> <td>r1</td></tr> <tr><td>72</td> <td>(72) <code>Core::Result</code></td> <td>r2</td></tr></tbody></table> <h3 id="crashdump-alldata"><a href="#crashdump-alldata" class="header-anchor">#</a> <code>CrashDump_AllData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>__int64</code></td> <td>mStartSentinel</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mFormatSize</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>mDataBlobCount</td></tr> <tr><td>16</td> <td>(1372) <code>char[1372]</code></td> <td>mFormat</td></tr> <tr><td>1388</td> <td>(520) <code>CrashDumpGlobalData</code></td> <td>mGlobalData</td></tr> <tr><td>1908</td> <td>(32784) <code>CrashDumpEventDataArray</code></td> <td>mEventDataArray</td></tr> <tr><td>34692</td> <td>(8208) <code>CrashDumpKeyValueDataArray</code></td> <td>mKeyValueDataArray</td></tr> <tr><td>42900</td> <td>(272) <code>CrashDumpFrameDataArray</code></td> <td>mFrameDataArray</td></tr> <tr><td>43172</td> <td>(1552) <code>CrashDumpGameplayDataArray</code></td> <td>mGameplayDataArray</td></tr> <tr><td>44724</td> <td>(1040) <code>CrashDumpRenderDataArray</code></td> <td>mRenderDataArray</td></tr> <tr><td>45764</td> <td>(272) <code>CrashDumpPlayerDataArray</code></td> <td>mPlayerDataArray</td></tr> <tr><td>46036</td> <td>(400) <code>CrashDumpFirstAssertsDataArray</code></td> <td>mFirstAssertsDataArray</td></tr> <tr><td>46436</td> <td>(400) <code>CrashDumpLastAssertsDataArray</code></td> <td>mLastAssertsDataArray</td></tr> <tr><td>46836</td> <td>(8) <code>__int64</code></td> <td>mEndSentinel</td></tr></tbody></table> <h3 id="crashdumpglobaldata"><a href="#crashdumpglobaldata" class="header-anchor">#</a> <code>CrashDumpGlobalData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(32) <code>char[32]</code></td> <td>mPlatform</td></tr> <tr><td>48</td> <td>(32) <code>char[32]</code></td> <td>mGameVersion</td></tr> <tr><td>80</td> <td>(4) <code>int</code></td> <td>mResourcePack</td></tr> <tr><td>84</td> <td>(4) <code>int</code></td> <td>mWorldSeed</td></tr> <tr><td>88</td> <td>(4) <code>int</code></td> <td>mRegion</td></tr> <tr><td>92</td> <td>(4) <code>int</code></td> <td>__pad</td></tr> <tr><td>96</td> <td>(8) <code>unsigned __int64</code></td> <td>mTotalMemory</td></tr> <tr><td>104</td> <td>(16) <code>_GUID</code></td> <td>mDeviceSessionId</td></tr> <tr><td>120</td> <td>(16) <code>_GUID</code></td> <td>mDeviceId</td></tr> <tr><td>136</td> <td>(256) <code>char[256]</code></td> <td>mResourcePackIds</td></tr> <tr><td>392</td> <td>(128) <code>char[128]</code></td> <td>mMainSceneStack</td></tr></tbody></table> <h3 id="crashdumplogblobheader"><a href="#crashdumplogblobheader" class="header-anchor">#</a> <code>CrashDumpLogBlobHeader</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>CrashDumpLogSectionType</code></td> <td>mType</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>mSize</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>mIndex</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>mFieldCount</td></tr></tbody></table> <h3 id="crashdumpeventdataarray"><a href="#crashdumpeventdataarray" class="header-anchor">#</a> <code>CrashDumpEventDataArray</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(32768) <code>CrashDumpEventData[4096]</code></td> <td>mEventData</td></tr></tbody></table> <h3 id="crashdumpkeyvaluedataarray"><a href="#crashdumpkeyvaluedataarray" class="header-anchor">#</a> <code>CrashDumpKeyValueDataArray</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(8192) <code>CrashDumpKeyValueData[512]</code></td> <td>mKeyValueData</td></tr></tbody></table> <h3 id="crashdumpframedataarray"><a href="#crashdumpframedataarray" class="header-anchor">#</a> <code>CrashDumpFrameDataArray</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(256) <code>CrashDumpFrameData[8]</code></td> <td>mFrameData</td></tr></tbody></table> <h3 id="crashdumpframedata"><a href="#crashdumpframedata" class="header-anchor">#</a> <code>CrashDumpFrameData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mNumControllers</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>mPrimaryControllerId</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>mFreeMemory</td></tr> <tr><td>16</td> <td>(4) <code>float</code></td> <td>mX</td></tr> <tr><td>20</td> <td>(4) <code>float</code></td> <td>mY</td></tr> <tr><td>24</td> <td>(4) <code>float</code></td> <td>mZ</td></tr> <tr><td>28</td> <td>(4) <code>float</code></td> <td>mDirection</td></tr></tbody></table> <h3 id="crashdumpgameplaydataarray"><a href="#crashdumpgameplaydataarray" class="header-anchor">#</a> <code>CrashDumpGameplayDataArray</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(1536) <code>CrashDumpGameplayData[128]</code></td> <td>mGameplayData</td></tr></tbody></table> <h3 id="crashdumprenderdataarray"><a href="#crashdumprenderdataarray" class="header-anchor">#</a> <code>CrashDumpRenderDataArray</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(1024) <code>CrashDumpRenderData[128]</code></td> <td>mRenderData</td></tr></tbody></table> <h3 id="crashdumprenderdata"><a href="#crashdumprenderdata" class="header-anchor">#</a> <code>CrashDumpRenderData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>_BYTE[2]</code></td> <td>mTag</td></tr> <tr><td>2</td> <td>(2) <code>__int16</code></td> <td>mPad</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mObjectId</td></tr></tbody></table> <h3 id="crashdumpplayerdataarray"><a href="#crashdumpplayerdataarray" class="header-anchor">#</a> <code>CrashDumpPlayerDataArray</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(256) <code>CrashDumpPlayerData[4]</code></td> <td>mPlayerData</td></tr></tbody></table> <h3 id="crashdumpplayerdata"><a href="#crashdumpplayerdata" class="header-anchor">#</a> <code>CrashDumpPlayerData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>char[64]</code></td> <td>mSceneStack</td></tr></tbody></table> <h3 id="crashdumpfirstassertsdataarray"><a href="#crashdumpfirstassertsdataarray" class="header-anchor">#</a> <code>CrashDumpFirstAssertsDataArray</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(384) <code>CrashDumpAssertData[3]</code></td> <td>mAssertData</td></tr></tbody></table> <h3 id="crashdumpassertdata"><a href="#crashdumpassertdata" class="header-anchor">#</a> <code>CrashDumpAssertData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(128) <code>char[128]</code></td> <td>mAssertMessage</td></tr></tbody></table> <h3 id="crashdumplastassertsdataarray"><a href="#crashdumplastassertsdataarray" class="header-anchor">#</a> <code>CrashDumpLastAssertsDataArray</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>CrashDumpLogBlobHeader</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(384) <code>CrashDumpAssertData[3]</code></td> <td>mAssertData</td></tr></tbody></table> <h3 id="cff-parserrec"><a href="#cff-parserrec" class="header-anchor">#</a> <code>CFF_ParserRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>FT_LibraryRec_ *</code></td> <td>library</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int8 *</code></td> <td>start</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int8 *</code></td> <td>limit</td></tr> <tr><td>24</td> <td>(8) <code>unsigned __int8 *</code></td> <td>cursor</td></tr> <tr><td>32</td> <td>(8) <code>unsigned __int8 **</code></td> <td>stack</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int8 **</code></td> <td>top</td></tr> <tr><td>48</td> <td>(4) <code>unsigned int</code></td> <td>stackSize</td></tr> <tr><td>52</td> <td>(4) <code>unsigned int</code></td> <td>object_code</td></tr> <tr><td>56</td> <td>(8) <code>void *</code></td> <td>object</td></tr> <tr><td>64</td> <td>(2) <code>unsigned __int16</code></td> <td>num_designs</td></tr> <tr><td>66</td> <td>(2) <code>unsigned __int16</code></td> <td>num_axes</td></tr></tbody></table> <h3 id="cff-indexrec"><a href="#cff-indexrec" class="header-anchor">#</a> <code>CFF_IndexRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>FT_StreamRec_ *</code></td> <td>stream</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>start</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>hdr_size</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>count</td></tr> <tr><td>20</td> <td>(1) <code>unsigned __int8</code></td> <td>off_size</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>data_offset</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>data_size</td></tr> <tr><td>32</td> <td>(8) <code>unsigned int *</code></td> <td>offsets</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int8 *</code></td> <td>bytes</td></tr></tbody></table> <h3 id="cid-parser"><a href="#cid-parser" class="header-anchor">#</a> <code>CID_Parser_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(144) <code>PS_ParserRec_</code></td> <td>root</td></tr> <tr><td>144</td> <td>(8) <code>FT_StreamRec_ *</code></td> <td>stream</td></tr> <tr><td>152</td> <td>(8) <code>unsigned __int8 *</code></td> <td>postscript</td></tr> <tr><td>160</td> <td>(4) <code>unsigned int</code></td> <td>postscript_len</td></tr> <tr><td>164</td> <td>(4) <code>unsigned int</code></td> <td>data_offset</td></tr> <tr><td>168</td> <td>(4) <code>unsigned int</code></td> <td>binary_length</td></tr> <tr><td>176</td> <td>(8) <code>CID_FaceInfoRec_ *</code></td> <td>cid</td></tr> <tr><td>184</td> <td>(4) <code>int</code></td> <td>num_dict</td></tr></tbody></table> <h3 id="cf2-matrix"><a href="#cf2-matrix" class="header-anchor">#</a> <code>CF2_Matrix_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>a</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>b</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>c</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>d</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>tx</td></tr> <tr><td>20</td> <td>(4) <code>int</code></td> <td>ty</td></tr></tbody></table> <h3 id="cf2-bufferrec"><a href="#cf2-bufferrec" class="header-anchor">#</a> <code>CF2_BufferRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>int *</code></td> <td>error</td></tr> <tr><td>8</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>start</td></tr> <tr><td>16</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>end</td></tr> <tr><td>24</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>ptr</td></tr></tbody></table> <h3 id="cf2-hintmaskrec"><a href="#cf2-hintmaskrec" class="header-anchor">#</a> <code>CF2_HintMaskRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>int *</code></td> <td>error</td></tr> <tr><td>8</td> <td>(1) <code>unsigned __int8</code></td> <td>isValid</td></tr> <tr><td>9</td> <td>(1) <code>unsigned __int8</code></td> <td>isNew</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>bitCount</td></tr> <tr><td>24</td> <td>(8) <code>unsigned __int64</code></td> <td>byteCount</td></tr> <tr><td>32</td> <td>(12) <code>unsigned __int8[12]</code></td> <td>mask</td></tr></tbody></table> <h3 id="cf2-hintrec"><a href="#cf2-hintrec" class="header-anchor">#</a> <code>CF2_HintRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>flags</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>index</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>csCoord</td></tr> <tr><td>20</td> <td>(4) <code>int</code></td> <td>dsCoord</td></tr> <tr><td>24</td> <td>(4) <code>int</code></td> <td>scale</td></tr></tbody></table> <h3 id="cf2-glyphpathrec"><a href="#cf2-glyphpathrec" class="header-anchor">#</a> <code>CF2_GlyphPathRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CF2_FontRec_ *</code></td> <td>font</td></tr> <tr><td>8</td> <td>(8) <code>CF2_OutlineCallbacksRec_ *</code></td> <td>callbacks</td></tr> <tr><td>16</td> <td>(6184) <code>CF2_HintMapRec_</code></td> <td>hintMap</td></tr> <tr><td>6200</td> <td>(6184) <code>CF2_HintMapRec_</code></td> <td>firstHintMap</td></tr> <tr><td>12384</td> <td>(6184) <code>CF2_HintMapRec_</code></td> <td>initialHintMap</td></tr> <tr><td>18568</td> <td>(64) <code>CF2_ArrStackRec_</code></td> <td>hintMoves</td></tr> <tr><td>18632</td> <td>(4) <code>int</code></td> <td>scaleX</td></tr> <tr><td>18636</td> <td>(4) <code>int</code></td> <td>scaleC</td></tr> <tr><td>18640</td> <td>(4) <code>int</code></td> <td>scaleY</td></tr> <tr><td>18644</td> <td>(8) <code>FT_Vector_</code></td> <td>fractionalTranslation</td></tr> <tr><td>18652</td> <td>(1) <code>unsigned __int8</code></td> <td>pathIsOpen</td></tr> <tr><td>18653</td> <td>(1) <code>unsigned __int8</code></td> <td>pathIsClosing</td></tr> <tr><td>18654</td> <td>(1) <code>unsigned __int8</code></td> <td>darken</td></tr> <tr><td>18655</td> <td>(1) <code>unsigned __int8</code></td> <td>moveIsPending</td></tr> <tr><td>18656</td> <td>(8) <code>CF2_ArrStackRec_ *</code></td> <td>hStemHintArray</td></tr> <tr><td>18664</td> <td>(8) <code>CF2_ArrStackRec_ *</code></td> <td>vStemHintArray</td></tr> <tr><td>18672</td> <td>(8) <code>CF2_HintMaskRec_ *</code></td> <td>hintMask</td></tr> <tr><td>18680</td> <td>(4) <code>int</code></td> <td>hintOriginY</td></tr> <tr><td>18688</td> <td>(8) <code>const CF2_BluesRec_ *</code></td> <td>blues</td></tr> <tr><td>18696</td> <td>(4) <code>int</code></td> <td>xOffset</td></tr> <tr><td>18700</td> <td>(4) <code>int</code></td> <td>yOffset</td></tr> <tr><td>18704</td> <td>(4) <code>int</code></td> <td>miterLimit</td></tr> <tr><td>18708</td> <td>(4) <code>int</code></td> <td>snapThreshold</td></tr> <tr><td>18712</td> <td>(8) <code>FT_Vector_</code></td> <td>offsetStart0</td></tr> <tr><td>18720</td> <td>(8) <code>FT_Vector_</code></td> <td>offsetStart1</td></tr> <tr><td>18728</td> <td>(8) <code>FT_Vector_</code></td> <td>currentCS</td></tr> <tr><td>18736</td> <td>(8) <code>FT_Vector_</code></td> <td>currentDS</td></tr> <tr><td>18744</td> <td>(8) <code>FT_Vector_</code></td> <td>start</td></tr> <tr><td>18752</td> <td>(1) <code>unsigned __int8</code></td> <td>elemIsQueued</td></tr> <tr><td>18756</td> <td>(4) <code>int</code></td> <td>prevElemOp</td></tr> <tr><td>18760</td> <td>(8) <code>FT_Vector_</code></td> <td>prevElemP0</td></tr> <tr><td>18768</td> <td>(8) <code>FT_Vector_</code></td> <td>prevElemP1</td></tr> <tr><td>18776</td> <td>(8) <code>FT_Vector_</code></td> <td>prevElemP2</td></tr> <tr><td>18784</td> <td>(8) <code>FT_Vector_</code></td> <td>prevElemP3</td></tr></tbody></table> <h3 id="cf2-hintmaprec"><a href="#cf2-hintmaprec" class="header-anchor">#</a> <code>CF2_HintMapRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CF2_FontRec_ *</code></td> <td>font</td></tr> <tr><td>8</td> <td>(8) <code>CF2_HintMapRec_ *</code></td> <td>initialHintMap</td></tr> <tr><td>16</td> <td>(8) <code>CF2_ArrStackRec_ *</code></td> <td>hintMoves</td></tr> <tr><td>24</td> <td>(1) <code>unsigned __int8</code></td> <td>isValid</td></tr> <tr><td>25</td> <td>(1) <code>unsigned __int8</code></td> <td>hinted</td></tr> <tr><td>28</td> <td>(4) <code>int</code></td> <td>scale</td></tr> <tr><td>32</td> <td>(4) <code>unsigned int</code></td> <td>count</td></tr> <tr><td>36</td> <td>(4) <code>unsigned int</code></td> <td>lastIndex</td></tr> <tr><td>40</td> <td>(6144) <code>CF2_HintRec_[192]</code></td> <td>edge</td></tr></tbody></table> <h3 id="cf2-arrstackrec"><a href="#cf2-arrstackrec" class="header-anchor">#</a> <code>CF2_ArrStackRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>FT_MemoryRec_ *</code></td> <td>memory</td></tr> <tr><td>8</td> <td>(8) <code>int *</code></td> <td>error</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>sizeItem</td></tr> <tr><td>24</td> <td>(8) <code>unsigned __int64</code></td> <td>allocated</td></tr> <tr><td>32</td> <td>(8) <code>unsigned __int64</code></td> <td>chunk</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>count</td></tr> <tr><td>48</td> <td>(8) <code>unsigned __int64</code></td> <td>totalSize</td></tr> <tr><td>56</td> <td>(8) <code>void *</code></td> <td>ptr</td></tr></tbody></table> <h3 id="cookie-type"><a href="#cookie-type" class="header-anchor">#</a> <code>cookie_type</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>__int64</code></td> <td>start_pos</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>dec_flags</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>bytes_to_feed</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>chars_to_skip</td></tr> <tr><td>20</td> <td>(1) <code>char</code></td> <td>need_eof</td></tr></tbody></table> <h3 id="compiling"><a href="#compiling" class="header-anchor">#</a> <code>compiling</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>char *</code></td> <td>c_encoding</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>c_future_unicode</td></tr> <tr><td>16</td> <td>(8) <code>_arena *</code></td> <td>c_arena</td></tr> <tr><td>24</td> <td>(8) <code>const char *</code></td> <td>c_filename</td></tr></tbody></table> <h3 id="compiler"><a href="#compiler" class="header-anchor">#</a> <code>compiler</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>c_filename</td></tr> <tr><td>8</td> <td>(8) <code>symtable *</code></td> <td>c_st</td></tr> <tr><td>16</td> <td>(8) <code>?</code></td> <td>c_future</td></tr> <tr><td>24</td> <td>(8) <code>?</code></td> <td>c_flags</td></tr> <tr><td>32</td> <td>(4) <code>int</code></td> <td>c_interactive</td></tr> <tr><td>36</td> <td>(4) <code>int</code></td> <td>c_nestlevel</td></tr> <tr><td>40</td> <td>(8) <code>compiler_unit *</code></td> <td>u</td></tr> <tr><td>48</td> <td>(8) <code>_object *</code></td> <td>c_stack</td></tr> <tr><td>56</td> <td>(8) <code>_arena *</code></td> <td>c_arena</td></tr></tbody></table> <h3 id="core-cpuringbufferallocator-dragon-platform-registry-basicrenderregistry-dragon-frameobject-components-computedispatch-dragon-frameobject-components-viewsetid-dragon-frameobject-components-defaultpasses-alphatest-dragon-frameobject-components-defaultpasses-blit-dragon-frameobject-components-defaultpasses-opaque-dragon-frameobject-components-defaultpasses-stencilwrite-dragon-frameobject-components-defaultpasses-transparent-dragon-frameobject-components-defaultpasses-postfx-dragon-frameobject-components-defaultpasses-ui-dragon-frameobject-components-lightparameters-dragon-frameobject-components-directionallight-dragon-frameobject-components-ambientlight-dragon-frameobject-components-pointlight-dragon-frameobject-components-meshfilter-dragon-frameobject-components-materialfilter-dragon-frameobject-components-particleobject-dragon-frameobject-components-passstate-dragon-frameobject-components-posteffect-dragon-frameobject-components-rendertarget-dragon-frameobject-components-sceneobject-dragon-frameobject-components-sceneoverlayobject-dragon-frameobject-components-scenesky-dragon-frameobject-components-sceneskyobject-dragon-frameobject-components-selectionoverlayobject-dragon-frameobject-components-cubemap-dragon-frameobject-components-shadowsource-dragon-frameobject-components-shadowcaster-dragon-frameobject-components-shadowoverlay-dragon-frameobject-components-shadowvolume-dragon-frameobject-components-sortindex-dragon-frameobject-components-sortorigin-dragon-frameobject-components-transform-dragon-frameobject-components-uielement-dragon-frameobject-components-forcerasterization-dragon-frameobject-components-forcerasterizationwithmultiply-dragon-frameobject-components-raytraceobject-mce-framebuilder-gamecomponents-alphatestcracks-mce-framebuilder-gamecomponents-atmosphere-mce-framebuilder-gamecomponents-blendedcracksobject-mce-framebuilder-gamecomponents-environmentaltext-mce-framebuilder-gamecomponents-gameface-mce-framebuilder-gamecomponents-inlevelcubemapobject-mce-framebuilder-gamecomponents-iteminhandobject-mce-framebuilder-gamecomponents-sceneobjectactors-mce-framebuilder-gamecomponents-transparentiteminworldobject-mce-framebuilder-gamecomponents-waterholeobject-mce-framebuilder-gamecomponents-playerui-mce-framebuilder-gamecomponents-playervision-mce-framebuilder-gamecomponents-overlayui-mce-framebuilder-gamecomponents-vrconfiguration-mce-framebuilder-gamecomponents-vrpresenceobject-mce-framebuilder-gamecomponents-livingroomviewfilter-mce-framebuilder-gamecomponents-livingroomtransitionfilter-mce-framebuilder-gamecomponents-livingroomsceneobject-mce-framebuilder-gamecomponents-vrfloatinguiquad-mce-framebuilder-gamecomponents-fadetoblackeffect-mce-framebuilder-bgfxbridge-rtxminecraftframerendererresources-mce-framebuilder-bgfxbridge-vanillaminecraftframerendererresources-mce-framebuilder-bgfxbridge-holographicminecraftframerendererresources-sortedview-sortable-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-dragon-platform-registry-basicrenderregistry-dragon-frameobject-components-computedispatch-dragon-frameobject-components-viewsetid-dragon-frameobject-components-defaultpasses-alphatest-dragon-frameobject-components-defaultpasses-blit-dragon-frameobject-components-defaultpasses-opaque-dragon-frameobject-components-defaultpasses-stencilwrite-dragon-frameobject-components-defaultpasses-transparent-dragon-frameobject-components-defaultpasses-postfx-dragon-frameobject-components-defaultpasses-ui-dragon-frameobject-components-lightparameters-dragon-frameobject-components-directionallight-dragon-frameobject-components-ambientlight-dragon-frameobject-components-pointlight-dragon-frameobject-components-meshfilter-dragon-frameobject-components-materialfilter-dragon-frameobject-components-particleobject-dragon-frameobject-components-passstate-dragon-frameobject-components-posteffect-dragon-frameobject-components-rendertarget-dragon-frameobject-components-sceneobject-dragon-frameobject-components-sceneoverlayobject-dragon-frameobject-components-scenesky-dragon-frameobject-components-sceneskyobject-dragon-frameobject-components-selectionoverlayobject-dragon-frameobject-components-cubemap-dragon-frameobject-components-shadowsource-dragon-frameobject-components-shadowcaster-dragon-frameobject-components-shadowoverlay-dragon-frameobject-components-shadowvolume-dragon-frameobject-components-sortindex-dragon-frameobject-components-sortorigin-dragon-frameobject-components-transform-dragon-frameobject-components-uielement-dragon-frameobject-components-forcerasterization-dragon-frameobject-components-forcerasterizationwithmultiply-dragon-frameobject-components-raytraceobject-mce-framebuilder-gamecomponents-alphatestcracks-mce-framebuilder-gamecomponents-atmosphere-mce-framebuilder-gamecomponents-blendedcracksobject-mce-framebuilder-gamecomponents-environmentaltext-mce-framebuilder-gamecomponents-gameface-mce-framebuilder-gamecomponents-inlevelcubemapobject-mce-framebuilder-gamecomponents-iteminhandobject-mce-framebuilder-gamecomponents-sceneobjectactors-mce-framebuilder-gamecomponents-transparentiteminworldobject-mce-framebuilder-gamecomponents-waterholeobject-mce-framebuilder-gamecomponents-playerui-mce-framebuilder-gamecomponents-playervision-mce-framebuilder-gamecomponents-overlayui-mce-framebuilder-gamecomponents-vrconfiguration-mce-framebuilder-gamecomponents-vrpresenceobject-mce-framebuilder-gamecomponents-livingroomviewfilter-mce-framebuilder-gamecomponents-livingroomtransitionfilter-mce-framebuilder-gamecomponents-livingroomsceneobject-mce-framebuilder-gamecomponents-vrfloatinguiquad-mce-framebuilder-gamecomponents-fadetoblackeffect-mce-framebuilder-bgfxbridge-rtxminecraftframerendererresources-mce-framebuilder-bgfxbridge-vanillaminecraftframerendererresources-mce-framebuilder-bgfxbridge-holographicminecraftframerendererresources-sortedview-sortable-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;dragon::platform::registry::BasicRenderRegistry&lt;dragon::frameobject::components::ComputeDispatch,dragon::frameobject::components::ViewSetId,dragon::frameobject::components::defaultpasses::AlphaTest,dragon::frameobject::components::defaultpasses::Blit,dragon::frameobject::components::defaultpasses::Opaque,dragon::frameobject::components::defaultpasses::StencilWrite,dragon::frameobject::components::defaultpasses::Transparent,dragon::frameobject::components::defaultpasses::PostFX,dragon::frameobject::components::defaultpasses::UI,dragon::frameobject::components::LightParameters,dragon::frameobject::components::DirectionalLight,dragon::frameobject::components::AmbientLight,dragon::frameobject::components::PointLight,dragon::frameobject::components::MeshFilter,dragon::frameobject::components::MaterialFilter,dragon::frameobject::components::ParticleObject,dragon::frameobject::components::PassState,dragon::frameobject::components::PostEffect,dragon::frameobject::components::RenderTarget,dragon::frameobject::components::SceneObject,dragon::frameobject::components::SceneOverlayObject,dragon::frameobject::components::SceneSky,dragon::frameobject::components::SceneSkyObject,dragon::frameobject::components::SelectionOverlayObject,dragon::frameobject::components::Cubemap,dragon::frameobject::components::ShadowSource,dragon::frameobject::components::ShadowCaster,dragon::frameobject::components::ShadowOverlay,dragon::frameobject::components::ShadowVolume,dragon::frameobject::components::SortIndex,dragon::frameobject::components::SortOrigin,dragon::frameobject::components::Transform,dragon::frameobject::components::UIElement,dragon::frameobject::components::ForceRasterization,dragon::frameobject::components::ForceRasterizationWithMultiply,dragon::frameobject::components::RaytraceObject,mce::framebuilder::gamecomponents::AlphaTestCracks,mce::framebuilder::gamecomponents::Atmosphere,mce::framebuilder::gamecomponents::BlendedCracksObject,mce::framebuilder::gamecomponents::EnvironmentalText,mce::framebuilder::gamecomponents::Gameface,mce::framebuilder::gamecomponents::InLevelCubeMapObject,mce::framebuilder::gamecomponents::ItemInHandObject,mce::framebuilder::gamecomponents::SceneObjectActors,mce::framebuilder::gamecomponents::TransparentItemInWorldObject,mce::framebuilder::gamecomponents::WaterHoleObject,mce::framebuilder::gamecomponents::PlayerUI,mce::framebuilder::gamecomponents::PlayerVision,mce::framebuilder::gamecomponents::OverlayUI,mce::framebuilder::gamecomponents::VrConfiguration,mce::framebuilder::gamecomponents::VrPresenceObject,mce::framebuilder::gamecomponents::LivingRoomViewFilter,mce::framebuilder::gamecomponents::LivingRoomTransitionFilter,mce::framebuilder::gamecomponents::LivingRoomSceneObject,mce::framebuilder::gamecomponents::VrFloatingUiQuad,mce::framebuilder::gamecomponents::FadeToBlackEffect,mce::framebuilder::bgfxbridge::RTXMinecraftFrameRendererResources,mce::framebuilder::bgfxbridge::VanillaMinecraftFrameRendererResources,mce::framebuilder::bgfxbridge::HolographicMinecraftFrameRendererResources&gt;::SortedView::Sortable,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Core::CheckedRingBuffer&lt;2,0&gt; *</code></td> <td>mBufferInstance</td></tr></tbody></table> <h3 id="csframe"><a href="#csframe" class="header-anchor">#</a> <code>CsFrame</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CsFrame
{
  unsigned __int64 SavedR10;
  unsigned __int64 SavedR11;
};

</code></pre></div><h3 id="compoundtag-vtbl"><a href="#compoundtag-vtbl" class="header-anchor">#</a> <code>CompoundTag_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CompoundTag_vtbl
{
  void (__fastcall *~Tag)(Tag *this);
  void (__fastcall *deleteChildren)(Tag *this);
  void (__fastcall *write)(Tag *this, IDataOutput *);
  void (__fastcall *load)(Tag *this, IDataInput *);
  void (__fastcall *writeScriptData)(Tag *this, IDataOutput *);
  void (__fastcall *loadScriptData)(Tag *this, IDataInput *);
  std::string *(__fastcall *toString)(Tag *this, std::string *result);
  Tag::Type (__fastcall *getId)(Tag *this);
  bool (__fastcall *equals)(Tag *this, const Tag *);
  void (__fastcall *print)(Tag *this, const std::string *, PrintStream *);
  void (__fastcall *print)(Tag *this, PrintStream *);
  std::unique_ptr&lt;Tag&gt; *(__fastcall *copy)(Tag *this, std::unique_ptr&lt;Tag&gt; *result);
  unsigned __int64 (__fastcall *hash)(Tag *this);
};

</code></pre></div><h3 id="clockspritecalculator"><a href="#clockspritecalculator" class="header-anchor">#</a> <code>ClockSpriteCalculator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClockSpriteCalculator
{
  int mFrame;
  float mRot;
  float mRotA;
};

</code></pre></div><h3 id="core-pathbuffer-std-string"><a href="#core-pathbuffer-std-string" class="header-anchor">#</a> <code>Core::PathBuffer&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::PathBuffer&lt;std::string &gt;
{
  std::string mContainer;
};

</code></pre></div><h3 id="cg-rendermaterialbase-vtbl"><a href="#cg-rendermaterialbase-vtbl" class="header-anchor">#</a> <code>cg::RenderMaterialBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ cg::RenderMaterialBase_vtbl
{
  void (__fastcall *~RenderMaterialBase)(cg::RenderMaterialBase *this);
  void (__fastcall *parseRuntimeStates)(cg::RenderMaterialBase *this, const Json::Value *);
  void (__fastcall *appendShaderPathForGfxAPI)(cg::RenderMaterialBase *this);
  std::string *(__fastcall *buildHeader)(cg::RenderMaterialBase *this, std::string *result, const std::set&lt;std::string&gt; *);
  void (__fastcall *parseShader)(cg::RenderMaterialBase *this, const Json::Value *);
};

</code></pre></div><h3 id="cg-texturesetimagedescription-layerinfovar"><a href="#cg-texturesetimagedescription-layerinfovar" class="header-anchor">#</a> <code>cg::TextureSetImageDescription::LayerInfoVar</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TextureSetImageDescription::LayerInfoVar
{
  cg::TextureSetLayerType mLayerType;
  std::variant&lt;cg::ImageDescription,ColorChannel,mce::Color&gt; mData;
};

</code></pre></div><h3 id="connector"><a href="#connector" class="header-anchor">#</a> <code>Connector</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Connector
{
  Connector_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="connector-connectionstatelistener"><a href="#connector-connectionstatelistener" class="header-anchor">#</a> <code>Connector::ConnectionStateListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Connector::ConnectionStateListener
{
  Connector::ConnectionStateListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="connector-connectionstatelistener-vtbl"><a href="#connector-connectionstatelistener-vtbl" class="header-anchor">#</a> <code>Connector::ConnectionStateListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Connector::ConnectionStateListener_vtbl
{
  void (__fastcall *~ConnectionStateListener)(Connector::ConnectionStateListener *this);
  void (__fastcall *onConnectionStateChanged)(Connector::ConnectionStateListener *this, const std::string *, const std::string *, unsigned int, unsigned int, unsigned int, const std::string *);
};

</code></pre></div><h3 id="connector-vtbl"><a href="#connector-vtbl" class="header-anchor">#</a> <code>Connector_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Connector_vtbl
{
  void (__fastcall *~Connector)(Connector *this);
  std::vector&lt;std::string&gt; *(__fastcall *getLocalIps)(Connector *this, std::vector&lt;std::string&gt; *result);
  std::string *(__fastcall *getLocalIp)(Connector *this, std::string *result);
  unsigned __int16 (__fastcall *getPort)(Connector *this);
  std::vector&lt;RakNet::SystemAddress&gt; *(__fastcall *getRefinedLocalIps)(Connector *this, std::vector&lt;RakNet::SystemAddress&gt; *result);
  const Social::GameConnectionInfo *(__fastcall *getConnectedGameInfo)(Connector *this);
  void (__fastcall *setupNatPunch)(Connector *this, bool);
  Connector::NatPunchInfo *(__fastcall *getNatPunchInfo)(Connector *this, Connector::NatPunchInfo *result);
  void (__fastcall *startNatPunchingClient)(Connector *this, Social::GameConnectionInfo);
  void (__fastcall *addConnectionStateListener)(Connector *this, Connector::ConnectionStateListener *);
  void (__fastcall *removeConnectionStateListener)(Connector *this, Connector::ConnectionStateListener *);
  bool (__fastcall *isIPv4Supported)(Connector *this);
  bool (__fastcall *isIPv6Supported)(Connector *this);
  unsigned __int16 (__fastcall *getIPv4Port)(Connector *this);
  unsigned __int16 (__fastcall *getIPv6Port)(Connector *this);
  RakNet::RakNetGUID *(__fastcall *getGUID)(Connector *this, RakNet::RakNetGUID *result);
};

</code></pre></div><h3 id="core-fileimpl"><a href="#core-fileimpl" class="header-anchor">#</a> <code>Core::FileImpl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::FileImpl
{
  Core::FileImpl_vtbl *__vftable /*VFT*/;
  Core::FileOpenMode mOpenMode;
  Core::FileSystemImpl *mpTransaction;
  bool mLoggingEnabled;
};

</code></pre></div><h3 id="core-fileimpl-vtbl"><a href="#core-fileimpl-vtbl" class="header-anchor">#</a> <code>Core::FileImpl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::FileImpl_vtbl
{
  void (__fastcall *~FileImpl)(Core::FileImpl *this);
  Core::PathBuffer&lt;std::string &gt; *(__fastcall *_getPath)(Core::FileImpl *this, Core::PathBuffer&lt;std::string &gt; *result);
  unsigned __int64 (__fastcall *_getBlockSize)(Core::FileImpl *this);
  bool (__fastcall *_isOpen)(Core::FileImpl *this);
  Core::Result *(__fastcall *_close)(Core::FileImpl *this, Core::Result *result);
  Core::Result *(__fastcall *_read)(Core::FileImpl *this, Core::Result *result, void *, unsigned __int64, unsigned __int64 *);
  Core::Result *(__fastcall *_readExactly)(Core::FileImpl *this, Core::Result *result, void *, unsigned __int64);
  Core::Result *(__fastcall *_skip)(Core::FileImpl *this, Core::Result *result, unsigned __int64);
  Core::Result *(__fastcall *_readAtPosition)(Core::FileImpl *this, Core::Result *result, unsigned __int64, void *, unsigned __int64, unsigned __int64 *);
  Core::Result *(__fastcall *_getPosition)(Core::FileImpl *this, Core::Result *result, unsigned __int64 *);
  Core::Result *(__fastcall *_setPosition)(Core::FileImpl *this, Core::Result *result, unsigned __int64);
  Core::Result *(__fastcall *_write)(Core::FileImpl *this, Core::Result *result, const void *, unsigned __int64);
  Core::Result *(__fastcall *_flush)(Core::FileImpl *this, Core::Result *result);
  Core::Result *(__fastcall *_getSize)(Core::FileImpl *this, Core::Result *result, unsigned __int64 *);
  Core::Result *(__fastcall *_getRemainingSize)(Core::FileImpl *this, Core::Result *result, unsigned __int64 *);
};

</code></pre></div><h3 id="core-filesystemimpl"><a href="#core-filesystemimpl" class="header-anchor">#</a> <code>Core::FileSystemImpl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FileSystemImpl
{
  Core::FileSystemImpl_vtbl *__vftable /*VFT*/;
  std::shared_ptr&lt;Core::FileStorageArea&gt; mpStorageArea;
  bool mLoggingEnabled;
  bool mTransactionEnded;
  __declspec(align(4)) _BYTE mTransactionFlags[4];
  Core::FileAccessType mAccessType;
  Core::FileStats mStats;
  std::mutex mFileLock;
  std::vector&lt;Core::FileImpl *&gt; mFiles;
  Core::FlatFileSystemImpl mFlatFileSystem;
};

</code></pre></div><h3 id="core-directoryiterationitem"><a href="#core-directoryiterationitem" class="header-anchor">#</a> <code>Core::DirectoryIterationItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj Core::DirectoryIterationItem
{
  Core::PathBuffer&lt;std::string &gt; mFullPathName;
  Core::PathPart mName;
  unsigned __int64 mFileSize;
  unsigned __int64 mFileSizeAllocationOnDisk;
  _BYTE mType[4];
  __int64 mCreateTime;
  __int64 mModifyTime;
};

</code></pre></div><h3 id="core-filestoragearea"><a href="#core-filestoragearea" class="header-anchor">#</a> <code>Core::FileStorageArea</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::FileStorageArea : std::enable_shared_from_this&lt;Core::FileStorageArea&gt;
{
  Core::FileStorageArea_vtbl *__vftable /*VFT*/;
  std::recursive_mutex mLock;
  std::vector&lt;Core::FileSystemImpl *&gt; mAllTransactions;
  bool mCanAttemptExtendSave;
  bool mCachedFileUsageSize;
  Core::FileStats mTransactionStats;
  Core::FileStats mTotalStats;
  Core::FileAccessType mAccessType;
  Core::PathBuffer&lt;std::string &gt; mRootPath;
  std::vector&lt;Core::FileSystemImpl *&gt; mWriteTransactions;
  Core::Subject&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt; mSubject;
  std::shared_ptr&lt;Core::FileStorageArea&gt; mParent;
  Core::StorageAreaState mState;
  std::atomic&lt;bool&gt; mFileIOSuspended;
  std::condition_variable_any mResumeSignal;
  bool mLoggingEnabled;
  std::shared_ptr&lt;Core::FlatFileManifestTracker&gt; mManifestTracker;
  bool mIsAccessedDirectly;
};

</code></pre></div><h3 id="core-filestoragearea-vtbl"><a href="#core-filestoragearea-vtbl" class="header-anchor">#</a> <code>Core::FileStorageArea_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::FileStorageArea_vtbl
{
  void (__fastcall *~FileStorageArea)(Core::FileStorageArea *this);
  std::unique_ptr&lt;Core::FileSystemImpl&gt; *(__fastcall *createTransaction)(Core::FileStorageArea *this, std::unique_ptr&lt;Core::FileSystemImpl&gt; *result, Core::FileAccessType, Core::TransactionFlags);
  std::unique_ptr&lt;Core::FileSystemImpl&gt; *(__fastcall *createTransaction)(Core::FileStorageArea *this, std::unique_ptr&lt;Core::FileSystemImpl&gt; *result, Core::FileAccessType);
  bool (__fastcall *supportsSizeQuery)(Core::FileStorageArea *this);
  unsigned __int64 (__fastcall *getTotalSize)(Core::FileStorageArea *this);
  Core::Result *(__fastcall *getUsedSize)(Core::FileStorageArea *this, Core::Result *result, unsigned __int64 *);
  void (__fastcall *notifyChangeInFileSize)(Core::FileStorageArea *this, __int64, __int64);
  bool (__fastcall *handlesPendingWrites)(Core::FileStorageArea *this);
  void (__fastcall *informPendingWriteSize)(Core::FileStorageArea *this, const unsigned __int64 *, const bool);
  void (__fastcall *informStorageAreaCopy)(Core::FileStorageArea *this, const unsigned __int64 *);
  bool (__fastcall *supportsExtendSize)(Core::FileStorageArea *this);
  bool (__fastcall *canExtendSize)(Core::FileStorageArea *this);
  void (__fastcall *resetCanAttemptExtendSize)(Core::FileStorageArea *this);
  Core::Result *(__fastcall *getExtendSizeThreshold)(Core::FileStorageArea *this, Core::Result *result, unsigned __int64 *);
  void (__fastcall *attemptExtendSize)(Core::FileStorageArea *this, const __int64 *, std::function&lt;void __cdecl(void)&gt;);
  void (__fastcall *preemptiveExtendSize)(Core::FileStorageArea *this, const unsigned __int64, std::function&lt;void __cdecl(void)&gt;, std::function&lt;void __cdecl(void)&gt;);
  void (__fastcall *unloadFlatFileManifests)(Core::FileStorageArea *this, bool);
  bool (__fastcall *canFlushToDisk)(Core::FileStorageArea *this);
  bool (__fastcall *needsTick)(Core::FileStorageArea *this);
  void (__fastcall *tick)(Core::FileStorageArea *this);
  void (__fastcall *flushImmediately)(Core::FileStorageArea *this);
  void (__fastcall *enableFlushToDisk)(Core::FileStorageArea *this, bool);
  bool (__fastcall *checkCorrupt)(Core::FileStorageArea *this, bool);
  Core::FileStorageArea::FlushableLevelDbEnvType (__fastcall *getFlushableLevelDbEnvType)(Core::FileStorageArea *this);
  unsigned __int64 (__fastcall *getTransactionWriteSizeLimit)(Core::FileStorageArea *this);
  Core::Result *(__fastcall *setSaveDataIcon)(Core::FileStorageArea *this, Core::Result *result, const Core::Path *);
  bool (__fastcall *shouldAllowCommit)(Core::FileStorageArea *this);
  void (__fastcall *trackFileWriteSize)(Core::FileStorageArea *this, const unsigned __int64);
  Core::Result *(__fastcall *_commit)(Core::FileStorageArea *this, Core::Result *result);
  Core::Result *(__fastcall *_onTransactionsEmpty)(Core::FileStorageArea *this, Core::Result *result, bool);
  void (__fastcall *_onTeardown)(Core::FileStorageArea *this);
};

</code></pre></div><h3 id="core-observer-core-filestorageareaobserver-core-singlethreadedlock"><a href="#core-observer-core-filestorageareaobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-core-filestorageareaobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-core-filestorageareaobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-core-filestorageareaobserver-core-singlethreadedlock"><a href="#core-subject-core-filestorageareaobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;Core::FileStorageAreaObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="core-filestorageareaobserver"><a href="#core-filestorageareaobserver" class="header-anchor">#</a> <code>Core::FileStorageAreaObserver</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FileStorageAreaObserver : Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;
{
};

</code></pre></div><h3 id="core-filestorageareaobserver-vtbl"><a href="#core-filestorageareaobserver-vtbl" class="header-anchor">#</a> <code>Core::FileStorageAreaObserver_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::FileStorageAreaObserver_vtbl
{
  void (__fastcall *~Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;Core::FileStorageAreaObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onBeginWrites)(Core::FileStorageAreaObserver *this);
  void (__fastcall *_onEndWrites)(Core::FileStorageAreaObserver *this);
  void (__fastcall *_onWriteFile)(Core::FileStorageAreaObserver *this, Core::Path);
  void (__fastcall *_onDeleteFile)(Core::FileStorageAreaObserver *this, Core::Path);
};

</code></pre></div><h3 id="core-storageareastatelistener"><a href="#core-storageareastatelistener" class="header-anchor">#</a> <code>Core::StorageAreaStateListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::StorageAreaStateListener
{
  Core::StorageAreaStateListener_vtbl *__vftable /*VFT*/;
  std::shared_ptr&lt;Core::FileStorageArea&gt; mFileStorageArea;
  std::mutex mMutex;
};

</code></pre></div><h3 id="core-storageareastatelistener-vtbl"><a href="#core-storageareastatelistener-vtbl" class="header-anchor">#</a> <code>Core::StorageAreaStateListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::StorageAreaStateListener_vtbl
{
  void (__fastcall *~StorageAreaStateListener)(Core::StorageAreaStateListener *this);
  void (__fastcall *onExtendDiskSpace)(Core::StorageAreaStateListener *this, const bool, std::weak_ptr&lt;Core::FileStorageArea&gt; *, const unsigned __int64 *, std::function&lt;void __cdecl(void)&gt;);
  void (__fastcall *onLowDiskSpace)(Core::StorageAreaStateListener *this, const bool);
  void (__fastcall *onOutOfDiskSpace)(Core::StorageAreaStateListener *this, const bool);
  void (__fastcall *onCriticalDiskError)(Core::StorageAreaStateListener *this, const bool, const Core::LevelStorageState *);
};

</code></pre></div><h3 id="core-storageareastate"><a href="#core-storageareastate" class="header-anchor">#</a> <code>Core::StorageAreaState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::StorageAreaState
{
  std::mutex mMutex;
  Core::PathBuffer&lt;std::string &gt; mStorageAreaRootPath;
  std::atomic&lt;bool&gt; mIsExtendDiskSpaceEvent;
  std::atomic&lt;bool&gt; mIsLowDiskSpaceWarning;
  std::atomic&lt;bool&gt; mIsOutOfDiskSpaceError;
  std::atomic&lt;bool&gt; mIsCriticalDiskError;
  std::vector&lt;Core::StorageAreaStateListener *&gt; mListeners;
};

</code></pre></div><h3 id="core-flatfilemanifestinfo"><a href="#core-flatfilemanifestinfo" class="header-anchor">#</a> <code>Core::FlatFileManifestInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::FlatFileManifestInfo
{
  Core::PathBuffer&lt;std::string &gt; mPath;
  unsigned __int64 mSeekPos;
  unsigned __int64 mFileSize;
  unsigned __int8 mFlags;
};

</code></pre></div><h3 id="core-flatfilemanifest"><a href="#core-flatfilemanifest" class="header-anchor">#</a> <code>Core::FlatFileManifest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FlatFileManifest
{
  std::unordered_map&lt;std::string,unsigned __int64&gt; mManifestEntriesMap;
  std::vector&lt;Core::FlatFileManifestInfo&gt; mManifestInfoVector;
  unsigned __int64 mEntriesCount;
  unsigned __int64 mVersion;
  Core::PathBuffer&lt;std::string &gt; mManifestPath;
};

</code></pre></div><h3 id="core-flatfilemanifesttracker"><a href="#core-flatfilemanifesttracker" class="header-anchor">#</a> <code>Core::FlatFileManifestTracker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FlatFileManifestTracker
{
  std::mutex mManifestsLock;
  std::unordered_map&lt;std::string,std::shared_ptr&lt;Core::FlatFileManifest&gt;&gt; mManifestMap;
  std::set&lt;std::string&gt; mManifestNames;
};

</code></pre></div><h3 id="core-flatfilesystemimpl"><a href="#core-flatfilesystemimpl" class="header-anchor">#</a> <code>Core::FlatFileSystemImpl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FlatFileSystemImpl
{
  Core::FileSystemImpl *mFileSystemImpl;
  std::shared_ptr&lt;Core::FlatFileManifestTracker&gt; mFlatFileManifestTracker;
};

</code></pre></div><h3 id="crypto-symmetric-isysteminterface-vtbl"><a href="#crypto-symmetric-isysteminterface-vtbl" class="header-anchor">#</a> <code>Crypto::Symmetric::ISystemInterface_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Crypto::Symmetric::ISystemInterface_vtbl
{
  void (__fastcall *~ISystemInterface)(Crypto::Symmetric::ISystemInterface *this);
  void (__fastcall *init)(Crypto::Symmetric::ISystemInterface *this, const std::string *, const std::string *);
  void (__fastcall *encrypt)(Crypto::Symmetric::ISystemInterface *this, const std::string *, std::string *);
  void (__fastcall *decrypt)(Crypto::Symmetric::ISystemInterface *this, const std::string *, std::string *);
  unsigned __int64 (__fastcall *getKeySize)(Crypto::Symmetric::ISystemInterface *this);
  unsigned __int64 (__fastcall *getBlockSize)(Crypto::Symmetric::ISystemInterface *this);
  unsigned __int64 (__fastcall *getEncryptionBufferSize)(Crypto::Symmetric::ISystemInterface *this, const unsigned __int64);
  bool (__fastcall *encryptToBuffer)(Crypto::Symmetric::ISystemInterface *this, const char *, const unsigned __int64, char *, const unsigned __int64, unsigned __int64 *);
};

</code></pre></div><h3 id="crypto-symmetric-symmetric-vtbl"><a href="#crypto-symmetric-symmetric-vtbl" class="header-anchor">#</a> <code>Crypto::Symmetric::Symmetric_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Crypto::Symmetric::Symmetric_vtbl
{
  void (__fastcall *~ISystemInterface)(Crypto::Symmetric::ISystemInterface *this);
  void (__fastcall *init)(Crypto::Symmetric::ISystemInterface *this, const std::string *, const std::string *);
  void (__fastcall *encrypt)(Crypto::Symmetric::ISystemInterface *this, const std::string *, std::string *);
  void (__fastcall *decrypt)(Crypto::Symmetric::ISystemInterface *this, const std::string *, std::string *);
  unsigned __int64 (__fastcall *getKeySize)(Crypto::Symmetric::ISystemInterface *this);
  unsigned __int64 (__fastcall *getBlockSize)(Crypto::Symmetric::ISystemInterface *this);
  unsigned __int64 (__fastcall *getEncryptionBufferSize)(Crypto::Symmetric::ISystemInterface *this, const unsigned __int64);
  bool (__fastcall *encryptToBuffer)(Crypto::Symmetric::ISystemInterface *this, const char *, const unsigned __int64, char *, const unsigned __int64, unsigned __int64 *);
};

</code></pre></div><h3 id="crypto-hash-ihash-vtbl"><a href="#crypto-hash-ihash-vtbl" class="header-anchor">#</a> <code>Crypto::Hash::IHash_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Crypto::Hash::IHash_vtbl
{
  void (__fastcall *~IHash)(Crypto::Hash::IHash *this);
  void (__fastcall *reset)(Crypto::Hash::IHash *this);
  void (__fastcall *update)(Crypto::Hash::IHash *this, const void *, unsigned int);
  void (__fastcall *final)(Crypto::Hash::IHash *this, unsigned __int8 *);
  unsigned __int64 (__fastcall *resultSize)(Crypto::Hash::IHash *this);
};

</code></pre></div><h3 id="crypto-hash-hmac"><a href="#crypto-hash-hmac" class="header-anchor">#</a> <code>Crypto::Hash::HMAC</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Crypto::Hash::HMAC
{
  std::unique_ptr&lt;Crypto::Hash::IHash&gt; mHash;
  std::string mKey;
  int mResultSize;
};

</code></pre></div><h3 id="correctplayermovepredictionpacket"><a href="#correctplayermovepredictionpacket" class="header-anchor">#</a> <code>CorrectPlayerMovePredictionPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) CorrectPlayerMovePredictionPacket : Packet
{
  Vec3 mPos;
  Vec3 mPosDelta;
  unsigned __int64 mTick;
  bool mOnGround;
};

</code></pre></div><h3 id="correctplayermovepredictionpacket-vtbl"><a href="#correctplayermovepredictionpacket-vtbl" class="header-anchor">#</a> <code>CorrectPlayerMovePredictionPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CorrectPlayerMovePredictionPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="codebuilderpacket"><a href="#codebuilderpacket" class="header-anchor">#</a> <code>CodeBuilderPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) CodeBuilderPacket : Packet
{
  std::string mURL;
  bool mShouldOpenCodeBuilder;
};

</code></pre></div><h3 id="codebuilderpacket-vtbl"><a href="#codebuilderpacket-vtbl" class="header-anchor">#</a> <code>CodeBuilderPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CodeBuilderPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="creativeitemregistry"><a href="#creativeitemregistry" class="header-anchor">#</a> <code>CreativeItemRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreativeItemRegistry : Bedrock::EnableNonOwnerReferences
{
  std::vector&lt;CreativeItemEntry&gt; mCreativeItems;
  std::vector&lt;CreativeGroupInfo&gt; mCreativeGroups;
  std::unordered_map&lt;enum CreativeItemCategory,CreativeItemGroupCategory&gt; mCreativeGroupCategories;
  std::unordered_map&lt;TypedServerNetId&lt;CreativeItemNetIdTag,unsigned int,0&gt;,unsigned __int64,std::hash&lt;TypedServerNetId&lt;CreativeItemNetIdTag,unsigned int,0&gt; &gt;,std::equal_to&lt;TypedServerNetId&lt;CreativeItemNetIdTag,unsigned int,0&gt; &gt;,std::allocator&lt;std::pair&lt;TypedServerNetId&lt;CreativeItemNetIdTag,unsigned int,0&gt; const ,unsigned __int64&gt; &gt; &gt; mCreativeNetIdIndex;
};

</code></pre></div><h3 id="creativegroupinfo"><a href="#creativegroupinfo" class="header-anchor">#</a> <code>CreativeGroupInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreativeGroupInfo : Bedrock::EnableNonOwnerReferences
{
  CreativeItemCategory mCategory;
  CreativeItemRegistry *mRegistry;
  HashedString mName;
  ItemInstance mIcon;
  unsigned int mIndex;
  std::vector&lt;unsigned int&gt; mItemIndexes;
};

</code></pre></div><h3 id="creativeitemgroupcategory"><a href="#creativeitemgroupcategory" class="header-anchor">#</a> <code>CreativeItemGroupCategory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreativeItemGroupCategory : Bedrock::EnableNonOwnerReferences
{
  std::string mName;
  CreativeItemCategory mCategory;
  CreativeItemRegistry *mRegistry;
  std::unordered_map&lt;HashedString,unsigned int&gt; mNamedGroupIndex;
  std::vector&lt;unsigned int&gt; mGroupIndexes;
};

</code></pre></div><h3 id="creativecontentpacket"><a href="#creativecontentpacket" class="header-anchor">#</a> <code>CreativeContentPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj CreativeContentPacket : Packet
{
  const std::vector&lt;CreativeItemEntry&gt; *mWriteEntries;
  std::vector&lt;CreativeItemEntry&gt; mReadEntries;
};

</code></pre></div><h3 id="creativecontentpacket-vtbl"><a href="#creativecontentpacket-vtbl" class="header-anchor">#</a> <code>CreativeContentPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CreativeContentPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="confirmskinpacket"><a href="#confirmskinpacket" class="header-anchor">#</a> <code>ConfirmSkinPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ConfirmSkinPacket : Packet
{
  std::vector&lt;ConfirmSkinPacket::ConfirmSkinEntry&gt; mEntries;
};

</code></pre></div><h3 id="confirmskinpacket-vtbl"><a href="#confirmskinpacket-vtbl" class="header-anchor">#</a> <code>ConfirmSkinPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConfirmSkinPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="changemodeltexturepacket-vtbl"><a href="#changemodeltexturepacket-vtbl" class="header-anchor">#</a> <code>ChangeModelTexturePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChangeModelTexturePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="changemodeloffsetpacket"><a href="#changemodeloffsetpacket" class="header-anchor">#</a> <code>ChangeModelOffsetPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) ChangeModelOffsetPacket : Packet
{
  ActorUniqueID mEntityId;
  Vec3 mModelOffset;
};

</code></pre></div><h3 id="changemodeloffsetpacket-vtbl"><a href="#changemodeloffsetpacket-vtbl" class="header-anchor">#</a> <code>ChangeModelOffsetPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChangeModelOffsetPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="changemodelbindpacket"><a href="#changemodelbindpacket" class="header-anchor">#</a> <code>ChangeModelBindPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ChangeModelBindPacket : Packet
{
  ActorUniqueID mEntityId;
  ActorUniqueID mBindEntityId;
};

</code></pre></div><h3 id="changemodelbindpacket-vtbl"><a href="#changemodelbindpacket-vtbl" class="header-anchor">#</a> <code>ChangeModelBindPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChangeModelBindPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="changemodelpacket-vtbl"><a href="#changemodelpacket-vtbl" class="header-anchor">#</a> <code>ChangeModelPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChangeModelPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="combinepacket"><a href="#combinepacket" class="header-anchor">#</a> <code>CombinePacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj CombinePacket : Packet
{
  unsigned __int8 mCount;
  std::string mContent;
};

</code></pre></div><h3 id="combinepacket-vtbl"><a href="#combinepacket-vtbl" class="header-anchor">#</a> <code>CombinePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CombinePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="custompacket-vtbl"><a href="#custompacket-vtbl" class="header-anchor">#</a> <code>CustomPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CustomPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="complexinventorytransaction-vtbl"><a href="#complexinventorytransaction-vtbl" class="header-anchor">#</a> <code>ComplexInventoryTransaction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ComplexInventoryTransaction_vtbl
{
  void (__fastcall *~ComplexInventoryTransaction)(ComplexInventoryTransaction *this);
  void (__fastcall *read)(ComplexInventoryTransaction *this, ReadOnlyBinaryStream *);
  void (__fastcall *write)(ComplexInventoryTransaction *this, BinaryStream *);
  InventoryTransactionError (__fastcall *handle)(ComplexInventoryTransaction *this, Player *, bool);
  void (__fastcall *onTransactionError)(ComplexInventoryTransaction *this, Player *, InventoryTransactionError);
};

</code></pre></div><h3 id="camerashakepacket"><a href="#camerashakepacket" class="header-anchor">#</a> <code>CameraShakePacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) CameraShakePacket : Packet
{
  float mIntensity;
  float mSeconds;
  CameraShakeType mShakeType;
};

</code></pre></div><h3 id="camerashakepacket-vtbl"><a href="#camerashakepacket-vtbl" class="header-anchor">#</a> <code>CameraShakePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraShakePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="camerapacket"><a href="#camerapacket" class="header-anchor">#</a> <code>CameraPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj CameraPacket : Packet
{
  ActorUniqueID mCameraId;
  ActorUniqueID mTargetPlayerId;
};

</code></pre></div><h3 id="camerapacket-vtbl"><a href="#camerapacket-vtbl" class="header-anchor">#</a> <code>CameraPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="completedusingitempacket"><a href="#completedusingitempacket" class="header-anchor">#</a> <code>CompletedUsingItemPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj CompletedUsingItemPacket : Packet
{
  __int16 mItemId;
  int mItemUseMethod;
  std::optional&lt;ItemStack&gt; mItemStack;
};

</code></pre></div><h3 id="completedusingitempacket-vtbl"><a href="#completedusingitempacket-vtbl" class="header-anchor">#</a> <code>CompletedUsingItemPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CompletedUsingItemPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="commandblockupdatepacket-vtbl"><a href="#commandblockupdatepacket-vtbl" class="header-anchor">#</a> <code>CommandBlockUpdatePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandBlockUpdatePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="commandpropertybag"><a href="#commandpropertybag" class="header-anchor">#</a> <code>CommandPropertyBag</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandPropertyBag : PropertyBag
{
  CommandPropertyBag_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="commandpropertybag-vtbl"><a href="#commandpropertybag-vtbl" class="header-anchor">#</a> <code>CommandPropertyBag_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandPropertyBag_vtbl
{
  void (__fastcall *~CommandPropertyBag)(CommandPropertyBag *this);
};

</code></pre></div><h3 id="commandoutput"><a href="#commandoutput" class="header-anchor">#</a> <code>CommandOutput</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CommandOutput
{
  _BYTE mType[4];
  std::unique_ptr&lt;CommandPropertyBag&gt; mBag;
  std::vector&lt;CommandOutputMessage&gt; mMessages;
  int mSuccessCount;
};

</code></pre></div><h3 id="commandoutputpacket"><a href="#commandoutputpacket" class="header-anchor">#</a> <code>CommandOutputPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj CommandOutputPacket : Packet
{
  CommandOriginData mOriginData;
  CommandOutput mOutput;
};

</code></pre></div><h3 id="commandoutputpacket-vtbl"><a href="#commandoutputpacket-vtbl" class="header-anchor">#</a> <code>CommandOutputPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandOutputPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="commandrequestpacket"><a href="#commandrequestpacket" class="header-anchor">#</a> <code>CommandRequestPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) CommandRequestPacket : Packet
{
  std::string mCommand;
  CommandOriginData mOrigin;
  bool mInternalSource;
  bool mUnLimit;
};

</code></pre></div><h3 id="commandrequestpacket-vtbl"><a href="#commandrequestpacket-vtbl" class="header-anchor">#</a> <code>CommandRequestPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandRequestPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="chunkradiusupdatedpacket"><a href="#chunkradiusupdatedpacket" class="header-anchor">#</a> <code>ChunkRadiusUpdatedPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) ChunkRadiusUpdatedPacket : Packet
{
  int mChunkRadius;
};

</code></pre></div><h3 id="chunkradiusupdatedpacket-vtbl"><a href="#chunkradiusupdatedpacket-vtbl" class="header-anchor">#</a> <code>ChunkRadiusUpdatedPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChunkRadiusUpdatedPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="clientcachestatuspacket"><a href="#clientcachestatuspacket" class="header-anchor">#</a> <code>ClientCacheStatusPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) ClientCacheStatusPacket : Packet
{
  bool mEnabled;
};

</code></pre></div><h3 id="clientcachestatuspacket-vtbl"><a href="#clientcachestatuspacket-vtbl" class="header-anchor">#</a> <code>ClientCacheStatusPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientCacheStatusPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="clientboundmapitemdatapacket-vtbl"><a href="#clientboundmapitemdatapacket-vtbl" class="header-anchor">#</a> <code>ClientboundMapItemDataPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientboundMapItemDataPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="changedimensionpacket"><a href="#changedimensionpacket" class="header-anchor">#</a> <code>ChangeDimensionPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) ChangeDimensionPacket : Packet
{
  AutomaticID&lt;Dimension,int&gt; mDimensionId;
  Vec3 mPos;
  bool mRespawn;
};

</code></pre></div><h3 id="changedimensionpacket-vtbl"><a href="#changedimensionpacket-vtbl" class="header-anchor">#</a> <code>ChangeDimensionPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChangeDimensionPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="clientcachemissresponsepacket"><a href="#clientcachemissresponsepacket" class="header-anchor">#</a> <code>ClientCacheMissResponsePacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientCacheMissResponsePacket : Packet
{
  std::vector&lt;std::shared_ptr&lt;ClientBlobCache::Server::Blob&gt;&gt; mWriteMissingContent;
  std::unordered_map&lt;unsigned __int64,std::string&gt; mReceivedMissingContent;
};

</code></pre></div><h3 id="clientcachemissresponsepacket-vtbl"><a href="#clientcachemissresponsepacket-vtbl" class="header-anchor">#</a> <code>ClientCacheMissResponsePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientCacheMissResponsePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="clientcacheblobstatuspacket"><a href="#clientcacheblobstatuspacket" class="header-anchor">#</a> <code>ClientCacheBlobStatusPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ClientCacheBlobStatusPacket : Packet
{
  std::vector&lt;unsigned __int64&gt; mMissingIds;
  std::vector&lt;unsigned __int64&gt; mFoundIds;
};

</code></pre></div><h3 id="clientcacheblobstatuspacket-vtbl"><a href="#clientcacheblobstatuspacket-vtbl" class="header-anchor">#</a> <code>ClientCacheBlobStatusPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientCacheBlobStatusPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="craftingeventpacket"><a href="#craftingeventpacket" class="header-anchor">#</a> <code>CraftingEventPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj CraftingEventPacket : Packet
{
  ContainerID mContainerId;
  int mContainerType;
  mce::UUID mRecipeId;
  std::vector&lt;ItemStack&gt; mInputItems;
  std::vector&lt;ItemStack&gt; mOutputItems;
};

</code></pre></div><h3 id="craftingeventpacket-vtbl"><a href="#craftingeventpacket-vtbl" class="header-anchor">#</a> <code>CraftingEventPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftingEventPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="containercontentchangelistener-vtbl"><a href="#containercontentchangelistener-vtbl" class="header-anchor">#</a> <code>ContainerContentChangeListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerContentChangeListener_vtbl
{
  void (__fastcall *containerContentChanged)(ContainerContentChangeListener *this, int);
  void (__fastcall *~ContainerContentChangeListener)(ContainerContentChangeListener *this);
  void (__fastcall *containerAddCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *containerRemoveCallback)(ContainerContentChangeListener *this, Container *);
};

</code></pre></div><h3 id="container-vtbl"><a href="#container-vtbl" class="header-anchor">#</a> <code>Container_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Container_vtbl
{
  void (__fastcall *~Container)(Container *this);
  void (__fastcall *init)(Container *this);
  void (__fastcall *serverInitItemStackIds)(Container *this, int, int, std::function&lt;void __cdecl(int,ItemStack const &amp;)&gt;);
  void (__fastcall *addContentChangeListener)(Container *this, ContainerContentChangeListener *);
  void (__fastcall *removeContentChangeListener)(Container *this, ContainerContentChangeListener *);
  const ItemStack *(__fastcall *getItem)(Container *this, int);
  bool (__fastcall *hasRoomForItem)(Container *this, const ItemStack *);
  void (__fastcall *addItem)(Container *this, ItemStack *);
  bool (__fastcall *addItemToFirstEmptySlot)(Container *this, ItemStack *);
  void (__fastcall *setItem)(Container *this, int, const ItemStack *);
  void (__fastcall *setItemWithForceBalance)(Container *this, int, const ItemStack *, bool);
  void (__fastcall *removeItem)(Container *this, int, int);
  void (__fastcall *removeAllItems)(Container *this);
  void (__fastcall *dropContents)(Container *this, BlockSource *, const Vec3 *, bool);
  int (__fastcall *getContainerSize)(Container *this);
  int (__fastcall *getMaxStackSize)(Container *this);
  void (__fastcall *startOpen)(Container *this, Player *);
  void (__fastcall *stopOpen)(Container *this, Player *);
  std::vector&lt;ItemStack&gt; *(__fastcall *getSlotCopies)(Container *this, std::vector&lt;ItemStack&gt; *result);
  const std::vector&lt;ItemStack const *&gt; *(__fastcall *getSlots)(Container *this, const std::vector&lt;ItemStack const *&gt; *result);
  int (__fastcall *getItemCount)(Container *this, const ItemStack *);
  int (__fastcall *findFirstSlotForItem)(Container *this, const ItemStack *);
  bool (__fastcall *canPushInItem)(Container *this, BlockSource *, int, int, const ItemInstance *);
  bool (__fastcall *canPullOutItem)(Container *this, BlockSource *, int, int, const ItemInstance *);
  void (__fastcall *setContainerChanged)(Container *this, int);
  void (__fastcall *setContainerMoved)(Container *this);
  void (__fastcall *setCustomName)(Container *this, const std::string *);
  bool (__fastcall *hasCustomName)(Container *this);
  void (__fastcall *readAdditionalSaveData)(Container *this, const CompoundTag *);
  void (__fastcall *addAdditionalSaveData)(Container *this, CompoundTag *);
  void (__fastcall *createTransactionContext)(Container *this, std::function&lt;void __cdecl(Container &amp;,int,ItemStack const &amp;,ItemStack const &amp;)&gt;, std::function&lt;void __cdecl(void)&gt;);
  void (__fastcall *initializeContainerContents)(Container *this, BlockSource *);
  bool (__fastcall *reviewItems)(Container *this, Level *);
};

</code></pre></div><h3 id="containersizechangelistener"><a href="#containersizechangelistener" class="header-anchor">#</a> <code>ContainerSizeChangeListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerSizeChangeListener
{
  ContainerSizeChangeListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="containersizechangelistener-vtbl"><a href="#containersizechangelistener-vtbl" class="header-anchor">#</a> <code>ContainerSizeChangeListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerSizeChangeListener_vtbl
{
  void (__fastcall *containerSizeChanged)(ContainerSizeChangeListener *this, int);
  void (__fastcall *~ContainerSizeChangeListener)(ContainerSizeChangeListener *this);
};

</code></pre></div><h3 id="craftingcontainer-vtbl"><a href="#craftingcontainer-vtbl" class="header-anchor">#</a> <code>CraftingContainer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftingContainer_vtbl
{
  void (__fastcall *~Container)(Container *this);
  void (__fastcall *init)(Container *this);
  void (__fastcall *serverInitItemStackIds)(Container *this, int, int, std::function&lt;void __cdecl(int,ItemStack const &amp;)&gt;);
  void (__fastcall *addContentChangeListener)(Container *this, ContainerContentChangeListener *);
  void (__fastcall *removeContentChangeListener)(Container *this, ContainerContentChangeListener *);
  const ItemStack *(__fastcall *getItem)(Container *this, int);
  bool (__fastcall *hasRoomForItem)(Container *this, const ItemStack *);
  void (__fastcall *addItem)(Container *this, ItemStack *);
  bool (__fastcall *addItemToFirstEmptySlot)(Container *this, ItemStack *);
  void (__fastcall *setItem)(Container *this, int, const ItemStack *);
  void (__fastcall *setItemWithForceBalance)(Container *this, int, const ItemStack *, bool);
  void (__fastcall *removeItem)(Container *this, int, int);
  void (__fastcall *removeAllItems)(Container *this);
  void (__fastcall *dropContents)(Container *this, BlockSource *, const Vec3 *, bool);
  int (__fastcall *getContainerSize)(Container *this);
  int (__fastcall *getMaxStackSize)(Container *this);
  void (__fastcall *startOpen)(Container *this, Player *);
  void (__fastcall *stopOpen)(Container *this, Player *);
  std::vector&lt;ItemStack&gt; *(__fastcall *getSlotCopies)(Container *this, std::vector&lt;ItemStack&gt; *result);
  const std::vector&lt;ItemStack const *&gt; *(__fastcall *getSlots)(Container *this, const std::vector&lt;ItemStack const *&gt; *result);
  int (__fastcall *getItemCount)(Container *this, const ItemStack *);
  int (__fastcall *findFirstSlotForItem)(Container *this, const ItemStack *);
  bool (__fastcall *canPushInItem)(Container *this, BlockSource *, int, int, const ItemInstance *);
  bool (__fastcall *canPullOutItem)(Container *this, BlockSource *, int, int, const ItemInstance *);
  void (__fastcall *setContainerChanged)(Container *this, int);
  void (__fastcall *setContainerMoved)(Container *this);
  void (__fastcall *setCustomName)(Container *this, const std::string *);
  bool (__fastcall *hasCustomName)(Container *this);
  void (__fastcall *readAdditionalSaveData)(Container *this, const CompoundTag *);
  void (__fastcall *addAdditionalSaveData)(Container *this, CompoundTag *);
  void (__fastcall *createTransactionContext)(Container *this, std::function&lt;void __cdecl(Container &amp;,int,ItemStack const &amp;,ItemStack const &amp;)&gt;, std::function&lt;void __cdecl(void)&gt;);
  void (__fastcall *initializeContainerContents)(Container *this, BlockSource *);
  bool (__fastcall *reviewItems)(Container *this, Level *);
};

</code></pre></div><h3 id="containermixdataentry"><a href="#containermixdataentry" class="header-anchor">#</a> <code>ContainerMixDataEntry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct ContainerMixDataEntry
{
  int fromItemId;
  int reagentItemId;
  int toItemId;
};

</code></pre></div><h3 id="craftingdatapacket"><a href="#craftingdatapacket" class="header-anchor">#</a> <code>CraftingDataPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) CraftingDataPacket : Packet
{
  std::vector&lt;CraftingDataEntry&gt; mCraftingEntries;
  std::vector&lt;PotionMixDataEntry&gt; mPotionMixEntries;
  std::vector&lt;ContainerMixDataEntry&gt; mContainerMixEntries;
  std::vector&lt;DurabilityDataEntry&gt; mDurabilityDataEntries;
  bool mClearRecipes;
};

</code></pre></div><h3 id="craftingdatapacket-vtbl"><a href="#craftingdatapacket-vtbl" class="header-anchor">#</a> <code>CraftingDataPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CraftingDataPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="containersetdatapacket"><a href="#containersetdatapacket" class="header-anchor">#</a> <code>ContainerSetDataPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) ContainerSetDataPacket : Packet
{
  int mId;
  int mValue;
  ContainerID mContainerId;
};

</code></pre></div><h3 id="containersetdatapacket-vtbl"><a href="#containersetdatapacket-vtbl" class="header-anchor">#</a> <code>ContainerSetDataPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerSetDataPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="containerclosepacket"><a href="#containerclosepacket" class="header-anchor">#</a> <code>ContainerClosePacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) ContainerClosePacket : Packet
{
  ContainerID mContainerId;
  bool mServerInitiatedClose;
};

</code></pre></div><h3 id="containerclosepacket-vtbl"><a href="#containerclosepacket-vtbl" class="header-anchor">#</a> <code>ContainerClosePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerClosePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="containeropenpacket-vtbl"><a href="#containeropenpacket-vtbl" class="header-anchor">#</a> <code>ContainerOpenPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerOpenPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="clienttoserverhandshakepacket"><a href="#clienttoserverhandshakepacket" class="header-anchor">#</a> <code>ClientToServerHandshakePacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ClientToServerHandshakePacket : Packet
{
};

</code></pre></div><h3 id="clienttoserverhandshakepacket-vtbl"><a href="#clienttoserverhandshakepacket-vtbl" class="header-anchor">#</a> <code>ClientToServerHandshakePacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientToServerHandshakePacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="certificate"><a href="#certificate" class="header-anchor">#</a> <code>Certificate</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Certificate
{
  UnverifiedCertificate mUnverifiedCertificate;
  std::unique_ptr&lt;Certificate&gt; mParentCertificate;
  bool mIsValid;
};

</code></pre></div><h3 id="compositepacksource"><a href="#compositepacksource" class="header-anchor">#</a> <code>CompositePackSource</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompositePackSource : PackSource
{
  std::vector&lt;PackSource *&gt; mPackSources;
};

</code></pre></div><h3 id="compositepacksource-vtbl"><a href="#compositepacksource-vtbl" class="header-anchor">#</a> <code>CompositePackSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CompositePackSource_vtbl
{
  void (__fastcall *~PackSource)(PackSource *this);
  void (__fastcall *forEachPackConst)(PackSource *this, std::function&lt;void __cdecl(Pack const &amp;)&gt;);
  void (__fastcall *forEachPack)(PackSource *this, std::function&lt;void __cdecl(Pack &amp;)&gt;);
  PackOrigin (__fastcall *getPackOrigin)(PackSource *this);
  PackType (__fastcall *getPackType)(PackSource *this);
  PackSourceReport *(__fastcall *load)(PackSource *this, PackSourceReport *result, PackManifestFactory *, const IContentKeyProvider *);
  void (__fastcall *addPackSource)(PackSource *this, PackSource *);
};

</code></pre></div><h3 id="core-observer-webviewobserver-core-singlethreadedlock"><a href="#core-observer-webviewobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;WebviewObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;WebviewObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;WebviewObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;WebviewObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-webviewobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-webviewobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;WebviewObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;WebviewObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;WebviewObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;WebviewObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;WebviewObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-webviewobserver-core-singlethreadedlock"><a href="#core-subject-webviewobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;WebviewObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;WebviewObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;WebviewObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="chatoptions"><a href="#chatoptions" class="header-anchor">#</a> <code>ChatOptions</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChatOptions
{
  std::map&lt;enum OptionID,ChatOptions::ChatOption&gt; mChatOptions;
};

</code></pre></div><h3 id="core-observer-optionsobserver-core-singlethreadedlock"><a href="#core-observer-optionsobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;OptionsObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-optionsobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-optionsobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-optionsobserver-core-singlethreadedlock"><a href="#core-subject-optionsobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;OptionsObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;OptionsObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;OptionsObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="core-observer-social-xboxliveuserobserver-core-singlethreadedlock"><a href="#core-observer-social-xboxliveuserobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-social-xboxliveuserobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-social-xboxliveuserobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-social-xboxliveuserobserver-core-singlethreadedlock"><a href="#core-subject-social-xboxliveuserobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;Social::XboxLiveUserObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;Social::XboxLiveUserObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="contenttiermanager"><a href="#contenttiermanager" class="header-anchor">#</a> <code>ContentTierManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ContentTierManager
{
  int mMemoryTier;
};

</code></pre></div><h3 id="commandregistry-parsetoken"><a href="#commandregistry-parsetoken" class="header-anchor">#</a> <code>CommandRegistry::ParseToken</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::ParseToken
{
  std::unique_ptr&lt;CommandRegistry::ParseToken&gt; child;
  std::unique_ptr&lt;CommandRegistry::ParseToken&gt; next;
  CommandRegistry::ParseToken *parent;
  const char *text;
  unsigned int length;
  CommandRegistry::Symbol type;
};

</code></pre></div><h3 id="commandregistry-parserule"><a href="#commandregistry-parserule" class="header-anchor">#</a> <code>CommandRegistry::ParseRule</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::ParseRule
{
  CommandRegistry::Symbol nonTerminal;
  std::function&lt;CommandRegistry::ParseToken * __cdecl(CommandRegistry::ParseToken &amp;,CommandRegistry::Symbol)&gt; process;
  std::vector&lt;CommandRegistry::Symbol&gt; derivation;
  CommandVersion versions;
};

</code></pre></div><h3 id="commandregistry-parsetable"><a href="#commandregistry-parsetable" class="header-anchor">#</a> <code>CommandRegistry::ParseTable</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::ParseTable
{
  std::map&lt;CommandRegistry::Symbol,std::vector&lt;CommandRegistry::Symbol&gt;&gt; first;
  std::map&lt;CommandRegistry::Symbol,std::vector&lt;CommandRegistry::Symbol&gt;&gt; follow;
  std::map&lt;std::pair&lt;CommandRegistry::Symbol,CommandRegistry::Symbol&gt;,int,std::less&lt;std::pair&lt;CommandRegistry::Symbol,CommandRegistry::Symbol&gt; &gt;,std::allocator&lt;std::pair&lt;std::pair&lt;CommandRegistry::Symbol,CommandRegistry::Symbol&gt; const ,int&gt; &gt; &gt; predict;
};

</code></pre></div><h3 id="commandregistry-optionalparameterchain"><a href="#commandregistry-optionalparameterchain" class="header-anchor">#</a> <code>CommandRegistry::OptionalParameterChain</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::OptionalParameterChain
{
  int parameterCount;
  int followingRuleIndex;
  CommandRegistry::Symbol paramSymbol;
};

</code></pre></div><h3 id="customparticle"><a href="#customparticle" class="header-anchor">#</a> <code>CustomParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomParticle
{
  CustomParticle_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="customparticle-vtbl"><a href="#customparticle-vtbl" class="header-anchor">#</a> <code>CustomParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CustomParticle_vtbl
{
  void (__fastcall *~CustomParticle)(CustomParticle *this);
  void (__fastcall *normalTick)(CustomParticle *this);
  void (__fastcall *render)(CustomParticle *this, BaseActorRenderContext *, const Vec3 *, float);
  bool (__fastcall *isRemoved)(CustomParticle *this);
};

</code></pre></div><h3 id="chunksource-vtbl"><a href="#chunksource-vtbl" class="header-anchor">#</a> <code>ChunkSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChunkSource_vtbl
{
  void (__fastcall *~ChunkSource)(ChunkSource *this);
  void (__fastcall *shutdown)(ChunkSource *this);
  bool (__fastcall *isShutdownDone)(ChunkSource *this);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getExistingChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getRandomChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, Random *);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *createNewChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *, ChunkSource::LoadMode);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getOrLoadChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *, ChunkSource::LoadMode);
  bool (__fastcall *postProcess)(ChunkSource *this, ChunkViewSource *);
  void (__fastcall *checkAndReplaceChunk)(ChunkSource *this, ChunkViewSource *, LevelChunk *);
  void (__fastcall *loadChunk)(ChunkSource *this, LevelChunk *, bool);
  void (__fastcall *postProcessMobsAt)(ChunkSource *this, BlockSource *, int, int, Random *);
  bool (__fastcall *saveLiveChunk)(ChunkSource *this, LevelChunk *);
  void (__fastcall *hintDiscardBatchBegin)(ChunkSource *this);
  void (__fastcall *hintDiscardBatchEnd)(ChunkSource *this);
  void (__fastcall *acquireDiscarded)(ChunkSource *this, std::unique_ptr&lt;LevelChunk,LevelChunkFinalDeleter&gt;);
  void (__fastcall *compact)(ChunkSource *this);
  void (__fastcall *flushPendingWrites)(ChunkSource *this);
  bool (__fastcall *isWithinWorldLimit)(ChunkSource *this, const ChunkPos *);
  const std::unordered_map&lt;ChunkPos,std::weak_ptr&lt;LevelChunk&gt;&gt; *(__fastcall *getChunkMap)(ChunkSource *this);
  const std::unordered_map&lt;ChunkPos,std::weak_ptr&lt;LevelChunk&gt;&gt; *(__fastcall *getStorage)(ChunkSource *this);
  void (__fastcall *clearDeletedEntities)(ChunkSource *this);
  void (__fastcall *removeDimensionData)(ChunkSource *this, const std::unordered_set&lt;AutomaticID&lt;Dimension,int&gt;&gt; *);
  bool (__fastcall *hasChunk)(ChunkSource *this, const ChunkPos *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *canCreateViews)(ChunkSource *this);
};

</code></pre></div><h3 id="chunkviewsource-vtbl"><a href="#chunkviewsource-vtbl" class="header-anchor">#</a> <code>ChunkViewSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChunkViewSource_vtbl
{
  void (__fastcall *~ChunkSource)(ChunkSource *this);
  void (__fastcall *shutdown)(ChunkSource *this);
  bool (__fastcall *isShutdownDone)(ChunkSource *this);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getExistingChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getRandomChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, Random *);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *createNewChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *, ChunkSource::LoadMode);
  std::shared_ptr&lt;LevelChunk&gt; *(__fastcall *getOrLoadChunk)(ChunkSource *this, std::shared_ptr&lt;LevelChunk&gt; *result, const ChunkPos *, ChunkSource::LoadMode);
  bool (__fastcall *postProcess)(ChunkSource *this, ChunkViewSource *);
  void (__fastcall *checkAndReplaceChunk)(ChunkSource *this, ChunkViewSource *, LevelChunk *);
  void (__fastcall *loadChunk)(ChunkSource *this, LevelChunk *, bool);
  void (__fastcall *postProcessMobsAt)(ChunkSource *this, BlockSource *, int, int, Random *);
  bool (__fastcall *saveLiveChunk)(ChunkSource *this, LevelChunk *);
  void (__fastcall *hintDiscardBatchBegin)(ChunkSource *this);
  void (__fastcall *hintDiscardBatchEnd)(ChunkSource *this);
  void (__fastcall *acquireDiscarded)(ChunkSource *this, std::unique_ptr&lt;LevelChunk,LevelChunkFinalDeleter&gt;);
  void (__fastcall *compact)(ChunkSource *this);
  void (__fastcall *flushPendingWrites)(ChunkSource *this);
  bool (__fastcall *isWithinWorldLimit)(ChunkSource *this, const ChunkPos *);
  const std::unordered_map&lt;ChunkPos,std::weak_ptr&lt;LevelChunk&gt;&gt; *(__fastcall *getChunkMap)(ChunkSource *this);
  const std::unordered_map&lt;ChunkPos,std::weak_ptr&lt;LevelChunk&gt;&gt; *(__fastcall *getStorage)(ChunkSource *this);
  void (__fastcall *clearDeletedEntities)(ChunkSource *this);
  void (__fastcall *removeDimensionData)(ChunkSource *this, const std::unordered_set&lt;AutomaticID&lt;Dimension,int&gt;&gt; *);
  bool (__fastcall *hasChunk)(ChunkSource *this, const ChunkPos *, AutomaticID&lt;Dimension,int&gt;);
  bool (__fastcall *canCreateViews)(ChunkSource *this);
};

</code></pre></div><h3 id="commandarea"><a href="#commandarea" class="header-anchor">#</a> <code>CommandArea</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandArea
{
  std::unique_ptr&lt;ChunkViewSource&gt; mChunkSource;
  BlockSource mBlockSource;
};

</code></pre></div><h3 id="core-levelstorageresult"><a href="#core-levelstorageresult" class="header-anchor">#</a> <code>Core::LevelStorageResult</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::LevelStorageResult
{
  _BYTE state[4];
  std::string telemetryMsg;
};

</code></pre></div><h3 id="callbacktokencancelstate"><a href="#callbacktokencancelstate" class="header-anchor">#</a> <code>CallbackTokenCancelState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CallbackTokenCancelState
{
  std::atomic&lt;bool&gt; mCanceled;
};

</code></pre></div><h3 id="contentlogendpoint"><a href="#contentlogendpoint" class="header-anchor">#</a> <code>ContentLogEndPoint</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLogEndPoint : Bedrock::LogEndPoint, Bedrock::EnableNonOwnerReferences
{
};

</code></pre></div><h3 id="contentlogendpoint-vtbl"><a href="#contentlogendpoint-vtbl" class="header-anchor">#</a> <code>ContentLogEndPoint_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentLogEndPoint_vtbl
{
  void (__fastcall *~LogEndPoint)(Bedrock::LogEndPoint *this);
  void (__fastcall *log)(Bedrock::LogEndPoint *this, const char *);
  void (__fastcall *flush)(Bedrock::LogEndPoint *this);
  void (__fastcall *setEnabled)(Bedrock::LogEndPoint *this, bool);
  bool (__fastcall *isEnabled)(Bedrock::LogEndPoint *this);
  void (__fastcall *log)(ContentLogEndPoint *this, const LogArea, const LogLevel, const char *);
};

</code></pre></div><h3 id="commandregistry"><a href="#commandregistry" class="header-anchor">#</a> <code>CommandRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry
{
  std::function&lt;void __cdecl(Packet const &amp;)&gt; mNetworkUpdateCallback;
  std::function&lt;int __cdecl(bool &amp;,std::string const &amp;,Actor const &amp;)&gt; mGetScoreForObjective;
  std::vector&lt;CommandRegistry::ParseRule&gt; mRules;
  std::map&lt;unsigned int,CommandRegistry::ParseTable&gt; mParseTables;
  std::vector&lt;CommandRegistry::OptionalParameterChain&gt; mOptionals;
  std::vector&lt;std::string&gt; mEnumValues;
  std::vector&lt;CommandRegistry::Enum&gt; mEnums;
  std::vector&lt;CommandRegistry::Factorization&gt; mFactorizations;
  std::vector&lt;std::string&gt; mPostfixes;
  std::map&lt;std::string,unsigned int&gt; mEnumLookup;
  std::map&lt;std::string,unsigned __int64&gt; mEnumValueLookup;
  std::vector&lt;CommandRegistry::Symbol&gt; mCommandSymbols;
  std::map&lt;std::string,CommandRegistry::Signature&gt; mSignatures;
  std::map&lt;typeid_t&lt;CommandRegistry&gt;,int,std::less&lt;typeid_t&lt;CommandRegistry&gt; &gt;,std::allocator&lt;std::pair&lt;typeid_t&lt;CommandRegistry&gt; const ,int&gt; &gt; &gt; mTypeLookup;
  std::map&lt;std::string,std::string&gt; mAliases;
  std::vector&lt;enum SemanticConstraint&gt; mSemanticConstraints;
  std::map&lt;enum SemanticConstraint,unsigned char&gt; mSemanticConstraintLookup;
  std::vector&lt;CommandRegistry::ConstrainedValue&gt; mConstrainedValues;
  std::map&lt;std::pair&lt;unsigned __int64,unsigned int&gt;,unsigned int,std::less&lt;std::pair&lt;unsigned __int64,unsigned int&gt; &gt;,std::allocator&lt;std::pair&lt;std::pair&lt;unsigned __int64,unsigned int&gt; const ,unsigned int&gt; &gt; &gt; mConstrainedValueLookup;
  std::vector&lt;CommandRegistry::SoftEnum&gt; mSoftEnums;
  std::map&lt;std::string,unsigned int&gt; mSoftEnumLookup;
  std::vector&lt;CommandRegistry::RegistryState&gt; mStateStack;
  CommandRegistry::ParamSymbols mArgs;
  std::function&lt;void __cdecl(CommandFlag &amp;,std::string const &amp;)&gt; mCommandOverrideFunctor;
};

</code></pre></div><h3 id="core-observer-social-multiplayerserviceobserver-core-singlethreadedlock"><a href="#core-observer-social-multiplayerserviceobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-social-multiplayerserviceobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-social-multiplayerserviceobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-social-multiplayerserviceobserver-core-singlethreadedlock"><a href="#core-subject-social-multiplayerserviceobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;Social::MultiplayerServiceObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;Social::MultiplayerServiceObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="crypto-asymmetric-isysteminterface"><a href="#crypto-asymmetric-isysteminterface" class="header-anchor">#</a> <code>Crypto::Asymmetric::ISystemInterface</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Crypto::Asymmetric::ISystemInterface
{
  Crypto::Asymmetric::ISystemInterface_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="crypto-asymmetric-isysteminterface-vtbl"><a href="#crypto-asymmetric-isysteminterface-vtbl" class="header-anchor">#</a> <code>Crypto::Asymmetric::ISystemInterface_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Crypto::Asymmetric::ISystemInterface_vtbl
{
  void (__fastcall *~ISystemInterface)(Crypto::Asymmetric::ISystemInterface *this);
  bool (__fastcall *generateKeyPair)(Crypto::Asymmetric::ISystemInterface *this, std::string *, std::string *);
  std::string *(__fastcall *encryptData)(Crypto::Asymmetric::ISystemInterface *this, std::string *result, const std::string *, const std::string *, Crypto::Asymmetric::Padding, Crypto::Asymmetric::PubKeyFormat);
  std::string *(__fastcall *decryptData)(Crypto::Asymmetric::ISystemInterface *this, std::string *result, const std::string *, const std::string *, Crypto::Asymmetric::Padding);
  std::string *(__fastcall *signData)(Crypto::Asymmetric::ISystemInterface *this, std::string *result, const std::string *, const std::string *, Crypto::Hash::HashType);
  bool (__fastcall *verifyData)(Crypto::Asymmetric::ISystemInterface *this, const std::string *, const std::string *, const std::string *, Crypto::Hash::HashType);
  std::string *(__fastcall *computeSharedSecret)(Crypto::Asymmetric::ISystemInterface *this, std::string *result, const std::string *, const std::string *);
  bool (__fastcall *ECCompressedKeyToPoint)(Crypto::Asymmetric::ISystemInterface *this, const std::string *, std::vector&lt;unsigned char&gt; *, std::vector&lt;unsigned char&gt; *);
  std::string *(__fastcall *getSystemAsString)(Crypto::Asymmetric::ISystemInterface *this, std::string *result);
};

</code></pre></div><h3 id="crypto-asymmetric-asymmetric"><a href="#crypto-asymmetric-asymmetric" class="header-anchor">#</a> <code>Crypto::Asymmetric::Asymmetric</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Crypto::Asymmetric::Asymmetric : Crypto::Asymmetric::ISystemInterface
{
  Crypto::Asymmetric::System mSystem;
  std::unique_ptr&lt;Crypto::Asymmetric::ISystemInterface&gt; mInterface;
};

</code></pre></div><h3 id="crypto-asymmetric-asymmetric-vtbl"><a href="#crypto-asymmetric-asymmetric-vtbl" class="header-anchor">#</a> <code>Crypto::Asymmetric::Asymmetric_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Crypto::Asymmetric::Asymmetric_vtbl
{
  void (__fastcall *~ISystemInterface)(Crypto::Asymmetric::ISystemInterface *this);
  bool (__fastcall *generateKeyPair)(Crypto::Asymmetric::ISystemInterface *this, std::string *, std::string *);
  std::string *(__fastcall *encryptData)(Crypto::Asymmetric::ISystemInterface *this, std::string *result, const std::string *, const std::string *, Crypto::Asymmetric::Padding, Crypto::Asymmetric::PubKeyFormat);
  std::string *(__fastcall *decryptData)(Crypto::Asymmetric::ISystemInterface *this, std::string *result, const std::string *, const std::string *, Crypto::Asymmetric::Padding);
  std::string *(__fastcall *signData)(Crypto::Asymmetric::ISystemInterface *this, std::string *result, const std::string *, const std::string *, Crypto::Hash::HashType);
  bool (__fastcall *verifyData)(Crypto::Asymmetric::ISystemInterface *this, const std::string *, const std::string *, const std::string *, Crypto::Hash::HashType);
  std::string *(__fastcall *computeSharedSecret)(Crypto::Asymmetric::ISystemInterface *this, std::string *result, const std::string *, const std::string *);
  bool (__fastcall *ECCompressedKeyToPoint)(Crypto::Asymmetric::ISystemInterface *this, const std::string *, std::vector&lt;unsigned char&gt; *, std::vector&lt;unsigned char&gt; *);
  std::string *(__fastcall *getSystemAsString)(Crypto::Asymmetric::ISystemInterface *this, std::string *result);
};

</code></pre></div><h3 id="commandoutputsender"><a href="#commandoutputsender" class="header-anchor">#</a> <code>CommandOutputSender</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandOutputSender
{
  CommandOutputSender_vtbl *__vftable /*VFT*/;
  Automation::AutomationClient *mAutomationClient;
  std::function&lt;void __cdecl(AutomationCmdOutput &amp;)&gt; mEmplaceTestCommandOutputCallback;
};

</code></pre></div><h3 id="commandoutputsender-vtbl"><a href="#commandoutputsender-vtbl" class="header-anchor">#</a> <code>CommandOutputSender_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandOutputSender_vtbl
{
  void (__fastcall *~CommandOutputSender)(CommandOutputSender *this);
  void (__fastcall *send)(CommandOutputSender *this, const CommandOrigin *, const CommandOutput *);
  void (__fastcall *registerOutputCallback)(CommandOutputSender *this, const std::function&lt;void __cdecl(AutomationCmdOutput &amp;)&gt; *);
};

</code></pre></div><h3 id="core-observer-automation-automationobserver-core-singlethreadedlock"><a href="#core-observer-automation-automationobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-automation-automationobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-automation-automationobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-automation-automationobserver-core-singlethreadedlock"><a href="#core-subject-automation-automationobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;Automation::AutomationObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;Automation::AutomationObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="command"><a href="#command" class="header-anchor">#</a> <code>Command</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) Command
{
  Command_vtbl *__vftable /*VFT*/;
  int mVersion;
  const CommandRegistry *mRegistry;
  int mCommandSymbol;
  _BYTE mPermissionLevel[1];
  CommandFlag mFlags;
};

</code></pre></div><h3 id="command-vtbl"><a href="#command-vtbl" class="header-anchor">#</a> <code>Command_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Command_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="clientblobcache-server-activetransfersmanager"><a href="#clientblobcache-server-activetransfersmanager" class="header-anchor">#</a> <code>ClientBlobCache::Server::ActiveTransfersManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlobCache::Server::ActiveTransfersManager
{
  std::unordered_map&lt;NetworkIdentifier,std::unique_ptr&lt;ClientBlobCache::Server::ActiveTransfersManager::TransferTracker&gt;&gt; mTransferTrackerMap;
  std::map&lt;unsigned __int64,std::weak_ptr&lt;ClientBlobCache::Server::Blob&gt;&gt; mSentBlobs;
  unsigned __int64 mCacheSizeBytes;
};

</code></pre></div><h3 id="clientblobcache-server-activetransfersmanager-transfertracker"><a href="#clientblobcache-server-activetransfersmanager-transfertracker" class="header-anchor">#</a> <code>ClientBlobCache::Server::ActiveTransfersManager::TransferTracker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientBlobCache::Server::ActiveTransfersManager::TransferTracker
{
  ClientBlobCache::Server::ActiveTransfersManager *mCache;
  const NetworkIdentifier mOwner;
  std::vector&lt;ClientBlobCache::Server::ActiveTransfer&gt; mTransfers;
  unsigned int mMaxConcurrentTransfers;
};

</code></pre></div><h3 id="classroommodenetworkhandler"><a href="#classroommodenetworkhandler" class="header-anchor">#</a> <code>ClassroomModeNetworkHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClassroomModeNetworkHandler : NetEventCallback, Bedrock::Threading::EnableQueueForMainThread
{
  Automation::AutomationClient *mAutomationClient;
  std::unique_ptr&lt;RoleChecker&gt; mRoleChecker;
  std::string mTenantId;
  std::string mLastRequestAddress;
  bool mIsDedicatedServer;
};

</code></pre></div><h3 id="core-filestdstreambuf-vtbl"><a href="#core-filestdstreambuf-vtbl" class="header-anchor">#</a> <code>Core::FileStdStreamBuf_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::FileStdStreamBuf_vtbl
{
  void (__fastcall *~basic_streambuf&lt;char,std::char_traits&lt;char&gt; &gt;)(std::streambuf *this);
  void (__fastcall *_Lock)(std::streambuf *this);
  void (__fastcall *_Unlock)(std::streambuf *this);
  int (__fastcall *overflow)(std::streambuf *this, int);
  int (__fastcall *pbackfail)(std::streambuf *this, int);
  __int64 (__fastcall *showmanyc)(std::streambuf *this);
  int (__fastcall *underflow)(std::streambuf *this);
  int (__fastcall *uflow)(std::streambuf *this);
  __int64 (__fastcall *xsgetn)(std::streambuf *this, char *, __int64);
  __int64 (__fastcall *xsputn)(std::streambuf *this, const char *, __int64);
  std::fpos&lt;_Mbstatet&gt; *(__fastcall *seekoff)(std::streambuf *this, std::fpos&lt;_Mbstatet&gt; *result, __int64, int, int);
  std::fpos&lt;_Mbstatet&gt; *(__fastcall *seekpos)(std::streambuf *this, std::fpos&lt;_Mbstatet&gt; *result, std::fpos&lt;_Mbstatet&gt;, int);
  std::streambuf *(__fastcall *setbuf)(std::streambuf *this, char *, __int64);
  int (__fastcall *sync)(std::streambuf *this);
  void (__fastcall *imbue)(std::streambuf *this, const std::locale *);
};

</code></pre></div><h3 id="core-filestream-vtbl"><a href="#core-filestream-vtbl" class="header-anchor">#</a> <code>Core::FileStream_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::FileStream_vtbl
{
  void *(__fastcall *__vecDelDtor)(Core::FileStream *this, unsigned int);
};

</code></pre></div><h3 id="core-outputfilestream-vtbl"><a href="#core-outputfilestream-vtbl" class="header-anchor">#</a> <code>Core::OutputFileStream_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::OutputFileStream_vtbl
{
  void *(__fastcall *__vecDelDtor)(Core::OutputFileStream *this, unsigned int);
};

</code></pre></div><h3 id="catalogbackend"><a href="#catalogbackend" class="header-anchor">#</a> <code>CatalogBackend</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CatalogBackend
{
  CatalogBackend_vtbl *__vftable /*VFT*/;
  CatalogProviderId mProviderId;
};

</code></pre></div><h3 id="catalogbackend-vtbl"><a href="#catalogbackend-vtbl" class="header-anchor">#</a> <code>CatalogBackend_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CatalogBackend_vtbl
{
  void (__fastcall *~CatalogBackend)(CatalogBackend *this);
  const std::string *(__fastcall *getCachedFilePrefix)(CatalogBackend *this);
  bool (__fastcall *usePascalCase)(CatalogBackend *this);
};

</code></pre></div><h3 id="customdocumentmodifier"><a href="#customdocumentmodifier" class="header-anchor">#</a> <code>CustomDocumentModifier</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomDocumentModifier
{
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;DateManager const &gt; &gt; mDateManager;
};

</code></pre></div><h3 id="commoncontent"><a href="#commoncontent" class="header-anchor">#</a> <code>CommonContent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommonContent
{
  std::string id;
  std::string url;
  std::string type;
  std::string maxClientVersion;
  std::string minClientVersion;
  std::vector&lt;std::string&gt; tags;
};

</code></pre></div><h3 id="commonimage"><a href="#commonimage" class="header-anchor">#</a> <code>CommonImage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommonImage
{
  std::string id;
  std::string tag;
  std::string type;
  std::string url;
};

</code></pre></div><h3 id="contentcatalogpacksource"><a href="#contentcatalogpacksource" class="header-anchor">#</a> <code>ContentCatalogPackSource</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ContentCatalogPackSource : PackSource
{
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;ContentCatalogService&gt; &gt; mCatalogService;
  IEntitlementManager *mEntitlementManager;
  bool mEnabled;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
  int mIconFetchesRemaining;
  ContentCatalogPackSource::FetchingState mFetchingCatalogEntries;
  std::vector&lt;std::unique_ptr&lt;Pack&gt;&gt; mPacks;
  std::vector&lt;DurableDocument&gt; mDocuments;
  std::function&lt;void __cdecl(bool)&gt; mOnAsyncLoadComplete;
  bool mHighPriorityIconRequests;
};

</code></pre></div><h3 id="contentcatalogpacksource-vtbl"><a href="#contentcatalogpacksource-vtbl" class="header-anchor">#</a> <code>ContentCatalogPackSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentCatalogPackSource_vtbl
{
  void (__fastcall *~PackSource)(PackSource *this);
  void (__fastcall *forEachPackConst)(PackSource *this, std::function&lt;void __cdecl(Pack const &amp;)&gt;);
  void (__fastcall *forEachPack)(PackSource *this, std::function&lt;void __cdecl(Pack &amp;)&gt;);
  PackOrigin (__fastcall *getPackOrigin)(PackSource *this);
  PackType (__fastcall *getPackType)(PackSource *this);
  PackSourceReport *(__fastcall *load)(PackSource *this, PackSourceReport *result, PackManifestFactory *, const IContentKeyProvider *);
  void (__fastcall *addPackSource)(PackSource *this, PackSource *);
};

</code></pre></div><h3 id="catalogcollection"><a href="#catalogcollection" class="header-anchor">#</a> <code>CatalogCollection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CatalogCollection
{
  StoreCatalogRepository *mStoreCatalog;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;ContentCatalogService&gt; &gt; mContentCatalogService;
  IEntitlementManager *mEntitlementManager;
  StoreCatalogItem *mInvalidItem;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
  std::shared_ptr&lt;CatalogCollection::CatalogCollectionListener&gt; mEntitlementChangeListener;
  __int64 mSaleExpirationTime;
  std::vector&lt;gsl::not_null&lt;StoreCatalogItem *&gt;&gt; mContents;
  std::unordered_set&lt;std::string&gt; mContentProductIds;
  std::function&lt;bool __cdecl(StoreCatalogItem const &amp;)&gt; mFilterOutIfTrue;
  int mItemLimit;
  std::vector&lt;std::shared_ptr&lt;SearchQuery&gt;&gt; mQueries;
  std::vector&lt;CatalogCollection::QueryContentInfo&gt; mContentCountPerQuery;
  bool mFetchingItems;
  bool mHasUpcomingSale;
  bool mFilterOwnedToBack;
  bool mFilterOutInvalidOffers;
  bool mClientSortEnabled;
  bool mTotalNumberOffersSent;
  bool mSent;
  bool mIsPromoRow;
  bool mDirty;
  bool mReady;
  int mQueryIndex;
  int mContentFetchLimit;
  int mVisibleItemsPerPage;
  int mFirstVisibleItemIndex;
  std::mutex mContentCheck;
};

</code></pre></div><h3 id="catalogcollection-catalogcollectionlistener"><a href="#catalogcollection-catalogcollectionlistener" class="header-anchor">#</a> <code>CatalogCollection::CatalogCollectionListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CatalogCollection::CatalogCollectionListener : EntitlementChangeListener
{
  CatalogCollection *mCollection;
};

</code></pre></div><h3 id="catalogcollection-catalogcollectionlistener-vtbl"><a href="#catalogcollection-catalogcollectionlistener-vtbl" class="header-anchor">#</a> <code>CatalogCollection::CatalogCollectionListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CatalogCollection::CatalogCollectionListener_vtbl
{
  void (__fastcall *~EntitlementChangeListener)(EntitlementChangeListener *this);
  void (__fastcall *_onEntitlementChanged)(EntitlementChangeListener *this);
};

</code></pre></div><h3 id="catalogcollection-querycontentinfo"><a href="#catalogcollection-querycontentinfo" class="header-anchor">#</a> <code>CatalogCollection::QueryContentInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) CatalogCollection::QueryContentInfo
{
  int mTotalContentCount;
  int mFilteredContent;
  int mSkipAmount;
  int mPossibleContent;
  bool mHasCheckedContentCount;
  bool mHasExhaustedQuery;
};

</code></pre></div><h3 id="carouselcomponent"><a href="#carouselcomponent" class="header-anchor">#</a> <code>CarouselComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CarouselComponent : StoreUIComponent
{
  bool mShouldCarouselCycle;
  std::vector&lt;std::shared_ptr&lt;StoreVisualStyle&gt;&gt; mCarouselStyles;
  int mCurrentCarouselPage;
  float mCarouselTimer;
  int mCarouselTimerDuration;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mTimeLastChecked;
};

</code></pre></div><h3 id="carouselcomponent-vtbl"><a href="#carouselcomponent-vtbl" class="header-anchor">#</a> <code>CarouselComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CarouselComponent_vtbl
{
  void (__fastcall *~StoreUIComponent)(StoreUIComponent *this);
  void (__fastcall *tick)(StoreUIComponent *this, ui::DirtyFlag *);
  bool (__fastcall *canRemove)(StoreUIComponent *this);
  int (__fastcall *getReadyCount)(StoreUIComponent *this);
  void (__fastcall *parseData)(StoreUIComponent *this, const struct web::json::value *);
};

</code></pre></div><h3 id="contentcatalogservice"><a href="#contentcatalogservice" class="header-anchor">#</a> <code>ContentCatalogService</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentCatalogService : ServiceClient, Bedrock::EnableNonOwnerReferences
{
  std::shared_ptr&lt;CatalogBackend&gt; mCatalogBackendPlayFab;
  std::shared_ptr&lt;CatalogBackend&gt; mCatalogBackendXforge;
  std::shared_ptr&lt;CatalogBackend&gt; mCatalogBackendPersonaService;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;DateManager const &gt; &gt; mDateManager;
  CustomDocumentModifier mCustomModifier;
  std::unique_ptr&lt;OwnedDurablesPagingCache&gt; mOwnedDurablesPagingInterface;
  std::string mAcceptLanguage;
  const Core::PathBuffer&lt;std::string &gt; mDefaultCacheLocation;
  std::unordered_map&lt;enum CatalogRequestType,Core::PathBuffer&lt;std::string &gt;&gt; mCacheLocationPerType;
  std::string mPlatformOverride;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
  unsigned int mCacheDurationSeconds;
  int mCacheExpirationOffsetSec;
};

</code></pre></div><h3 id="contentcatalogservice-vtbl"><a href="#contentcatalogservice-vtbl" class="header-anchor">#</a> <code>ContentCatalogService_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentCatalogService_vtbl
{
  void (__fastcall *~ServiceClient)(ServiceClient *this);
  void (__fastcall *update)(ServiceClient *this);
  void (__fastcall *_submitRequest)(ServiceClient *this, std::shared_ptr&lt;RequestHandler&gt;);
};

</code></pre></div><h3 id="controlleridtoclientmap"><a href="#controlleridtoclientmap" class="header-anchor">#</a> <code>ControllerIDtoClientMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ControllerIDtoClientMap
{
  std::map&lt;int,std::weak_ptr&lt;IClientInstance&gt;&gt; controllerIDtoClientMap;
  bool useGameControllerId;
  bool onScreenAcceptingAllControllerInput;
  bool acceptInputFromAllControllers;
  bool inGame;
  int primaryUserControllerId;
  int lastInputUserControllerId;
};

</code></pre></div><h3 id="core-observer-levellocationobserver-core-singlethreadedlock"><a href="#core-observer-levellocationobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;LevelLocationObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-levellocationobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-levellocationobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-levellocationobserver-core-singlethreadedlock"><a href="#core-subject-levellocationobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;LevelLocationObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="clientblockpipeline-blockschematicpart"><a href="#clientblockpipeline-blockschematicpart" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockSchematicPart</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BlockSchematicPart
{
  std::vector&lt;ClientBlockPipeline::BoxSchematic&gt; mBoxes;
  std::string mName;
};

</code></pre></div><h3 id="clientblockpipeline-blockschematic"><a href="#clientblockpipeline-blockschematic" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockSchematic</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BlockSchematic
{
  Matrix mModelToGridTransform;
  std::vector&lt;ClientBlockPipeline::BlockSchematicPart&gt; mParts;
  std::vector&lt;std::string&gt; mMaterialNames;
};

</code></pre></div><h3 id="clientblockpipeline-material"><a href="#clientblockpipeline-material" class="header-anchor">#</a> <code>ClientBlockPipeline::Material</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) ClientBlockPipeline::Material : Bedrock::EnableNonOwnerReferences
{
  const TerrainLayer *mTerrainLayer;
  TextureUVCoordinateSet mUvSet;
  bool mAmbientOcclusion;
  bool mFaceDimming;
};

</code></pre></div><h3 id="clientblockpipeline-materialrepository"><a href="#clientblockpipeline-materialrepository" class="header-anchor">#</a> <code>ClientBlockPipeline::MaterialRepository</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::MaterialRepository
{
  std::vector&lt;std::shared_ptr&lt;ClientBlockPipeline::Material const &gt;&gt; mMaterials;
};

</code></pre></div><h3 id="clientblockpipeline-schematicsrepository"><a href="#clientblockpipeline-schematicsrepository" class="header-anchor">#</a> <code>ClientBlockPipeline::SchematicsRepository</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::SchematicsRepository
{
  std::unordered_map&lt;HashedString,std::shared_ptr&lt;ClientBlockPipeline::BlockSchematic&gt;&gt; mSchematicNameMap;
  std::shared_ptr&lt;ClientBlockPipeline::MaterialRepository&gt; mMaterialRepository;
};

</code></pre></div><h3 id="callbacktokencontext-std-function-void-cdecl-enum-social-userplatformconnectionresult"><a href="#callbacktokencontext-std-function-void-cdecl-enum-social-userplatformconnectionresult" class="header-anchor">#</a> <code>CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Social::UserPlatformConnectionResult)&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Social::UserPlatformConnectionResult)&gt; &gt;
{
  std::vector&lt;std::function&lt;void __cdecl(enum Social::UserPlatformConnectionResult)&gt;&gt; mCallbacks;
  std::shared_ptr&lt;CallbackTokenCancelState&gt; mCancelState;
};

</code></pre></div><h3 id="callbacktokencontext-std-function-void-cdecl-core-result"><a href="#callbacktokencontext-std-function-void-cdecl-core-result" class="header-anchor">#</a> <code>CallbackTokenContext&lt;std::function&lt;void __cdecl(Core::Result)&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CallbackTokenContext&lt;std::function&lt;void __cdecl(Core::Result)&gt; &gt;
{
  std::vector&lt;std::function&lt;void __cdecl(Core::Result)&gt;&gt; mCallbacks;
  std::shared_ptr&lt;CallbackTokenCancelState&gt; mCancelState;
};

</code></pre></div><h3 id="core-remotestorageprovider"><a href="#core-remotestorageprovider" class="header-anchor">#</a> <code>Core::RemoteStorageProvider</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::RemoteStorageProvider
{
  Core::RemoteStorageProvider_vtbl *__vftable /*VFT*/;
  std::map&lt;std::string,std::string&gt; mContainerRoots;
};

</code></pre></div><h3 id="core-remotestoragemanifest-blobsequence"><a href="#core-remotestoragemanifest-blobsequence" class="header-anchor">#</a> <code>Core::RemoteStorageManifest::BlobSequence</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::RemoteStorageManifest::BlobSequence
{
  std::string mName;
  int mNumber;
};

</code></pre></div><h3 id="core-remotestoragemanifest-blobrecord"><a href="#core-remotestoragemanifest-blobrecord" class="header-anchor">#</a> <code>Core::RemoteStorageManifest::BlobRecord</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::RemoteStorageManifest::BlobRecord
{
  std::vector&lt;Core::RemoteStorageManifest::BlobSequence&gt; mBlobSequences;
  std::string mDecodedName;
  unsigned __int64 mChunkSize;
};

</code></pre></div><h3 id="core-remotestoragemanifest"><a href="#core-remotestoragemanifest" class="header-anchor">#</a> <code>Core::RemoteStorageManifest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::RemoteStorageManifest
{
  std::map&lt;std::string,Core::RemoteStorageManifest::BlobRecord&gt; mCorrelationTable;
  Core::RemoteStorageManifest::State mState;
  std::string mContainerName;
};

</code></pre></div><h3 id="core-remotestorageprovider-vtbl"><a href="#core-remotestorageprovider-vtbl" class="header-anchor">#</a> <code>Core::RemoteStorageProvider_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::RemoteStorageProvider_vtbl
{
  void (__fastcall *~RemoteStorageProvider)(Core::RemoteStorageProvider *this);
  void (__fastcall *shutdown)(Core::RemoteStorageProvider *this);
  const std::string *(__fastcall *getWorldsPrefix)(Core::RemoteStorageProvider *this);
  std::string *(__fastcall *encodeWorldName)(Core::RemoteStorageProvider *this, std::string *result, const std::string *);
  std::string *(__fastcall *encodeFileName)(Core::RemoteStorageProvider *this, std::string *result, const std::string *);
  void (__fastcall *tick)(Core::RemoteStorageProvider *this);
  void (__fastcall *onAppSuspend)(Core::RemoteStorageProvider *this);
  void (__fastcall *onAppResume)(Core::RemoteStorageProvider *this);
  void (__fastcall *onSignOut)(Core::RemoteStorageProvider *this);
  CallbackToken *(__fastcall *onSignIn)(Core::RemoteStorageProvider *this, CallbackToken *result, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(Core::Result)&gt; &gt; &gt;);
  CallbackToken *(__fastcall *deleteContainer)(Core::RemoteStorageProvider *this, CallbackToken *result, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(Core::Result)&gt; &gt; &gt;, const std::string *);
  CallbackToken *(__fastcall *commit)(Core::RemoteStorageProvider *this, CallbackToken *result, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(Core::Result)&gt; &gt; &gt;, const std::string *, const std::set&lt;std::string&gt; *, std::set&lt;std::string&gt; *, std::set&lt;std::string&gt; *);
  CallbackToken *(__fastcall *sync)(Core::RemoteStorageProvider *this, CallbackToken *result, const std::string *, const std::string *, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(Core::Result)&gt; &gt; &gt;, std::function&lt;void __cdecl(std::string const &amp;,bool)&gt;);
  CallbackToken *(__fastcall *syncMeta)(Core::RemoteStorageProvider *this, CallbackToken *result, const std::string *, const std::string *, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(Core::Result)&gt; &gt; &gt;);
  CallbackToken *(__fastcall *syncContainerManifest)(Core::RemoteStorageProvider *this, CallbackToken *result, const std::string *, const std::string *, std::shared_ptr&lt;CallbackTokenContext&lt;std::function&lt;void __cdecl(Core::Result)&gt; &gt; &gt;);
  Core::RemoteStorageManifest *(__fastcall *getManifest)(Core::RemoteStorageProvider *this, Core::RemoteStorageManifest *result, const std::string *);
};

</code></pre></div><h3 id="cloudsavesystemwrapper"><a href="#cloudsavesystemwrapper" class="header-anchor">#</a> <code>CloudSaveSystemWrapper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CloudSaveSystemWrapper : OptionsObserver
{
  std::unique_ptr&lt;GameSaveSystem&gt; mGameSaveSystem;
  std::weak_ptr&lt;Social::User&gt; mOwningUser;
  std::function&lt;void __cdecl(std::function&lt;void __cdecl(void)&gt;)&gt; mInitRemoteSystemCallback;
};

</code></pre></div><h3 id="cloudsavesystemwrapper-vtbl"><a href="#cloudsavesystemwrapper-vtbl" class="header-anchor">#</a> <code>CloudSaveSystemWrapper_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CloudSaveSystemWrapper_vtbl
{
  void (__fastcall *~Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;OptionsObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *onForceCloudSave)(OptionsObserver *this);
  void (__fastcall *onOptionsLoadBegin)(OptionsObserver *this);
  void (__fastcall *onOptionsLoadComplete)(OptionsObserver *this);
};

</code></pre></div><h3 id="cg-resourcemanager-std-shared-ptr-mce-image-resourcelocation-imagetrackertemplate-imageresourcemanager-std-shared-ptr-mce-image-std-unordered-map"><a href="#cg-resourcemanager-std-shared-ptr-mce-image-resourcelocation-imagetrackertemplate-imageresourcemanager-std-shared-ptr-mce-image-std-unordered-map" class="header-anchor">#</a> <code>cg::ResourceManager&lt;std::shared_ptr&lt;mce::Image&gt;,ResourceLocation,ImageTrackerTemplate&lt;ImageResourceManager&gt;,std::shared_ptr&lt;mce::Image&gt;,std::unordered_map&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::ResourceManager&lt;std::shared_ptr&lt;mce::Image&gt;,ResourceLocation,ImageTrackerTemplate&lt;ImageResourceManager&gt;,std::shared_ptr&lt;mce::Image&gt;,std::unordered_map&gt;
{
  std::unordered_map&lt;ResourceLocation,std::shared_ptr&lt;mce::Image&gt;&gt; mContainer;
};

</code></pre></div><h3 id="cg-resourcemanager-std-shared-ptr-mce-image-enum-mce-dynamictexture-imagetrackertemplate-dynamicimageresourcemanager-std-shared-ptr-mce-image-std-map"><a href="#cg-resourcemanager-std-shared-ptr-mce-image-enum-mce-dynamictexture-imagetrackertemplate-dynamicimageresourcemanager-std-shared-ptr-mce-image-std-map" class="header-anchor">#</a> <code>cg::ResourceManager&lt;std::shared_ptr&lt;mce::Image&gt;,enum mce::DynamicTexture,ImageTrackerTemplate&lt;DynamicImageResourceManager&gt;,std::shared_ptr&lt;mce::Image&gt;,std::map&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::ResourceManager&lt;std::shared_ptr&lt;mce::Image&gt;,enum mce::DynamicTexture,ImageTrackerTemplate&lt;DynamicImageResourceManager&gt;,std::shared_ptr&lt;mce::Image&gt;,std::map&gt;
{
  std::map&lt;enum mce::DynamicTexture,std::shared_ptr&lt;mce::Image&gt;&gt; mContainer;
};

</code></pre></div><h3 id="cg-resourcemanager-std-shared-ptr-mce-clienttexture-enum-mce-dynamictexture-void-std-shared-ptr-mce-clienttexture-std-map"><a href="#cg-resourcemanager-std-shared-ptr-mce-clienttexture-enum-mce-dynamictexture-void-std-shared-ptr-mce-clienttexture-std-map" class="header-anchor">#</a> <code>cg::ResourceManager&lt;std::shared_ptr&lt;mce::ClientTexture&gt;,enum mce::DynamicTexture,void,std::shared_ptr&lt;mce::ClientTexture&gt;,std::map&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::ResourceManager&lt;std::shared_ptr&lt;mce::ClientTexture&gt;,enum mce::DynamicTexture,void,std::shared_ptr&lt;mce::ClientTexture&gt;,std::map&gt;
{
  std::map&lt;enum mce::DynamicTexture,std::shared_ptr&lt;mce::ClientTexture&gt;&gt; mContainer;
};

</code></pre></div><h3 id="channelservice"><a href="#channelservice" class="header-anchor">#</a> <code>ChannelService</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChannelService : ServiceClient
{
  const WorldTemplateManager *mWorldTemplateManager;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;DateManager const &gt; &gt; mDateManager;
  std::string mAcceptLanguage;
  const Core::PathBuffer&lt;std::string &gt; mDefaultCacheLocation;
  const std::string mHostUrl;
  unsigned int mCacheDurationHours;
  std::string mUserToken;
  std::shared_ptr&lt;LessonItemCache&gt; mItemCache;
};

</code></pre></div><h3 id="channelservice-vtbl"><a href="#channelservice-vtbl" class="header-anchor">#</a> <code>ChannelService_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChannelService_vtbl
{
  void (__fastcall *~ServiceClient)(ServiceClient *this);
  void (__fastcall *update)(ServiceClient *this);
  void (__fastcall *_submitRequest)(ServiceClient *this, std::shared_ptr&lt;RequestHandler&gt;);
};

</code></pre></div><h3 id="controlscreenaction-vtbl"><a href="#controlscreenaction-vtbl" class="header-anchor">#</a> <code>ControlScreenAction_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ControlScreenAction_vtbl
{
  void (__fastcall *~ControlScreenAction)(ControlScreenAction *this);
  bool (__fastcall *getDirty)(ControlScreenAction *this, ui::DirtyFlag);
  bool (__fastcall *getDirty)(ControlScreenAction *this);
  ui::DirtyFlag (__fastcall *getDirtyValue)(ControlScreenAction *this);
  void (__fastcall *addDirtyFlag)(ControlScreenAction *this, ui::DirtyFlag);
  void (__fastcall *measureControls)(ControlScreenAction *this, UIControl *);
  void (__fastcall *markToRemoveDeadDependencies)(ControlScreenAction *this, std::shared_ptr&lt;UIControl&gt;);
  void (__fastcall *updateControlCollection)(ControlScreenAction *this, std::shared_ptr&lt;UIControl&gt;);
  void (__fastcall *updateControlCollectionFromRoot)(ControlScreenAction *this);
  void (__fastcall *removeFromControlCollection)(ControlScreenAction *this, std::shared_ptr&lt;UIControl&gt;);
  void (__fastcall *updateControlBinds)(ControlScreenAction *this, std::shared_ptr&lt;UIControl&gt;);
  void (__fastcall *updateBindsFromRoot)(ControlScreenAction *this);
  void (__fastcall *markTextEditFocusChanged)(ControlScreenAction *this);
  void (__fastcall *markTextEditAlwaysListeningChanged)(ControlScreenAction *this);
  std::shared_ptr&lt;UIControl&gt; *(__fastcall *getControlWithName)(ControlScreenAction *this, std::shared_ptr&lt;UIControl&gt; *result, const std::string *);
};

</code></pre></div><h3 id="caretmeasuredata"><a href="#caretmeasuredata" class="header-anchor">#</a> <code>CaretMeasureData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(4)) CaretMeasureData
{
  const int position;
  const bool shouldRender;
};

</code></pre></div><h3 id="cachedscene"><a href="#cachedscene" class="header-anchor">#</a> <code>CachedScene</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CachedScene
{
  std::unique_ptr&lt;VisualTree&gt; mVisualTree;
  std::shared_ptr&lt;UIControlFactory&gt; mControlFactory;
  std::unique_ptr&lt;LayoutManager&gt; mLayoutManager;
};

</code></pre></div><h3 id="cachedscenes"><a href="#cachedscenes" class="header-anchor">#</a> <code>CachedScenes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CachedScenes
{
  bool mLowMemoryDevice;
  std::unique_ptr&lt;TaskGroup&gt; mDestroyScreenTaskGroup;
  std::map&lt;Json::Value,std::unique_ptr&lt;CachedScene&gt;&gt; mCachedScene;
};

</code></pre></div><h3 id="customrendercomponent"><a href="#customrendercomponent" class="header-anchor">#</a> <code>CustomRenderComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomRenderComponent : RenderableComponent
{
  std::shared_ptr&lt;UICustomRenderer&gt; mRenderer;
};

</code></pre></div><h3 id="componentrenderbatch"><a href="#componentrenderbatch" class="header-anchor">#</a> <code>ComponentRenderBatch</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentRenderBatch
{
  BatchKey mBatchKey;
  bool mIsDirty;
  bool mRequiresPreRenderSetup;
  int mRenderPass;
  std::vector&lt;CustomRenderComponent *&gt; mCustomRenderInstances;
  std::vector&lt;SpriteComponent *&gt; mSpriteInstances;
  std::vector&lt;TextComponent *&gt; mTextInstances;
};

</code></pre></div><h3 id="customrendercomponent-vtbl"><a href="#customrendercomponent-vtbl" class="header-anchor">#</a> <code>CustomRenderComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CustomRenderComponent_vtbl
{
  void (__fastcall *~UIComponent)(UIComponent *this);
  void (__fastcall *OnScreenPop)(UIComponent *this);
  std::unique_ptr&lt;UIComponent&gt; *(__fastcall *clone)(UIComponent *this, std::unique_ptr&lt;UIComponent&gt; *result, UIControl *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, const ScreenEvent *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, VisualTree *, ScreenInputContext *, UIAnimationController *, const ScreenEvent *);
  void (__fastcall *onNotifyChildAdded)(UIComponent *this);
  void (__fastcall *onNotifyChildRemoved)(UIComponent *this);
  void (__fastcall *onRemoved)(UIComponent *this);
  void (__fastcall *onAdded)(UIComponent *this);
  void (__fastcall *onVisibilityChanged)(UIComponent *this, bool);
  void (__fastcall *onEnabledChanged)(UIComponent *this, bool);
  bool (__fastcall *isRenderableComponent)(UIComponent *this);
  bool (__fastcall *onLayoutChange)(UIComponent *this);
  void (__fastcall *reset)(UIComponent *this);
  void (__fastcall *reload)(UIComponent *this, const UIComponent *);
  const std::string *(__fastcall *getTextToSpeechComponentValue)(UIComponent *this);
  void (__fastcall *updateUI)(RenderableComponent *this, const UIMeasureStrategy *);
  bool (__fastcall *overridesLayoutAxisOffset)(RenderableComponent *this, const LayoutVariableType);
  float (__fastcall *getLayoutAxisOffsetOverride)(RenderableComponent *this, const LayoutVariableType);
  UIBatchType (__fastcall *getBatchType)(CustomRenderComponent *this);
  int (__fastcall *getCustomId)(CustomRenderComponent *this);
  int (__fastcall *getNumRenderPasses)(CustomRenderComponent *this);
  UIMaterialType (__fastcall *getUIMaterialType)(CustomRenderComponent *this, int);
  ResourceLocation *(__fastcall *getResourceLocation)(CustomRenderComponent *this, ResourceLocation *result, int, int);
  bool (__fastcall *getRequiresPreRenderSetup)(CustomRenderComponent *this, int);
  void (__fastcall *collectScreenEvents)(CustomRenderComponent *this, std::queue&lt;ScreenEvent&gt; *);
};

</code></pre></div><h3 id="contentitem"><a href="#contentitem" class="header-anchor">#</a> <code>ContentItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentItem
{
  ContentItem_vtbl *__vftable /*VFT*/;
  unsigned __int64 mId;
  std::string mName;
  std::string mDescription;
  unsigned __int64 mSize;
  bool mIsDescriptionExpanded;
  __declspec(align(8)) _BYTE mType[8];
  _BYTE mItemType[8];
  _BYTE mFlags[8];
  ContentSource *mSource;
};

</code></pre></div><h3 id="contentitem-vtbl"><a href="#contentitem-vtbl" class="header-anchor">#</a> <code>ContentItem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentItem_vtbl
{
  void (__fastcall *~ContentItem)(ContentItem *this);
};

</code></pre></div><h3 id="contentsource-vtbl"><a href="#contentsource-vtbl" class="header-anchor">#</a> <code>ContentSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentSource_vtbl
{
  void (__fastcall *~ContentSource)(ContentSource *this);
  void (__fastcall *load)(ContentSource *this);
  void (__fastcall *generateItems)(ContentSource *this, std::vector&lt;std::unique_ptr&lt;ContentItem&gt;&gt; *);
  void (__fastcall *save)(ContentSource *this);
  void (__fastcall *deleteContentFiles)(ContentSource *this, std::vector&lt;ContentItem const *&gt;);
  void (__fastcall *postDeleteContent)(ContentSource *this, std::vector&lt;ContentItem const *&gt;);
};

</code></pre></div><h3 id="contentmanager"><a href="#contentmanager" class="header-anchor">#</a> <code>ContentManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentManager : LevelLocationObserver, std::enable_shared_from_this&lt;ContentManager&gt;
{
  Core::FilePathManager *mFilePathManager;
  LevelListCache *mLevelListCache;
  WorldTemplateManager *mWorldTemplateManager;
  ResourcePackRepository *mResourcePackRepository;
  ResourcePackManager *mResourcePackManager;
  PackManifestFactory *mPackManifestFactory;
  IEntitlementManager *mEntitlementManager;
  const ContentTierManager *mContentTierManager;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;StoreCatalogRepository&gt; &gt; mStoreCatalog;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;ContentCatalogService&gt; &gt; mContentCatalogService;
  PackSourceFactory *mPackSourceFactory;
  std::vector&lt;std::unique_ptr&lt;ContentItem&gt;&gt; mContent;
  std::vector&lt;std::unique_ptr&lt;ContentSource&gt;&gt; mContentSources;
  std::vector&lt;ContentManagerContext *&gt; mContexts;
  unsigned __int64 mContentId;
  ContentCatalogPackSource *mCatalogResourcePackSource;
  std::unique_ptr&lt;ContentManagerProxy&gt; mProxy;
  bool mInitialized;
  const std::string WORLD_RESOURCE_PACK_FILENAME;
  const std::string WORLD_BEHAVIOR_PACK_FILENAME;
};

</code></pre></div><h3 id="contentview-itemcollection"><a href="#contentview-itemcollection" class="header-anchor">#</a> <code>ContentView::ItemCollection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentView::ItemCollection
{
  std::unique_ptr&lt;ContentItem&gt; mItemProxy;
  std::vector&lt;ContentItem *&gt; mItems;
  std::function&lt;bool __cdecl(ContentItem const *)&gt; mPredicate;
};

</code></pre></div><h3 id="contentview"><a href="#contentview" class="header-anchor">#</a> <code>ContentView</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentView
{
  ContentManager *mContentManager;
  std::vector&lt;ContentItem *&gt; mItems;
  std::function&lt;bool __cdecl(ContentItem const *)&gt; mPredicate;
  std::function&lt;bool __cdecl(ContentItem *,ContentItem *)&gt; mSortFunction;
  std::function&lt;void __cdecl(void)&gt; mOnReload;
  std::vector&lt;std::unique_ptr&lt;ContentView::ItemCollection&gt;&gt; mItemCollections;
  std::vector&lt;ContentView const *&gt; mContentViewSources;
};

</code></pre></div><h3 id="contentmanagercontext"><a href="#contentmanagercontext" class="header-anchor">#</a> <code>ContentManagerContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentManagerContext
{
  std::function&lt;bool __cdecl(ContentItem const *)&gt; mContextPredicate;
  std::vector&lt;std::unique_ptr&lt;ContentView&gt;&gt; mContentViews;
  ContentManager *mManager;
};

</code></pre></div><h3 id="contentmanagerproxycallbacks"><a href="#contentmanagerproxycallbacks" class="header-anchor">#</a> <code>ContentManagerProxyCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentManagerProxyCallbacks
{
  std::function&lt;ContentItem * __cdecl(PackManifest &amp;)&gt; mGetContentItemByManifest;
};

</code></pre></div><h3 id="contentmanagerproxy"><a href="#contentmanagerproxy" class="header-anchor">#</a> <code>ContentManagerProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentManagerProxy
{
  ContentManagerProxyCallbacks mCallbacks;
};

</code></pre></div><h3 id="contentmanager-vtbl"><a href="#contentmanager-vtbl" class="header-anchor">#</a> <code>ContentManager_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentManager_vtbl
{
  void (__fastcall *~Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;LevelLocationObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *onLevelAdded)(LevelLocationObserver *this, const std::string *);
  void (__fastcall *onLevelUpdated)(LevelLocationObserver *this, const std::string *);
  void (__fastcall *onLevelDeleted)(LevelLocationObserver *this, const std::string *);
  void (__fastcall *onStorageChanged)(LevelLocationObserver *this);
};

</code></pre></div><h3 id="clientmodel"><a href="#clientmodel" class="header-anchor">#</a> <code>ClientModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientModel
{
  ClientModel_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="clientmodel-vtbl"><a href="#clientmodel-vtbl" class="header-anchor">#</a> <code>ClientModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientModel_vtbl
{
  void (__fastcall *~ClientModel)(ClientModel *this);
  bool (__fastcall *hasCommandsEnabled)(ClientModel *this);
  std::string *(__fastcall *getFormattedHoverText)(ClientModel *this, std::string *result, const ItemStackBase *, const bool);
  bool (__fastcall *achievementsWillBeDisabledOnLoad)(ClientModel *this);
  bool (__fastcall *hasAchievementsDisabled)(ClientModel *this);
  std::string *(__fastcall *getLevelName)(ClientModel *this, std::string *result);
  int (__fastcall *getGameDifficulty)(ClientModel *this);
  int (__fastcall *getGameType)(ClientModel *this);
  void (__fastcall *setGameType)(ClientModel *this, GameType);
  int (__fastcall *getGenerator)(ClientModel *this);
  bool (__fastcall *getStartWithMap)(ClientModel *this);
  bool (__fastcall *isAlwaysDay)(ClientModel *this);
  bool (__fastcall *isGameRule)(ClientModel *this, GameRuleId);
  bool (__fastcall *isImmutableWorld)(ClientModel *this);
  std::unique_ptr&lt;PlayerCommandOrigin&gt; *(__fastcall *makePlayerCommandOrigin)(ClientModel *this, std::unique_ptr&lt;PlayerCommandOrigin&gt; *result);
  void (__fastcall *setCommandsEnabled)(ClientModel *this, bool);
  void (__fastcall *disableAchievements)(ClientModel *this);
  float (__fastcall *getGuiScale)(ClientModel *this);
  const Option *(__fastcall *getGuiScaleOption)(ClientModel *this);
  void (__fastcall *setGuiScaleOffset)(ClientModel *this, int);
  void (__fastcall *notifyForLeaveGame)(ClientModel *this);
};

</code></pre></div><h3 id="clientinstancemodel"><a href="#clientinstancemodel" class="header-anchor">#</a> <code>ClientInstanceModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceModel : ClientModel
{
  IClientInstance *mClient;
};

</code></pre></div><h3 id="clientinstancemodel-vtbl"><a href="#clientinstancemodel-vtbl" class="header-anchor">#</a> <code>ClientInstanceModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientInstanceModel_vtbl
{
  void (__fastcall *~ClientModel)(ClientModel *this);
  bool (__fastcall *hasCommandsEnabled)(ClientModel *this);
  std::string *(__fastcall *getFormattedHoverText)(ClientModel *this, std::string *result, const ItemStackBase *, const bool);
  bool (__fastcall *achievementsWillBeDisabledOnLoad)(ClientModel *this);
  bool (__fastcall *hasAchievementsDisabled)(ClientModel *this);
  std::string *(__fastcall *getLevelName)(ClientModel *this, std::string *result);
  int (__fastcall *getGameDifficulty)(ClientModel *this);
  int (__fastcall *getGameType)(ClientModel *this);
  void (__fastcall *setGameType)(ClientModel *this, GameType);
  int (__fastcall *getGenerator)(ClientModel *this);
  bool (__fastcall *getStartWithMap)(ClientModel *this);
  bool (__fastcall *isAlwaysDay)(ClientModel *this);
  bool (__fastcall *isGameRule)(ClientModel *this, GameRuleId);
  bool (__fastcall *isImmutableWorld)(ClientModel *this);
  std::unique_ptr&lt;PlayerCommandOrigin&gt; *(__fastcall *makePlayerCommandOrigin)(ClientModel *this, std::unique_ptr&lt;PlayerCommandOrigin&gt; *result);
  void (__fastcall *setCommandsEnabled)(ClientModel *this, bool);
  void (__fastcall *disableAchievements)(ClientModel *this);
  float (__fastcall *getGuiScale)(ClientModel *this);
  const Option *(__fastcall *getGuiScaleOption)(ClientModel *this);
  void (__fastcall *setGuiScaleOffset)(ClientModel *this, int);
  void (__fastcall *notifyForLeaveGame)(ClientModel *this);
};

</code></pre></div><h3 id="core-observer-social-userlistobserver-core-singlethreadedlock"><a href="#core-observer-social-userlistobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;Social::UserListObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;Social::UserListObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;Social::UserListObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;Social::UserListObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-social-userlistobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-social-userlistobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;Social::UserListObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;Social::UserListObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;Social::UserListObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;Social::UserListObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;Social::UserListObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-social-userlistobserver-core-singlethreadedlock"><a href="#core-subject-social-userlistobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;Social::UserListObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;Social::UserListObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;Social::UserListObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="channeltransform"><a href="#channeltransform" class="header-anchor">#</a> <code>ChannelTransform</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChannelTransform
{
  ExpressionNode mXYZ[3];
  Vec3 mAxis;
  ChannelTransformAxisType mTransformDataType;
};

</code></pre></div><h3 id="channeltransform-float"><a href="#channeltransform-float" class="header-anchor">#</a> <code>ChannelTransform_Float</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChannelTransform_Float
{
  float mXYZ[3];
};

</code></pre></div><h3 id="chunkvisibilitycacheelement"><a href="#chunkvisibilitycacheelement" class="header-anchor">#</a> <code>ChunkVisibilityCacheElement</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkVisibilityCacheElement
{
  unsigned __int8 mVisibility[6];
  unsigned __int16 mLatticeLookup;
  float mDistance;
  unsigned __int8 mCanSeeChunkBitfield;
  unsigned __int8 mChunkIsEmpty : 1;
  unsigned __int8 mChunkVisible : 1;
  unsigned __int8 mChunkAccessBitX : 1;
  unsigned __int8 mChunkAccessBitY : 1;
  unsigned __int8 mChunkAccessBitZ : 1;
  unsigned __int8 mIsSkyLit : 1;
  unsigned __int8 mAllSidesCanSeeAllSides : 1;
  unsigned __int8 mForceRequery : 1;
  unsigned __int8 mUpdateCounter;
  unsigned __int8 mInitted;
};

</code></pre></div><h3 id="chunkvisibilitycache"><a href="#chunkvisibilitycache" class="header-anchor">#</a> <code>ChunkVisibilityCache</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) ChunkVisibilityCache
{
  std::vector&lt;ChunkVisibilityCacheElement&gt; mCache;
  int mCacheSideMask;
  unsigned __int8 mCacheSideShift;
  unsigned __int8 mCacheDoubleSideShift;
};

</code></pre></div><h3 id="clientblockpipeline-simplemesh"><a href="#clientblockpipeline-simplemesh" class="header-anchor">#</a> <code>ClientBlockPipeline::SimpleMesh</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::SimpleMesh
{
  mce::MeshData mMeshData;
  std::vector&lt;TessellatorQuadInfo&gt; mQuadInfoList;
};

</code></pre></div><h3 id="clientblockpipeline-namedmeshstreams"><a href="#clientblockpipeline-namedmeshstreams" class="header-anchor">#</a> <code>ClientBlockPipeline::NamedMeshStreams</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::NamedMeshStreams
{
  std::unordered_map&lt;TerrainLayer const *,ClientBlockPipeline::SimpleMesh&gt; mStreams;
};

</code></pre></div><h3 id="clientblockpipeline-blocktessellatorpipeline"><a href="#clientblockpipeline-blocktessellatorpipeline" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockTessellatorPipeline</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BlockTessellatorPipeline
{
  ClientBlockPipeline::NamedMeshStreams mMeshStreams;
};

</code></pre></div><h3 id="clientblockpipeline-step"><a href="#clientblockpipeline-step" class="header-anchor">#</a> <code>ClientBlockPipeline::Step</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ClientBlockPipeline::Step
{
  ClientBlockPipeline::Step_vtbl *__vftable /*VFT*/;
  unsigned __int64 mStepId;
};

</code></pre></div><h3 id="clientblockpipeline-pipelineerror"><a href="#clientblockpipeline-pipelineerror" class="header-anchor">#</a> <code>ClientBlockPipeline::PipelineError</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::PipelineError
{
  std::string mError;
};

</code></pre></div><h3 id="clientblockpipeline-stepresult"><a href="#clientblockpipeline-stepresult" class="header-anchor">#</a> <code>ClientBlockPipeline::StepResult</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::StepResult
{
  std::variant&lt;ClientBlockPipeline::PipelineError,std::vector&lt;std::any&gt; &gt; mResults;
};

</code></pre></div><h3 id="clientblockpipeline-step-vtbl"><a href="#clientblockpipeline-step-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::Step_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::Step_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-description"><a href="#clientblockpipeline-description" class="header-anchor">#</a> <code>ClientBlockPipeline::Description</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::Description
{
  std::vector&lt;std::shared_ptr&lt;ClientBlockPipeline::Step const &gt;&gt; mSteps;
  std::vector&lt;std::shared_ptr&lt;ClientBlockPipeline::Step const &gt;&gt; mOutputs;
  std::vector&lt;ClientBlockPipeline::Description::BakedStep&gt; mBakedSteps;
};

</code></pre></div><h3 id="commandlistbase"><a href="#commandlistbase" class="header-anchor">#</a> <code>CommandListBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandListBase
{
};

</code></pre></div><h3 id="cg-details-lambdaexecutorcontextcontainer-std-nullptr-t-0"><a href="#cg-details-lambdaexecutorcontextcontainer-std-nullptr-t-0" class="header-anchor">#</a> <code>cg::details::LambdaExecutorContextContainer&lt;std::nullptr_t,0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) cg::details::LambdaExecutorContextContainer&lt;std::nullptr_t,0&gt;
{
  __int16 mContext;
};

</code></pre></div><h3 id="cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1"><a href="#cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1" class="header-anchor">#</a> <code>cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;
{
  std::unique_ptr&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;&gt; mWorkQueue;
  __int16 *mContext;
};

</code></pre></div><h3 id="cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const"><a href="#cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const" class="header-anchor">#</a> <code>cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;
{
  cg::details::LambdaExecutorContextContainer&lt;std::nullptr_t,0&gt; mContextContainer;
  __int16 *mContext;
  cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt; mExecutionPolicy;
};

</code></pre></div><h3 id="cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const"><a href="#cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const" class="header-anchor">#</a> <code>cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt;
{
  std::unique_ptr&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;&gt; mExecutionContext;
  std::atomic&lt;int&gt; mPendingWorkCount;
};

</code></pre></div><h3 id="cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const"><a href="#cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const" class="header-anchor">#</a> <code>cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;
{
  cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; mScheduler;
};

</code></pre></div><h3 id="cg-details-scopedframebase-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution"><a href="#cg-details-scopedframebase-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution" class="header-anchor">#</a> <code>cg::details::ScopedFrameBase&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::ScopedFrameBase&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution&gt;
{
};

</code></pre></div><h3 id="cg-details-scopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution-0"><a href="#cg-details-scopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution-0" class="header-anchor">#</a> <code>cg::details::ScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::ScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,0&gt; : cg::details::ScopedFrameBase&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution&gt;
{
  cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt; *mDispatcher;
};

</code></pre></div><h3 id="cg-details-specializedscopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution-void"><a href="#cg-details-specializedscopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution-void" class="header-anchor">#</a> <code>cg::details::SpecializedScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::SpecializedScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,void&gt; : cg::details::ScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,0&gt;
{
};

</code></pre></div><h3 id="commandlistqueue"><a href="#commandlistqueue" class="header-anchor">#</a> <code>CommandListQueue</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandListQueue
{
  CommandListTaskContext mGlobalContext;
  bool mIsAsync;
  mce::RenderContext *mGlobalRenderContext;
  cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt; mDragonDispatcher;
  std::unique_ptr&lt;cg::details::SpecializedScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,void&gt;&gt; mDragonDispatcherScope;
  Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt; mPerThreadContextConstants;
};

</code></pre></div><h3 id="core-observer-hbui-routerobserver-core-singlethreadedlock"><a href="#core-observer-hbui-routerobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-hbui-routerobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-hbui-routerobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-hbui-routerobserver-core-singlethreadedlock"><a href="#core-subject-hbui-routerobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;hbui::RouterObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;hbui::RouterObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="contentdiscovery"><a href="#contentdiscovery" class="header-anchor">#</a> <code>ContentDiscovery</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentDiscovery
{
  IContentDiscoveryListener *mContentDiscoveryListener;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;ContentCatalogService&gt; &gt; mCatalogService;
  PackSourceFactory *mPackSourceFactory;
  const int SEARCH_BATCH_SIZE;
  const int SEARCH_PAGE_SIZE;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
};

</code></pre></div><h3 id="contenttracker"><a href="#contenttracker" class="header-anchor">#</a> <code>ContentTracker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentTracker
{
  bool mUsePersonaService;
  IContentEventListener *mEventListener;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;ContentCatalogService&gt; &gt; mCatalogService;
  ExternalContentManager *mExternalContentManager;
  Bedrock::NonOwnerPointer&lt;SoundEngine&gt; mSoundEngine;
  std::function&lt;std::shared_ptr&lt;DlcImportContext&gt; __cdecl(bool,Core::Path const &amp;,std::function&lt;void __cdecl(bool)&gt;,std::function&lt;void __cdecl(bool,PackManifest const *)&gt;)&gt; mDlcImportContextFactory;
  PropertyBag mProperties;
  int mPropertyChangeVersion;
  std::string mContentUrl;
  std::string mTitle;
  unsigned __int64 mFileSize;
  bool mTitleLocked;
  bool mHasHydrated;
  std::shared_ptr&lt;TaskGroup&gt; mIOTaskGroup;
  std::shared_ptr&lt;FileDownloadManager&gt; mFileDownloadManager;
  std::shared_ptr&lt;DlcImportContext&gt; mImportContext;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
  bool mReleaseDownloader;
  int mDownloadRetryAttempts;
  std::chrono::duration&lt;__int64,std::ratio&lt;1,1&gt; &gt; mDownloadRetryDelay;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mDownloadFailureTime;
};

</code></pre></div><h3 id="contentacquisition-packimportcallbackinfo"><a href="#contentacquisition-packimportcallbackinfo" class="header-anchor">#</a> <code>ContentAcquisition::PackImportCallbackInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentAcquisition::PackImportCallbackInfo
{
  bool mShouldCheckExistence;
  std::weak_ptr&lt;bool&gt; mExistenceTracker;
  std::function&lt;void __cdecl(PackImportStateObject &amp;)&gt; mCallback;
};

</code></pre></div><h3 id="contentacquisition"><a href="#contentacquisition" class="header-anchor">#</a> <code>ContentAcquisition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentAcquisition : IContentEventListener, IContentDiscoveryListener, IContentAcquisition, Bedrock::EnableNonOwnerReferences
{
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;ContentCatalogService&gt; &gt; mCatalogService;
  ExternalContentManager *mExternalContentManager;
  ResourcePackRepository *mResourcePackRepository;
  ResourcePackManager *mResourcePackManager;
  WorldTemplateManager *mTemplateManager;
  IMinecraftEventing *mEventing;
  ToastManager *mToastManager;
  Bedrock::NonOwnerPointer&lt;SoundEngine&gt; mSoundEngine;
  bool mStarted;
  __declspec(align(4)) RetryDelay mAutoSaveRetry;
  RetryDelay mContentDiscoveryRetry;
  Json::Value mSerializedState;
  AutoUpdateMode mAutoUpdateMode;
  std::unique_ptr&lt;ContentDiscovery&gt; mContentDiscovery;
  std::vector&lt;std::shared_ptr&lt;ContentTracker&gt;&gt; mContentTrackers;
  std::vector&lt;ContentAcquisition::DownloadCallback&gt; mDownloadCallbacks;
  std::function&lt;void __cdecl(std::string const &amp;,DurableDocument const &amp;)&gt; mUpdateFoundCallback;
  std::vector&lt;ContentAcquisition::PackImportCallbackInfo&gt; mPackImportCallbacks;
  std::unordered_map&lt;DlcId,ContentAcquisition::DownloadHistory&gt; mDownloadHistory;
  std::unordered_map&lt;std::string,DlcId&gt; mCachedProductIdLookup;
  std::shared_ptr&lt;TaskGroup&gt; mIOTaskGroup;
};

</code></pre></div><h3 id="contentacquisition-vtbl"><a href="#contentacquisition-vtbl" class="header-anchor">#</a> <code>ContentAcquisition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentAcquisition_vtbl
{
  void (__fastcall *~IContentEventListener)(IContentEventListener *this);
  void (__fastcall *onDownloadEvent)(IContentEventListener *this, ContentEventType, InitiatorCategory, const DlcId *, const std::string *, const std::vector&lt;PackIdVersion&gt; *, unsigned __int64, long double, bool);
  void (__fastcall *onImportEvent)(IContentEventListener *this, ContentEventType, InitiatorCategory, const DlcId *, const std::string *, const std::vector&lt;PackIdVersion&gt; *, bool, bool);
  void (__fastcall *onPackImportEvent)(IContentEventListener *this, const std::string *, const PackManifest *, bool);
};

</code></pre></div><h3 id="componentdescription-vtbl"><a href="#componentdescription-vtbl" class="header-anchor">#</a> <code>ComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ComponentDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
};

</code></pre></div><h3 id="core-observer-activedirectoryidentityobserver-core-singlethreadedlock"><a href="#core-observer-activedirectoryidentityobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-activedirectoryidentityobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-activedirectoryidentityobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-activedirectoryidentityobserver-core-singlethreadedlock"><a href="#core-subject-activedirectoryidentityobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;ActiveDirectoryIdentityObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;ActiveDirectoryIdentityObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="core-observer-i18nobserver-core-singlethreadedlock"><a href="#core-observer-i18nobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;I18nObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;I18nObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;I18nObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;I18nObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-i18nobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-i18nobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;I18nObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;I18nObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;I18nObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;I18nObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;I18nObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-deferredtask"><a href="#core-deferredtask" class="header-anchor">#</a> <code>Core::DeferredTask</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::DeferredTask
{
  std::atomic&lt;enum Core::DeferredTask::State&gt; mState;
  std::condition_variable mCondition;
  std::mutex mExecutionMutex;
  std::function&lt;void __cdecl(void)&gt; mCallback;
  const bool mCanSkipExecution;
};

</code></pre></div><h3 id="cg-details-lambdaexecutorcontextcontainer-dragon-rendering-rendercontext-0"><a href="#cg-details-lambdaexecutorcontextcontainer-dragon-rendering-rendercontext-0" class="header-anchor">#</a> <code>cg::details::LambdaExecutorContextContainer&lt;dragon::rendering::RenderContext,0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::LambdaExecutorContextContainer&lt;dragon::rendering::RenderContext,0&gt;
{
  dragon::rendering::RenderContext mContext;
};

</code></pre></div><h3 id="cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1"><a href="#cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1" class="header-anchor">#</a> <code>cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;
{
  std::unique_ptr&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;&gt; mWorkQueue;
  dragon::rendering::RenderContext *mContext;
};

</code></pre></div><h3 id="cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const"><a href="#cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const" class="header-anchor">#</a> <code>cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;
{
  cg::details::LambdaExecutorContextContainer&lt;dragon::rendering::RenderContext,0&gt; mContextContainer;
  dragon::rendering::RenderContext *mContext;
  cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt; mExecutionPolicy;
};

</code></pre></div><h3 id="cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const"><a href="#cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const" class="header-anchor">#</a> <code>cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt;
{
  std::unique_ptr&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;&gt; mExecutionContext;
  std::atomic&lt;int&gt; mPendingWorkCount;
};

</code></pre></div><h3 id="cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const"><a href="#cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const" class="header-anchor">#</a> <code>cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;
{
  cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; mScheduler;
};

</code></pre></div><h3 id="core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource"><a href="#core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-vertexbuffertype-bufferresource" class="header-anchor">#</a> <code>Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt; &gt;
{
  std::shared_mutex mAccess;
  std::unordered_map&lt;unsigned __int64,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::VertexBufferType&gt;::BufferResource&gt;&gt; mContent;
};

</code></pre></div><h3 id="core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource"><a href="#core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-mesh-indexbuffertype-bufferresource" class="header-anchor">#</a> <code>Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt; &gt;
{
  std::shared_mutex mAccess;
  std::unordered_map&lt;unsigned __int64,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::mesh::IndexBufferType&gt;::BufferResource&gt;&gt; mContent;
};

</code></pre></div><h3 id="core-cpuringbufferallocation-buffer-buffer"><a href="#core-cpuringbufferallocation-buffer-buffer" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocation_Buffer::Buffer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocation_Buffer::Buffer
{
  std::vector&lt;unsigned char&gt; mBuffer;
};

</code></pre></div><h3 id="core-cpuringbufferallocation-buffer"><a href="#core-cpuringbufferallocation-buffer" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocation_Buffer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocation_Buffer
{
};

</code></pre></div><h3 id="core-checkedringbuffer-2-0"><a href="#core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CheckedRingBuffer&lt;2,0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CheckedRingBuffer&lt;2,0&gt;
{
  FencedDynamicRingBuffer&lt;Core::CpuRingBufferAllocation_Buffer,2,0&gt; *mBuffer;
  unsigned __int64 mFence;
};

</code></pre></div><h3 id="core-cpuringbufferallocator-unsigned-char-2-0-core-checkedringbuffer-2-0"><a href="#core-cpuringbufferallocator-unsigned-char-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::CpuRingBufferAllocator&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CpuRingBufferAllocator&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;
{
  Core::CheckedRingBuffer&lt;2,0&gt; *mBufferInstance;
};

</code></pre></div><h3 id="core-sharedmemorytracker"><a href="#core-sharedmemorytracker" class="header-anchor">#</a> <code>Core::SharedMemoryTracker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::SharedMemoryTracker
{
  MPMCQueue&lt;std::shared_ptr&lt;Core::SharedMemoryTracker::SharedMemoryTrackerBase&gt; &gt; mTrackedMemory;
};

</code></pre></div><h3 id="core-ringallocatorcontainer-unsigned-char-2-0-core-checkedringbuffer-2-0-allocationscope"><a href="#core-ringallocatorcontainer-unsigned-char-2-0-core-checkedringbuffer-2-0-allocationscope" class="header-anchor">#</a> <code>Core::RingAllocatorContainer&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::AllocationScope</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::RingAllocatorContainer&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;::AllocationScope
{
  std::function&lt;void __cdecl(void)&gt; mFinalizer;
  Core::CpuRingBufferAllocator&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt; mAllocator;
  FencedDynamicRingBuffer&lt;Core::CpuRingBufferAllocation_Buffer,2,0&gt; *mRing;
  Core::CheckedRingBuffer&lt;2,0&gt; mCheckedRing;
  const unsigned __int64 mFence;
};

</code></pre></div><h3 id="core-ringallocatorcontainer-unsigned-char-2-0-core-checkedringbuffer-2-0"><a href="#core-ringallocatorcontainer-unsigned-char-2-0-core-checkedringbuffer-2-0" class="header-anchor">#</a> <code>Core::RingAllocatorContainer&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::RingAllocatorContainer&lt;unsigned char,2,0,Core::CheckedRingBuffer&lt;2,0&gt; &gt;
{
  unsigned __int64 mCurrentFence;
  std::atomic&lt;unsigned __int64&gt; mLastCompletedFence;
  std::atomic&lt;bool&gt; mHasLastCompletedFence;
  std::shared_ptr&lt;Core::CpuRingBufferAllocation_Buffer&gt; mBuffer;
  FencedDynamicRingBuffer&lt;Core::CpuRingBufferAllocation_Buffer,2,0&gt; mRing;
};

</code></pre></div><h3 id="cg-details-scopedframebase-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution"><a href="#cg-details-scopedframebase-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution" class="header-anchor">#</a> <code>cg::details::ScopedFrameBase&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::ScopedFrameBase&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution&gt;
{
};

</code></pre></div><h3 id="cg-details-scopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution-0"><a href="#cg-details-scopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution-0" class="header-anchor">#</a> <code>cg::details::ScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::ScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,0&gt; : cg::details::ScopedFrameBase&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution&gt;
{
  cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt; *mDispatcher;
};

</code></pre></div><h3 id="cg-details-specializedscopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution-void"><a href="#cg-details-specializedscopedframe-cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution-void" class="header-anchor">#</a> <code>cg::details::SpecializedScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::SpecializedScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,void&gt; : cg::details::ScopedFrame&lt;cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution,0&gt;
{
};

</code></pre></div><h3 id="cg-resourcemanager-std-unique-ptr-dragon-materials-compiledmaterialdefinition-std-string-void-std-unique-ptr-dragon-materials-compiledmaterialdefinition-std-unordered-map"><a href="#cg-resourcemanager-std-unique-ptr-dragon-materials-compiledmaterialdefinition-std-string-void-std-unique-ptr-dragon-materials-compiledmaterialdefinition-std-unordered-map" class="header-anchor">#</a> <code>cg::ResourceManager&lt;std::unique_ptr&lt;dragon::materials::CompiledMaterialDefinition&gt;,std::string,void,std::unique_ptr&lt;dragon::materials::CompiledMaterialDefinition&gt; *,std::unordered_map&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::ResourceManager&lt;std::unique_ptr&lt;dragon::materials::CompiledMaterialDefinition&gt;,std::string,void,std::unique_ptr&lt;dragon::materials::CompiledMaterialDefinition&gt; *,std::unordered_map&gt;
{
  std::unordered_map&lt;std::string,std::unique_ptr&lt;dragon::materials::CompiledMaterialDefinition&gt;&gt; mContainer;
};

</code></pre></div><h3 id="cg-resourcemanager-std-unique-ptr-dragon-materials-material-dragon-materials-materiallocation-void-std-unique-ptr-dragon-materials-material-std-unordered-map"><a href="#cg-resourcemanager-std-unique-ptr-dragon-materials-material-dragon-materials-materiallocation-void-std-unique-ptr-dragon-materials-material-std-unordered-map" class="header-anchor">#</a> <code>cg::ResourceManager&lt;std::unique_ptr&lt;dragon::materials::Material&gt;,dragon::materials::MaterialLocation,void,std::unique_ptr&lt;dragon::materials::Material&gt; *,std::unordered_map&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::ResourceManager&lt;std::unique_ptr&lt;dragon::materials::Material&gt;,dragon::materials::MaterialLocation,void,std::unique_ptr&lt;dragon::materials::Material&gt; *,std::unordered_map&gt;
{
  std::unordered_map&lt;dragon::materials::MaterialLocation,std::unique_ptr&lt;dragon::materials::Material&gt;&gt; mContainer;
};

</code></pre></div><h3 id="core-ifilesystem"><a href="#core-ifilesystem" class="header-anchor">#</a> <code>Core::IFileSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::IFileSystem
{
  Core::IFileSystem_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="core-ifile"><a href="#core-ifile" class="header-anchor">#</a> <code>Core::IFile</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::IFile
{
  Core::IFile_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="core-ifile-vtbl"><a href="#core-ifile-vtbl" class="header-anchor">#</a> <code>Core::IFile_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::IFile_vtbl
{
  void (__fastcall *~IFile)(Core::IFile *this);
  Core::Result *(__fastcall *readExactly)(Core::IFile *this, Core::Result *result, void *, unsigned __int64);
  Core::Result *(__fastcall *readAtPosition)(Core::IFile *this, Core::Result *result, unsigned __int64, void *, unsigned __int64, unsigned __int64 *);
  Core::Result *(__fastcall *getSize)(Core::IFile *this, Core::Result *result, unsigned __int64 *);
};

</code></pre></div><h3 id="core-ifilesystem-vtbl"><a href="#core-ifilesystem-vtbl" class="header-anchor">#</a> <code>Core::IFileSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::IFileSystem_vtbl
{
  void (__fastcall *~IFileSystem)(Core::IFileSystem *this);
  std::unique_ptr&lt;Core::IFile&gt; *(__fastcall *openFile)(Core::IFileSystem *this, std::unique_ptr&lt;Core::IFile&gt; *result, Core::Path, Core::FileOpenMode, Core::FileBufferingMode);
  bool (__fastcall *fileExists)(Core::IFileSystem *this, Core::Path);
  Core::Result *(__fastcall *iterateOverDirectory)(Core::IFileSystem *this, Core::Result *result, Core::Path, Core::DirectoryIterationFlags, std::function&lt;Core::Result __cdecl(Core::DirectoryIterationItem const &amp;)&gt;);
  Core::Result *(__fastcall *getDirectoryFiles)(Core::IFileSystem *this, Core::Result *result, std::vector&lt;Core::PathBuffer&lt;std::string &gt;&gt; *, Core::Path);
};

</code></pre></div><h3 id="contentlog-threadspecificdata-scopedata"><a href="#contentlog-threadspecificdata-scopedata" class="header-anchor">#</a> <code>ContentLog::ThreadSpecificData::ScopeData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLog::ThreadSpecificData::ScopeData
{
  std::string mMessage;
  gsl::not_null&lt;ContentLog::ContentLogScope const *&gt; mContentLogScope;
};

</code></pre></div><h3 id="contextmessagelogger-vtbl"><a href="#contextmessagelogger-vtbl" class="header-anchor">#</a> <code>ContextMessageLogger_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContextMessageLogger_vtbl
{
  void (__fastcall *~ContextMessageLogger)(ContextMessageLogger *this);
};

</code></pre></div><h3 id="contextmessage"><a href="#contextmessage" class="header-anchor">#</a> <code>ContextMessage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContextMessage
{
  LogArea mArea;
  LogLevel mLevel;
  std::string mMessage;
};

</code></pre></div><h3 id="contentlog-threadspecificdata"><a href="#contentlog-threadspecificdata" class="header-anchor">#</a> <code>ContentLog::ThreadSpecificData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLog::ThreadSpecificData
{
  std::vector&lt;ContentLog::ThreadSpecificData::ScopeData&gt; mScope;
  std::vector&lt;ContextMessageLogger *&gt; mMessageLoggers;
};

</code></pre></div><h3 id="contentlog-scopehandler"><a href="#contentlog-scopehandler" class="header-anchor">#</a> <code>ContentLog::ScopeHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLog::ScopeHandler : std::enable_shared_from_this&lt;ContentLog::ScopeHandler&gt;
{
  Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt; mThreadSpecificData;
};

</code></pre></div><h3 id="contentlog"><a href="#contentlog" class="header-anchor">#</a> <code>ContentLog</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLog : Bedrock::EnableNonOwnerReferences, DisableServiceLocatorOverride
{
  bool mEnabled;
  std::map&lt;typeid_t&lt;ContentLog&gt;,ContentLog::ContentLogEndPointData,std::less&lt;typeid_t&lt;ContentLog&gt; &gt;,std::allocator&lt;std::pair&lt;typeid_t&lt;ContentLog&gt; const ,ContentLog::ContentLogEndPointData&gt; &gt; &gt; mEndPoints;
  std::mutex mEndpointMutex;
  std::shared_ptr&lt;ContentLog::ScopeHandler&gt; mScopeHandler;
};

</code></pre></div><h3 id="contentlogfileendpoint"><a href="#contentlogfileendpoint" class="header-anchor">#</a> <code>ContentLogFileEndPoint</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) ContentLogFileEndPoint : ContentLogEndPoint
{
  std::unique_ptr&lt;Core::OutputFileStream&gt; mFileStream;
  Core::PathBuffer&lt;std::string &gt; mDebugLogDirectory;
  Core::PathBuffer&lt;std::string &gt; mFilePath;
  unsigned int mNumTimesOpened;
  bool mIsEnabled;
};

</code></pre></div><h3 id="contentlogfileendpoint-vtbl"><a href="#contentlogfileendpoint-vtbl" class="header-anchor">#</a> <code>ContentLogFileEndPoint_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentLogFileEndPoint_vtbl
{
  void (__fastcall *~LogEndPoint)(Bedrock::LogEndPoint *this);
  void (__fastcall *log)(Bedrock::LogEndPoint *this, const char *);
  void (__fastcall *flush)(Bedrock::LogEndPoint *this);
  void (__fastcall *setEnabled)(Bedrock::LogEndPoint *this, bool);
  bool (__fastcall *isEnabled)(Bedrock::LogEndPoint *this);
  void (__fastcall *log)(ContentLogEndPoint *this, const LogArea, const LogLevel, const char *);
};

</code></pre></div><h3 id="core-lrucache-core-pathbuffer-std-string-fmod-sound-std-shared-ptr-fmod-sound-cacheitem"><a href="#core-lrucache-core-pathbuffer-std-string-fmod-sound-std-shared-ptr-fmod-sound-cacheitem" class="header-anchor">#</a> <code>Core::LRUCache&lt;Core::PathBuffer&lt;std::string &gt;,FMOD::Sound,std::shared_ptr&lt;FMOD::Sound&gt; &gt;::CacheItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::LRUCache&lt;Core::PathBuffer&lt;std::string &gt;,FMOD::Sound,std::shared_ptr&lt;FMOD::Sound&gt; &gt;::CacheItem
{
  Core::PathBuffer&lt;std::string &gt; mKey;
  std::shared_ptr&lt;FMOD::Sound&gt; mValue;
  unsigned __int64 mSizeInBytes;
};

</code></pre></div><h3 id="core-lrucache-core-pathbuffer-std-string-fmod-sound-std-shared-ptr-fmod-sound"><a href="#core-lrucache-core-pathbuffer-std-string-fmod-sound-std-shared-ptr-fmod-sound" class="header-anchor">#</a> <code>Core::LRUCache&lt;Core::PathBuffer&lt;std::string &gt;,FMOD::Sound,std::shared_ptr&lt;FMOD::Sound&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::LRUCache&lt;Core::PathBuffer&lt;std::string &gt;,FMOD::Sound,std::shared_ptr&lt;FMOD::Sound&gt; &gt;
{
  std::shared_mutex mAccess;
  std::atomic&lt;unsigned __int64&gt; mCurrentSizeInBytes;
  const unsigned __int64 mCapacityInBytes;
  std::list&lt;Core::LRUCache&lt;Core::PathBuffer&lt;std::string &gt;,FMOD::Sound,std::shared_ptr&lt;FMOD::Sound&gt; &gt;::CacheItem,std::allocator&lt;Core::LRUCache&lt;Core::PathBuffer&lt;std::string &gt;,FMOD::Sound,std::shared_ptr&lt;FMOD::Sound&gt; &gt;::CacheItem&gt; &gt; mCacheList;
  std::unordered_map&lt;Core::PathBuffer&lt;std::string &gt;,std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;Core::LRUCache&lt;Core::PathBuffer&lt;std::string &gt;,FMOD::Sound,std::shared_ptr&lt;FMOD::Sound&gt; &gt;::CacheItem&gt; &gt; &gt;,std::hash&lt;Core::PathBuffer&lt;std::string &gt; &gt;,std::equal_to&lt;Core::PathBuffer&lt;std::string &gt; &gt;,std::allocator&lt;std::pair&lt;Core::PathBuffer&lt;std::string &gt; const ,std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;Core::LRUCache&lt;Core::PathBuffer&lt;std::string &gt;,FMOD::Sound,std::shared_ptr&lt;FMOD::Sound&gt; &gt;::CacheItem&gt; &gt; &gt; &gt; &gt; &gt; mCacheMap;
};

</code></pre></div><h3 id="custommusic-queuedmusicitem"><a href="#custommusic-queuedmusicitem" class="header-anchor">#</a> <code>CustomMusic::QueuedMusicItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CustomMusic::QueuedMusicItem
{
  std::string mEventName;
  float mVolume;
  float mFadeoutSeconds;
  _BYTE mPlayMode[1];
};

</code></pre></div><h3 id="custommusic"><a href="#custommusic" class="header-anchor">#</a> <code>CustomMusic</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CustomMusic : Music
{
  _BYTE mCurrentPlayMode[1];
  std::queue&lt;CustomMusic::QueuedMusicItem&gt; mMusicQueue;
  bool _mIsActive;
};

</code></pre></div><h3 id="custommusic-vtbl"><a href="#custommusic-vtbl" class="header-anchor">#</a> <code>CustomMusic_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CustomMusic_vtbl
{
  void (__fastcall *~Music)(Music *this);
  bool (__fastcall *hasTracks)(Music *this);
  void (__fastcall *nextTrack)(Music *this);
  void (__fastcall *setActive)(Music *this, bool);
};

</code></pre></div><h3 id="clientassetcachecontroller-unloadcallback"><a href="#clientassetcachecontroller-unloadcallback" class="header-anchor">#</a> <code>ClientAssetCacheController::UnloadCallback</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientAssetCacheController::UnloadCallback
{
  std::function&lt;void __cdecl(void)&gt; mCallback;
  bool mResourceCached;
};

</code></pre></div><h3 id="clientassetcachecontroller"><a href="#clientassetcachecontroller" class="header-anchor">#</a> <code>ClientAssetCacheController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientAssetCacheController
{
  bool mIsInGame;
  bool mCacheInvalid;
  std::vector&lt;std::string&gt; mPackIds;
  std::map&lt;enum AssetCacheCategory,ClientAssetCacheController::UnloadCallback&gt; mUnloadCallbacks;
};

</code></pre></div><h3 id="clubsservice"><a href="#clubsservice" class="header-anchor">#</a> <code>ClubsService</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClubsService : ServiceClient
{
  IMinecraftEventing *mMinecraftEventing;
};

</code></pre></div><h3 id="clubsservice-vtbl"><a href="#clubsservice-vtbl" class="header-anchor">#</a> <code>ClubsService_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClubsService_vtbl
{
  void (__fastcall *~ServiceClient)(ServiceClient *this);
  void (__fastcall *update)(ServiceClient *this);
  void (__fastcall *_submitRequest)(ServiceClient *this, std::shared_ptr&lt;RequestHandler&gt;);
};

</code></pre></div><h3 id="cubemapbackgroundresources"><a href="#cubemapbackgroundresources" class="header-anchor">#</a> <code>CubemapBackgroundResources</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CubemapBackgroundResources
{
  std::array&lt;mce::TexturePtr,6&gt; mPanoramaImages;
  std::array&lt;ResourceLocation,6&gt; mPanormaResourceLocations;
  mce::ClientTexture mCubemapTexture;
  ResourceLocation mOverlayLocation;
  mce::TexturePtr mOverlayTexture;
  int mTextureRefCount;
  bool mPrimaryClientUnloaded;
  bool mPendingRecreateCubemap;
  mce::Color mFadeInColor;
};

</code></pre></div><h3 id="clientinstanceeventlistener"><a href="#clientinstanceeventlistener" class="header-anchor">#</a> <code>ClientInstanceEventListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventListener
{
  ClientInstanceEventListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="clientinstance"><a href="#clientinstance" class="header-anchor">#</a> <code>ClientInstance</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance : IClientInstance, Core::StorageAreaStateListener, GameCallbacks, PlayerListener, std::enable_shared_from_this&lt;ClientInstance&gt;
{
  ClientInstanceState mClientState;
  IMinecraftApp *mApp;
  LevelListener *mLevelListener;
  IMinecraftGame *mMinecraftGame;
  std::unique_ptr&lt;Minecraft&gt; mMinecraft;
  bool mIsFullVanillaPackOnStack;
  std::unique_ptr&lt;LevelRenderer&gt; mLevelRenderer;
  std::unique_ptr&lt;LightTexture&gt; mLightTexture;
  std::unique_ptr&lt;LoopbackPacketSender&gt; mPacketSender;
  std::unique_ptr&lt;HolographicPlatform&gt; mHoloInput;
  std::unique_ptr&lt;VoiceSystem&gt; mVoiceSystem;
  std::unique_ptr&lt;MoveInputHandler&gt; mClientMoveInputHandler;
  std::unique_ptr&lt;ClientInputHandler&gt; mClientInputHandler;
  std::unique_ptr&lt;MinecraftKeyboardManager&gt; mKeyboardManager;
  std::unique_ptr&lt;HitDetectSystem&gt; mHitDetectSystem;
  std::shared_ptr&lt;UserAuthentication&gt; mUserAuthentication;
  std::unique_ptr&lt;SceneFactory&gt; mSceneFactory;
  std::unique_ptr&lt;CachedScenes&gt; mCachesScenes;
  std::unique_ptr&lt;CameraManager&gt; mCameraManager;
  Actor *mCameraEntity;
  Actor *mCameraTargetEntity;
  LocalPlayer *mPlayer;
  ActorUniqueID mCameraTargetEntityId;
  std::unique_ptr&lt;BuildActionIntention&gt; mInProgressBai;
  int mLastBuildActionTick;
  float mHoloviewerScale;
  float mRealityModeFrameFactor;
  bool mRealityModeToggleTriggered;
  ClientPlayMode mPlayMode;
  bool mTickedLastFrame;
  std::atomic&lt;bool&gt; mOpenControllerDisconnectScreen;
  std::atomic&lt;bool&gt; mHandlingControllerDisconnect;
  std::atomic&lt;bool&gt; mConnectGamepadScreenActive;
  PlayScreenDefaultTab mDefaultPlayscreenTab;
  bool mIsInUpdate;
  bool mLivingRoomCredits;
  std::function&lt;void __cdecl(void)&gt; mCreditsCallback;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mNoBlockBreakUntil;
  bool mNewDictationString;
  std::string mDictation;
  mce::ViewportInfo mViewportInfo;
  ClientInstance::ClientRenderResources mClientRenderResources;
  mce::Texture *mLevelTexture;
  mce::Camera mCamera;
  ShaderColor mShaderColor;
  ShaderColor mDarkShaderColor;
  Vec3 mLastPointerLocation;
  std::unique_ptr&lt;SceneStack&gt; mSceneStack;
  std::unique_ptr&lt;hbui::Router&gt; mUIRouter;
  std::unique_ptr&lt;ContentCatalogService&gt; mServerService;
  std::unique_ptr&lt;UIProfanityContext&gt; mUIProfanityContext;
  std::shared_ptr&lt;TextToSpeechClient&gt; mTextToSpeechClient;
  std::shared_ptr&lt;TTSEventManager&gt; mTTSEventManager;
  std::unique_ptr&lt;TaskGroup&gt; mTaskGroup;
  std::unique_ptr&lt;BlockTessellator&gt; mBlockTessellator;
  std::unique_ptr&lt;BlockActorRenderDispatcher&gt; mBlockEntityRenderDispatcher;
  std::unique_ptr&lt;ActorRenderDispatcher&gt; mEntityRenderDispatcher;
  std::unique_ptr&lt;ActorBlockRenderer&gt; mEntityBlockRenderer;
  std::unique_ptr&lt;ItemInHandRenderer&gt; mItemInHandRenderer;
  std::unique_ptr&lt;ItemRenderer&gt; mItemRenderer;
  std::unique_ptr&lt;GuiData&gt; mGuiData;
  std::unique_ptr&lt;GuidedFlowManager&gt; mGuidedFlowManager;
  std::unique_ptr&lt;MobEffectsLayout&gt; mMobEffectsLayout;
  std::unique_ptr&lt;ToastManager&gt; mToastManager;
  const unsigned __int8 mClientSubId;
  std::unique_ptr&lt;SkinRepositoryClientInterface&gt; mSkinRepositoryClientInterface;
  std::shared_ptr&lt;persona::PersonaPieceCollectionModel&gt; mPersonaPieceCollectionModel;
  ClientHMDState mHMDState;
  bool mIsSceneStackChanging;
  std::unique_ptr&lt;FogDefinitionRegistry&gt; mFogDefinitionRegistry;
  std::unique_ptr&lt;FogManager&gt; mFogManager;
  bool mHasSwitchedScreen;
  bool mShouldLeaveGame;
  bool mPreparingToLeaveGame;
  bool mIsLeavingGame;
  bool mSyncLeaveGame;
  bool mDestroyingGame;
  bool mShuttingDown;
  bool mUsingTripodNow;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mServerConnectionTime;
  unsigned int mServerPingTime;
  std::deque&lt;std::string&gt; mSentMessageHistory;
  std::deque&lt;std::string&gt; mDevConsoleMessageHistory;
  std::function&lt;void __cdecl(std::string const &amp;,enum BehaviorStatus)&gt; mBehaviorCommandStatusCallback;
  std::unique_ptr&lt;UIEventCoordinator&gt; mUIEventCoordinator;
  std::unique_ptr&lt;ClientHitDetectCoordinator&gt; mHitEventCoordinator;
  std::unordered_map&lt;std::string,int&gt; mProfanityExactMap;
  std::unordered_set&lt;std::string&gt; mProfanityContainsSet;
  std::unique_ptr&lt;EducationOptions&gt; mEducationOptions;
  glm::tvec2&lt;float,0&gt; mPrevCursorPos;
  glm::tvec2&lt;float,0&gt; mCurrentCursorPos;
  float mCursorPosAlpha;
  LatencyGraphDisplay *mLatencyGraphDisplay;
  std::unique_ptr&lt;GameModuleClient&gt; mGameModule;
  gsl::not_null&lt;Bedrock::NonOwnerPointer&lt;ClientInstanceEventCoordinator&gt; &gt; mEventCoordinator;
  std::unique_ptr&lt;MinecraftClientScriptEngine&gt; mScriptEngine;
  int mGameControllerId;
  bool mHideSnakeGUI;
  bool mHookMouse;
  bool mResponse;
  Actor *mHovered;
  std::vector&lt;std::string&gt; mAddOnList;
  int mSendCreateUiFinished;
  bool mLoadFinished;
  bool mHudScreenFinish;
  std::unique_ptr&lt;hbui::SceneProvider&gt; mSceneProvider;
  hbui::Telemetry mHBUITelemetry;
  std::shared_ptr&lt;ClientRequirementVerifier&gt; mClientRequirementVerifier;
};

</code></pre></div><h3 id="clientinputhandler"><a href="#clientinputhandler" class="header-anchor">#</a> <code>ClientInputHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputHandler
{
  IClientInstance *mClient;
  InputHandler *mInputHandler;
  std::unique_ptr&lt;ClientBindingFactory&gt; mBindingFactory;
  std::unique_ptr&lt;ClientInputMappingFactory&gt; mMappingFactory;
  std::string mLastGameMode;
  std::string mLastHoloUIMode;
  bool mIsFlying;
  bool mIsSneaking;
  bool mIsSwimming;
  bool mIsInWater;
  bool mIsInScaffolding;
  bool mIsOnScaffolding;
  bool mIsCreativeMode;
  bool mInteractActive;
  bool mHasMobEffects;
  bool mShowJumpButton;
  bool mShowSneakButton;
  std::unique_ptr&lt;ClientInputHandlerProxy&gt; mProxy;
};

</code></pre></div><h3 id="clientbindingfactory-vtbl"><a href="#clientbindingfactory-vtbl" class="header-anchor">#</a> <code>ClientBindingFactory_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBindingFactory_vtbl
{
  void (__fastcall *~BindingFactory)(BindingFactory *this);
  std::function&lt;bool __cdecl(void)&gt; *(__fastcall *getBooleanBinding)(BindingFactory *this, std::function&lt;bool __cdecl(void)&gt; *result, const std::string *);
  std::function&lt;std::string __cdecl(void)&gt; *(__fastcall *getStringBinding)(BindingFactory *this, std::function&lt;std::string __cdecl(void)&gt; *result, const std::string *);
  std::function&lt;glm::tvec2&lt;float,0&gt; __cdecl(void)&gt; *(__fastcall *getPointBinding)(BindingFactory *this, std::function&lt;glm::tvec2&lt;float,0&gt; __cdecl(void)&gt; *result, const std::string *);
  std::function&lt;RectangleArea __cdecl(void)&gt; *(__fastcall *getAreaBinding)(BindingFactory *this, std::function&lt;RectangleArea __cdecl(void)&gt; *result, const std::string *);
};

</code></pre></div><h3 id="chordbuttonmapping"><a href="#chordbuttonmapping" class="header-anchor">#</a> <code>ChordButtonMapping</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChordButtonMapping
{
  std::string generatedButtonName;
  std::vector&lt;std::string&gt; sourceButtonNames;
};

</code></pre></div><h3 id="clientinputmappingfactory"><a href="#clientinputmappingfactory" class="header-anchor">#</a> <code>ClientInputMappingFactory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputMappingFactory : InputMappingFactory
{
  std::unordered_map&lt;std::string,InputMapping&gt; mActiveInputMappings;
  std::unordered_map&lt;std::string,InputMapping&gt; mInputMappingTemplates;
  bool mInvertYAxis;
  bool mSwapGamepadButtonsXY;
  bool mSwapGamepadButtonsAB;
  float mSensitivity;
  GamePadRemappingLayout mGameControllerRemappingLayout;
  GamePadRemappingLayout mMotionControllerRemappingLayout;
  std::weak_ptr&lt;KeyboardRemappingLayout&gt; mKeyboardRemappingLayout;
};

</code></pre></div><h3 id="clientinputmappingfactory-vtbl"><a href="#clientinputmappingfactory-vtbl" class="header-anchor">#</a> <code>ClientInputMappingFactory_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientInputMappingFactory_vtbl
{
  void (__fastcall *~InputMappingFactory)(InputMappingFactory *this);
  const InputMapping *(__fastcall *getMapping)(InputMappingFactory *this, const std::string *);
  void (__fastcall *createInputMappingTemplates)(ClientInputMappingFactory *this, Options *);
  TouchInputMapping *(__fastcall *_createScreenTouchMapping)(ClientInputMappingFactory *this, TouchInputMapping *result);
  std::vector&lt;DeviceButtonMapping&gt; *(__fastcall *_createScreenDeviceButtonMapping)(ClientInputMappingFactory *this, std::vector&lt;DeviceButtonMapping&gt; *result);
  void (__fastcall *_updateKeyboardAndMouseControls)(ClientInputMappingFactory *this);
  void (__fastcall *_updateGameControllerControls)(ClientInputMappingFactory *this);
};

</code></pre></div><h3 id="clientinputhandlerproxycallbacks"><a href="#clientinputhandlerproxycallbacks" class="header-anchor">#</a> <code>ClientInputHandlerProxyCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ClientInputHandlerProxyCallbacks
{
  std::function&lt;unsigned int __cdecl(std::string const &amp;)&gt; mGetNameId;
};

</code></pre></div><h3 id="clientinputhandlerproxy"><a href="#clientinputhandlerproxy" class="header-anchor">#</a> <code>ClientInputHandlerProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputHandlerProxy
{
  const ClientInputHandlerProxyCallbacks mCallbacks;
};

</code></pre></div><h3 id="clienthitdetectlistener"><a href="#clienthitdetectlistener" class="header-anchor">#</a> <code>ClientHitDetectListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientHitDetectListener
{
  ClientHitDetectListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="clienthitdetectlistener-vtbl"><a href="#clienthitdetectlistener-vtbl" class="header-anchor">#</a> <code>ClientHitDetectListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientHitDetectListener_vtbl
{
  void (__fastcall *~ClientHitDetectListener)(ClientHitDetectListener *this);
  EventResult (__fastcall *onChangedHitResult)(ClientHitDetectListener *this, HitResult *);
  EventResult (__fastcall *onContinuousHitResult)(ClientHitDetectListener *this, HitResult *);
  EventResult (__fastcall *onChangedPickHitResult)(ClientHitDetectListener *this, HitResult *);
  EventResult (__fastcall *onContinuousPickHitResult)(ClientHitDetectListener *this, HitResult *);
};

</code></pre></div><h3 id="clienthitdetectcoordinator"><a href="#clienthitdetectcoordinator" class="header-anchor">#</a> <code>ClientHitDetectCoordinator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientHitDetectCoordinator : EventCoordinator&lt;ClientHitDetectListener&gt;
{
};

</code></pre></div><h3 id="cameraloader"><a href="#cameraloader" class="header-anchor">#</a> <code>CameraLoader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraLoader
{
  CameraLoader_vtbl *__vftable /*VFT*/;
  std::vector&lt;std::unique_ptr&lt;CameraBehaviorLoader&gt;&gt; mRegisteredBehaviorLoaders;
  std::unordered_map&lt;HashedString,std::unique_ptr&lt;ActivationRule&gt;&gt; mRegisteredActivationRules;
};

</code></pre></div><h3 id="cameraloader-vtbl"><a href="#cameraloader-vtbl" class="header-anchor">#</a> <code>CameraLoader_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraLoader_vtbl
{
  void (__fastcall *~CameraLoader)(CameraLoader *this);
  void (__fastcall *setupFallbackCamera)(CameraLoader *this, CameraDirector *);
};

</code></pre></div><h3 id="camerabehaviorloader"><a href="#camerabehaviorloader" class="header-anchor">#</a> <code>CameraBehaviorLoader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraBehaviorLoader
{
  CameraBehaviorLoader_vtbl *__vftable /*VFT*/;
  HashedString mId;
  std::string mName;
};

</code></pre></div><h3 id="camerabehaviorloader-vtbl"><a href="#camerabehaviorloader-vtbl" class="header-anchor">#</a> <code>CameraBehaviorLoader_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehaviorLoader_vtbl
{
  void (__fastcall *~CameraBehaviorLoader)(CameraBehaviorLoader *this);
  std::unique_ptr&lt;ICameraBehavior&gt; *(__fastcall *create)(CameraBehaviorLoader *this, std::unique_ptr&lt;ICameraBehavior&gt; *result);
  void (__fastcall *parse)(CameraBehaviorLoader *this, Json::Value *, ICameraBehavior *);
};

</code></pre></div><h3 id="camerapairhasher"><a href="#camerapairhasher" class="header-anchor">#</a> <code>CameraPairHasher</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraPairHasher
{
};

</code></pre></div><h3 id="camerablend"><a href="#camerablend" class="header-anchor">#</a> <code>CameraBlend</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBlend
{
  HashedString mCameraFromId;
  HashedString mCameraToId;
  float mPercentage;
  float mFieldOfViewOffset;
  Vec3 mPositionOffset;
  glm::tquat&lt;float,0&gt; mRotationOffset;
};

</code></pre></div><h3 id="cameramanager"><a href="#cameramanager" class="header-anchor">#</a> <code>CameraManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) CameraManager
{
  bool mIsDebugCameraActive;
  bool mIsDebugCameraControlActive;
  float mPreviousUpdateTime;
  std::unique_ptr&lt;CameraLoader&gt; mCameraLoader;
  std::unordered_map&lt;HashedString,CameraDirector&gt; mAvailableCameras;
  std::unordered_map&lt;std::pair&lt;HashedString,HashedString&gt;,CameraBlendSettings,CameraPairHasher,std::equal_to&lt;std::pair&lt;HashedString,HashedString&gt; &gt;,std::allocator&lt;std::pair&lt;std::pair&lt;HashedString,HashedString&gt; const ,CameraBlendSettings&gt; &gt; &gt; mCameraBlends;
  CameraDirector mFallbackCamera;
  HashedString mOverrideCamera;
  HashedString mForceActivateCamera;
  CameraBlend mCameraBlend;
  Camera mCamera;
  bool mDebugRenderFlagActiveCamera;
  bool mDebugRenderFlagAvoidance;
  bool mDebugRenderFlagFraming;
  bool mDebugRenderFlagSpline;
  bool mDebugRenderFlagAll;
  bool mIsBindingEntity;
};

</code></pre></div><h3 id="clientinstance-clientrenderresources"><a href="#clientinstance-clientrenderresources" class="header-anchor">#</a> <code>ClientInstance::ClientRenderResources</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::ClientRenderResources
{
  mce::Texture *mUITexture;
  mce::TexturePtr mUICursorTexture;
};

</code></pre></div><h3 id="chestblockactor"><a href="#chestblockactor" class="header-anchor">#</a> <code>ChestBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ChestBlockActor : RandomizableBlockActorFillingContainer
{
  float mSpeed;
  bool mIsGlobalChest;
  bool mUsesLegacyBlockDetection;
  float mObstructionHeight;
  __int8 mPairLead : 1;
  float mOpenness;
  float mOldOpenness;
  bool mIsOpen;
  int mTickInterval;
  __int8 mPairingChanged : 1;
  __int8 mAlongX : 1;
  __int8 mDeferredPairLoad : 1;
  __int8 mConverted : 1;
  int mDeferredPairX;
  int mDeferredPairZ;
  ChestBlockActor *mLargeChestPaired;
  BlockPos mLargeChestPairedPosition;
  bool mIsTrappedChest;
  bool mIsFindable;
  std::unordered_set&lt;ActorUniqueID&gt; mOpenedByIds;
  bool mNotifyPlayersOnChange;
};

</code></pre></div><h3 id="conduitblockactor"><a href="#conduitblockactor" class="header-anchor">#</a> <code>ConduitBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConduitBlockActor : BlockActor
{
  bool mIsActive;
  bool mIsHunting;
  int mBlockRefreshCounter;
  unsigned __int64 mNextAmbientSound;
  float mAnimationValue;
  float mRotation;
  int mRotationTickCount;
  int mWindLevel;
  int mEffectRange;
  ActorUniqueID mTarget;
  std::vector&lt;BlockPos&gt; mBlockPositions;
};

</code></pre></div><h3 id="clienthmdstate-vrrotationresetstate"><a href="#clienthmdstate-vrrotationresetstate" class="header-anchor">#</a> <code>ClientHMDState::VRRotationResetState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientHMDState::VRRotationResetState
{
  bool mPendingReset;
  bool mForceNextReset;
};

</code></pre></div><h3 id="clienthmdstate"><a href="#clienthmdstate" class="header-anchor">#</a> <code>ClientHMDState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientHMDState
{
  ClientInstance *mClientInstance;
  HoloHudDriftDynamics mHoloHudDriftDynamics;
  mce::RenderStage *mUIStage;
  mce::RenderStage *mLevelStage;
  mce::Texture *mLevelTexture;
  mce::Texture *mUITexture;
  std::shared_ptr&lt;mce::Texture&gt; mUILayersTexture;
  float mHoloScreenCursorXCoordNorm;
  float mHoloScreenCursorYCoordNorm;
  Matrix mLastLevelViewMatrix;
  Matrix mLastLevelViewMatrixAbsolute;
  Matrix mLastLevelProjMatrix;
  Matrix mLastLevelWorldMatrix;
  Matrix mHUDMatrixPatch;
  Matrix mVRTransitionMatrixPatch;
  float mLastLevelViewMatrixVerticalShift;
  float mLastVRPitchAngle;
  float mVRRotationAdjustment;
  float mVRRotAdjYawTweak;
  float mGazeCursorPitchBoostAngle;
  float mFadeScreenAlpha;
  float mDesiredFadeScreenAlpha;
  float mRealityFrameModeWorldScale;
  float mHeadSetDirForSleeping;
  __int16 mPointerX;
  __int16 mPointerY;
  bool mHoloCursorOn;
  bool mAppJustResumed;
  ClientHMDState::VRRotationResetState mVRRotationResetState;
  bool mHoloTransformsHaveBeenUpdated;
  HoloUIToPoseSource mLastHoloUIToPoseSource;
};

</code></pre></div><h3 id="clientrequirementverifier"><a href="#clientrequirementverifier" class="header-anchor">#</a> <code>ClientRequirementVerifier</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientRequirementVerifier : std::enable_shared_from_this&lt;ClientRequirementVerifier&gt;
{
  std::weak_ptr&lt;FlightingService&gt; mFlightingServiceExistenceTracker;
  bool mTreatmentsReady;
  std::vector&lt;std::string&gt; mTreatments;
  unsigned int mFlightingMonitorHandle;
};

</code></pre></div><h3 id="clientinstanceeventlistener-vtbl"><a href="#clientinstanceeventlistener-vtbl" class="header-anchor">#</a> <code>ClientInstanceEventListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientInstanceEventListener_vtbl
{
  void (__fastcall *~ClientInstanceEventListener)(ClientInstanceEventListener *this);
  EventResult (__fastcall *onClientInitializeStart)(ClientInstanceEventListener *this, ClientInstance *);
  EventResult (__fastcall *onClientInitializeEnd)(ClientInstanceEventListener *this, ClientInstance *);
  EventResult (__fastcall *onClientMinecraftInitialized)(ClientInstanceEventListener *this, ClientInstance *, Minecraft *);
  EventResult (__fastcall *onClientCreatedLevel)(ClientInstanceEventListener *this, ClientInstance *, Level *);
  EventResult (__fastcall *onClientUpdateStart)(ClientInstanceEventListener *this, ClientInstance *);
  EventResult (__fastcall *onClientUpdateEnd)(ClientInstanceEventListener *this, ClientInstance *);
  EventResult (__fastcall *onClientSuspend)(ClientInstanceEventListener *this, ClientInstance *);
  EventResult (__fastcall *onClientEnteredWorld)(ClientInstanceEventListener *this, ClientInstance *);
  EventResult (__fastcall *onStartLeaveGame)(ClientInstanceEventListener *this, ClientInstance *);
};

</code></pre></div><h3 id="clientinstanceeventcoordinator"><a href="#clientinstanceeventcoordinator" class="header-anchor">#</a> <code>ClientInstanceEventCoordinator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstanceEventCoordinator : EventCoordinator&lt;ClientInstanceEventListener&gt;
{
};

</code></pre></div><h3 id="compactionlistenerenv"><a href="#compactionlistenerenv" class="header-anchor">#</a> <code>CompactionListenerEnv</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompactionListenerEnv : leveldb::EnvWrapper
{
  leveldb::Env *mTarget;
  std::mutex mLock;
  bool mCompactionRunning;
  std::function&lt;void __cdecl(enum CompactionStatus)&gt; mCompactionCallback;
};

</code></pre></div><h3 id="compactionlistenerenv-vtbl"><a href="#compactionlistenerenv-vtbl" class="header-anchor">#</a> <code>CompactionListenerEnv_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CompactionListenerEnv_vtbl
{
  void (__fastcall *~Env)(leveldb::Env *this);
  leveldb::Status *(__fastcall *NewSequentialFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::SequentialFile **);
  leveldb::Status *(__fastcall *NewRandomAccessFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::RandomAccessFile **);
  leveldb::Status *(__fastcall *NewWritableFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::WritableFile **);
  leveldb::Status *(__fastcall *NewAppendableFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::WritableFile **);
  bool (__fastcall *FileExists)(leveldb::Env *this, const std::string *);
  leveldb::Status *(__fastcall *GetChildren)(leveldb::Env *this, leveldb::Status *result, const std::string *, std::vector&lt;std::string&gt; *);
  leveldb::Status *(__fastcall *DeleteFileA)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *CreateDir)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *DeleteDir)(leveldb::Env *this, leveldb::Status *result, const std::string *);
  leveldb::Status *(__fastcall *GetFileSize)(leveldb::Env *this, leveldb::Status *result, const std::string *, unsigned __int64 *);
  leveldb::Status *(__fastcall *RenameFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, const std::string *);
  leveldb::Status *(__fastcall *LockFile)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::FileLock **);
  leveldb::Status *(__fastcall *UnlockFile)(leveldb::Env *this, leveldb::Status *result, leveldb::FileLock *);
  void (__fastcall *Schedule)(leveldb::Env *this, void (__fastcall *)(void *), void *);
  void (__fastcall *StartThread)(leveldb::Env *this, void (__fastcall *)(void *), void *);
  leveldb::Status *(__fastcall *GetTestDirectory)(leveldb::Env *this, leveldb::Status *result, std::string *);
  leveldb::Status *(__fastcall *NewLogger)(leveldb::Env *this, leveldb::Status *result, const std::string *, leveldb::Logger **);
  unsigned __int64 (__fastcall *NowMicros)(leveldb::Env *this);
  void (__fastcall *SleepForMicroseconds)(leveldb::Env *this, int);
};

</code></pre></div><h3 id="clientblobcache-cache"><a href="#clientblobcache-cache" class="header-anchor">#</a> <code>ClientBlobCache::Cache</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlobCache::Cache : AppPlatformListener
{
  std::shared_ptr&lt;DBStorage&gt; mDB;
  TaskGroup mTaskGroup;
  std::mutex mTimestampMutex;
  std::unordered_map&lt;unsigned __int64,unsigned __int64&gt; mTimestamps;
  unsigned __int64 mBaseTimestamp;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mCacheLoadingTime;
};

</code></pre></div><h3 id="clientblobcache-cache-vtbl"><a href="#clientblobcache-cache-vtbl" class="header-anchor">#</a> <code>ClientBlobCache::Cache_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlobCache::Cache_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
};

</code></pre></div><h3 id="core-observer-edudiscovery-discoveryobserver-core-singlethreadedlock"><a href="#core-observer-edudiscovery-discoveryobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Observer&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt;
{
  Core::Observer&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-edudiscovery-discoveryobserver-core-singlethreadedlock-vtbl"><a href="#core-observer-edudiscovery-discoveryobserver-core-singlethreadedlock-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt;_vtbl
{
  void (__fastcall *~Observer&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt;)(Core::Observer&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt; *this);
};

</code></pre></div><h3 id="core-subject-edudiscovery-discoveryobserver-core-singlethreadedlock"><a href="#core-subject-edudiscovery-discoveryobserver-core-singlethreadedlock" class="header-anchor">#</a> <code>Core::Subject&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;EDUDiscovery::DiscoveryObserver,Core::SingleThreadedLock&gt;
{
  Core::SingleThreadedLock mLock;
  std::vector&lt;gsl::not_null&lt;EDUDiscovery::DiscoveryObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="chunkperformancedata-atomictimeaccumulator"><a href="#chunkperformancedata-atomictimeaccumulator" class="header-anchor">#</a> <code>ChunkPerformanceData::AtomicTimeAccumulator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkPerformanceData::AtomicTimeAccumulator
{
  unsigned __int64 mCount;
  std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; mTimeSum;
  std::mutex mTimeSumMutex;
};

</code></pre></div><h3 id="chunkperformancedata-atomicmemoryaccumulator"><a href="#chunkperformancedata-atomicmemoryaccumulator" class="header-anchor">#</a> <code>ChunkPerformanceData::AtomicMemoryAccumulator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkPerformanceData::AtomicMemoryAccumulator
{
  std::atomic&lt;unsigned __int64&gt; mCount;
  std::atomic&lt;unsigned __int64&gt; mMemorySum;
};

</code></pre></div><h3 id="chunkperformancedata"><a href="#chunkperformancedata" class="header-anchor">#</a> <code>ChunkPerformanceData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkPerformanceData : Bedrock::EnableNonOwnerReferences
{
  ChunkPerformanceData::AtomicTimeAccumulator mRenderChunkBuildPerformanceData;
  ChunkPerformanceData::AtomicTimeAccumulator mRenderChunkVisibilityPerformanceData;
  ChunkPerformanceData::AtomicTimeAccumulator mClientLevelChunkInitialLightingPerformanceData;
  ChunkPerformanceData::AtomicTimeAccumulator mServerLevelChunkLoadChunkPerformanceData;
  ChunkPerformanceData::AtomicTimeAccumulator mServerLevelChunkPostProcessingPerformanceData;
  ChunkPerformanceData::AtomicTimeAccumulator mServerLevelChunkCheckForReplacementDataPerformanceData;
  ChunkPerformanceData::AtomicTimeAccumulator mServerLevelChunkInitialLightingPerformanceData;
  ChunkPerformanceData::AtomicMemoryAccumulator mRenderChunkMemorySizePerformanceData;
  ChunkPerformanceData::AtomicTimeAccumulator mBiomeDecorationSystemDecorateTimeData;
  ChunkPerformanceData::AtomicTimeAccumulator mScatterFeaturePlaceTimeData;
  std::atomic&lt;unsigned __int64&gt; mBiomeFeaturePlaceCallsCount;
};

</code></pre></div><h3 id="chunkbuildorderpolicybase"><a href="#chunkbuildorderpolicybase" class="header-anchor">#</a> <code>ChunkBuildOrderPolicyBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkBuildOrderPolicyBase
{
  ChunkBuildOrderPolicyBase_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="chunkbuildorderpolicybase-vtbl"><a href="#chunkbuildorderpolicybase-vtbl" class="header-anchor">#</a> <code>ChunkBuildOrderPolicyBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChunkBuildOrderPolicyBase_vtbl
{
  void (__fastcall *~ChunkBuildOrderPolicyBase)(ChunkBuildOrderPolicyBase *this);
  int (__fastcall *getChunkRebuildPriority)(ChunkBuildOrderPolicyBase *this, const ChunkPos *);
  unsigned int (__fastcall *registerForUpdates)(ChunkBuildOrderPolicyBase *this);
  void (__fastcall *unregisterForUpdates)(ChunkBuildOrderPolicyBase *this, unsigned int);
  void (__fastcall *setBuildOrderInfluence)(ChunkBuildOrderPolicyBase *this, unsigned int, const ChunkPos *, const Vec3 *);
  void (__fastcall *updateInfluences)(ChunkBuildOrderPolicyBase *this);
};

</code></pre></div><h3 id="circuitscenegraph"><a href="#circuitscenegraph" class="header-anchor">#</a> <code>CircuitSceneGraph</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CircuitSceneGraph
{
  std::unordered_map&lt;BlockPos,std::unique_ptr&lt;BaseCircuitComponent&gt;&gt; mAllComponents;
  CircuitComponentList mActiveComponents;
  std::unordered_map&lt;BlockPos,CircuitComponentList&gt; mActiveComponentsPerChunk;
  std::unordered_map&lt;BlockPos,CircuitComponentList&gt; mPowerAssociationMap;
  std::unordered_map&lt;BlockPos,CircuitSceneGraph::PendingEntry&gt; mPendingAdds;
  std::unordered_map&lt;BlockPos,CircuitSceneGraph::PendingEntry&gt; mPendingUpdates;
  std::unordered_map&lt;BlockPos,std::vector&lt;BlockPos&gt;&gt; mComponentsToReEvaluate;
  std::vector&lt;CircuitSceneGraph::PendingEntry&gt; mPendingRemoves;
};

</code></pre></div><h3 id="circuitsystem"><a href="#circuitsystem" class="header-anchor">#</a> <code>CircuitSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CircuitSystem
{
  bool mLockGraph;
  CircuitSceneGraph mSceneGraph;
  std::vector&lt;CircuitSystem::LevelChunkTracking&gt; mAddedLevelChunk;
  bool mHasBeenEvaluated;
};

</code></pre></div><h3 id="circuitsystem-levelchunktracking"><a href="#circuitsystem-levelchunktracking" class="header-anchor">#</a> <code>CircuitSystem::LevelChunkTracking</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CircuitSystem::LevelChunkTracking
{
  BlockPos mChunkPos;
};

</code></pre></div><h3 id="chunkloadactionlist"><a href="#chunkloadactionlist" class="header-anchor">#</a> <code>ChunkLoadActionList</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ChunkLoadActionList
{
  std::vector&lt;ChunkLoadedRequest&gt; mChunkLoadedRequests;
  std::vector&lt;ChunkLoadedRequest&gt; mChunkLoadedRequestsWaitForTicking;
  unsigned int mRequestSaveCounter;
};

</code></pre></div><h3 id="commandorigin-vtbl"><a href="#commandorigin-vtbl" class="header-anchor">#</a> <code>CommandOrigin_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandOrigin_vtbl
{
  void (__fastcall *~CommandOrigin)(CommandOrigin *this);
  const std::string *(__fastcall *getRequestId)(CommandOrigin *this);
  std::string *(__fastcall *getName)(CommandOrigin *this, std::string *result);
  BlockPos *(__fastcall *getBlockPosition)(CommandOrigin *this, BlockPos *result);
  Vec3 *(__fastcall *getWorldPosition)(CommandOrigin *this, Vec3 *result);
  Level *(__fastcall *getLevel)(CommandOrigin *this);
  Dimension *(__fastcall *getDimension)(CommandOrigin *this);
  Actor *(__fastcall *getEntity)(CommandOrigin *this);
  CommandPermissionLevel (__fastcall *getPermissionsLevel)(CommandOrigin *this);
  std::unique_ptr&lt;CommandOrigin&gt; *(__fastcall *clone)(CommandOrigin *this, std::unique_ptr&lt;CommandOrigin&gt; *result);
  std::optional&lt;BlockPos&gt; *(__fastcall *getCursorHitBlockPos)(CommandOrigin *this, std::optional&lt;BlockPos&gt; *result);
  std::optional&lt;Vec3&gt; *(__fastcall *getCursorHitPos)(CommandOrigin *this, std::optional&lt;Vec3&gt; *result);
  bool (__fastcall *hasChatPerms)(CommandOrigin *this);
  bool (__fastcall *hasTellPerms)(CommandOrigin *this);
  bool (__fastcall *canUseAbility)(CommandOrigin *this, AbilitiesIndex);
  bool (__fastcall *isWorldBuilder)(CommandOrigin *this);
  bool (__fastcall *canUseCommandsWithoutCheatsEnabled)(CommandOrigin *this);
  bool (__fastcall *isSelectorExpansionAllowed)(CommandOrigin *this);
  const NetworkIdentifier *(__fastcall *getSourceId)(CommandOrigin *this);
  unsigned __int8 (__fastcall *getSourceSubId)(CommandOrigin *this);
  const CommandOrigin *(__fastcall *getOutputReceiver)(CommandOrigin *this);
  CommandOriginType (__fastcall *getOriginType)(CommandOrigin *this);
  CommandOriginData *(__fastcall *toCommandOriginData)(CommandOrigin *this, CommandOriginData *result);
  const mce::UUID *(__fastcall *getUUID)(CommandOrigin *this);
  void (__fastcall *handleCommandOutputCallback)(CommandOrigin *this, Json::Value *);
  void (__fastcall *_setUUID)(CommandOrigin *this, const mce::UUID *);
};

</code></pre></div><h3 id="commandregistry-enum"><a href="#commandregistry-enum" class="header-anchor">#</a> <code>CommandRegistry::Enum</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::Enum
{
  std::string name;
  typeid_t&lt;CommandRegistry&gt; type;
  bool (__fastcall *parse)(CommandRegistry *this, void *, const CommandRegistry::ParseToken *, const CommandOrigin *, int, std::string *, std::vector&lt;std::string&gt; *);
  std::vector&lt;std::pair&lt;unsigned __int64,unsigned __int64&gt;&gt; values;
};

</code></pre></div><h3 id="commandregistry-factorization"><a href="#commandregistry-factorization" class="header-anchor">#</a> <code>CommandRegistry::Factorization</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::Factorization
{
  CommandRegistry::Symbol commandSymbol;
};

</code></pre></div><h3 id="commandregistry-overload"><a href="#commandregistry-overload" class="header-anchor">#</a> <code>CommandRegistry::Overload</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CommandRegistry::Overload
{
  CommandVersion version;
  std::unique_ptr&lt;Command&gt; *(__fastcall *alloc)(std::unique_ptr&lt;Command&gt; *result);
  std::vector&lt;CommandParameterData&gt; params;
  int versionOffset;
};

</code></pre></div><h3 id="commandregistry-constrainedvalue"><a href="#commandregistry-constrainedvalue" class="header-anchor">#</a> <code>CommandRegistry::ConstrainedValue</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::ConstrainedValue
{
  CommandRegistry::Symbol mValue;
  CommandRegistry::Symbol mEnum;
  std::vector&lt;unsigned char&gt; mConstraints;
};

</code></pre></div><h3 id="commandregistry-softenum"><a href="#commandregistry-softenum" class="header-anchor">#</a> <code>CommandRegistry::SoftEnum</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::SoftEnum
{
  std::string mName;
  std::vector&lt;std::string&gt; mValues;
};

</code></pre></div><h3 id="commandregistry-paramsymbols"><a href="#commandregistry-paramsymbols" class="header-anchor">#</a> <code>CommandRegistry::ParamSymbols</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::ParamSymbols
{
  CommandRegistry::Symbol x;
  CommandRegistry::Symbol y;
  CommandRegistry::Symbol z;
  CommandRegistry::Symbol dx;
  CommandRegistry::Symbol dy;
  CommandRegistry::Symbol dz;
  CommandRegistry::Symbol r;
  CommandRegistry::Symbol rm;
  CommandRegistry::Symbol rx;
  CommandRegistry::Symbol rxm;
  CommandRegistry::Symbol ry;
  CommandRegistry::Symbol rym;
  CommandRegistry::Symbol l;
  CommandRegistry::Symbol lm;
  CommandRegistry::Symbol c;
  CommandRegistry::Symbol m;
  CommandRegistry::Symbol name;
  CommandRegistry::Symbol type;
  CommandRegistry::Symbol family;
  CommandRegistry::Symbol score;
  CommandRegistry::Symbol tag;
};

</code></pre></div><h3 id="chalkboardblockactor"><a href="#chalkboardblockactor" class="header-anchor">#</a> <code>ChalkboardBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChalkboardBlockActor : BlockActor
{
  std::string mText;
  std::string mTextObjectString;
  TextObjectRoot mTextObjectMessage;
  ChalkboardBlockActor::CachedMessageData mCachedMessage;
  BlockPos mBasePos;
  _BYTE mSize[1];
  bool mIsOnGround;
  bool mIsLocked;
  ActorUniqueID mOwner;
};

</code></pre></div><h3 id="cameracallbacks"><a href="#cameracallbacks" class="header-anchor">#</a> <code>CameraCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraCallbacks
{
  CameraCallbacks_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="cameracallbacks-vtbl"><a href="#cameracallbacks-vtbl" class="header-anchor">#</a> <code>CameraCallbacks_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraCallbacks_vtbl
{
  void (__fastcall *onTakePictureNow)(CameraCallbacks *this, Player *, Actor *, Actor *);
  void (__fastcall *onStartTakingPicture)(CameraCallbacks *this, Player *);
  void (__fastcall *onEndTakingPicture)(CameraCallbacks *this, Player *, Actor *, Actor *);
  void (__fastcall *~CameraCallbacks)(CameraCallbacks *this);
};

</code></pre></div><h3 id="componentitem"><a href="#componentitem" class="header-anchor">#</a> <code>ComponentItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComponentItem : Item
{
  std::unique_ptr&lt;std::unordered_map&lt;std::string,DefinitionEvent&gt;&gt; mEventHandlers;
  __int8 mExcludeUserDataDiffCheck : 1;
  __int8 mCanDestroyInCreative : 1;
  __int8 mRequiresInteract : 1;
  __int8 mIsLiquidClipped : 1;
  int mLevel;
  int mUses;
  float mSpeed;
  int mDamage;
  _BYTE mEnchantSlot[4];
  int mEnchantValue;
  std::vector&lt;std::string&gt; mAlias;
  Json::Value mOffsetList;
  std::map&lt;HashedString,std::shared_ptr&lt;ItemComponent&gt;&gt; mItemComponents;
  std::map&lt;std::string,std::shared_ptr&lt;ItemComponent&gt;&gt; mRegisteredCerealComponents;
};

</code></pre></div><h3 id="cameraitemcomponentlegacy-vtbl"><a href="#cameraitemcomponentlegacy-vtbl" class="header-anchor">#</a> <code>CameraItemComponentLegacy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraItemComponentLegacy_vtbl
{
  void (__fastcall *~ICameraItemComponent)(ICameraItemComponent *this);
  float (__fastcall *blackBarsDuration)(ICameraItemComponent *this);
  float (__fastcall *blackBarsScreenRatio)(ICameraItemComponent *this);
  float (__fastcall *shutterScreenRatio)(ICameraItemComponent *this);
  float (__fastcall *shutterDuration)(ICameraItemComponent *this);
  float (__fastcall *pictureDuration)(ICameraItemComponent *this);
  float (__fastcall *slideAwayDuration)(ICameraItemComponent *this);
  bool (__fastcall *canPlace)(ICameraItemComponent *this, const ItemStack *, Actor *, const BlockPos *, unsigned __int8);
  void (__fastcall *takePictureNow)(ICameraItemComponent *this, Player *, Actor *, Actor *);
  void (__fastcall *registerCallbacks)(ICameraItemComponent *this, CameraCallbacks *);
  void (__fastcall *use)(ICameraItemComponent *this, ItemStack *, Player *);
  void (__fastcall *releaseUsing)(ICameraItemComponent *this, ItemStack *, Player *, int);
  bool (__fastcall *useOn)(ICameraItemComponent *this, ItemStack *, Actor *, const BlockPos *, unsigned __int8, const Vec3 *);
};

</code></pre></div><h3 id="control"><a href="#control" class="header-anchor">#</a> <code>Control</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Control
{
  Control_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="control-vtbl"><a href="#control-vtbl" class="header-anchor">#</a> <code>Control_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Control_vtbl
{
  void (__fastcall *~Control)(Control *this);
};

</code></pre></div><h3 id="containermanagermodel"><a href="#containermanagermodel" class="header-anchor">#</a> <code>ContainerManagerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerManagerModel : IContainerManager
{
  Player *mPlayer;
  std::vector&lt;ItemStack&gt; mLastSlots;
  ContainerID mContainerId;
  ContainerType mContainerType;
  std::function&lt;void __cdecl(ContainerManagerModel &amp;)&gt; mInformControllerOfDestructionCallback;
  std::unordered_map&lt;std::string,std::shared_ptr&lt;ContainerModel&gt;&gt; mContainers;
};

</code></pre></div><h3 id="containermodel"><a href="#containermodel" class="header-anchor">#</a> <code>ContainerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerModel : ContainerContentChangeListener
{
  const bool mIsClientSide;
  std::string mContainerStringName;
  const ContainerEnumName mContainerEnumName;
  std::vector&lt;std::function&lt;void __cdecl(int,ItemStack const &amp;,ItemStack const &amp;)&gt;&gt; mOnContainerChangedCallbacks;
  std::function&lt;void __cdecl(int,ItemStack const &amp;,ItemStack const &amp;)&gt; mPlayerNotificationCallbacks;
  ContainerCategory mContainerCategory;
  std::vector&lt;SlotData&gt; mItemSource;
  SparseContainer *mClientUIContainer;
  std::vector&lt;ItemStack&gt; mItems;
};

</code></pre></div><h3 id="containerenumnamehasher"><a href="#containerenumnamehasher" class="header-anchor">#</a> <code>ContainerEnumNameHasher</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerEnumNameHasher
{
};

</code></pre></div><h3 id="containermodel-vtbl"><a href="#containermodel-vtbl" class="header-anchor">#</a> <code>ContainerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerModel_vtbl
{
  void (__fastcall *containerContentChanged)(ContainerContentChangeListener *this, int);
  void (__fastcall *~ContainerContentChangeListener)(ContainerContentChangeListener *this);
  void (__fastcall *containerAddCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *containerRemoveCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *postInit)(ContainerModel *this);
  void (__fastcall *releaseResources)(ContainerModel *this);
  int (__fastcall *getContainerSize)(ContainerModel *this);
  int (__fastcall *getFilteredContainerSize)(ContainerModel *this);
  void (__fastcall *tick)(ContainerModel *this, int);
  ContainerWeakRef *(__fastcall *getContainerWeakRef)(ContainerModel *this, ContainerWeakRef *result);
  const ItemStack *(__fastcall *getItemStack)(ContainerModel *this, int);
  const std::vector&lt;ItemStack&gt; *(__fastcall *getItems)(ContainerModel *this);
  const ItemInstance *(__fastcall *getItemInstance)(ContainerModel *this, int);
  const ItemStackBase *(__fastcall *getItemStackBase)(ContainerModel *this, int);
  bool (__fastcall *isItemInstanceBased)(ContainerModel *this);
  void (__fastcall *setItem)(ContainerModel *this, int, const ItemStack *);
  bool (__fastcall *isValid)(ContainerModel *this);
  bool (__fastcall *isItemFiltered)(ContainerModel *this, const ItemStackBase *);
  bool (__fastcall *isExpanableItemFiltered)(ContainerModel *this, int);
  ContainerExpandStatus (__fastcall *getItemExpandStatus)(ContainerModel *this, int);
  const std::string *(__fastcall *getItemGroupName)(ContainerModel *this, int);
  void (__fastcall *switchItemExpando)(ContainerModel *this, int);
  Container *(__fastcall *_getContainer)(ContainerModel *this);
  int (__fastcall *_getContainerOffset)(ContainerModel *this);
  void (__fastcall *_onItemChanged)(ContainerModel *this, int, const ItemStack *, const ItemStack *);
};

</code></pre></div><h3 id="containermanagermodel-vtbl"><a href="#containermanagermodel-vtbl" class="header-anchor">#</a> <code>ContainerManagerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerManagerModel_vtbl
{
  void (__fastcall *~IContainerManager)(IContainerManager *this);
  ContainerID (__fastcall *getContainerId)(IContainerManager *this);
  void (__fastcall *setContainerId)(IContainerManager *this, ContainerID);
  ContainerType (__fastcall *getContainerType)(IContainerManager *this);
  void (__fastcall *setContainerType)(IContainerManager *this, ContainerType);
  void (__fastcall *serverInitItemStackIds)(IContainerManager *this);
  std::vector&lt;ItemStack&gt; *(__fastcall *getItemCopies)(IContainerManager *this, std::vector&lt;ItemStack&gt; *result);
  void (__fastcall *setSlot)(IContainerManager *this, int, const ItemStack *, bool);
  const ItemStack *(__fastcall *getSlot)(IContainerManager *this, int);
  void (__fastcall *setData)(IContainerManager *this, int, int);
  void (__fastcall *broadcastChanges)(IContainerManager *this);
  bool (__fastcall *validateContainer)(IContainerManager *this);
  bool (__fastcall *isValid)(ContainerManagerModel *this, float);
  ContainerScreenContext *(__fastcall *_postInit)(ContainerManagerModel *this, ContainerScreenContext *result);
};

</code></pre></div><h3 id="core-cache-unsigned-short-block-const-block-const"><a href="#core-cache-unsigned-short-block-const-block-const" class="header-anchor">#</a> <code>Core::Cache&lt;unsigned short,Block const *,Block const *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Cache&lt;unsigned short,Block const *,Block const *&gt;
{
  std::shared_mutex mAccess;
  std::unordered_map&lt;unsigned short,Block const *&gt; mContent;
};

</code></pre></div><h3 id="contextaccessor-typebase"><a href="#contextaccessor-typebase" class="header-anchor">#</a> <code>ContextAccessor::TypeBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContextAccessor::TypeBase
{
  ContextAccessor::TypeBase_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="contextaccessor-typebase-vtbl"><a href="#contextaccessor-typebase-vtbl" class="header-anchor">#</a> <code>ContextAccessor::TypeBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContextAccessor::TypeBase_vtbl
{
  void (__fastcall *~TypeBase)(ContextAccessor::TypeBase *this);
};

</code></pre></div><h3 id="customentitytypedescription"><a href="#customentitytypedescription" class="header-anchor">#</a> <code>CustomEntityTypeDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomEntityTypeDescription : ComponentDescription
{
  std::string mCustomEntityType;
};

</code></pre></div><h3 id="customentitytypedescription-vtbl"><a href="#customentitytypedescription-vtbl" class="header-anchor">#</a> <code>CustomEntityTypeDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CustomEntityTypeDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
};

</code></pre></div><h3 id="commandblockdescription"><a href="#commandblockdescription" class="header-anchor">#</a> <code>CommandBlockDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CommandBlockDescription : ComponentDescription
{
  int mCurrentTickCount;
  int mTicksPerCommand;
  bool mTicking;
};

</code></pre></div><h3 id="commandblockdescription-vtbl"><a href="#commandblockdescription-vtbl" class="header-anchor">#</a> <code>CommandBlockDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommandBlockDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
};

</code></pre></div><h3 id="containerdescription-vtbl"><a href="#containerdescription-vtbl" class="header-anchor">#</a> <code>ContainerDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
};

</code></pre></div><h3 id="changedimensionrequest"><a href="#changedimensionrequest" class="header-anchor">#</a> <code>ChangeDimensionRequest</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChangeDimensionRequest
{
  ChangeDimensionRequest::State mState;
  AutomaticID&lt;Dimension,int&gt; mFromDimensionId;
  AutomaticID&lt;Dimension,int&gt; mToDimensionId;
  Vec3 mPosition;
  bool mUsePortal;
  bool mRespawn;
  std::unique_ptr&lt;CompoundTag&gt; mAgentTag;
};

</code></pre></div><h3 id="clientplayereventcoordinator"><a href="#clientplayereventcoordinator" class="header-anchor">#</a> <code>ClientPlayerEventCoordinator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerEventCoordinator : PlayerEventCoordinator
{
};

</code></pre></div><h3 id="clientleveleventcoordinator"><a href="#clientleveleventcoordinator" class="header-anchor">#</a> <code>ClientLevelEventCoordinator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientLevelEventCoordinator : LevelEventCoordinator
{
};

</code></pre></div><h3 id="chunksourceviewmgr"><a href="#chunksourceviewmgr" class="header-anchor">#</a> <code>ChunkSourceViewMgr</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChunkSourceViewMgr : LevelListener
{
  std::unordered_map&lt;std::string,std::pair&lt;__int64,std::unique_ptr&lt;GridArea&lt;std::shared_ptr&lt;LevelChunk&gt; &gt;&gt; &gt;&gt; mViewPtrs;
  std::unordered_map&lt;std::string,std::unique_ptr&lt;GridArea&lt;std::shared_ptr&lt;LevelChunk&gt; &gt;&gt;&gt; mPermanentViewPtrs;
};

</code></pre></div><h3 id="core-string"><a href="#core-string" class="header-anchor">#</a> <code>Core::String</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::String
{
};

</code></pre></div><h3 id="core-stringspan"><a href="#core-stringspan" class="header-anchor">#</a> <code>Core::StringSpan</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::StringSpan
{
  gsl::basic_string_span&lt;char const ,-1&gt; mStringSpan;
};

</code></pre></div><h3 id="core-path-path-less"><a href="#core-path-path-less" class="header-anchor">#</a> <code>Core::Path::path_less</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Path::path_less
{
};

</code></pre></div><h3 id="core-pathcontainerconversions-std-string"><a href="#core-pathcontainerconversions-std-string" class="header-anchor">#</a> <code>Core::PathContainerConversions&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::PathContainerConversions&lt;std::string &gt;
{
};

</code></pre></div><h3 id="core-storageareastree-treechild"><a href="#core-storageareastree-treechild" class="header-anchor">#</a> <code>Core::StorageAreasTree::TreeChild</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::StorageAreasTree::TreeChild
{
  HashedString mKey;
  std::unique_ptr&lt;Core::StorageAreasTree::TreeNode&gt; mNode;
};

</code></pre></div><h3 id="core-observer-networkchangeobserver-std-mutex"><a href="#core-observer-networkchangeobserver-std-mutex" class="header-anchor">#</a> <code>Core::Observer&lt;NetworkChangeObserver,std::mutex&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Observer&lt;NetworkChangeObserver,std::mutex&gt;
{
  Core::Observer&lt;NetworkChangeObserver,std::mutex&gt;_vtbl *__vftable /*VFT*/;
  Core::Subject&lt;NetworkChangeObserver,std::mutex&gt; *mpSubject;
};

</code></pre></div><h3 id="core-observer-networkchangeobserver-std-mutex-vtbl"><a href="#core-observer-networkchangeobserver-std-mutex-vtbl" class="header-anchor">#</a> <code>Core::Observer&lt;NetworkChangeObserver,std::mutex&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::Observer&lt;NetworkChangeObserver,std::mutex&gt;_vtbl
{
  void (__fastcall *~Observer&lt;NetworkChangeObserver,std::mutex&gt;)(Core::Observer&lt;NetworkChangeObserver,std::mutex&gt; *this);
  void (__fastcall *_onSubjectDestroyed)(Core::Observer&lt;NetworkChangeObserver,std::mutex&gt; *this);
};

</code></pre></div><h3 id="core-subject-networkchangeobserver-std-mutex"><a href="#core-subject-networkchangeobserver-std-mutex" class="header-anchor">#</a> <code>Core::Subject&lt;NetworkChangeObserver,std::mutex&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Subject&lt;NetworkChangeObserver,std::mutex&gt;
{
  std::mutex mLock;
  std::vector&lt;gsl::not_null&lt;NetworkChangeObserver *&gt;&gt; mObservers;
};

</code></pre></div><h3 id="core-inputfilestream-vtbl"><a href="#core-inputfilestream-vtbl" class="header-anchor">#</a> <code>Core::InputFileStream_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::InputFileStream_vtbl
{
  void *(__fastcall *__vecDelDtor)(Core::InputFileStream *this, unsigned int);
};

</code></pre></div><h3 id="cg-igraphicsdeviceplatformprovider"><a href="#cg-igraphicsdeviceplatformprovider" class="header-anchor">#</a> <code>cg::IGraphicsDevicePlatformProvider</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::IGraphicsDevicePlatformProvider : Bedrock::EnableNonOwnerReferences
{
  cg::IGraphicsDevicePlatformProvider_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="cg-igraphicsdeviceplatformprovider-vtbl"><a href="#cg-igraphicsdeviceplatformprovider-vtbl" class="header-anchor">#</a> <code>cg::IGraphicsDevicePlatformProvider_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ cg::IGraphicsDevicePlatformProvider_vtbl
{
  void (__fastcall *~IGraphicsDevicePlatformProvider)(cg::IGraphicsDevicePlatformProvider *this);
  std::string *(__fastcall *getDriverVersion)(cg::IGraphicsDevicePlatformProvider *this, std::string *result);
  Json::Value *(__fastcall *getDeviceInfoJson)(cg::IGraphicsDevicePlatformProvider *this, Json::Value *result);
};

</code></pre></div><h3 id="core-loadtimedata"><a href="#core-loadtimedata" class="header-anchor">#</a> <code>Core::LoadTimeData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::LoadTimeData
{
  const std::string mName;
  int mScope;
  long double mTotalTime;
};

</code></pre></div><h3 id="core-scopedloadtimesection"><a href="#core-scopedloadtimesection" class="header-anchor">#</a> <code>Core::ScopedLoadTimeSection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::ScopedLoadTimeSection
{
  long double mStartTime;
  Core::LoadTimeData mProfileData;
};

</code></pre></div><h3 id="core-loadtimeprofiler"><a href="#core-loadtimeprofiler" class="header-anchor">#</a> <code>Core::LoadTimeProfiler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Core::LoadTimeProfiler : Bedrock::EnableNonOwnerReferences
{
  std::vector&lt;Core::ScopedLoadTimeSection *&gt; mSections;
  unsigned int mCurrentFrame;
  std::vector&lt;Core::LoadTimeData&gt; mFinishedSections;
  Core::OutputFileStream mLogFile;
  bool mEnabled;
  bool mCloseLogOnUpdate;
};

</code></pre></div><h3 id="clientnetworkhandler"><a href="#clientnetworkhandler" class="header-anchor">#</a> <code>ClientNetworkHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientNetworkHandler : NetEventCallback
{
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mLastBossRemoved;
  std::shared_ptr&lt;ClientBlobCache::Cache&gt; mBlobCache;
  IClientInstance *mClient;
  NetworkHandler *mNetworkHandler;
  PacketSender *mPacketSender;
  PrivateKeyManager *mClientKeys;
  MinecraftCommands *mMinecraftCommands;
  Level *mLevel;
  bool mHasMessage;
  bool mIsLoggedIn;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
  std::unordered_map&lt;std::pair&lt;Dimension const *,ChunkPos&gt;,unsigned __int64,mce::Math::PairHash,std::equal_to&lt;std::pair&lt;Dimension const *,ChunkPos&gt; &gt;,std::allocator&lt;std::pair&lt;std::pair&lt;Dimension const *,ChunkPos&gt; const ,unsigned __int64&gt; &gt; &gt; mPendingChunks;
  std::unordered_map&lt;std::tuple&lt;NetworkIdentifier,Dimension const *,ChunkPos&gt;,std::function&lt;void __cdecl(BlockSource &amp;)&gt;,mce::Math::Tuple3Hash,std::equal_to&lt;std::tuple&lt;NetworkIdentifier,Dimension const *,ChunkPos&gt; &gt;,std::allocator&lt;std::pair&lt;std::tuple&lt;NetworkIdentifier,Dimension const *,ChunkPos&gt; const ,std::function&lt;void __cdecl(BlockSource &amp;)&gt; &gt; &gt; &gt; mConnectionPausedCallbacks;
};

</code></pre></div><h3 id="clientinstance-lambda-f6e4b0d87d4d949bdaea4c283d4c6cc0"><a href="#clientinstance-lambda-f6e4b0d87d4d949bdaea4c283d4c6cc0" class="header-anchor">#</a> <code>ClientInstance::&lt;lambda_f6e4b0d87d4d949bdaea4c283d4c6cc0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::&lt;lambda_f6e4b0d87d4d949bdaea4c283d4c6cc0&gt;
{
};

</code></pre></div><h3 id="clientinstance-lambda-57e1ebedf9bd0f5ca98bc6185e1f58e3"><a href="#clientinstance-lambda-57e1ebedf9bd0f5ca98bc6185e1f58e3" class="header-anchor">#</a> <code>ClientInstance::&lt;lambda_57e1ebedf9bd0f5ca98bc6185e1f58e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::&lt;lambda_57e1ebedf9bd0f5ca98bc6185e1f58e3&gt;
{
};

</code></pre></div><h3 id="commandselectorresults-actor"><a href="#commandselectorresults-actor" class="header-anchor">#</a> <code>CommandSelectorResults&lt;Actor&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelectorResults&lt;Actor&gt;
{
  std::shared_ptr&lt;std::vector&lt;Actor *&gt; &gt; mTargets;
};

</code></pre></div><h3 id="commandposition"><a href="#commandposition" class="header-anchor">#</a> <code>CommandPosition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandPosition
{
  Vec3 mOffset;
  bool mRelativeX;
  bool mRelativeY;
  bool mRelativeZ;
  bool mLocal;
};

</code></pre></div><h3 id="commandselectorbase"><a href="#commandselectorbase" class="header-anchor">#</a> <code>CommandSelectorBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) CommandSelectorBase
{
  int mVersion;
  CommandSelectionType mType;
  _BYTE mOrder[4];
  std::vector&lt;InvertableFilter&lt;std::string &gt;&gt; mNameFilters;
  std::vector&lt;InvertableFilter&lt;ActorDefinitionIdentifier&gt;&gt; mTypeFilters;
  std::vector&lt;InvertableFilter&lt;std::string &gt;&gt; mFamilyFilters;
  std::vector&lt;InvertableFilter&lt;std::string &gt;&gt; mTagFilters;
  std::vector&lt;std::function&lt;bool __cdecl(CommandOrigin const &amp;,Actor const &amp;)&gt;&gt; mFilterChain;
  CommandPosition mPosition;
  BlockPos mBoxDeltas;
  float mRadiusMin;
  float mRadiusMax;
  unsigned __int64 mCount;
  bool mIncludeDeadPlayers;
  bool mIsPositionBound;
  bool mDistanceFiltered;
  bool mHaveDeltas;
  bool mForcePlayer;
  bool mIsExplicitIdSelector;
};

</code></pre></div><h3 id="customtabstorage"><a href="#customtabstorage" class="header-anchor">#</a> <code>CustomTabStorage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CustomTabStorage
{
  int index;
  std::string name;
  std::string path;
};

</code></pre></div><h3 id="camerabehavior-comfortmovebehavior"><a href="#camerabehavior-comfortmovebehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;ComfortMoveBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;ComfortMoveBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-comfortmovebehavior-vtbl"><a href="#camerabehavior-comfortmovebehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;ComfortMoveBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;ComfortMoveBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="comfortmovebehavior"><a href="#comfortmovebehavior" class="header-anchor">#</a> <code>ComfortMoveBehavior</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ComfortMoveBehavior : CameraBehavior&lt;ComfortMoveBehavior&gt;
{
  float mLinearYRemap;
  float mMaxLinearYRemap;
  float mStartYPos;
  float mAccumulatedDT;
  bool mYMotionUp;
};

</code></pre></div><h3 id="comfortmovebehavior-vtbl"><a href="#comfortmovebehavior-vtbl" class="header-anchor">#</a> <code>ComfortMoveBehavior_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ComfortMoveBehavior_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-shakebehavior"><a href="#camerabehavior-shakebehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;ShakeBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;ShakeBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-shakebehavior-vtbl"><a href="#camerabehavior-shakebehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;ShakeBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;ShakeBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="comfortmovebehaviorloader"><a href="#comfortmovebehaviorloader" class="header-anchor">#</a> <code>ComfortMoveBehaviorLoader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ComfortMoveBehaviorLoader : CameraBehaviorLoader
{
};

</code></pre></div><h3 id="comfortmovebehaviorloader-vtbl"><a href="#comfortmovebehaviorloader-vtbl" class="header-anchor">#</a> <code>ComfortMoveBehaviorLoader_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ComfortMoveBehaviorLoader_vtbl
{
  void (__fastcall *~CameraBehaviorLoader)(CameraBehaviorLoader *this);
  std::unique_ptr&lt;ICameraBehavior&gt; *(__fastcall *create)(CameraBehaviorLoader *this, std::unique_ptr&lt;ICameraBehavior&gt; *result);
  void (__fastcall *parse)(CameraBehaviorLoader *this, Json::Value *, ICameraBehavior *);
};

</code></pre></div><h3 id="clubs-feeditem"><a href="#clubs-feeditem" class="header-anchor">#</a> <code>Clubs::FeedItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Clubs::FeedItem
{
  _BYTE mFeedItemType[4];
  std::string mFeedItemRoot;
  std::string mFeedItemId;
  std::string mContent;
  std::string mAuthorXuid;
  std::string mDatePosted;
  std::string mCaption;
  int mNumComments;
  int mNumLikes;
  bool mHasLiked;
  bool mHasScreenshotLoaded;
};

</code></pre></div><h3 id="clubs-activityfeed"><a href="#clubs-activityfeed" class="header-anchor">#</a> <code>Clubs::ActivityFeed</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Clubs::ActivityFeed
{
  Clubs::ActivityFeed::Type mType;
  std::vector&lt;Clubs::FeedItem&gt; mFeedItems;
};

</code></pre></div><h3 id="clubs-reporteditem"><a href="#clubs-reporteditem" class="header-anchor">#</a> <code>Clubs::ReportedItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Clubs::ReportedItem
{
  Clubs::ReportedItem::Type mType;
  std::string mPathToItem;
  std::string mLastReported;
  int mReportCount;
  std::string mReportId;
  std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; mReports;
  Clubs::FeedItem mFeedItem;
};

</code></pre></div><h3 id="clubs-newfeeditem"><a href="#clubs-newfeeditem" class="header-anchor">#</a> <code>Clubs::NewFeedItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Clubs::NewFeedItem
{
  Clubs::NewFeedItem::Type mType;
  std::string mContent;
  std::string mScreenshotCaption;
};

</code></pre></div><h3 id="clientinputcallbacks"><a href="#clientinputcallbacks" class="header-anchor">#</a> <code>ClientInputCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks
{
};

</code></pre></div><h3 id="clientcontentkeyprovider"><a href="#clientcontentkeyprovider" class="header-anchor">#</a> <code>ClientContentKeyProvider</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientContentKeyProvider : IContentAccessibilityProvider
{
  IEntitlementManager *mEntitlementManager;
  std::unordered_map&lt;ContentIdentity,std::string&gt; mTempContentKeys;
};

</code></pre></div><h3 id="clientcontentkeyprovider-vtbl"><a href="#clientcontentkeyprovider-vtbl" class="header-anchor">#</a> <code>ClientContentKeyProvider_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientContentKeyProvider_vtbl
{
  void (__fastcall *~IContentKeyProvider)(IContentKeyProvider *this);
  std::string *(__fastcall *getContentKey)(IContentKeyProvider *this, std::string *result, const ContentIdentity *);
  std::string *(__fastcall *getAlternateContentKey)(IContentKeyProvider *this, std::string *result, const ContentIdentity *);
  bool (__fastcall *requireEncryptedReads)(IContentKeyProvider *this);
  void (__fastcall *setTempContentKeys)(IContentKeyProvider *this, const std::unordered_map&lt;ContentIdentity,std::string&gt; *);
  void (__fastcall *clearTempContentKeys)(IContentKeyProvider *this);
  bool (__fastcall *canAccess)(IContentAccessibilityProvider *this, const ContentIdentity *);
};

</code></pre></div><h3 id="createreviewparams"><a href="#createreviewparams" class="header-anchor">#</a> <code>CreateReviewParams</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreateReviewParams
{
  std::string mProductId;
  std::string mTitle;
  std::string mReviewText;
  int mRating;
  bool mIsInstalled;
  std::string mItemVersion;
};

</code></pre></div><h3 id="core-callbacklisteners-int-enum-social-signinresult"><a href="#core-callbacklisteners-int-enum-social-signinresult" class="header-anchor">#</a> <code>Core::CallbackListeners&lt;int,enum Social::SignInResult&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::CallbackListeners&lt;int,enum Social::SignInResult&gt;
{
  std::mutex mLock;
  std::vector&lt;Core::CallbackListeners&lt;int,enum Social::SignInResult&gt;::Listener,std::allocator&lt;Core::CallbackListeners&lt;int,enum Social::SignInResult&gt;::Listener&gt; &gt; mListeners;
};

</code></pre></div><h3 id="compiletime-hash-38"><a href="#compiletime-hash-38" class="header-anchor">#</a> <code>CompileTime::Hash&lt;38&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;38&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-37"><a href="#compiletime-hash-37" class="header-anchor">#</a> <code>CompileTime::Hash&lt;37&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;37&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-36"><a href="#compiletime-hash-36" class="header-anchor">#</a> <code>CompileTime::Hash&lt;36&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;36&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-35"><a href="#compiletime-hash-35" class="header-anchor">#</a> <code>CompileTime::Hash&lt;35&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;35&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-34"><a href="#compiletime-hash-34" class="header-anchor">#</a> <code>CompileTime::Hash&lt;34&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;34&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-33"><a href="#compiletime-hash-33" class="header-anchor">#</a> <code>CompileTime::Hash&lt;33&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;33&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-32"><a href="#compiletime-hash-32" class="header-anchor">#</a> <code>CompileTime::Hash&lt;32&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;32&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-31"><a href="#compiletime-hash-31" class="header-anchor">#</a> <code>CompileTime::Hash&lt;31&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;31&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-30"><a href="#compiletime-hash-30" class="header-anchor">#</a> <code>CompileTime::Hash&lt;30&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;30&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-29"><a href="#compiletime-hash-29" class="header-anchor">#</a> <code>CompileTime::Hash&lt;29&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;29&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-28"><a href="#compiletime-hash-28" class="header-anchor">#</a> <code>CompileTime::Hash&lt;28&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;28&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-27"><a href="#compiletime-hash-27" class="header-anchor">#</a> <code>CompileTime::Hash&lt;27&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;27&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-26"><a href="#compiletime-hash-26" class="header-anchor">#</a> <code>CompileTime::Hash&lt;26&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;26&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-25"><a href="#compiletime-hash-25" class="header-anchor">#</a> <code>CompileTime::Hash&lt;25&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;25&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-24"><a href="#compiletime-hash-24" class="header-anchor">#</a> <code>CompileTime::Hash&lt;24&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;24&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-23"><a href="#compiletime-hash-23" class="header-anchor">#</a> <code>CompileTime::Hash&lt;23&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;23&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-22"><a href="#compiletime-hash-22" class="header-anchor">#</a> <code>CompileTime::Hash&lt;22&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;22&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-21"><a href="#compiletime-hash-21" class="header-anchor">#</a> <code>CompileTime::Hash&lt;21&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;21&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-20"><a href="#compiletime-hash-20" class="header-anchor">#</a> <code>CompileTime::Hash&lt;20&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;20&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-19"><a href="#compiletime-hash-19" class="header-anchor">#</a> <code>CompileTime::Hash&lt;19&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;19&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-18"><a href="#compiletime-hash-18" class="header-anchor">#</a> <code>CompileTime::Hash&lt;18&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;18&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-17"><a href="#compiletime-hash-17" class="header-anchor">#</a> <code>CompileTime::Hash&lt;17&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;17&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-16"><a href="#compiletime-hash-16" class="header-anchor">#</a> <code>CompileTime::Hash&lt;16&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;16&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-15"><a href="#compiletime-hash-15" class="header-anchor">#</a> <code>CompileTime::Hash&lt;15&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;15&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-14"><a href="#compiletime-hash-14" class="header-anchor">#</a> <code>CompileTime::Hash&lt;14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;14&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-13"><a href="#compiletime-hash-13" class="header-anchor">#</a> <code>CompileTime::Hash&lt;13&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;13&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-12"><a href="#compiletime-hash-12" class="header-anchor">#</a> <code>CompileTime::Hash&lt;12&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;12&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-11"><a href="#compiletime-hash-11" class="header-anchor">#</a> <code>CompileTime::Hash&lt;11&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;11&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-10"><a href="#compiletime-hash-10" class="header-anchor">#</a> <code>CompileTime::Hash&lt;10&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;10&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-9"><a href="#compiletime-hash-9" class="header-anchor">#</a> <code>CompileTime::Hash&lt;9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;9&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-8"><a href="#compiletime-hash-8" class="header-anchor">#</a> <code>CompileTime::Hash&lt;8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;8&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-7"><a href="#compiletime-hash-7" class="header-anchor">#</a> <code>CompileTime::Hash&lt;7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;7&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-6"><a href="#compiletime-hash-6" class="header-anchor">#</a> <code>CompileTime::Hash&lt;6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;6&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-5"><a href="#compiletime-hash-5" class="header-anchor">#</a> <code>CompileTime::Hash&lt;5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;5&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-4"><a href="#compiletime-hash-4" class="header-anchor">#</a> <code>CompileTime::Hash&lt;4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;4&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-3"><a href="#compiletime-hash-3" class="header-anchor">#</a> <code>CompileTime::Hash&lt;3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;3&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-2"><a href="#compiletime-hash-2" class="header-anchor">#</a> <code>CompileTime::Hash&lt;2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;2&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-1"><a href="#compiletime-hash-1" class="header-anchor">#</a> <code>CompileTime::Hash&lt;1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;1&gt;
{
};

</code></pre></div><h3 id="clientinstancescreenmodel-vtbl"><a href="#clientinstancescreenmodel-vtbl" class="header-anchor">#</a> <code>ClientInstanceScreenModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientInstanceScreenModel_vtbl
{
  void (__fastcall *~IDlcBatcher)(IDlcBatcher *this);
  IDlcBatchModel *(__fastcall *getDlcBatchModel)(IDlcBatcher *this, const std::vector&lt;PackIdVersion&gt; *);
  IDlcBatchModel *(__fastcall *getDlcBatchModel)(IDlcBatcher *this, const std::vector&lt;std::string&gt; *);
  IDlcBatchModel *(__fastcall *getDlcBatchModel)(IDlcBatcher *this, const std::vector&lt;DlcId&gt; *);
};

</code></pre></div><h3 id="clientinstancescreencontroller-vtbl"><a href="#clientinstancescreencontroller-vtbl" class="header-anchor">#</a> <code>ClientInstanceScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientInstanceScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="containersplitcontrol"><a href="#containersplitcontrol" class="header-anchor">#</a> <code>ContainerSplitControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ContainerSplitControl
{
  SlotData slot;
  int addedCount;
};

</code></pre></div><h3 id="containermanagercontroller-vtbl"><a href="#containermanagercontroller-vtbl" class="header-anchor">#</a> <code>ContainerManagerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerManagerController_vtbl
{
  void (__fastcall *~ContainerManagerController)(ContainerManagerController *this);
  void (__fastcall *registerContainerCallbacks)(ContainerManagerController *this);
  const ItemStackBase *(__fastcall *getTakeableItemStackBase)(ContainerManagerController *this, const SlotData *);
  void (__fastcall *handleTakeAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  void (__fastcall *handleTakeAll)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAll)(ContainerManagerController *this, const SelectedSlotInfo *, const SlotData *);
  void (__fastcall *handleTakeHalf)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceOne)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handlePlaceAmount)(ContainerManagerController *this, const SlotData *, int, const SlotData *);
  int (__fastcall *handleAutoPlace)(ContainerManagerController *this, const SlotData *, int, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  int (__fastcall *handleAutoPlaceStack)(ContainerManagerController *this, const SlotData *, ItemTakeType, const std::vector&lt;AutoPlaceItem&gt; *, std::vector&lt;AutoPlaceResult&gt; *);
  void (__fastcall *handleSplitSingle)(ContainerManagerController *this, const SlotData *, const SlotData *);
  void (__fastcall *handleSplitMultiple)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemInstance *, const SlotData *);
  void (__fastcall *handleCoalesce)(ContainerManagerController *this, const SlotData *, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *handleSwap)(ContainerManagerController *this, const SlotData *, const SlotData *);
  bool (__fastcall *handleDrop)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  bool (__fastcall *handleDestroy)(ContainerManagerController *this, const SelectedSlotInfo *, const ItemTransferAmount);
  bool (__fastcall *handleConsume)(ContainerManagerController *this, const SlotData *, const ItemTransferAmount);
  void (__fastcall *handleAddToStack)(ContainerManagerController *this, const SlotData *, const SlotData *, ItemTakeType);
  void (__fastcall *closeContainers)(ContainerManagerController *this);
  const std::vector&lt;ContainerSplitControl&gt; *(__fastcall *getSplitItems)(ContainerManagerController *this);
  bool (__fastcall *isOutputSlot)(ContainerManagerController *this, const std::string *);
  void (__fastcall *_onItemTransferredFrom)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemTransferredTo)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemAcquired)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
  void (__fastcall *_onItemPlaced)(ContainerManagerController *this, const ItemInstance *, const SlotData *);
};

</code></pre></div><h3 id="containercontroller"><a href="#containercontroller" class="header-anchor">#</a> <code>ContainerController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ContainerController
{
  ContainerController_vtbl *__vftable /*VFT*/;
  std::weak_ptr&lt;ContainerModel&gt; mContainerModel;
  bool mDrop;
};

</code></pre></div><h3 id="containercontroller-vtbl"><a href="#containercontroller-vtbl" class="header-anchor">#</a> <code>ContainerController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerController_vtbl
{
  void (__fastcall *~ContainerController)(ContainerController *this);
  bool (__fastcall *canRemove)(ContainerController *this, int, int);
  bool (__fastcall *isItemAllowed)(ContainerController *this, const ItemStackBase *);
  bool (__fastcall *isItemFiltered)(ContainerController *this, const Recipes *, const ItemStackBase *);
  int (__fastcall *getBackgroundStyle)(ContainerController *this, int, bool);
  ItemSetType (__fastcall *_canSet)(ContainerController *this, int, const ItemStackBase *, ItemTransferAmount);
  int (__fastcall *_getAvailableSetCount)(ContainerController *this, int, const ItemStackBase *);
  bool (__fastcall *_canRemove)(ContainerController *this, int, int);
  void (__fastcall *_onItemChanged)(ContainerController *this, int);
};

</code></pre></div><h3 id="compiletime-hash-50"><a href="#compiletime-hash-50" class="header-anchor">#</a> <code>CompileTime::Hash&lt;50&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;50&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-39"><a href="#compiletime-hash-39" class="header-anchor">#</a> <code>CompileTime::Hash&lt;39&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;39&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-49"><a href="#compiletime-hash-49" class="header-anchor">#</a> <code>CompileTime::Hash&lt;49&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;49&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-48"><a href="#compiletime-hash-48" class="header-anchor">#</a> <code>CompileTime::Hash&lt;48&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;48&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-47"><a href="#compiletime-hash-47" class="header-anchor">#</a> <code>CompileTime::Hash&lt;47&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;47&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-46"><a href="#compiletime-hash-46" class="header-anchor">#</a> <code>CompileTime::Hash&lt;46&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;46&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-45"><a href="#compiletime-hash-45" class="header-anchor">#</a> <code>CompileTime::Hash&lt;45&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;45&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-44"><a href="#compiletime-hash-44" class="header-anchor">#</a> <code>CompileTime::Hash&lt;44&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;44&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-43"><a href="#compiletime-hash-43" class="header-anchor">#</a> <code>CompileTime::Hash&lt;43&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;43&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-42"><a href="#compiletime-hash-42" class="header-anchor">#</a> <code>CompileTime::Hash&lt;42&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;42&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-41"><a href="#compiletime-hash-41" class="header-anchor">#</a> <code>CompileTime::Hash&lt;41&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;41&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-40"><a href="#compiletime-hash-40" class="header-anchor">#</a> <code>CompileTime::Hash&lt;40&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;40&gt;
{
};

</code></pre></div><h3 id="correctplayerpredictioninput"><a href="#correctplayerpredictioninput" class="header-anchor">#</a> <code>CorrectPlayerPredictionInput</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CorrectPlayerPredictionInput : IReplayableActorInput
{
  CorrectPlayerMovePredictionPacket mPacket;
};

</code></pre></div><h3 id="clientplayerrewindlistener"><a href="#clientplayerrewindlistener" class="header-anchor">#</a> <code>ClientPlayerRewindListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerRewindListener : PlayerEventListener
{
  std::vector&lt;std::unique_ptr&lt;IReplayableActorStateSource&gt;&gt; mActorStateSources;
};

</code></pre></div><h3 id="clientplayerrewindlistener-vtbl"><a href="#clientplayerrewindlistener-vtbl" class="header-anchor">#</a> <code>ClientPlayerRewindListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientPlayerRewindListener_vtbl
{
  void (__fastcall *~PlayerEventListener)(PlayerEventListener *this);
  EventResult (__fastcall *onPlayerAwardAchievement)(PlayerEventListener *this, Player *, MinecraftEventing::AchievementIds);
  EventResult (__fastcall *onPlayerPortalBuilt)(PlayerEventListener *this, Player *, AutomaticID&lt;Dimension,int&gt;);
  EventResult (__fastcall *onPlayerPortalUsed)(PlayerEventListener *this, Player *, AutomaticID&lt;Dimension,int&gt;, AutomaticID&lt;Dimension,int&gt;);
  EventResult (__fastcall *onPlayerCaravanChanged)(PlayerEventListener *this, const Actor *, int);
  EventResult (__fastcall *onPlayerSaved)(PlayerEventListener *this, Player *);
  EventResult (__fastcall *onPlayerInput)(PlayerEventListener *this, IPlayerMovementProxy *, MoveInputHandler *);
  EventResult (__fastcall *onPlayerAuthInputReceived)(PlayerEventListener *this, Player *, const PlayerAuthInputPacket *);
  EventResult (__fastcall *onPlayerAuthInputApplied)(PlayerEventListener *this, Player *, const PlayerAuthInputPacket *);
  EventResult (__fastcall *onPlayerTurn)(PlayerEventListener *this, Player *, Vec2 *);
  EventResult (__fastcall *onCameraSetPlayerRot)(PlayerEventListener *this, Player *, const Camera *);
  EventResult (__fastcall *onStartDestroyBlock)(PlayerEventListener *this, Player *, const BlockPos *, unsigned __int8 *);
  EventResult (__fastcall *onPlayerAction)(PlayerEventListener *this, Player *, PlayerActionType, const BlockPos *, int);
  EventResult (__fastcall *onPlayerHurt)(PlayerEventListener *this, const PlayerDamageEvent *);
  EventResult (__fastcall *onLocalPlayerDeath)(PlayerEventListener *this, IClientInstance *, LocalPlayer *);
  EventResult (__fastcall *onLocalPlayerRespawn)(PlayerEventListener *this, IClientInstance *, LocalPlayer *);
  EventResult (__fastcall *onPlayerMove)(PlayerEventListener *this, Player *);
  EventResult (__fastcall *onPlayerSlide)(PlayerEventListener *this, Player *);
  EventResult (__fastcall *onPlayerTargetBlockHit)(PlayerEventListener *this, Player *, const int);
  EventResult (__fastcall *onPlayerAIStepBegin)(PlayerEventListener *this, Player *);
  EventResult (__fastcall *onPlayerTick)(PlayerEventListener *this, Player *);
  EventResult (__fastcall *onPlayerStartRiding)(PlayerEventListener *this, Player *, Actor *);
  EventResult (__fastcall *onPlayerStopRiding)(PlayerEventListener *this, Player *, bool, bool, bool);
  EventResult (__fastcall *onPlayerCreated)(PlayerEventListener *this, LocalPlayer *, const std::string *, const std::string *, bool);
  EventResult (__fastcall *onPlayerTeleported)(PlayerEventListener *this, Player *);
  EventResult (__fastcall *onPlayerAttackedActor)(PlayerEventListener *this, Player *, Actor *);
  EventResult (__fastcall *onPlayerMovementCorrected)(PlayerEventListener *this, Player *, const Vec3 *, const float, const float);
  EventResult (__fastcall *onPlayerMovementAnomaly)(PlayerEventListener *this, Player *, const Vec3 *, const float, const float);
  EventResult (__fastcall *onPlayerDestroyedBlock)(PlayerEventListener *this, Player *, const BlockLegacy *);
  EventResult (__fastcall *onPlayerDestroyedBlock)(PlayerEventListener *this, Player *, int, int, int);
  EventResult (__fastcall *onPlayerOnGround)(PlayerEventListener *this, Player *);
  EventResult (__fastcall *onPlayerEquippedArmor)(PlayerEventListener *this, Player *, const ItemDescriptor *);
  EventResult (__fastcall *onPlayerEnchantedItem)(PlayerEventListener *this, Player *, const ItemStack *, const ItemEnchants *);
  EventResult (__fastcall *onPlayerNamedItem)(PlayerEventListener *this, Player *, const ItemDescriptor *);
  EventResult (__fastcall *onPlayerItemUseInteraction)(PlayerEventListener *this, Player *, const ItemInstance *);
  EventResult (__fastcall *onPlayerItemPlaceInteraction)(PlayerEventListener *this, Player *, const ItemInstance *);
  EventResult (__fastcall *onPlayerStartUsingItem)(PlayerEventListener *this, const Player *, const ItemStack *);
  EventResult (__fastcall *onPlayerStopUsingItem)(PlayerEventListener *this, const Player *, const ItemStack *);
  EventResult (__fastcall *onPlayerCraftedItem)(PlayerEventListener *this, Player *, const ItemInstance *, bool, bool, bool, int, int, int, bool, bool, const std::vector&lt;short&gt; *);
  EventResult (__fastcall *onPlayerItemEquipped)(PlayerEventListener *this, Player *, const ItemInstance *, int);
  EventResult (__fastcall *onPlayerJumped)(PlayerEventListener *this, const Player *);
  EventResult (__fastcall *onPlayerOpenContainer)(PlayerEventListener *this, Player *, ContainerType, const BlockPos *, ActorUniqueID);
  EventResult (__fastcall *onPlayerPiglinBarter)(PlayerEventListener *this, Player *, const std::string *, bool);
  EventResult (__fastcall *onPlayerAddExp)(PlayerEventListener *this, const PlayerAddExpEvent *);
  EventResult (__fastcall *onPlayerAddLevel)(PlayerEventListener *this, const PlayerAddLevelEvent *);
  EventResult (__fastcall *onPlayerArmorExchange)(PlayerEventListener *this, const PlayerArmorExchangeEvent *);
  EventResult (__fastcall *onPlayerDestroyBlock)(PlayerEventListener *this, const PlayerDestroyBlockEvent *);
  EventResult (__fastcall *onPlayerDie)(PlayerEventListener *this, const PlayerDamageEvent *);
  EventResult (__fastcall *onPlayerGetExperienceOrb)(PlayerEventListener *this, const PlayerGetExperienceOrbEvent *);
  EventResult (__fastcall *onPlayerSayCommand)(PlayerEventListener *this, const PlayerSayCommandEvent *);
  EventResult (__fastcall *onPlayerShootArrow)(PlayerEventListener *this, const PlayerShootArrowEvent *);
  EventResult (__fastcall *onPlayerStopLoading)(PlayerEventListener *this, const PlayerEvent *);
  EventResult (__fastcall *onPlayerUseNameTag)(PlayerEventListener *this, const PlayerUseNameTagEvent *);
};

</code></pre></div><h3 id="cg-texturesetlayertypehash"><a href="#cg-texturesetlayertypehash" class="header-anchor">#</a> <code>cg::TextureSetLayerTypeHash</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TextureSetLayerTypeHash
{
};

</code></pre></div><h3 id="clientplayermovementproxy"><a href="#clientplayermovementproxy" class="header-anchor">#</a> <code>ClientPlayerMovementProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientPlayerMovementProxy : DirectPlayerMovementProxy
{
  std::unique_ptr&lt;IClientInstanceProxy&gt; mClient;
};

</code></pre></div><h3 id="clientblockpipeline-faceschematicinstance"><a href="#clientblockpipeline-faceschematicinstance" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceSchematicInstance</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceSchematicInstance
{
  bool mExists;
  const ClientBlockPipeline::Material *mMaterial;
  ClientBlockPipeline::UvTransform mUvTransform;
};

</code></pre></div><h3 id="clientblockpipeline-nullptrerrorchecker"><a href="#clientblockpipeline-nullptrerrorchecker" class="header-anchor">#</a> <code>ClientBlockPipeline::NullPtrErrorChecker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::NullPtrErrorChecker
{
};

</code></pre></div><h3 id="clientblockpipeline-blockopacitydata"><a href="#clientblockpipeline-blockopacitydata" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockOpacityData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BlockOpacityData
{
  bool mSolid;
  bool mOpaque;
};

</code></pre></div><h3 id="clientblockpipeline-instance-stepcache"><a href="#clientblockpipeline-instance-stepcache" class="header-anchor">#</a> <code>ClientBlockPipeline::Instance::StepCache</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::Instance::StepCache
{
  unsigned __int64 mDependenciesCount;
  unsigned __int64 mDependentsCount;
  ClientBlockPipeline::StepResult mResult;
};

</code></pre></div><h3 id="clientblockpipeline-instance"><a href="#clientblockpipeline-instance" class="header-anchor">#</a> <code>ClientBlockPipeline::Instance</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::Instance
{
  const ClientBlockPipeline::Description *mDescription;
  std::vector&lt;ClientBlockPipeline::Instance::StepCache&gt; mStepCache;
  std::queue&lt;unsigned __int64&gt; mStepsToProcess;
  std::vector&lt;std::function&lt;void __cdecl(ClientBlockPipeline::Inputs const &amp;)&gt;&gt; mCallbackFunctions;
};

</code></pre></div><h3 id="clientblockpipeline-volumeof-clientblockpipeline-blockcell"><a href="#clientblockpipeline-volumeof-clientblockpipeline-blockcell" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockCell&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockCell&gt;
{
  Pos mMin;
  Pos mMax;
  std::vector&lt;ClientBlockPipeline::BlockCell&gt; mData;
};

</code></pre></div><h3 id="clientblockpipeline-ownedblockvolume"><a href="#clientblockpipeline-ownedblockvolume" class="header-anchor">#</a> <code>ClientBlockPipeline::OwnedBlockVolume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::OwnedBlockVolume : ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockCell&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-volumeviewof-clientblockpipeline-blockcell"><a href="#clientblockpipeline-volumeviewof-clientblockpipeline-blockcell" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockCell&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockCell&gt;
{
  Pos mMin;
  Pos mMax;
  buffer_span_mut&lt;ClientBlockPipeline::BlockCell&gt; mView;
};

</code></pre></div><h3 id="clientblockpipeline-blocktessellatorpipeline-run-l2-lambda-95e3b116649ef0529b93b2b805ca35e0"><a href="#clientblockpipeline-blocktessellatorpipeline-run-l2-lambda-95e3b116649ef0529b93b2b805ca35e0" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockTessellatorPipeline::_run::__l2::&lt;lambda_95e3b116649ef0529b93b2b805ca35e0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BlockTessellatorPipeline::_run::__l2::&lt;lambda_95e3b116649ef0529b93b2b805ca35e0&gt;
{
  ClientBlockPipeline::BlockTessellatorPipeline *const __this;
};

</code></pre></div><h3 id="clientblockpipeline-quadindices"><a href="#clientblockpipeline-quadindices" class="header-anchor">#</a> <code>ClientBlockPipeline::QuadIndices</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::QuadIndices
{
  std::array&lt;unsigned __int64,4&gt; mIndices;
};

</code></pre></div><h3 id="clientblockpipeline-facedimmingstep"><a href="#clientblockpipeline-facedimmingstep" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceDimmingStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceDimmingStep : ClientBlockPipeline::Step
{
  ClientBlockPipeline::DimensionDimmingScalars mDimmingScalars;
};

</code></pre></div><h3 id="clientblockpipeline-facedimmingstep-vtbl"><a href="#clientblockpipeline-facedimmingstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceDimmingStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::FaceDimmingStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-vec3"><a href="#clientblockpipeline-faceattribute-vec3" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;Vec3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;Vec3&gt; : std::vector&lt;Vec3&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-facenormalattributes"><a href="#clientblockpipeline-facenormalattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceNormalAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceNormalAttributes : ClientBlockPipeline::FaceAttribute&lt;Vec3&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-float"><a href="#clientblockpipeline-faceattribute-float" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;float&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;float&gt; : std::vector&lt;float&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-facedimmingattributes"><a href="#clientblockpipeline-facedimmingattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceDimmingAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceDimmingAttributes : ClientBlockPipeline::FaceAttribute&lt;float&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-clientblockpipeline-material-const"><a href="#clientblockpipeline-faceattribute-clientblockpipeline-material-const" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::Material const *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::Material const *&gt; : std::vector&lt;ClientBlockPipeline::Material const *&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-materialfaceattributes"><a href="#clientblockpipeline-materialfaceattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::MaterialFaceAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::MaterialFaceAttributes : ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::Material const *&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-facemergingstep"><a href="#clientblockpipeline-facemergingstep" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceMergingStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceMergingStep : ClientBlockPipeline::Step
{
};

</code></pre></div><h3 id="clientblockpipeline-facemergingstep-vtbl"><a href="#clientblockpipeline-facemergingstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceMergingStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::FaceMergingStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-localcliparea"><a href="#clientblockpipeline-localcliparea" class="header-anchor">#</a> <code>ClientBlockPipeline::LocalClipArea</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::LocalClipArea : AABB
{
};

</code></pre></div><h3 id="clientblockpipeline-vertexattribute-vec3"><a href="#clientblockpipeline-vertexattribute-vec3" class="header-anchor">#</a> <code>ClientBlockPipeline::VertexAttribute&lt;Vec3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VertexAttribute&lt;Vec3&gt; : std::vector&lt;Vec3&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-positionvertexattributes"><a href="#clientblockpipeline-positionvertexattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::PositionVertexAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::PositionVertexAttributes : ClientBlockPipeline::VertexAttribute&lt;Vec3&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-clientblockpipeline-quadindices"><a href="#clientblockpipeline-faceattribute-clientblockpipeline-quadindices" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::QuadIndices&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::QuadIndices&gt; : std::vector&lt;ClientBlockPipeline::QuadIndices&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-quadindicesfaceattributes"><a href="#clientblockpipeline-quadindicesfaceattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::QuadIndicesFaceAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::QuadIndicesFaceAttributes : ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::QuadIndices&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-bool"><a href="#clientblockpipeline-faceattribute-bool" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;bool&gt; : std::vector&lt;bool&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-culledfaceattribute"><a href="#clientblockpipeline-culledfaceattribute" class="header-anchor">#</a> <code>ClientBlockPipeline::CulledFaceAttribute</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::CulledFaceAttribute : ClientBlockPipeline::FaceAttribute&lt;bool&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-flatlightbakingstep"><a href="#clientblockpipeline-flatlightbakingstep" class="header-anchor">#</a> <code>ClientBlockPipeline::FlatLightBakingStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FlatLightBakingStep : ClientBlockPipeline::Step
{
};

</code></pre></div><h3 id="clientblockpipeline-flatlightbakingstep-vtbl"><a href="#clientblockpipeline-flatlightbakingstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::FlatLightBakingStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::FlatLightBakingStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-volumeof-brightnesspair"><a href="#clientblockpipeline-volumeof-brightnesspair" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeOf&lt;BrightnessPair&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeOf&lt;BrightnessPair&gt;
{
  Pos mMin;
  Pos mMax;
  std::vector&lt;BrightnessPair&gt; mData;
};

</code></pre></div><h3 id="clientblockpipeline-lightvolume"><a href="#clientblockpipeline-lightvolume" class="header-anchor">#</a> <code>ClientBlockPipeline::LightVolume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::LightVolume : ClientBlockPipeline::VolumeOf&lt;BrightnessPair&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-vec2"><a href="#clientblockpipeline-faceattribute-vec2" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;Vec2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;Vec2&gt; : std::vector&lt;Vec2&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-lightuvfaceattributes"><a href="#clientblockpipeline-lightuvfaceattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::LightUvFaceAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::LightUvFaceAttributes : ClientBlockPipeline::FaceAttribute&lt;Vec2&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-gpubuffergenstep"><a href="#clientblockpipeline-gpubuffergenstep" class="header-anchor">#</a> <code>ClientBlockPipeline::GpuBufferGenStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientBlockPipeline::GpuBufferGenStep : ClientBlockPipeline::Step
{
  bool mEmitColors;
};

</code></pre></div><h3 id="clientblockpipeline-gpubuffergenstep-vtbl"><a href="#clientblockpipeline-gpubuffergenstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::GpuBufferGenStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::GpuBufferGenStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-clientblockpipeline-uvtransform"><a href="#clientblockpipeline-faceattribute-clientblockpipeline-uvtransform" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::UvTransform&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::UvTransform&gt; : std::vector&lt;ClientBlockPipeline::UvTransform&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-imageuvfaceattributes"><a href="#clientblockpipeline-imageuvfaceattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::ImageUvFaceAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::ImageUvFaceAttributes : ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::UvTransform&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-unsigned-char"><a href="#clientblockpipeline-faceattribute-unsigned-char" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;unsigned char&gt; : std::vector&lt;unsigned char&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-facedirectionfaceattributes"><a href="#clientblockpipeline-facedirectionfaceattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceDirectionFaceAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceDirectionFaceAttributes : ClientBlockPipeline::FaceAttribute&lt;unsigned char&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-quadvertexbrightnessuvs"><a href="#clientblockpipeline-quadvertexbrightnessuvs" class="header-anchor">#</a> <code>ClientBlockPipeline::QuadVertexBrightnessUvs</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::QuadVertexBrightnessUvs
{
  std::array&lt;Vec2,4&gt; mUvs;
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-clientblockpipeline-quadvertexbrightnessuvs"><a href="#clientblockpipeline-faceattribute-clientblockpipeline-quadvertexbrightnessuvs" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::QuadVertexBrightnessUvs&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::QuadVertexBrightnessUvs&gt; : std::vector&lt;ClientBlockPipeline::QuadVertexBrightnessUvs&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-smoothlightinguvattributes"><a href="#clientblockpipeline-smoothlightinguvattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::SmoothLightingUvAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::SmoothLightingUvAttributes : ClientBlockPipeline::FaceAttribute&lt;ClientBlockPipeline::QuadVertexBrightnessUvs&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-faceattribute-vec4"><a href="#clientblockpipeline-faceattribute-vec4" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceAttribute&lt;Vec4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceAttribute&lt;Vec4&gt; : std::vector&lt;Vec4&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-vertexaoattributes"><a href="#clientblockpipeline-vertexaoattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::VertexAOAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VertexAOAttributes : ClientBlockPipeline::FaceAttribute&lt;Vec4&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-materialoverridestep"><a href="#clientblockpipeline-materialoverridestep" class="header-anchor">#</a> <code>ClientBlockPipeline::MaterialOverrideStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientBlockPipeline::MaterialOverrideStep : ClientBlockPipeline::Step
{
  Bedrock::NonOwnerPointer&lt;ClientBlockPipeline::Material const &gt; mMaterialOverride;
  _BYTE mUvGenerationType[4];
};

</code></pre></div><h3 id="clientblockpipeline-materialoverridestep-vtbl"><a href="#clientblockpipeline-materialoverridestep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::MaterialOverrideStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::MaterialOverrideStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-normalgenerationstep"><a href="#clientblockpipeline-normalgenerationstep" class="header-anchor">#</a> <code>ClientBlockPipeline::NormalGenerationStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::NormalGenerationStep : ClientBlockPipeline::Step
{
};

</code></pre></div><h3 id="clientblockpipeline-normalgenerationstep-vtbl"><a href="#clientblockpipeline-normalgenerationstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::NormalGenerationStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::NormalGenerationStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-primitivegenerationstep"><a href="#clientblockpipeline-primitivegenerationstep" class="header-anchor">#</a> <code>ClientBlockPipeline::PrimitiveGenerationStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::PrimitiveGenerationStep : ClientBlockPipeline::Step
{
};

</code></pre></div><h3 id="clientblockpipeline-primitivegenerationstep-vtbl"><a href="#clientblockpipeline-primitivegenerationstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::PrimitiveGenerationStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::PrimitiveGenerationStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-blockschematicinstance"><a href="#clientblockpipeline-blockschematicinstance" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockSchematicInstance</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BlockSchematicInstance
{
  const ClientBlockPipeline::BlockSchematic *mSchematic;
  unsigned __int64 mBoxIndexStart;
  unsigned __int64 mBoxCount;
};

</code></pre></div><h3 id="clientblockpipeline-blockschematiccell"><a href="#clientblockpipeline-blockschematiccell" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockSchematicCell</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BlockSchematicCell
{
  std::array&lt;ClientBlockPipeline::BlockSchematicInstance,2&gt; mSchematics;
};

</code></pre></div><h3 id="clientblockpipeline-volumeof-clientblockpipeline-blockschematiccell"><a href="#clientblockpipeline-volumeof-clientblockpipeline-blockschematiccell" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockSchematicCell&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockSchematicCell&gt;
{
  Pos mMin;
  Pos mMax;
  std::vector&lt;ClientBlockPipeline::BlockSchematicCell&gt; mData;
};

</code></pre></div><h3 id="clientblockpipeline-blockschematicvolume"><a href="#clientblockpipeline-blockschematicvolume" class="header-anchor">#</a> <code>ClientBlockPipeline::BlockSchematicVolume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BlockSchematicVolume : ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockSchematicCell&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-boxattribute-clientblockpipeline-boxschematicinstance"><a href="#clientblockpipeline-boxattribute-clientblockpipeline-boxschematicinstance" class="header-anchor">#</a> <code>ClientBlockPipeline::BoxAttribute&lt;ClientBlockPipeline::BoxSchematicInstance&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BoxAttribute&lt;ClientBlockPipeline::BoxSchematicInstance&gt; : std::vector&lt;ClientBlockPipeline::BoxSchematicInstance&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-boxschematicattributes"><a href="#clientblockpipeline-boxschematicattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::BoxSchematicAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BoxSchematicAttributes : ClientBlockPipeline::BoxAttribute&lt;ClientBlockPipeline::BoxSchematicInstance&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-faceschematicattributes"><a href="#clientblockpipeline-faceschematicattributes" class="header-anchor">#</a> <code>ClientBlockPipeline::FaceSchematicAttributes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::FaceSchematicAttributes : std::vector&lt;ClientBlockPipeline::FaceSchematicInstance&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-volumeviewof-clientblockpipeline-blockschematiccell"><a href="#clientblockpipeline-volumeviewof-clientblockpipeline-blockschematiccell" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockSchematicCell&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockSchematicCell&gt;
{
  Pos mMin;
  Pos mMax;
  buffer_span_mut&lt;ClientBlockPipeline::BlockSchematicCell&gt; mView;
};

</code></pre></div><h3 id="clientblockpipeline-volumeviewof-clientblockpipeline-blockschematiccell-const-volumeviewofiterator"><a href="#clientblockpipeline-volumeviewof-clientblockpipeline-blockschematiccell-const-volumeviewofiterator" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockSchematicCell const &gt;::VolumeViewOfIterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockSchematicCell const &gt;::VolumeViewOfIterator
{
  Pos mMin;
  Pos mMax;
  Pos mPosition;
  buffer_span_mut&lt;ClientBlockPipeline::BlockSchematicCell const &gt;::iterator mIterator;
};

</code></pre></div><h3 id="clientblockpipeline-schematicsjoiningstep"><a href="#clientblockpipeline-schematicsjoiningstep" class="header-anchor">#</a> <code>ClientBlockPipeline::SchematicsJoiningStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::SchematicsJoiningStep : ClientBlockPipeline::Step
{
};

</code></pre></div><h3 id="clientblockpipeline-schematicsjoiningstep-vtbl"><a href="#clientblockpipeline-schematicsjoiningstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::SchematicsJoiningStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::SchematicsJoiningStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-volumeof-clientblockpipeline-blockopacitydata"><a href="#clientblockpipeline-volumeof-clientblockpipeline-blockopacitydata" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockOpacityData&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockOpacityData&gt;
{
  Pos mMin;
  Pos mMax;
  std::vector&lt;ClientBlockPipeline::BlockOpacityData&gt; mData;
};

</code></pre></div><h3 id="clientblockpipeline-solidopaqueblockvolume"><a href="#clientblockpipeline-solidopaqueblockvolume" class="header-anchor">#</a> <code>ClientBlockPipeline::SolidOpaqueBlockVolume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ClientBlockPipeline::SolidOpaqueBlockVolume : ClientBlockPipeline::VolumeOf&lt;ClientBlockPipeline::BlockOpacityData&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-volumeviewof-clientblockpipeline-blockcell-const-volumeviewofiterator"><a href="#clientblockpipeline-volumeviewof-clientblockpipeline-blockcell-const-volumeviewofiterator" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockCell const &gt;::VolumeViewOfIterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockCell const &gt;::VolumeViewOfIterator
{
  Pos mMin;
  Pos mMax;
  Pos mPosition;
  buffer_span_mut&lt;ClientBlockPipeline::BlockCell const &gt;::iterator mIterator;
};

</code></pre></div><h3 id="clientblockpipeline-schematicsmappingstep"><a href="#clientblockpipeline-schematicsmappingstep" class="header-anchor">#</a> <code>ClientBlockPipeline::SchematicsMappingStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::SchematicsMappingStep : ClientBlockPipeline::Step
{
};

</code></pre></div><h3 id="clientblockpipeline-schematicsmappingstep-vtbl"><a href="#clientblockpipeline-schematicsmappingstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::SchematicsMappingStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::SchematicsMappingStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-bakedbox"><a href="#clientblockpipeline-bakedbox" class="header-anchor">#</a> <code>ClientBlockPipeline::BakedBox</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BakedBox
{
  Vec3 mCenter;
  Vec3 mScale;
  Vec3 mRotation;
  Vec3 mPivot;
};

</code></pre></div><h3 id="clientblockpipeline-bakednode"><a href="#clientblockpipeline-bakednode" class="header-anchor">#</a> <code>ClientBlockPipeline::BakedNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::BakedNode
{
  Vec3 mPivot;
  Vec3 mRotation;
  Vec3 mScale;
  Vec3 mBindPoseRotation;
  float mInflate;
};

</code></pre></div><h3 id="clientblockpipeline-smoothlightbakingstep"><a href="#clientblockpipeline-smoothlightbakingstep" class="header-anchor">#</a> <code>ClientBlockPipeline::SmoothLightBakingStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::SmoothLightBakingStep : ClientBlockPipeline::Step
{
};

</code></pre></div><h3 id="clientblockpipeline-smoothlightbakingstep-vtbl"><a href="#clientblockpipeline-smoothlightbakingstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::SmoothLightBakingStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::SmoothLightBakingStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-volumeof-float"><a href="#clientblockpipeline-volumeof-float" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeOf&lt;float&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeOf&lt;float&gt;
{
  Pos mMin;
  Pos mMax;
  std::vector&lt;float&gt; mData;
};

</code></pre></div><h3 id="clientblockpipeline-aobrightnessvolume"><a href="#clientblockpipeline-aobrightnessvolume" class="header-anchor">#</a> <code>ClientBlockPipeline::AOBrightnessVolume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::AOBrightnessVolume : ClientBlockPipeline::VolumeOf&lt;float&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-smoothlightbakingstep-visiblecelldata"><a href="#clientblockpipeline-smoothlightbakingstep-visiblecelldata" class="header-anchor">#</a> <code>ClientBlockPipeline::SmoothLightBakingStep::VisibleCellData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::SmoothLightBakingStep::VisibleCellData
{
  unsigned __int64 mIndex;
  float mDistanceSq;
  Pos mSampleCellPos;
};

</code></pre></div><h3 id="clientblockpipeline-surfaceextractionstep"><a href="#clientblockpipeline-surfaceextractionstep" class="header-anchor">#</a> <code>ClientBlockPipeline::SurfaceExtractionStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::SurfaceExtractionStep : ClientBlockPipeline::Step
{
};

</code></pre></div><h3 id="clientblockpipeline-surfaceextractionstep-vtbl"><a href="#clientblockpipeline-surfaceextractionstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::SurfaceExtractionStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::SurfaceExtractionStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-surfaceextractionstep-run-l2-quaddata"><a href="#clientblockpipeline-surfaceextractionstep-run-l2-quaddata" class="header-anchor">#</a> <code>ClientBlockPipeline::SurfaceExtractionStep::_run::__l2::QuadData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(4)) ClientBlockPipeline::SurfaceExtractionStep::_run::__l2::QuadData
{
  std::array&lt;int,4&gt; vertices;
  unsigned __int8 facing;
};

</code></pre></div><h3 id="core-sharedmemorytracker-sharedmemorytrackerbase"><a href="#core-sharedmemorytracker-sharedmemorytrackerbase" class="header-anchor">#</a> <code>Core::SharedMemoryTracker::SharedMemoryTrackerBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::SharedMemoryTracker::SharedMemoryTrackerBase
{
  Core::SharedMemoryTracker::SharedMemoryTrackerBase_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="core-sharedmemorytracker-sharedmemorytrackerbase-vtbl"><a href="#core-sharedmemorytracker-sharedmemorytrackerbase-vtbl" class="header-anchor">#</a> <code>Core::SharedMemoryTracker::SharedMemoryTrackerBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::SharedMemoryTracker::SharedMemoryTrackerBase_vtbl
{
  void (__fastcall *~SharedMemoryTrackerBase)(Core::SharedMemoryTracker::SharedMemoryTrackerBase *this);
};

</code></pre></div><h3 id="cg-details-worktoken"><a href="#cg-details-worktoken" class="header-anchor">#</a> <code>cg::details::WorkToken</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::WorkToken
{
  std::atomic&lt;bool&gt; mIsDone;
};

</code></pre></div><h3 id="cg-grouppooldescription"><a href="#cg-grouppooldescription" class="header-anchor">#</a> <code>cg::GroupPoolDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) cg::GroupPoolDescription
{
  WorkerPool *mPool;
  Scheduler *mScheduler;
  bool mIsHelper;
};

</code></pre></div><h3 id="cg-taskdispatcherschedulertraits-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const"><a href="#cg-taskdispatcherschedulertraits-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const" class="header-anchor">#</a> <code>cg::TaskDispatcherSchedulerTraits&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TaskDispatcherSchedulerTraits&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;
{
};

</code></pre></div><h3 id="cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution"><a href="#cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution" class="header-anchor">#</a> <code>cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution
{
};

</code></pre></div><h3 id="cg-schedulerexecutiontraits-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-cg-details-worktoken"><a href="#cg-schedulerexecutiontraits-cg-lambdaexecutor-dragon-rendering-rendercontext-cg-taskpoolgroupexecutionpolicy-dragon-rendering-rendercontext-1-std-string-const-std-vector-cg-grouppooldescription-const-cg-details-worktoken" class="header-anchor">#</a> <code>cg::SchedulerExecutionTraits&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;,cg::details::WorkToken&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::SchedulerExecutionTraits&lt;cg::LambdaExecutor&lt;dragon::rendering::RenderContext,cg::TaskPoolGroupExecutionPolicy&lt;dragon::rendering::RenderContext,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;,cg::details::WorkToken&gt;
{
};

</code></pre></div><h3 id="cg-details-dispatchtoken-std-shared-ptr-cg-details-worktoken-const-std-shared-ptr-std-function-void-cdecl-dragon-rendering-rendercontext"><a href="#cg-details-dispatchtoken-std-shared-ptr-cg-details-worktoken-const-std-shared-ptr-std-function-void-cdecl-dragon-rendering-rendercontext" class="header-anchor">#</a> <code>cg::details::DispatchToken&lt;std::shared_ptr&lt;cg::details::WorkToken const &gt;,std::shared_ptr&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::details::DispatchToken&lt;std::shared_ptr&lt;cg::details::WorkToken const &gt;,std::shared_ptr&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt; &gt; &gt;
{
  std::shared_ptr&lt;cg::details::WorkToken const &gt; mToken;
  std::optional&lt;std::shared_ptr&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt; &gt; &gt; mResult;
};

</code></pre></div><h3 id="core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource"><a href="#core-cache-unsigned-int64-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource-std-shared-ptr-dragon-rendering-bufferresourcemanager-dragon-rendering-textureresourcetype-bufferresource" class="header-anchor">#</a> <code>Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Cache&lt;unsigned __int64,dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt; &gt;
{
  std::shared_mutex mAccess;
  std::unordered_map&lt;unsigned __int64,std::shared_ptr&lt;dragon::rendering::BufferResourceManager&lt;dragon::rendering::TextureResourceType&gt;::BufferResource&gt;&gt; mContent;
};

</code></pre></div><h3 id="clientblockpipeline-worldextractorstep"><a href="#clientblockpipeline-worldextractorstep" class="header-anchor">#</a> <code>ClientBlockPipeline::WorldExtractorStep</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj ClientBlockPipeline::WorldExtractorStep : ClientBlockPipeline::Step
{
  std::function&lt;bool __cdecl(Block const &amp;)&gt; mBlockUsagePredicate;
};

</code></pre></div><h3 id="clientblockpipeline-worldextractorstep-vtbl"><a href="#clientblockpipeline-worldextractorstep-vtbl" class="header-anchor">#</a> <code>ClientBlockPipeline::WorldExtractorStep_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientBlockPipeline::WorldExtractorStep_vtbl
{
  void (__fastcall *~Step)(ClientBlockPipeline::Step *this);
  ClientBlockPipeline::StepResult *(__fastcall *run)(ClientBlockPipeline::Step *this, ClientBlockPipeline::StepResult *result, const ClientBlockPipeline::Inputs *);
};

</code></pre></div><h3 id="clientblockpipeline-volumeof-int"><a href="#clientblockpipeline-volumeof-int" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeOf&lt;int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeOf&lt;int&gt;
{
  Pos mMin;
  Pos mMax;
  std::vector&lt;int&gt; mData;
};

</code></pre></div><h3 id="clientblockpipeline-grasstintvolume"><a href="#clientblockpipeline-grasstintvolume" class="header-anchor">#</a> <code>ClientBlockPipeline::GrassTintVolume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::GrassTintVolume : ClientBlockPipeline::VolumeOf&lt;int&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-watertintvolume"><a href="#clientblockpipeline-watertintvolume" class="header-anchor">#</a> <code>ClientBlockPipeline::WaterTintVolume</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::WaterTintVolume : ClientBlockPipeline::VolumeOf&lt;int&gt;
{
};

</code></pre></div><h3 id="clientblockpipeline-volumeviewof-clientblockpipeline-blockcell-volumeviewofiterator"><a href="#clientblockpipeline-volumeviewof-clientblockpipeline-blockcell-volumeviewofiterator" class="header-anchor">#</a> <code>ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockCell&gt;::VolumeViewOfIterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::VolumeViewOf&lt;ClientBlockPipeline::BlockCell&gt;::VolumeViewOfIterator
{
  Pos mMin;
  Pos mMax;
  Pos mPosition;
  buffer_span_mut&lt;ClientBlockPipeline::BlockCell&gt;::iterator mIterator;
};

</code></pre></div><h3 id="clientblockpipeline-worldcliparea"><a href="#clientblockpipeline-worldcliparea" class="header-anchor">#</a> <code>ClientBlockPipeline::WorldClipArea</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientBlockPipeline::WorldClipArea : AABB
{
};

</code></pre></div><h3 id="crimsonforestmoodsoundplayer"><a href="#crimsonforestmoodsoundplayer" class="header-anchor">#</a> <code>CrimsonForestMoodSoundPlayer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CrimsonForestMoodSoundPlayer
{
};

</code></pre></div><h3 id="commerceauthtoken"><a href="#commerceauthtoken" class="header-anchor">#</a> <code>CommerceAuthToken</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommerceAuthToken
{
  std::string mToken;
  std::string mExpiration;
};

</code></pre></div><h3 id="commerceidentity"><a href="#commerceidentity" class="header-anchor">#</a> <code>CommerceIdentity</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommerceIdentity : std::enable_shared_from_this&lt;CommerceIdentity&gt;
{
  IMinecraftEventing *mEventing;
  Bedrock::NonOwnerPointer&lt;Social::IUserManager&gt; mUserManager;
  std::unique_ptr&lt;SecureStorage&gt; mSecureStore;
  std::unique_ptr&lt;Crypto::Asymmetric::Asymmetric&gt; mSSLInterface;
  bool mHasQueriedForDeviceId;
  bool mDeviceAccountUsed;
  std::string mUserId;
  CommerceAuthToken mDeviceAuthToken;
};

</code></pre></div><h3 id="crypto-pkcs7-isysteminterface"><a href="#crypto-pkcs7-isysteminterface" class="header-anchor">#</a> <code>Crypto::Pkcs7::ISystemInterface</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Crypto::Pkcs7::ISystemInterface
{
  Crypto::Pkcs7::ISystemInterface_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="crypto-pkcs7-isysteminterface-vtbl"><a href="#crypto-pkcs7-isysteminterface-vtbl" class="header-anchor">#</a> <code>Crypto::Pkcs7::ISystemInterface_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Crypto::Pkcs7::ISystemInterface_vtbl
{
  void (__fastcall *~ISystemInterface)(Crypto::Pkcs7::ISystemInterface *this);
  std::vector&lt;unsigned char&gt; *(__fastcall *verifyAndReadPKCS7Data)(Crypto::Pkcs7::ISystemInterface *this, std::vector&lt;unsigned char&gt; *result, const std::string *);
};

</code></pre></div><h3 id="cmsghdr"><a href="#cmsghdr" class="header-anchor">#</a> <code>cmsghdr</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct cmsghdr
{
  unsigned __int64 cmsg_len;
  int cmsg_level;
  int cmsg_type;
};

</code></pre></div><h3 id="concurrency-context"><a href="#concurrency-context" class="header-anchor">#</a> <code>Concurrency::Context</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::Context
{
  Concurrency::Context_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="concurrency-context-vtbl"><a href="#concurrency-context-vtbl" class="header-anchor">#</a> <code>Concurrency::Context_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::Context_vtbl
{
  unsigned int (__fastcall *GetId)(Concurrency::Context *this);
  unsigned int (__fastcall *GetVirtualProcessorId)(Concurrency::Context *this);
  unsigned int (__fastcall *GetScheduleGroupId)(Concurrency::Context *this);
  void (__fastcall *Unblock)(Concurrency::Context *this);
  bool (__fastcall *IsSynchronouslyBlocked)(Concurrency::Context *this);
  void (__fastcall *~Context)(Concurrency::Context *this);
};

</code></pre></div><h3 id="concurrency-message-not-found"><a href="#concurrency-message-not-found" class="header-anchor">#</a> <code>Concurrency::message_not_found</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::message_not_found : std::exception
{
};

</code></pre></div><h3 id="concurrency-message-not-found-vtbl"><a href="#concurrency-message-not-found-vtbl" class="header-anchor">#</a> <code>Concurrency::message_not_found_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::message_not_found_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-critical-section"><a href="#concurrency-critical-section" class="header-anchor">#</a> <code>Concurrency::critical_section</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::critical_section
{
  void *_M_activeNode[5];
  void *volatile _M_pHead;
  void *volatile _M_pTail;
};

</code></pre></div><h3 id="concurrency-critical-section-scoped-lock"><a href="#concurrency-critical-section-scoped-lock" class="header-anchor">#</a> <code>Concurrency::critical_section::scoped_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::critical_section::scoped_lock
{
  Concurrency::critical_section *_M_critical_section;
  void *_M_node[5];
};

</code></pre></div><h3 id="concurrency-scheduler"><a href="#concurrency-scheduler" class="header-anchor">#</a> <code>Concurrency::Scheduler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::Scheduler
{
  Concurrency::Scheduler_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="concurrency-schedulerpolicy-policybag-unnamed-type-m-values-unnamed-type-m-specificvalues"><a href="#concurrency-schedulerpolicy-policybag-unnamed-type-m-values-unnamed-type-m-specificvalues" class="header-anchor">#</a> <code>Concurrency::SchedulerPolicy::_PolicyBag::&lt;unnamed_type__M_values&gt;::&lt;unnamed_type__M_specificValues&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct Concurrency::SchedulerPolicy::_PolicyBag::&lt;unnamed_type__M_values&gt;::&lt;unnamed_type__M_specificValues&gt;
{
  Concurrency::SchedulerType _M_schedulerKind;
  unsigned int _M_maxConcurrency;
  unsigned int _M_minConcurrency;
  unsigned int _M_targetOversubscriptionFactor;
  unsigned int _M_localContextCacheSize;
  unsigned int _M_contextStackSize;
  unsigned int _M_contextPriority;
  Concurrency::SchedulingProtocolType _M_schedulingProtocol;
  Concurrency::DynamicProgressFeedbackType _M_dynamicProgressFeedback;
  Concurrency::WinRTInitializationType _M_WinRTInitialization;
};

</code></pre></div><h3 id="concurrency-schedulerpolicy-policybag"><a href="#concurrency-schedulerpolicy-policybag" class="header-anchor">#</a> <code>Concurrency::SchedulerPolicy::_PolicyBag</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct Concurrency::SchedulerPolicy::_PolicyBag
{
  Concurrency::SchedulerPolicy::_PolicyBag::&lt;unnamed_type__M_values&gt; _M_values;
};

</code></pre></div><h3 id="concurrency-schedulerpolicy"><a href="#concurrency-schedulerpolicy" class="header-anchor">#</a> <code>Concurrency::SchedulerPolicy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::SchedulerPolicy
{
  Concurrency::SchedulerPolicy::_PolicyBag *_M_pPolicyBag;
};

</code></pre></div><h3 id="concurrency-schedulegroup"><a href="#concurrency-schedulegroup" class="header-anchor">#</a> <code>Concurrency::ScheduleGroup</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::ScheduleGroup
{
  Concurrency::ScheduleGroup_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="concurrency-schedulegroup-vtbl"><a href="#concurrency-schedulegroup-vtbl" class="header-anchor">#</a> <code>Concurrency::ScheduleGroup_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::ScheduleGroup_vtbl
{
  void (__fastcall *ScheduleTask)(Concurrency::ScheduleGroup *this, void (__fastcall *)(void *), void *);
  unsigned int (__fastcall *Id)(Concurrency::ScheduleGroup *this);
  unsigned int (__fastcall *Reference)(Concurrency::ScheduleGroup *this);
  unsigned int (__fastcall *Release)(Concurrency::ScheduleGroup *this);
  void (__fastcall *~ScheduleGroup)(Concurrency::ScheduleGroup *this);
};

</code></pre></div><h3 id="concurrency-location"><a href="#concurrency-location" class="header-anchor">#</a> <code>Concurrency::location</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::location
{
  unsigned __int32 _M_type : 28;
  unsigned __int32 _M_reserved : 4;
  unsigned int _M_bindingId;
  $441E66D683A4B86F862CB9A174F60F9E ___u3;
  void *_M_pBinding;
};

</code></pre></div><h3 id="concurrency-scheduler-vtbl"><a href="#concurrency-scheduler-vtbl" class="header-anchor">#</a> <code>Concurrency::Scheduler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::Scheduler_vtbl
{
  void (__fastcall *~Scheduler)(Concurrency::Scheduler *this);
  unsigned int (__fastcall *Id)(Concurrency::Scheduler *this);
  unsigned int (__fastcall *GetNumberOfVirtualProcessors)(Concurrency::Scheduler *this);
  Concurrency::SchedulerPolicy *(__fastcall *GetPolicy)(Concurrency::Scheduler *this, Concurrency::SchedulerPolicy *result);
  unsigned int (__fastcall *Reference)(Concurrency::Scheduler *this);
  unsigned int (__fastcall *Release)(Concurrency::Scheduler *this);
  void (__fastcall *RegisterShutdownEvent)(Concurrency::Scheduler *this, void *);
  void (__fastcall *Attach)(Concurrency::Scheduler *this);
  Concurrency::ScheduleGroup *(__fastcall *CreateScheduleGroup)(Concurrency::Scheduler *this, Concurrency::location *);
  Concurrency::ScheduleGroup *(__fastcall *CreateScheduleGroup)(Concurrency::Scheduler *this);
  void (__fastcall *ScheduleTask)(Concurrency::Scheduler *this, void (__fastcall *)(void *), void *, Concurrency::location *);
  void (__fastcall *ScheduleTask)(Concurrency::Scheduler *this, void (__fastcall *)(void *), void *);
  bool (__fastcall *IsAvailableLocation)(Concurrency::Scheduler *this, const Concurrency::location *);
};

</code></pre></div><h3 id="concurrency-scheduler-resource-allocation-error"><a href="#concurrency-scheduler-resource-allocation-error" class="header-anchor">#</a> <code>Concurrency::scheduler_resource_allocation_error</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::scheduler_resource_allocation_error : std::exception
{
  HRESULT _Hresult;
};

</code></pre></div><h3 id="concurrency-scheduler-resource-allocation-error-vtbl"><a href="#concurrency-scheduler-resource-allocation-error-vtbl" class="header-anchor">#</a> <code>Concurrency::scheduler_resource_allocation_error_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::scheduler_resource_allocation_error_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-scheduler-worker-creation-error"><a href="#concurrency-scheduler-worker-creation-error" class="header-anchor">#</a> <code>Concurrency::scheduler_worker_creation_error</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::scheduler_worker_creation_error : Concurrency::scheduler_resource_allocation_error
{
};

</code></pre></div><h3 id="concurrency-scheduler-worker-creation-error-vtbl"><a href="#concurrency-scheduler-worker-creation-error-vtbl" class="header-anchor">#</a> <code>Concurrency::scheduler_worker_creation_error_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::scheduler_worker_creation_error_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-details-refcounterbase"><a href="#concurrency-details-refcounterbase" class="header-anchor">#</a> <code>Concurrency::details::_RefCounterBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::details::_RefCounterBase
{
  Concurrency::details::_RefCounterBase_vtbl *__vftable /*VFT*/;
  volatile int _M_refCount;
};

</code></pre></div><h3 id="concurrency-details-refcounterbase-vtbl"><a href="#concurrency-details-refcounterbase-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_RefCounterBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_RefCounterBase_vtbl
{
  void (__fastcall *~_RefCounterBase)(Concurrency::details::_RefCounterBase *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounterBase *this);
};

</code></pre></div><h3 id="concurrency-details-taskcollectionbase"><a href="#concurrency-details-taskcollectionbase" class="header-anchor">#</a> <code>Concurrency::details::_TaskCollectionBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TaskCollectionBase
{
  Concurrency::details::_TaskCollectionBase *_M_pParent;
  __int32 _M_inliningDepth : 28;
  __int32 _M_inlineFlags : 4;
  Concurrency::details::_CancellationTokenState *_M_pTokenState;
  void *_M_pOwningContext;
  int _M_unpoppedChores;
  volatile int _M_completedStolenChores;
  std::exception_ptr *_M_pException;
};

</code></pre></div><h3 id="concurrency-details-refcounter"><a href="#concurrency-details-refcounter" class="header-anchor">#</a> <code>Concurrency::details::_RefCounter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::details::_RefCounter
{
  Concurrency::details::_RefCounter_vtbl *__vftable /*VFT*/;
  volatile int _M_refCount;
};

</code></pre></div><h3 id="concurrency-details-refcounter-vtbl"><a href="#concurrency-details-refcounter-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_RefCounter_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_RefCounter_vtbl
{
  void (__fastcall *~_RefCounter)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounter *this);
};

</code></pre></div><h3 id="concurrency-details-cancellationtokenregistration"><a href="#concurrency-details-cancellationtokenregistration" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenRegistration</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_CancellationTokenRegistration : Concurrency::details::_RefCounter
{
  std::atomic&lt;long&gt; _M_state;
  std::condition_variable _M_CondVar;
  std::mutex _M_Mutex;
  bool _M_signaled;
  Concurrency::details::_CancellationTokenState *_M_pTokenState;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokenstate"><a href="#concurrency-details-cancellationtokenstate" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_CancellationTokenState : Concurrency::details::_RefCounter
{
  std::atomic&lt;long&gt; _M_stateFlag;
  std::mutex _M_listLock;
  Concurrency::details::_CancellationTokenState::TokenRegistrationContainer _M_registrations;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokenregistration-vtbl"><a href="#concurrency-details-cancellationtokenregistration-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenRegistration_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_CancellationTokenRegistration_vtbl
{
  void (__fastcall *~_RefCounter)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Exec)(Concurrency::details::_CancellationTokenRegistration *this);
};

</code></pre></div><h3 id="concurrency-details-cancellationtokenstate-tokenregistrationcontainer-node"><a href="#concurrency-details-cancellationtokenstate-tokenregistrationcontainer-node" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenState::TokenRegistrationContainer::_Node</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_CancellationTokenState::TokenRegistrationContainer::_Node
{
  Concurrency::details::_CancellationTokenRegistration *_M_token;
  Concurrency::details::_CancellationTokenState::TokenRegistrationContainer::_Node *_M_next;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokenstate-tokenregistrationcontainer"><a href="#concurrency-details-cancellationtokenstate-tokenregistrationcontainer" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenState::TokenRegistrationContainer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_CancellationTokenState::TokenRegistrationContainer
{
  Concurrency::details::_CancellationTokenState::TokenRegistrationContainer::_Node *_M_begin;
  Concurrency::details::_CancellationTokenState::TokenRegistrationContainer::_Node *_M_last;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokenstate-vtbl"><a href="#concurrency-details-cancellationtokenstate-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenState_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_CancellationTokenState_vtbl
{
  void (__fastcall *~_RefCounter)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounter *this);
};

</code></pre></div><h3 id="concurrency-event"><a href="#concurrency-event" class="header-anchor">#</a> <code>Concurrency::event</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::event
{
  void *volatile _M_pWaitChain;
  void *_M_pResetChain;
  Concurrency::critical_section _M_lock;
};

</code></pre></div><h3 id="concurrency-details-taskcollection"><a href="#concurrency-details-taskcollection" class="header-anchor">#</a> <code>Concurrency::details::_TaskCollection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TaskCollection : Concurrency::details::_TaskCollectionBase
{
  void *_M_stealTracker[4];
  int _M_activeStealersForCancellation;
  volatile int _M_exitCode;
  volatile int _M_executionStatus;
  Concurrency::event _M_event;
  Concurrency::details::_TaskCollection *_M_pOriginalCollection;
  Concurrency::details::_TaskCollection *_M_pNextAlias;
  void *_M_pTaskExtension;
  int _M_taskCookies[2];
  volatile int _M_flags;
  volatile int _M_chaining;
  unsigned int _M_boundQueueId;
  int _M_stackPos;
  void (__fastcall *_M_completionHandler)(void *);
  void *_M_pCompletionContext;
};

</code></pre></div><h3 id="concurrency-details-asynctaskcollection"><a href="#concurrency-details-asynctaskcollection" class="header-anchor">#</a> <code>Concurrency::details::_AsyncTaskCollection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_AsyncTaskCollection : Concurrency::details::_RefCounterBase
{
  Concurrency::details::_TaskCollection _M_taskCollection;
};

</code></pre></div><h3 id="concurrency-details-asynctaskcollection-vtbl"><a href="#concurrency-details-asynctaskcollection-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_AsyncTaskCollection_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_AsyncTaskCollection_vtbl
{
  void (__fastcall *~_RefCounterBase)(Concurrency::details::_RefCounterBase *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounterBase *this);
};

</code></pre></div><h3 id="concurrency-details-chore"><a href="#concurrency-details-chore" class="header-anchor">#</a> <code>Concurrency::details::_Chore</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Chore
{
  Concurrency::details::_Chore_vtbl *__vftable /*VFT*/;
  void (__fastcall *m_pFunction)(void *);
};

</code></pre></div><h3 id="concurrency-details-chore-vtbl"><a href="#concurrency-details-chore-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_Chore_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_Chore_vtbl
{
  void (__fastcall *~_Chore)(Concurrency::details::_Chore *this);
};

</code></pre></div><h3 id="concurrency-details-allocbase"><a href="#concurrency-details-allocbase" class="header-anchor">#</a> <code>Concurrency::details::_AllocBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_AllocBase
{
};

</code></pre></div><h3 id="concurrency-details-unrealizedchore"><a href="#concurrency-details-unrealizedchore" class="header-anchor">#</a> <code>Concurrency::details::_UnrealizedChore</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::details::_UnrealizedChore : Concurrency::details::_Chore, Concurrency::details::_AllocBase
{
  Concurrency::details::_TaskCollectionBase *_M_pTaskCollection;
  void (__fastcall *_M_pChoreFunction)(Concurrency::details::_UnrealizedChore *);
  bool _M_fRuntimeOwnsLifetime;
  bool _M_fDetached;
};

</code></pre></div><h3 id="concurrency-details-unrealizedchore-vtbl"><a href="#concurrency-details-unrealizedchore-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_UnrealizedChore_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_UnrealizedChore_vtbl
{
  void (__fastcall *~_Chore)(Concurrency::details::_Chore *this);
};

</code></pre></div><h3 id="concurrency-details-task-generator-oversubscriber"><a href="#concurrency-details-task-generator-oversubscriber" class="header-anchor">#</a> <code>Concurrency::details::_Task_generator_oversubscriber</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Task_generator_oversubscriber
{
};

</code></pre></div><h3 id="concurrency-details-beacon-reference"><a href="#concurrency-details-beacon-reference" class="header-anchor">#</a> <code>Concurrency::details::_Beacon_reference</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Beacon_reference
{
  volatile int _M_signals;
};

</code></pre></div><h3 id="concurrency-details-cancellation-beacon"><a href="#concurrency-details-cancellation-beacon" class="header-anchor">#</a> <code>Concurrency::details::_Cancellation_beacon</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Cancellation_beacon
{
  Concurrency::details::_Beacon_reference *_M_pRef;
};

</code></pre></div><h3 id="concurrency-details-nonreentrantblockinglock"><a href="#concurrency-details-nonreentrantblockinglock" class="header-anchor">#</a> <code>Concurrency::details::_NonReentrantBlockingLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_NonReentrantBlockingLock
{
  void *_M_criticalSection[5];
};

</code></pre></div><h3 id="concurrency-details-nonreentrantblockinglock-scoped-lock"><a href="#concurrency-details-nonreentrantblockinglock-scoped-lock" class="header-anchor">#</a> <code>Concurrency::details::_NonReentrantBlockingLock::_Scoped_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_NonReentrantBlockingLock::_Scoped_lock
{
  Concurrency::details::_NonReentrantBlockingLock *_M_lock;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokencallback-lambda-a40cf361f6b489cdc7950415e60bfc49"><a href="#concurrency-details-cancellationtokencallback-lambda-a40cf361f6b489cdc7950415e60bfc49" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_a40cf361f6b489cdc7950415e60bfc49&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_a40cf361f6b489cdc7950415e60bfc49&gt; &gt; : Concurrency::details::_CancellationTokenRegistration
{
  struct Concurrency::details::_JoinAllTokens_Add::__l5::&lt;lambda_a40cf361f6b489cdc7950415e60bfc49&gt; _M_function;
  _BYTE gapC0[8];
};

</code></pre></div><h3 id="concurrency-details-cancellationtokencallback-lambda-a40cf361f6b489cdc7950415e60bfc49-vtbl"><a href="#concurrency-details-cancellationtokencallback-lambda-a40cf361f6b489cdc7950415e60bfc49-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_a40cf361f6b489cdc7950415e60bfc49&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_a40cf361f6b489cdc7950415e60bfc49&gt; &gt;_vtbl
{
  void (__fastcall *~_RefCounter)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Exec)(Concurrency::details::_CancellationTokenRegistration *this);
};

</code></pre></div><h3 id="concurrency-details-task-impl-base"><a href="#concurrency-details-task-impl-base" class="header-anchor">#</a> <code>Concurrency::details::_Task_impl_base</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Task_impl_base
{
  Concurrency::details::_Task_impl_base_vtbl *__vftable /*VFT*/;
  volatile Concurrency::details::_Task_impl_base::_TaskInternalState _M_TaskState;
  bool _M_fFromAsync;
  bool _M_fUnwrappedTask;
  std::shared_ptr&lt;Concurrency::details::_ExceptionHolder&gt; _M_exceptionHolder;
  std::mutex _M_ContinuationsCritSec;
  Concurrency::details::_ContinuationTaskHandleBase *_M_Continuations;
  Concurrency::details::_CancellationTokenState *_M_pTokenState;
  Concurrency::details::_CancellationTokenRegistration *_M_pRegistration;
  Concurrency::details::_TaskCollectionBaseImpl _M_TaskCollection;
  Concurrency::details::_TaskCreationCallstack _M_pTaskCreationCallstack;
  Concurrency::details::_TaskEventLogger _M_taskEventLogger;
};

</code></pre></div><h3 id="concurrency-details-exceptionholder"><a href="#concurrency-details-exceptionholder" class="header-anchor">#</a> <code>Concurrency::details::_ExceptionHolder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ExceptionHolder
{
  std::atomic&lt;long&gt; _M_exceptionObserved;
  std::exception_ptr _M_stdException;
  Concurrency::details::_TaskCreationCallstack _M_stackTrace;
};

</code></pre></div><h3 id="concurrency-details-task-impl-base-vtbl"><a href="#concurrency-details-task-impl-base-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_Task_impl_base_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_Task_impl_base_vtbl
{
  void (__fastcall *~_Task_impl_base)(Concurrency::details::_Task_impl_base *this);
  bool (__fastcall *_CancelAndRunContinuations)(Concurrency::details::_Task_impl_base *this, bool, bool, bool, const std::shared_ptr&lt;Concurrency::details::_ExceptionHolder&gt; *);
};

</code></pre></div><h3 id="concurrency-details-taskprochandle"><a href="#concurrency-details-taskprochandle" class="header-anchor">#</a> <code>Concurrency::details::_TaskProcHandle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TaskProcHandle
{
  Concurrency::details::_TaskProcHandle_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="concurrency-details-taskprochandle-vtbl"><a href="#concurrency-details-taskprochandle-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_TaskProcHandle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_TaskProcHandle_vtbl
{
  void (__fastcall *~_TaskProcHandle)(Concurrency::details::_TaskProcHandle *this);
  void (__fastcall *invoke)(Concurrency::details::_TaskProcHandle *this);
};

</code></pre></div><h3 id="concurrency-details-continuationtaskhandlebase"><a href="#concurrency-details-continuationtaskhandlebase" class="header-anchor">#</a> <code>Concurrency::details::_ContinuationTaskHandleBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ContinuationTaskHandleBase : Concurrency::details::_TaskProcHandle
{
  Concurrency::details::_ContinuationTaskHandleBase *_M_next;
  Concurrency::task_continuation_context _M_continuationContext;
  bool _M_isTaskBasedContinuation;
  Concurrency::details::_TaskInliningMode _M_inliningMode;
};

</code></pre></div><h3 id="concurrency-details-continuationtaskhandlebase-vtbl"><a href="#concurrency-details-continuationtaskhandlebase-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_ContinuationTaskHandleBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_ContinuationTaskHandleBase_vtbl
{
  void (__fastcall *~_TaskProcHandle)(Concurrency::details::_TaskProcHandle *this);
  void (__fastcall *invoke)(Concurrency::details::_TaskProcHandle *this);
  std::shared_ptr&lt;Concurrency::details::_Task_impl_base&gt; *(__fastcall *_GetTaskImplBase)(Concurrency::details::_ContinuationTaskHandleBase *this, std::shared_ptr&lt;Concurrency::details::_Task_impl_base&gt; *result);
};

</code></pre></div><h3 id="concurrency-scheduler-interface-vtbl"><a href="#concurrency-scheduler-interface-vtbl" class="header-anchor">#</a> <code>Concurrency::scheduler_interface_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::scheduler_interface_vtbl
{
  void (__fastcall *schedule)(Concurrency::scheduler_interface *this, void (__fastcall *)(void *), void *);
};

</code></pre></div><h3 id="concurrency-details-taskcollectionbaseimpl"><a href="#concurrency-details-taskcollectionbaseimpl" class="header-anchor">#</a> <code>Concurrency::details::_TaskCollectionBaseImpl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::details::_TaskCollectionBaseImpl
{
  std::condition_variable _M_StateChanged;
  std::mutex _M_Cs;
  Concurrency::scheduler_ptr _M_pScheduler;
  Concurrency::details::_TaskCollectionBaseImpl::_TaskCollectionState _M_State;
};

</code></pre></div><h3 id="concurrency-details-taskeventlogger"><a href="#concurrency-details-taskeventlogger" class="header-anchor">#</a> <code>Concurrency::details::_TaskEventLogger</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::details::_TaskEventLogger
{
  Concurrency::details::_Task_impl_base *_M_task;
  bool _M_scheduled;
  bool _M_taskPostEventStarted;
};

</code></pre></div><h3 id="concurrency-details-task-impl-base-registercancellation-l2-lambda-be3e5d9dce35d2c8dbfa8485373731d5"><a href="#concurrency-details-task-impl-base-registercancellation-l2-lambda-be3e5d9dce35d2c8dbfa8485373731d5" class="header-anchor">#</a> <code>Concurrency::details::_Task_impl_base::_RegisterCancellation::__l2::&lt;lambda_be3e5d9dce35d2c8dbfa8485373731d5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Task_impl_base::_RegisterCancellation::__l2::&lt;lambda_be3e5d9dce35d2c8dbfa8485373731d5&gt;
{
  std::weak_ptr&lt;Concurrency::details::_Task_impl_base&gt; _WeakPtr;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokencallback-lambda-be3e5d9dce35d2c8dbfa8485373731d5"><a href="#concurrency-details-cancellationtokencallback-lambda-be3e5d9dce35d2c8dbfa8485373731d5" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_be3e5d9dce35d2c8dbfa8485373731d5&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_be3e5d9dce35d2c8dbfa8485373731d5&gt; &gt; : Concurrency::details::_CancellationTokenRegistration
{
  Concurrency::details::_Task_impl_base::_RegisterCancellation::__l2::&lt;lambda_be3e5d9dce35d2c8dbfa8485373731d5&gt; _M_function;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokencallback-lambda-be3e5d9dce35d2c8dbfa8485373731d5-vtbl"><a href="#concurrency-details-cancellationtokencallback-lambda-be3e5d9dce35d2c8dbfa8485373731d5-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_be3e5d9dce35d2c8dbfa8485373731d5&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_be3e5d9dce35d2c8dbfa8485373731d5&gt; &gt;_vtbl
{
  void (__fastcall *~_RefCounter)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Exec)(Concurrency::details::_CancellationTokenRegistration *this);
};

</code></pre></div><h3 id="concurrency-details-typeselectorasyncaction"><a href="#concurrency-details-typeselectorasyncaction" class="header-anchor">#</a> <code>Concurrency::details::_TypeSelectorAsyncAction</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TypeSelectorAsyncAction
{
};

</code></pre></div><h3 id="concurrency-details-interruption-exception"><a href="#concurrency-details-interruption-exception" class="header-anchor">#</a> <code>Concurrency::details::_Interruption_exception</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Interruption_exception : std::exception
{
};

</code></pre></div><h3 id="concurrency-details-interruption-exception-vtbl"><a href="#concurrency-details-interruption-exception-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_Interruption_exception_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_Interruption_exception_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-details-resultholder-unsigned-char"><a href="#concurrency-details-resultholder-unsigned-char" class="header-anchor">#</a> <code>Concurrency::details::_ResultHolder&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct Concurrency::details::_ResultHolder&lt;unsigned char&gt;
{
  unsigned __int8 _Result;
};

</code></pre></div><h3 id="concurrency-details-task-impl-unsigned-char"><a href="#concurrency-details-task-impl-unsigned-char" class="header-anchor">#</a> <code>Concurrency::details::_Task_impl&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Task_impl&lt;unsigned char&gt; : Concurrency::details::_Task_impl_base
{
  Concurrency::details::_ResultHolder&lt;unsigned char&gt; _M_Result;
  std::function&lt;void __cdecl(void)&gt; _M_InternalCancellation;
};

</code></pre></div><h3 id="concurrency-details-task-impl-unsigned-char-vtbl"><a href="#concurrency-details-task-impl-unsigned-char-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_Task_impl&lt;unsigned char&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_Task_impl&lt;unsigned char&gt;_vtbl
{
  void (__fastcall *~_Task_impl_base)(Concurrency::details::_Task_impl_base *this);
  bool (__fastcall *_CancelAndRunContinuations)(Concurrency::details::_Task_impl_base *this, bool, bool, bool, const std::shared_ptr&lt;Concurrency::details::_ExceptionHolder&gt; *);
};

</code></pre></div><h3 id="concurrency-details-task-completion-event-impl-unsigned-char"><a href="#concurrency-details-task-completion-event-impl-unsigned-char" class="header-anchor">#</a> <code>Concurrency::details::_Task_completion_event_impl&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::details::_Task_completion_event_impl&lt;unsigned char&gt;
{
  std::vector&lt;std::shared_ptr&lt;Concurrency::details::_Task_impl&lt;unsigned char&gt; &gt;&gt; _M_tasks;
  std::mutex _M_taskListCritSec;
  Concurrency::details::_ResultHolder&lt;unsigned char&gt; _M_value;
  std::shared_ptr&lt;Concurrency::details::_ExceptionHolder&gt; _M_exceptionHolder;
  bool _M_fHasValue;
  bool _M_fIsCanceled;
};

</code></pre></div><h3 id="concurrency-details-taskprocthunk"><a href="#concurrency-details-taskprocthunk" class="header-anchor">#</a> <code>Concurrency::details::_TaskProcThunk</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TaskProcThunk
{
  std::function&lt;void __cdecl(void)&gt; _M_func;
};

</code></pre></div><h3 id="concurrency-details-taskprocthunk-holder"><a href="#concurrency-details-taskprocthunk-holder" class="header-anchor">#</a> <code>Concurrency::details::_TaskProcThunk::_Holder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TaskProcThunk::_Holder
{
  Concurrency::details::_TaskProcThunk *_M_pThunk;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokenregistration-taskproc"><a href="#concurrency-details-cancellationtokenregistration-taskproc" class="header-anchor">#</a> <code>Concurrency::details::CancellationTokenRegistration_TaskProc</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::CancellationTokenRegistration_TaskProc : Concurrency::details::_CancellationTokenRegistration
{
  void (__fastcall *_M_proc)(void *);
  void *_M_pData;
};

</code></pre></div><h3 id="concurrency-details-cancellationtokenregistration-taskproc-vtbl"><a href="#concurrency-details-cancellationtokenregistration-taskproc-vtbl" class="header-anchor">#</a> <code>Concurrency::details::CancellationTokenRegistration_TaskProc_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::CancellationTokenRegistration_TaskProc_vtbl
{
  void (__fastcall *~_RefCounter)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Exec)(Concurrency::details::_CancellationTokenRegistration *this);
};

</code></pre></div><h3 id="concurrency-details-taskworkitemraiilogger"><a href="#concurrency-details-taskworkitemraiilogger" class="header-anchor">#</a> <code>Concurrency::details::_TaskWorkItemRAIILogger</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TaskWorkItemRAIILogger
{
  Concurrency::details::_TaskEventLogger *_M_logger;
};

</code></pre></div><h3 id="concurrency-details-scheduler"><a href="#concurrency-details-scheduler" class="header-anchor">#</a> <code>Concurrency::details::_Scheduler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Scheduler
{
  Concurrency::Scheduler *_M_pScheduler;
};

</code></pre></div><h3 id="concurrency-details-thenimploptions"><a href="#concurrency-details-thenimploptions" class="header-anchor">#</a> <code>Concurrency::details::_ThenImplOptions</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ThenImplOptions
{
  Concurrency::details::_CancellationTokenState *_PTokenState;
  Concurrency::scheduler_ptr _Scheduler;
  Concurrency::details::_TaskCreationCallstack _CreationStack;
  Concurrency::details::_TaskInliningMode _InliningMode;
  Concurrency::task_continuation_context *_PContinuationContext;
};

</code></pre></div><h3 id="concurrency-details-reentrantppllock"><a href="#concurrency-details-reentrantppllock" class="header-anchor">#</a> <code>Concurrency::details::_ReentrantPPLLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReentrantPPLLock
{
  Concurrency::critical_section _M_criticalSection;
  int _M_recursionCount;
  volatile int _M_owner;
};

</code></pre></div><h3 id="concurrency-details-reentrantppllock-scoped-lock"><a href="#concurrency-details-reentrantppllock-scoped-lock" class="header-anchor">#</a> <code>Concurrency::details::_ReentrantPPLLock::_Scoped_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReentrantPPLLock::_Scoped_lock
{
  Concurrency::details::_ReentrantPPLLock *_M_lock;
  void *_M_lockNode[5];
};

</code></pre></div><h3 id="concurrency-details-tasktypefromparam-concurrency-task-completion-event-void"><a href="#concurrency-details-tasktypefromparam-concurrency-task-completion-event-void" class="header-anchor">#</a> <code>Concurrency::details::_TaskTypeFromParam&lt;Concurrency::task_completion_event&lt;void&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TaskTypeFromParam&lt;Concurrency::task_completion_event&lt;void&gt; &gt;
{
};

</code></pre></div><h3 id="concurrency-details-isunwrappedasyncselector-concurrency-details-typeselectornoasync"><a href="#concurrency-details-isunwrappedasyncselector-concurrency-details-typeselectornoasync" class="header-anchor">#</a> <code>Concurrency::details::_IsUnwrappedAsyncSelector&lt;Concurrency::details::_TypeSelectorNoAsync&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_IsUnwrappedAsyncSelector&lt;Concurrency::details::_TypeSelectorNoAsync&gt;
{
};

</code></pre></div><h3 id="concurrency-details-context"><a href="#concurrency-details-context" class="header-anchor">#</a> <code>Concurrency::details::_Context</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Context
{
  Concurrency::Context *_M_pContext;
};

</code></pre></div><h3 id="concurrency-details-badargtype"><a href="#concurrency-details-badargtype" class="header-anchor">#</a> <code>Concurrency::details::_BadArgType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_BadArgType
{
};

</code></pre></div><h3 id="concurrency-details-spincount"><a href="#concurrency-details-spincount" class="header-anchor">#</a> <code>Concurrency::details::_SpinCount</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_SpinCount
{
};

</code></pre></div><h3 id="concurrency-task-completion-event-unsigned-char"><a href="#concurrency-task-completion-event-unsigned-char" class="header-anchor">#</a> <code>Concurrency::task_completion_event&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::task_completion_event&lt;unsigned char&gt;
{
  std::shared_ptr&lt;Concurrency::details::_Task_completion_event_impl&lt;unsigned char&gt; &gt; _M_Impl;
};

</code></pre></div><h3 id="concurrency-details-runallparam-unsigned-char"><a href="#concurrency-details-runallparam-unsigned-char" class="header-anchor">#</a> <code>Concurrency::details::_RunAllParam&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_RunAllParam&lt;unsigned char&gt;
{
  Concurrency::task_completion_event&lt;unsigned char&gt; _M_completed;
  std::atomic&lt;unsigned __int64&gt; _M_completeCount;
  unsigned __int64 _M_numTasks;
};

</code></pre></div><h3 id="concurrency-details-threadpool-chore"><a href="#concurrency-details-threadpool-chore" class="header-anchor">#</a> <code>Concurrency::details::_Threadpool_chore</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Threadpool_chore
{
  void *_M_work;
  void (__fastcall *_M_callback)(void *);
  void *_M_data;
};

</code></pre></div><h3 id="concurrency-details-defaultppltaskscheduler-ppltaskchore"><a href="#concurrency-details-defaultppltaskscheduler-ppltaskchore" class="header-anchor">#</a> <code>Concurrency::details::_DefaultPPLTaskScheduler::_PPLTaskChore</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_DefaultPPLTaskScheduler::_PPLTaskChore
{
  Concurrency::details::_Threadpool_chore _M_Chore;
  void (__fastcall *_M_proc)(void *);
  void *_M_param;
};

</code></pre></div><h3 id="concurrency-details-defaultppltaskscheduler-vtbl"><a href="#concurrency-details-defaultppltaskscheduler-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_DefaultPPLTaskScheduler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_DefaultPPLTaskScheduler_vtbl
{
  void (__fastcall *schedule)(Concurrency::scheduler_interface *this, void (__fastcall *)(void *), void *);
};

</code></pre></div><h3 id="concurrency-details-threadpool-task"><a href="#concurrency-details-threadpool-task" class="header-anchor">#</a> <code>Concurrency::details::_Threadpool_task</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Threadpool_task
{
  Concurrency::details::_Threadpool_task_vtbl *__vftable /*VFT*/;
  Concurrency::details::_Threadpool_chore _M_chore;
};

</code></pre></div><h3 id="concurrency-details-threadpool-task-vtbl"><a href="#concurrency-details-threadpool-task-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_Threadpool_task_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_Threadpool_task_vtbl
{
  void (__fastcall *_Invoke)(Concurrency::details::_Threadpool_task *this);
  void (__fastcall *~_Threadpool_task)(Concurrency::details::_Threadpool_task *this);
};

</code></pre></div><h3 id="concurrency-details-typeselectorasyncoperationortask"><a href="#concurrency-details-typeselectorasyncoperationortask" class="header-anchor">#</a> <code>Concurrency::details::_TypeSelectorAsyncOperationOrTask</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TypeSelectorAsyncOperationOrTask
{
};

</code></pre></div><h3 id="concurrency-details-typeselectorasynctask"><a href="#concurrency-details-typeselectorasynctask" class="header-anchor">#</a> <code>Concurrency::details::_TypeSelectorAsyncTask</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TypeSelectorAsyncTask : Concurrency::details::_TypeSelectorAsyncOperationOrTask
{
};

</code></pre></div><h3 id="concurrency-details-currentscheduler"><a href="#concurrency-details-currentscheduler" class="header-anchor">#</a> <code>Concurrency::details::_CurrentScheduler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_CurrentScheduler
{
};

</code></pre></div><h3 id="concurrency-details-task-ptr-unsigned-int64"><a href="#concurrency-details-task-ptr-unsigned-int64" class="header-anchor">#</a> <code>Concurrency::details::_Task_ptr&lt;unsigned __int64&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Task_ptr&lt;unsigned __int64&gt;
{
};

</code></pre></div><h3 id="concurrency-details-task-ptr-unsigned-char"><a href="#concurrency-details-task-ptr-unsigned-char" class="header-anchor">#</a> <code>Concurrency::details::_Task_ptr&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Task_ptr&lt;unsigned char&gt;
{
};

</code></pre></div><h3 id="concurrency-details-resultholder-std-vector-bool"><a href="#concurrency-details-resultholder-std-vector-bool" class="header-anchor">#</a> <code>Concurrency::details::_ResultHolder&lt;std::vector&lt;bool&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ResultHolder&lt;std::vector&lt;bool&gt; &gt;
{
  std::vector&lt;char&gt; _Result;
};

</code></pre></div><h3 id="concurrency-details-reentrantlock"><a href="#concurrency-details-reentrantlock" class="header-anchor">#</a> <code>Concurrency::details::_ReentrantLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReentrantLock
{
  int _M_recursionCount;
  volatile int _M_owner;
};

</code></pre></div><h3 id="concurrency-details-reentrantlock-scoped-lock"><a href="#concurrency-details-reentrantlock-scoped-lock" class="header-anchor">#</a> <code>Concurrency::details::_ReentrantLock::_Scoped_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReentrantLock::_Scoped_lock
{
  Concurrency::details::_ReentrantLock *_M_lock;
};

</code></pre></div><h3 id="concurrency-details-spinlock"><a href="#concurrency-details-spinlock" class="header-anchor">#</a> <code>Concurrency::details::_SpinLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_SpinLock
{
  volatile int *_M_flag;
};

</code></pre></div><h3 id="concurrency-details-normalizevoidtounittype-void"><a href="#concurrency-details-normalizevoidtounittype-void" class="header-anchor">#</a> <code>Concurrency::details::_NormalizeVoidToUnitType&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_NormalizeVoidToUnitType&lt;void&gt;
{
};

</code></pre></div><h3 id="concurrency-details-typeselectornoasync"><a href="#concurrency-details-typeselectornoasync" class="header-anchor">#</a> <code>Concurrency::details::_TypeSelectorNoAsync</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TypeSelectorNoAsync
{
};

</code></pre></div><h3 id="concurrency-details-concrt-trace-info"><a href="#concurrency-details-concrt-trace-info" class="header-anchor">#</a> <code>Concurrency::details::_CONCRT_TRACE_INFO</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) Concurrency::details::_CONCRT_TRACE_INFO
{
  volatile unsigned int EnableFlags;
  volatile unsigned __int8 EnableLevel;
};

</code></pre></div><h3 id="concurrency-details-timer"><a href="#concurrency-details-timer" class="header-anchor">#</a> <code>Concurrency::details::_Timer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) Concurrency::details::_Timer
{
  Concurrency::details::_Timer_vtbl *__vftable /*VFT*/;
  void *_M_hTimer;
  unsigned int _M_ms;
  bool _M_fRepeating;
};

</code></pre></div><h3 id="concurrency-details-timer-vtbl"><a href="#concurrency-details-timer-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_Timer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_Timer_vtbl
{
  void (__fastcall *~_Timer)(Concurrency::details::_Timer *this);
  void (__fastcall *_Fire)(Concurrency::details::_Timer *this);
};

</code></pre></div><h3 id="concurrency-details-tasktypetraits-void-0"><a href="#concurrency-details-tasktypetraits-void-0" class="header-anchor">#</a> <code>Concurrency::details::_TaskTypeTraits&lt;void,0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TaskTypeTraits&lt;void,0&gt;
{
};

</code></pre></div><h3 id="concurrency-details-structuredtaskcollection"><a href="#concurrency-details-structuredtaskcollection" class="header-anchor">#</a> <code>Concurrency::details::_StructuredTaskCollection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_StructuredTaskCollection : Concurrency::details::_TaskCollectionBase
{
  void *_M_event[1];
};

</code></pre></div><h3 id="concurrency-details-cancellationtokencallback-lambda-cef198b90b48c5c98bd59f7c1dcac0b2"><a href="#concurrency-details-cancellationtokencallback-lambda-cef198b90b48c5c98bd59f7c1dcac0b2" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_cef198b90b48c5c98bd59f7c1dcac0b2&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_cef198b90b48c5c98bd59f7c1dcac0b2&gt; &gt; : Concurrency::details::_CancellationTokenRegistration
{
  struct Concurrency::cancellation_token_source::create_linked_source::__l2::&lt;lambda_cef198b90b48c5c98bd59f7c1dcac0b2&gt; _M_function;
  _BYTE gapC0[8];
};

</code></pre></div><h3 id="concurrency-details-cancellationtokencallback-lambda-cef198b90b48c5c98bd59f7c1dcac0b2-vtbl"><a href="#concurrency-details-cancellationtokencallback-lambda-cef198b90b48c5c98bd59f7c1dcac0b2-vtbl" class="header-anchor">#</a> <code>Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_cef198b90b48c5c98bd59f7c1dcac0b2&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::details::_CancellationTokenCallback&lt;&lt;lambda_cef198b90b48c5c98bd59f7c1dcac0b2&gt; &gt;_vtbl
{
  void (__fastcall *~_RefCounter)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Destroy)(Concurrency::details::_RefCounter *this);
  void (__fastcall *_Exec)(Concurrency::details::_CancellationTokenRegistration *this);
};

</code></pre></div><h3 id="concurrency-details-readerwriterlock"><a href="#concurrency-details-readerwriterlock" class="header-anchor">#</a> <code>Concurrency::details::_ReaderWriterLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReaderWriterLock
{
  volatile int _M_state;
  volatile int _M_numberOfWriters;
};

</code></pre></div><h3 id="concurrency-details-readerwriterlock-scoped-lock"><a href="#concurrency-details-readerwriterlock-scoped-lock" class="header-anchor">#</a> <code>Concurrency::details::_ReaderWriterLock::_Scoped_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReaderWriterLock::_Scoped_lock
{
  Concurrency::details::_ReaderWriterLock *_M_lock;
};

</code></pre></div><h3 id="concurrency-details-readerwriterlock-scoped-lock-read"><a href="#concurrency-details-readerwriterlock-scoped-lock-read" class="header-anchor">#</a> <code>Concurrency::details::_ReaderWriterLock::_Scoped_lock_read</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReaderWriterLock::_Scoped_lock_read
{
  Concurrency::details::_ReaderWriterLock *_M_lock;
};

</code></pre></div><h3 id="concurrency-details-badcontinuationparamtype"><a href="#concurrency-details-badcontinuationparamtype" class="header-anchor">#</a> <code>Concurrency::details::_BadContinuationParamType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_BadContinuationParamType
{
};

</code></pre></div><h3 id="concurrency-details-defaulttaskhelper"><a href="#concurrency-details-defaulttaskhelper" class="header-anchor">#</a> <code>Concurrency::details::_DefaultTaskHelper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_DefaultTaskHelper
{
};

</code></pre></div><h3 id="concurrency-details-nonreentrantppllock"><a href="#concurrency-details-nonreentrantppllock" class="header-anchor">#</a> <code>Concurrency::details::_NonReentrantPPLLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_NonReentrantPPLLock
{
  Concurrency::critical_section _M_criticalSection;
};

</code></pre></div><h3 id="concurrency-details-nonreentrantppllock-scoped-lock"><a href="#concurrency-details-nonreentrantppllock-scoped-lock" class="header-anchor">#</a> <code>Concurrency::details::_NonReentrantPPLLock::_Scoped_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_NonReentrantPPLLock::_Scoped_lock
{
  Concurrency::details::_NonReentrantPPLLock *_M_lock;
  void *_M_lockNode[5];
};

</code></pre></div><h3 id="concurrency-details-stackguard"><a href="#concurrency-details-stackguard" class="header-anchor">#</a> <code>Concurrency::details::_StackGuard</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_StackGuard
{
  unsigned __int64 *_Depth;
};

</code></pre></div><h3 id="concurrency-details-subatomic-impl-4"><a href="#concurrency-details-subatomic-impl-4" class="header-anchor">#</a> <code>Concurrency::details::_Subatomic_impl&lt;4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Subatomic_impl&lt;4&gt;
{
};

</code></pre></div><h3 id="concurrency-details-reentrantblockinglock"><a href="#concurrency-details-reentrantblockinglock" class="header-anchor">#</a> <code>Concurrency::details::_ReentrantBlockingLock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReentrantBlockingLock
{
  void *_M_criticalSection[5];
};

</code></pre></div><h3 id="concurrency-details-reentrantblockinglock-scoped-lock"><a href="#concurrency-details-reentrantblockinglock-scoped-lock" class="header-anchor">#</a> <code>Concurrency::details::_ReentrantBlockingLock::_Scoped_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ReentrantBlockingLock::_Scoped_lock
{
  Concurrency::details::_ReentrantBlockingLock *_M_lock;
};

</code></pre></div><h3 id="concurrency-details-subatomic-impl-8"><a href="#concurrency-details-subatomic-impl-8" class="header-anchor">#</a> <code>Concurrency::details::_Subatomic_impl&lt;8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Subatomic_impl&lt;8&gt;
{
};

</code></pre></div><h3 id="concurrency-details-typeselectorasyncoperationwithprogress"><a href="#concurrency-details-typeselectorasyncoperationwithprogress" class="header-anchor">#</a> <code>Concurrency::details::_TypeSelectorAsyncOperationWithProgress</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TypeSelectorAsyncOperationWithProgress
{
};

</code></pre></div><h3 id="concurrency-details-progressreporterctorargtype"><a href="#concurrency-details-progressreporterctorargtype" class="header-anchor">#</a> <code>Concurrency::details::_ProgressReporterCtorArgType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_ProgressReporterCtorArgType
{
};

</code></pre></div><h3 id="concurrency-details-typeselectorasyncoperation"><a href="#concurrency-details-typeselectorasyncoperation" class="header-anchor">#</a> <code>Concurrency::details::_TypeSelectorAsyncOperation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TypeSelectorAsyncOperation : Concurrency::details::_TypeSelectorAsyncOperationOrTask
{
};

</code></pre></div><h3 id="concurrency-details-typeselectorasyncactionwithprogress"><a href="#concurrency-details-typeselectorasyncactionwithprogress" class="header-anchor">#</a> <code>Concurrency::details::_TypeSelectorAsyncActionWithProgress</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_TypeSelectorAsyncActionWithProgress
{
};

</code></pre></div><h3 id="concurrency-improper-scheduler-reference"><a href="#concurrency-improper-scheduler-reference" class="header-anchor">#</a> <code>Concurrency::improper_scheduler_reference</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::improper_scheduler_reference : std::exception
{
};

</code></pre></div><h3 id="concurrency-improper-scheduler-reference-vtbl"><a href="#concurrency-improper-scheduler-reference-vtbl" class="header-anchor">#</a> <code>Concurrency::improper_scheduler_reference_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::improper_scheduler_reference_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-auto-partitioner"><a href="#concurrency-auto-partitioner" class="header-anchor">#</a> <code>Concurrency::auto_partitioner</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::auto_partitioner
{
};

</code></pre></div><h3 id="concurrency-simple-partitioner"><a href="#concurrency-simple-partitioner" class="header-anchor">#</a> <code>Concurrency::simple_partitioner</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::simple_partitioner
{
  unsigned __int64 _M_chunk_size;
};

</code></pre></div><h3 id="concurrency-task-group"><a href="#concurrency-task-group" class="header-anchor">#</a> <code>Concurrency::task_group</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::task_group
{
  Concurrency::details::_TaskCollection _M_task_collection;
};

</code></pre></div><h3 id="concurrency-currentscheduler"><a href="#concurrency-currentscheduler" class="header-anchor">#</a> <code>Concurrency::CurrentScheduler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::CurrentScheduler
{
};

</code></pre></div><h3 id="concurrency-binary-transform-impl-helper-std-random-access-iterator-tag-std-random-access-iterator-tag-std-random-access-iterator-tag"><a href="#concurrency-binary-transform-impl-helper-std-random-access-iterator-tag-std-random-access-iterator-tag-std-random-access-iterator-tag" class="header-anchor">#</a> <code>Concurrency::_Binary_transform_impl_helper&lt;std::random_access_iterator_tag,std::random_access_iterator_tag,std::random_access_iterator_tag&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::_Binary_transform_impl_helper&lt;std::random_access_iterator_tag,std::random_access_iterator_tag,std::random_access_iterator_tag&gt;
{
};

</code></pre></div><h3 id="concurrency-init-func-transformer-void"><a href="#concurrency-init-func-transformer-void" class="header-anchor">#</a> <code>Concurrency::_Init_func_transformer&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::_Init_func_transformer&lt;void&gt;
{
};

</code></pre></div><h3 id="concurrency-continuation-func-transformer-void-void"><a href="#concurrency-continuation-func-transformer-void-void" class="header-anchor">#</a> <code>Concurrency::_Continuation_func_transformer&lt;void,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::_Continuation_func_transformer&lt;void,void&gt;
{
};

</code></pre></div><h3 id="concurrency-bad-target"><a href="#concurrency-bad-target" class="header-anchor">#</a> <code>Concurrency::bad_target</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::bad_target : std::exception
{
};

</code></pre></div><h3 id="concurrency-bad-target-vtbl"><a href="#concurrency-bad-target-vtbl" class="header-anchor">#</a> <code>Concurrency::bad_target_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::bad_target_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-invalid-oversubscribe-operation"><a href="#concurrency-invalid-oversubscribe-operation" class="header-anchor">#</a> <code>Concurrency::invalid_oversubscribe_operation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::invalid_oversubscribe_operation : std::exception
{
};

</code></pre></div><h3 id="concurrency-invalid-oversubscribe-operation-vtbl"><a href="#concurrency-invalid-oversubscribe-operation-vtbl" class="header-anchor">#</a> <code>Concurrency::invalid_oversubscribe_operation_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::invalid_oversubscribe_operation_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-task-unsigned-int64"><a href="#concurrency-task-unsigned-int64" class="header-anchor">#</a> <code>Concurrency::task&lt;unsigned __int64&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::task&lt;unsigned __int64&gt;
{
  std::shared_ptr&lt;Concurrency::details::_Task_impl&lt;unsigned __int64&gt; &gt; _M_Impl;
};

</code></pre></div><h3 id="concurrency-unsupported-os"><a href="#concurrency-unsupported-os" class="header-anchor">#</a> <code>Concurrency::unsupported_os</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::unsupported_os : std::exception
{
};

</code></pre></div><h3 id="concurrency-unsupported-os-vtbl"><a href="#concurrency-unsupported-os-vtbl" class="header-anchor">#</a> <code>Concurrency::unsupported_os_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::unsupported_os_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-scheduler-not-attached"><a href="#concurrency-scheduler-not-attached" class="header-anchor">#</a> <code>Concurrency::scheduler_not_attached</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::scheduler_not_attached : std::exception
{
};

</code></pre></div><h3 id="concurrency-scheduler-not-attached-vtbl"><a href="#concurrency-scheduler-not-attached-vtbl" class="header-anchor">#</a> <code>Concurrency::scheduler_not_attached_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::scheduler_not_attached_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-invalid-link-target"><a href="#concurrency-invalid-link-target" class="header-anchor">#</a> <code>Concurrency::invalid_link_target</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::invalid_link_target : std::exception
{
};

</code></pre></div><h3 id="concurrency-invalid-link-target-vtbl"><a href="#concurrency-invalid-link-target-vtbl" class="header-anchor">#</a> <code>Concurrency::invalid_link_target_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::invalid_link_target_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-cancellation-token-registration"><a href="#concurrency-cancellation-token-registration" class="header-anchor">#</a> <code>Concurrency::cancellation_token_registration</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::cancellation_token_registration
{
  Concurrency::details::_CancellationTokenRegistration *_M_pRegistration;
};

</code></pre></div><h3 id="concurrency-invalid-scheduler-policy-thread-specification"><a href="#concurrency-invalid-scheduler-policy-thread-specification" class="header-anchor">#</a> <code>Concurrency::invalid_scheduler_policy_thread_specification</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::invalid_scheduler_policy_thread_specification : std::exception
{
};

</code></pre></div><h3 id="concurrency-invalid-scheduler-policy-thread-specification-vtbl"><a href="#concurrency-invalid-scheduler-policy-thread-specification-vtbl" class="header-anchor">#</a> <code>Concurrency::invalid_scheduler_policy_thread_specification_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::invalid_scheduler_policy_thread_specification_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-cancellation-token-source"><a href="#concurrency-cancellation-token-source" class="header-anchor">#</a> <code>Concurrency::cancellation_token_source</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::cancellation_token_source
{
  Concurrency::details::_CancellationTokenState *_M_Impl;
};

</code></pre></div><h3 id="concurrency-structured-task-group"><a href="#concurrency-structured-task-group" class="header-anchor">#</a> <code>Concurrency::structured_task_group</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::structured_task_group
{
  Concurrency::details::_StructuredTaskCollection _M_task_collection;
};

</code></pre></div><h3 id="concurrency-invalid-multiple-scheduling"><a href="#concurrency-invalid-multiple-scheduling" class="header-anchor">#</a> <code>Concurrency::invalid_multiple_scheduling</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::invalid_multiple_scheduling : std::exception
{
};

</code></pre></div><h3 id="concurrency-invalid-multiple-scheduling-vtbl"><a href="#concurrency-invalid-multiple-scheduling-vtbl" class="header-anchor">#</a> <code>Concurrency::invalid_multiple_scheduling_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::invalid_multiple_scheduling_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-static-partitioner"><a href="#concurrency-static-partitioner" class="header-anchor">#</a> <code>Concurrency::static_partitioner</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::static_partitioner
{
};

</code></pre></div><h3 id="concurrency-task-unsigned-char"><a href="#concurrency-task-unsigned-char" class="header-anchor">#</a> <code>Concurrency::task&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::task&lt;unsigned char&gt;
{
  std::shared_ptr&lt;Concurrency::details::_Task_impl&lt;unsigned char&gt; &gt; _M_Impl;
};

</code></pre></div><h3 id="concurrency-task-void"><a href="#concurrency-task-void" class="header-anchor">#</a> <code>Concurrency::task&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::task&lt;void&gt;
{
  Concurrency::task&lt;unsigned char&gt; _M_unitTask;
};

</code></pre></div><h3 id="concurrency-task-completion-event-void"><a href="#concurrency-task-completion-event-void" class="header-anchor">#</a> <code>Concurrency::task_completion_event&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::task_completion_event&lt;void&gt;
{
  Concurrency::task_completion_event&lt;unsigned char&gt; _M_unitEvent;
};

</code></pre></div><h3 id="concurrency-operation-timed-out"><a href="#concurrency-operation-timed-out" class="header-anchor">#</a> <code>Concurrency::operation_timed_out</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::operation_timed_out : std::exception
{
};

</code></pre></div><h3 id="concurrency-operation-timed-out-vtbl"><a href="#concurrency-operation-timed-out-vtbl" class="header-anchor">#</a> <code>Concurrency::operation_timed_out_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::operation_timed_out_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-invalid-scheduler-policy-value"><a href="#concurrency-invalid-scheduler-policy-value" class="header-anchor">#</a> <code>Concurrency::invalid_scheduler_policy_value</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::invalid_scheduler_policy_value : std::exception
{
};

</code></pre></div><h3 id="concurrency-invalid-scheduler-policy-value-vtbl"><a href="#concurrency-invalid-scheduler-policy-value-vtbl" class="header-anchor">#</a> <code>Concurrency::invalid_scheduler_policy_value_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::invalid_scheduler_policy_value_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-task-canceled"><a href="#concurrency-task-canceled" class="header-anchor">#</a> <code>Concurrency::task_canceled</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::task_canceled : std::exception
{
};

</code></pre></div><h3 id="concurrency-task-canceled-vtbl"><a href="#concurrency-task-canceled-vtbl" class="header-anchor">#</a> <code>Concurrency::task_canceled_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::task_canceled_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-context-self-unblock"><a href="#concurrency-context-self-unblock" class="header-anchor">#</a> <code>Concurrency::context_self_unblock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::context_self_unblock : std::exception
{
};

</code></pre></div><h3 id="concurrency-context-self-unblock-vtbl"><a href="#concurrency-context-self-unblock-vtbl" class="header-anchor">#</a> <code>Concurrency::context_self_unblock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::context_self_unblock_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-nested-scheduler-missing-detach"><a href="#concurrency-nested-scheduler-missing-detach" class="header-anchor">#</a> <code>Concurrency::nested_scheduler_missing_detach</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::nested_scheduler_missing_detach : std::exception
{
};

</code></pre></div><h3 id="concurrency-nested-scheduler-missing-detach-vtbl"><a href="#concurrency-nested-scheduler-missing-detach-vtbl" class="header-anchor">#</a> <code>Concurrency::nested_scheduler_missing_detach_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::nested_scheduler_missing_detach_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-missing-wait"><a href="#concurrency-missing-wait" class="header-anchor">#</a> <code>Concurrency::missing_wait</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::missing_wait : std::exception
{
};

</code></pre></div><h3 id="concurrency-missing-wait-vtbl"><a href="#concurrency-missing-wait-vtbl" class="header-anchor">#</a> <code>Concurrency::missing_wait_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::missing_wait_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-task-continuation-context-tag"><a href="#concurrency-task-continuation-context-tag" class="header-anchor">#</a> <code>Concurrency::task_continuation_context::_Tag</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::task_continuation_context::_Tag
{
};

</code></pre></div><h3 id="concurrency-invalid-scheduler-policy-key"><a href="#concurrency-invalid-scheduler-policy-key" class="header-anchor">#</a> <code>Concurrency::invalid_scheduler_policy_key</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::invalid_scheduler_policy_key : std::exception
{
};

</code></pre></div><h3 id="concurrency-invalid-scheduler-policy-key-vtbl"><a href="#concurrency-invalid-scheduler-policy-key-vtbl" class="header-anchor">#</a> <code>Concurrency::invalid_scheduler_policy_key_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::invalid_scheduler_policy_key_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-unary-transform-impl-helper-std-random-access-iterator-tag-std-random-access-iterator-tag"><a href="#concurrency-unary-transform-impl-helper-std-random-access-iterator-tag-std-random-access-iterator-tag" class="header-anchor">#</a> <code>Concurrency::_Unary_transform_impl_helper&lt;std::random_access_iterator_tag,std::random_access_iterator_tag&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::_Unary_transform_impl_helper&lt;std::random_access_iterator_tag,std::random_access_iterator_tag&gt;
{
};

</code></pre></div><h3 id="concurrency-improper-lock"><a href="#concurrency-improper-lock" class="header-anchor">#</a> <code>Concurrency::improper_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::improper_lock : std::exception
{
};

</code></pre></div><h3 id="concurrency-improper-lock-vtbl"><a href="#concurrency-improper-lock-vtbl" class="header-anchor">#</a> <code>Concurrency::improper_lock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::improper_lock_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-default-scheduler-exists"><a href="#concurrency-default-scheduler-exists" class="header-anchor">#</a> <code>Concurrency::default_scheduler_exists</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::default_scheduler_exists : std::exception
{
};

</code></pre></div><h3 id="concurrency-default-scheduler-exists-vtbl"><a href="#concurrency-default-scheduler-exists-vtbl" class="header-anchor">#</a> <code>Concurrency::default_scheduler_exists_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::default_scheduler_exists_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-improper-scheduler-attach"><a href="#concurrency-improper-scheduler-attach" class="header-anchor">#</a> <code>Concurrency::improper_scheduler_attach</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::improper_scheduler_attach : std::exception
{
};

</code></pre></div><h3 id="concurrency-improper-scheduler-attach-vtbl"><a href="#concurrency-improper-scheduler-attach-vtbl" class="header-anchor">#</a> <code>Concurrency::improper_scheduler_attach_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::improper_scheduler_attach_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-context-unblock-unbalanced"><a href="#concurrency-context-unblock-unbalanced" class="header-anchor">#</a> <code>Concurrency::context_unblock_unbalanced</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::context_unblock_unbalanced : std::exception
{
};

</code></pre></div><h3 id="concurrency-context-unblock-unbalanced-vtbl"><a href="#concurrency-context-unblock-unbalanced-vtbl" class="header-anchor">#</a> <code>Concurrency::context_unblock_unbalanced_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::context_unblock_unbalanced_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-improper-scheduler-detach"><a href="#concurrency-improper-scheduler-detach" class="header-anchor">#</a> <code>Concurrency::improper_scheduler_detach</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::improper_scheduler_detach : std::exception
{
};

</code></pre></div><h3 id="concurrency-improper-scheduler-detach-vtbl"><a href="#concurrency-improper-scheduler-detach-vtbl" class="header-anchor">#</a> <code>Concurrency::improper_scheduler_detach_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::improper_scheduler_detach_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-reader-writer-lock"><a href="#concurrency-reader-writer-lock" class="header-anchor">#</a> <code>Concurrency::reader_writer_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Concurrency::reader_writer_lock
{
  void *_M_activeWriter[5];
  void *_M_pReaderHead;
  void *_M_pWriterHead;
  void *_M_pWriterTail;
  volatile int _M_lockState;
};

</code></pre></div><h3 id="concurrency-reader-writer-lock-scoped-lock"><a href="#concurrency-reader-writer-lock-scoped-lock" class="header-anchor">#</a> <code>Concurrency::reader_writer_lock::scoped_lock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::reader_writer_lock::scoped_lock
{
  Concurrency::reader_writer_lock *_M_reader_writer_lock;
  void *_M_writerNode[5];
};

</code></pre></div><h3 id="concurrency-reader-writer-lock-scoped-lock-read"><a href="#concurrency-reader-writer-lock-scoped-lock-read" class="header-anchor">#</a> <code>Concurrency::reader_writer_lock::scoped_lock_read</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::reader_writer_lock::scoped_lock_read
{
  Concurrency::reader_writer_lock *_M_reader_writer_lock;
};

</code></pre></div><h3 id="concurrency-invalid-operation-vtbl"><a href="#concurrency-invalid-operation-vtbl" class="header-anchor">#</a> <code>Concurrency::invalid_operation_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Concurrency::invalid_operation_vtbl
{
  void (__fastcall *~exception)(std::exception *this);
  const char *(__fastcall *what)(std::exception *this);
};

</code></pre></div><h3 id="concurrency-affinity-partitioner"><a href="#concurrency-affinity-partitioner" class="header-anchor">#</a> <code>Concurrency::affinity_partitioner</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::affinity_partitioner
{
  unsigned int _M_num_chunks;
  Concurrency::location *_M_pChunk_locations;
};

</code></pre></div><h3 id="concurrency-details-task-impl-unsigned-char-cancelandruncontinuations-l34-lambda-763529b0c7473cbc215a52d189ac9b18"><a href="#concurrency-details-task-impl-unsigned-char-cancelandruncontinuations-l34-lambda-763529b0c7473cbc215a52d189ac9b18" class="header-anchor">#</a> <code>Concurrency::details::_Task_impl&lt;unsigned char&gt;::_CancelAndRunContinuations::__l34::&lt;lambda_763529b0c7473cbc215a52d189ac9b18&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Task_impl&lt;unsigned char&gt;::_CancelAndRunContinuations::__l34::&lt;lambda_763529b0c7473cbc215a52d189ac9b18&gt;
{
  Concurrency::details::_Task_impl&lt;unsigned char&gt; *const __this;
};

</code></pre></div><h3 id="concurrency-details-task-impl-base-schedulecontinuationtask-l5-lambda-713ee8bbd6b08550d59c52695cab5ce3"><a href="#concurrency-details-task-impl-base-schedulecontinuationtask-l5-lambda-713ee8bbd6b08550d59c52695cab5ce3" class="header-anchor">#</a> <code>Concurrency::details::_Task_impl_base::_ScheduleContinuationTask::__l5::&lt;lambda_713ee8bbd6b08550d59c52695cab5ce3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_Task_impl_base::_ScheduleContinuationTask::__l5::&lt;lambda_713ee8bbd6b08550d59c52695cab5ce3&gt;
{
  Concurrency::details::_ContinuationTaskHandleBase *_PTaskHandle;
};

</code></pre></div><h3 id="concurrency-details-getstaticambientschedulerref-l2-lambda-0e64988457575224279dcb6d61e61bdd"><a href="#concurrency-details-getstaticambientschedulerref-l2-lambda-0e64988457575224279dcb6d61e61bdd" class="header-anchor">#</a> <code>Concurrency::details::_GetStaticAmbientSchedulerRef::__l2::&lt;lambda_0e64988457575224279dcb6d61e61bdd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Concurrency::details::_GetStaticAmbientSchedulerRef::__l2::&lt;lambda_0e64988457575224279dcb6d61e61bdd&gt;
{
};

</code></pre></div><h3 id="cm-power-data-s"><a href="#cm-power-data-s" class="header-anchor">#</a> <code>CM_Power_Data_s</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct CM_Power_Data_s
{
  unsigned int PD_Size;
  _DEVICE_POWER_STATE PD_MostRecentPowerState;
  unsigned int PD_Capabilities;
  unsigned int PD_D1Latency;
  unsigned int PD_D2Latency;
  unsigned int PD_D3Latency;
  _DEVICE_POWER_STATE PD_PowerStateMapping[7];
  _SYSTEM_POWER_STATE PD_DeepestSystemWake;
};

</code></pre></div><h3 id="compiletime-hash64-0"><a href="#compiletime-hash64-0" class="header-anchor">#</a> <code>CompileTime::Hash64&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash64&lt;0&gt;
{
};

</code></pre></div><h3 id="compiletime-hash-0"><a href="#compiletime-hash-0" class="header-anchor">#</a> <code>CompileTime::Hash&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompileTime::Hash&lt;0&gt;
{
};

</code></pre></div><h3 id="copyfile2-message-unnamed-type-info-unnamed-type-chunkstarted"><a href="#copyfile2-message-unnamed-type-info-unnamed-type-chunkstarted" class="header-anchor">#</a> <code>COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_ChunkStarted&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_ChunkStarted&gt;
{
  unsigned int dwStreamNumber;
  unsigned int dwReserved;
  void *hSourceFile;
  void *hDestinationFile;
  _ULARGE_INTEGER uliChunkNumber;
  _ULARGE_INTEGER uliChunkSize;
  _ULARGE_INTEGER uliStreamSize;
  _ULARGE_INTEGER uliTotalFileSize;
};

</code></pre></div><h3 id="copyfile2-message-unnamed-type-info-unnamed-type-chunkfinished"><a href="#copyfile2-message-unnamed-type-info-unnamed-type-chunkfinished" class="header-anchor">#</a> <code>COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_ChunkFinished&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_ChunkFinished&gt;
{
  unsigned int dwStreamNumber;
  unsigned int dwFlags;
  void *hSourceFile;
  void *hDestinationFile;
  _ULARGE_INTEGER uliChunkNumber;
  _ULARGE_INTEGER uliChunkSize;
  _ULARGE_INTEGER uliStreamSize;
  _ULARGE_INTEGER uliStreamBytesTransferred;
  _ULARGE_INTEGER uliTotalFileSize;
  _ULARGE_INTEGER uliTotalBytesTransferred;
};

</code></pre></div><h3 id="copyfile2-message-unnamed-type-info-unnamed-type-streamstarted"><a href="#copyfile2-message-unnamed-type-info-unnamed-type-streamstarted" class="header-anchor">#</a> <code>COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_StreamStarted&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_StreamStarted&gt;
{
  unsigned int dwStreamNumber;
  unsigned int dwReserved;
  void *hSourceFile;
  void *hDestinationFile;
  _ULARGE_INTEGER uliStreamSize;
  _ULARGE_INTEGER uliTotalFileSize;
};

</code></pre></div><h3 id="copyfile2-message-unnamed-type-info-unnamed-type-streamfinished"><a href="#copyfile2-message-unnamed-type-info-unnamed-type-streamfinished" class="header-anchor">#</a> <code>COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_StreamFinished&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_StreamFinished&gt;
{
  unsigned int dwStreamNumber;
  unsigned int dwReserved;
  void *hSourceFile;
  void *hDestinationFile;
  _ULARGE_INTEGER uliStreamSize;
  _ULARGE_INTEGER uliStreamBytesTransferred;
  _ULARGE_INTEGER uliTotalFileSize;
  _ULARGE_INTEGER uliTotalBytesTransferred;
};

</code></pre></div><h3 id="copyfile2-message-unnamed-type-info-unnamed-type-pollcontinue"><a href="#copyfile2-message-unnamed-type-info-unnamed-type-pollcontinue" class="header-anchor">#</a> <code>COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_PollContinue&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_PollContinue&gt;
{
  unsigned int dwReserved;
};

</code></pre></div><h3 id="copyfile2-message-unnamed-type-info-unnamed-type-error"><a href="#copyfile2-message-unnamed-type-info-unnamed-type-error" class="header-anchor">#</a> <code>COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_Error&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt;::&lt;unnamed_type_Error&gt;
{
  _COPYFILE2_COPY_PHASE CopyPhase;
  unsigned int dwStreamNumber;
  HRESULT hrFailure;
  unsigned int dwReserved;
  _ULARGE_INTEGER uliChunkNumber;
  _ULARGE_INTEGER uliStreamSize;
  _ULARGE_INTEGER uliStreamBytesTransferred;
  _ULARGE_INTEGER uliTotalFileSize;
  _ULARGE_INTEGER uliTotalBytesTransferred;
};

</code></pre></div><h3 id="copyfile2-message"><a href="#copyfile2-message" class="header-anchor">#</a> <code>COPYFILE2_MESSAGE</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct COPYFILE2_MESSAGE
{
  _COPYFILE2_MESSAGE_TYPE Type;
  unsigned int dwPadding;
  COPYFILE2_MESSAGE::&lt;unnamed_type_Info&gt; Info;
};

</code></pre></div><h3 id="copyfile2-extended-parameters"><a href="#copyfile2-extended-parameters" class="header-anchor">#</a> <code>COPYFILE2_EXTENDED_PARAMETERS</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct COPYFILE2_EXTENDED_PARAMETERS
{
  unsigned int dwSize;
  unsigned int dwCopyFlags;
  int *pfCancel;
  _COPYFILE2_MESSAGE_ACTION (__fastcall *pProgressRoutine)(const COPYFILE2_MESSAGE *, void *);
  void *pvCallbackContext;
};

</code></pre></div><h3 id="confirmsafety"><a href="#confirmsafety" class="header-anchor">#</a> <code>CONFIRMSAFETY</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) CONFIRMSAFETY
{
  _GUID clsid;
  IUnknown *pUnk;
  unsigned int dwFlags;
};

</code></pre></div><h3 id="cg-texturesetlayerimagemiplist"><a href="#cg-texturesetlayerimagemiplist" class="header-anchor">#</a> <code>cg::TextureSetLayerImageMipList</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TextureSetLayerImageMipList
{
  cg::TextureSetLayerType mLayerType;
  std::vector&lt;cg::ImageBuffer&gt; mImageList;
};

</code></pre></div><h3 id="cg-texturesetimagecontainer"><a href="#cg-texturesetimagecontainer" class="header-anchor">#</a> <code>cg::TextureSetImageContainer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TextureSetImageContainer : Bedrock::EnableNonOwnerReferences
{
  std::vector&lt;cg::TextureSetLayerImageMipList&gt; mLayerImageList;
};

</code></pre></div><h3 id="cg-texturesetdefinition"><a href="#cg-texturesetdefinition" class="header-anchor">#</a> <code>cg::TextureSetDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TextureSetDefinition
{
  std::vector&lt;cg::TextureSetLayerDefinition&gt; mLayerInfoList;
  bool mIsMissingTexture;
  std::shared_ptr&lt;cg::TextureSetImageContainer&gt; mTextureSetImageData;
  ResourceLocationPair mResourceLocationPair;
};

</code></pre></div><h3 id="cg-cachelocation"><a href="#cg-cachelocation" class="header-anchor">#</a> <code>cg::CacheLocation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) cg::CacheLocation
{
  Core::PathBuffer&lt;std::string &gt; mPath;
  _BYTE mOrigin[1];
};

</code></pre></div><h3 id="core-filesystem"><a href="#core-filesystem" class="header-anchor">#</a> <code>Core::FileSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FileSystem
{
};

</code></pre></div><h3 id="core-filesystem-basicfiledata"><a href="#core-filesystem-basicfiledata" class="header-anchor">#</a> <code>Core::FileSystem::BasicFileData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FileSystem::BasicFileData
{
  Core::PathBuffer&lt;std::string &gt; mPath;
  unsigned __int64 mSize;
};

</code></pre></div><h3 id="core-filesystem-filetransferprogress"><a href="#core-filesystem-filetransferprogress" class="header-anchor">#</a> <code>Core::FileSystem::FileTransferProgress</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FileSystem::FileTransferProgress
{
  unsigned __int64 mStartPosition;
  unsigned __int64 mBytesWritten;
  unsigned __int64 mBytesRemaining;
};

</code></pre></div><h3 id="camerabehavior-attachbehavior"><a href="#camerabehavior-attachbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;AttachBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;AttachBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-attachbehavior-vtbl"><a href="#camerabehavior-attachbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;AttachBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;AttachBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-avoidancebehavior"><a href="#camerabehavior-avoidancebehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;AvoidanceBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;AvoidanceBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-avoidancebehavior-vtbl"><a href="#camerabehavior-avoidancebehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;AvoidanceBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;AvoidanceBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="criticallydampedspring-float"><a href="#criticallydampedspring-float" class="header-anchor">#</a> <code>CriticallyDampedSpring&lt;float&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CriticallyDampedSpring&lt;float&gt;
{
  float mSpring;
};

</code></pre></div><h3 id="camerabehavior-orbitbehavior"><a href="#camerabehavior-orbitbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;OrbitBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;OrbitBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-orbitbehavior-vtbl"><a href="#camerabehavior-orbitbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;OrbitBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;OrbitBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-bobbehavior"><a href="#camerabehavior-bobbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;BobBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;BobBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-bobbehavior-vtbl"><a href="#camerabehavior-bobbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;BobBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;BobBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-firstpersonlookbehavior"><a href="#camerabehavior-firstpersonlookbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;FirstPersonLookBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;FirstPersonLookBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-firstpersonlookbehavior-vtbl"><a href="#camerabehavior-firstpersonlookbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;FirstPersonLookBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;FirstPersonLookBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-riderotationbehavior"><a href="#camerabehavior-riderotationbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;RideRotationBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;RideRotationBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-riderotationbehavior-vtbl"><a href="#camerabehavior-riderotationbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;RideRotationBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;RideRotationBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-flybehavior"><a href="#camerabehavior-flybehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;FlyBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;FlyBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-flybehavior-vtbl"><a href="#camerabehavior-flybehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;FlyBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;FlyBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-liquidoffsetbehavior"><a href="#camerabehavior-liquidoffsetbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;LiquidOffsetBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;LiquidOffsetBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-liquidoffsetbehavior-vtbl"><a href="#camerabehavior-liquidoffsetbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;LiquidOffsetBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;LiquidOffsetBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-lookatbehavior"><a href="#camerabehavior-lookatbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;LookAtBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;LookAtBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-lookatbehavior-vtbl"><a href="#camerabehavior-lookatbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;LookAtBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;LookAtBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-portalbehavior"><a href="#camerabehavior-portalbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;PortalBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;PortalBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-portalbehavior-vtbl"><a href="#camerabehavior-portalbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;PortalBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;PortalBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-sleepbehavior"><a href="#camerabehavior-sleepbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;SleepBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;SleepBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-sleepbehavior-vtbl"><a href="#camerabehavior-sleepbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;SleepBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;SleepBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="camerabehavior-sneakbehavior"><a href="#camerabehavior-sneakbehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;SneakBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;SneakBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-sneakbehavior-vtbl"><a href="#camerabehavior-sneakbehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;SneakBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;SneakBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="core-pathcontainerconversions-core-stackstring-char-1024"><a href="#core-pathcontainerconversions-core-stackstring-char-1024" class="header-anchor">#</a> <code>Core::PathContainerConversions&lt;Core::StackString&lt;char,1024&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::PathContainerConversions&lt;Core::StackString&lt;char,1024&gt; &gt;
{
};

</code></pre></div><h3 id="camerabehavior-splinebehavior"><a href="#camerabehavior-splinebehavior" class="header-anchor">#</a> <code>CameraBehavior&lt;SplineBehavior&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CameraBehavior&lt;SplineBehavior&gt; : ICameraBehavior
{
  ICameraBehavior::UpdateOrder mUpdateOrder;
};

</code></pre></div><h3 id="camerabehavior-splinebehavior-vtbl"><a href="#camerabehavior-splinebehavior-vtbl" class="header-anchor">#</a> <code>CameraBehavior&lt;SplineBehavior&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CameraBehavior&lt;SplineBehavior&gt;_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="criticallydampedspring-vec3"><a href="#criticallydampedspring-vec3" class="header-anchor">#</a> <code>CriticallyDampedSpring&lt;Vec3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CriticallyDampedSpring&lt;Vec3&gt;
{
  float mSpring;
};

</code></pre></div><h3 id="catmullromspline"><a href="#catmullromspline" class="header-anchor">#</a> <code>CatmullRomSpline</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CatmullRomSpline
{
  std::vector&lt;Vec3&gt; mControlPoints;
  std::vector&lt;float&gt; mAccumulatedSegmentLengths;
  bool mLooped;
};

</code></pre></div><h3 id="cameraloader-parsecameras-l2-lambda-39f3f306e576c66b261bbdd8909b2247"><a href="#cameraloader-parsecameras-l2-lambda-39f3f306e576c66b261bbdd8909b2247" class="header-anchor">#</a> <code>CameraLoader::parseCameras::__l2::&lt;lambda_39f3f306e576c66b261bbdd8909b2247&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraLoader::parseCameras::__l2::&lt;lambda_39f3f306e576c66b261bbdd8909b2247&gt;
{
  CameraLoader *const __this;
  std::unordered_map&lt;HashedString,CameraDirector&gt; *loadedCameras;
  std::unordered_map&lt;HashedString,CameraDirector&gt; *newCameraMap;
};

</code></pre></div><h3 id="cameraloader-parseblends-l2-lambda-c6a4c0e67c1895cce63e1cdd7ae7d3c3"><a href="#cameraloader-parseblends-l2-lambda-c6a4c0e67c1895cce63e1cdd7ae7d3c3" class="header-anchor">#</a> <code>CameraLoader::parseBlends::__l2::&lt;lambda_c6a4c0e67c1895cce63e1cdd7ae7d3c3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CameraLoader::parseBlends::__l2::&lt;lambda_c6a4c0e67c1895cce63e1cdd7ae7d3c3&gt;
{
  CameraLoader *const __this;
  std::unordered_map&lt;HashedString,CameraDirector&gt; *loadedCameras;
  std::unordered_map&lt;std::pair&lt;HashedString,HashedString&gt;,CameraBlendSettings,CameraPairHasher,std::equal_to&lt;std::pair&lt;HashedString,HashedString&gt; &gt;,std::allocator&lt;std::pair&lt;std::pair&lt;HashedString,HashedString&gt; const ,CameraBlendSettings&gt; &gt; &gt; *customBlendMap;
};

</code></pre></div><h3 id="commandcontext"><a href="#commandcontext" class="header-anchor">#</a> <code>CommandContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CommandContext
{
  std::string mCommand;
  std::unique_ptr&lt;CommandOrigin&gt; mOrigin;
  int mVersion;
};

</code></pre></div><h3 id="clientcommand"><a href="#clientcommand" class="header-anchor">#</a> <code>ClientCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientCommand : Command
{
};

</code></pre></div><h3 id="clientcommand-vtbl"><a href="#clientcommand-vtbl" class="header-anchor">#</a> <code>ClientCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="clientcommandoutputsender"><a href="#clientcommandoutputsender" class="header-anchor">#</a> <code>ClientCommandOutputSender</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientCommandOutputSender : CommandOutputSender
{
  GuiData *mMachineGuiData;
};

</code></pre></div><h3 id="clientcommandoutputsender-vtbl"><a href="#clientcommandoutputsender-vtbl" class="header-anchor">#</a> <code>ClientCommandOutputSender_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientCommandOutputSender_vtbl
{
  void (__fastcall *~CommandOutputSender)(CommandOutputSender *this);
  void (__fastcall *send)(CommandOutputSender *this, const CommandOrigin *, const CommandOutput *);
  void (__fastcall *registerOutputCallback)(CommandOutputSender *this, const std::function&lt;void __cdecl(AutomationCmdOutput &amp;)&gt; *);
};

</code></pre></div><h3 id="commandselector-actor"><a href="#commandselector-actor" class="header-anchor">#</a> <code>CommandSelector&lt;Actor&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandSelector&lt;Actor&gt; : CommandSelectorBase
{
};

</code></pre></div><h3 id="commandregistry-semanticinfo"><a href="#commandregistry-semanticinfo" class="header-anchor">#</a> <code>CommandRegistry::SemanticInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandRegistry::SemanticInfo
{
  bool mIsValid;
  std::vector&lt;CommandRegistry::Symbol&gt; mConstrainedParams;
  std::string mSoftEnumText;
  std::string mSoftEnumEscapeCharExceptions;
  std::set&lt;CommandRegistry::Symbol&gt; mAlreadyCompletedSymbols;
};

</code></pre></div><h3 id="commands-postfix"><a href="#commands-postfix" class="header-anchor">#</a> <code>commands::Postfix</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj commands::Postfix
{
  const char *postfix;
};

</code></pre></div><h3 id="commands-softenum"><a href="#commands-softenum" class="header-anchor">#</a> <code>commands::SoftEnum</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj commands::SoftEnum
{
  const char *name;
};

</code></pre></div><h3 id="closewebsocketcommand"><a href="#closewebsocketcommand" class="header-anchor">#</a> <code>CloseWebSocketCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CloseWebSocketCommand : Command
{
};

</code></pre></div><h3 id="closewebsocketcommand-vtbl"><a href="#closewebsocketcommand-vtbl" class="header-anchor">#</a> <code>CloseWebSocketCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CloseWebSocketCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="closechatcommand"><a href="#closechatcommand" class="header-anchor">#</a> <code>CloseChatCommand</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CloseChatCommand : Command
{
};

</code></pre></div><h3 id="closechatcommand-vtbl"><a href="#closechatcommand-vtbl" class="header-anchor">#</a> <code>CloseChatCommand_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CloseChatCommand_vtbl
{
  void (__fastcall *~Command)(Command *this);
  void (__fastcall *execute)(Command *this, const CommandOrigin *, CommandOutput *);
};

</code></pre></div><h3 id="clientcommandoutputsender-send-l20-lambda-0b751b1533f17cdbef71e6a6deb7f9bd"><a href="#clientcommandoutputsender-send-l20-lambda-0b751b1533f17cdbef71e6a6deb7f9bd" class="header-anchor">#</a> <code>ClientCommandOutputSender::send::__l20::&lt;lambda_0b751b1533f17cdbef71e6a6deb7f9bd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientCommandOutputSender::send::__l20::&lt;lambda_0b751b1533f17cdbef71e6a6deb7f9bd&gt;
{
  const CommandOutputMessage *message;
};

</code></pre></div><h3 id="clientskininfodata-vtbl"><a href="#clientskininfodata-vtbl" class="header-anchor">#</a> <code>ClientSkinInfoData_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ClientSkinInfoData_vtbl
{
  void (__fastcall *~SkinInfoData)(SkinInfoData *this);
  void (__fastcall *updateSkin)(SkinInfoData *this, const SerializedSkin *, const mce::Image *, const mce::Image *);
  void (__fastcall *updateSkinNe)(SkinInfoData *this, const SerializedSkin *, const mce::Image *, const mce::Image *, const mce::Image *);
  bool (__fastcall *hasValidTexture)(SkinInfoData *this);
  bool (__fastcall *validateAndResizeSkinData)(SkinInfoData *this, mce::Image *, bool);
};

</code></pre></div><h3 id="clientskinsystem"><a href="#clientskinsystem" class="header-anchor">#</a> <code>ClientSkinSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientSkinSystem
{
};

</code></pre></div><h3 id="clientparticleterminationcomponent"><a href="#clientparticleterminationcomponent" class="header-anchor">#</a> <code>ClientParticleTerminationComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientParticleTerminationComponent : IEntityComponent
{
  HashedString mAnimationControllerName;
};

</code></pre></div><h3 id="callbacktokencontext-std-function-void-cdecl-void"><a href="#callbacktokencontext-std-function-void-cdecl-void" class="header-anchor">#</a> <code>CallbackTokenContext&lt;std::function&lt;void __cdecl(void)&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CallbackTokenContext&lt;std::function&lt;void __cdecl(void)&gt; &gt;
{
  std::vector&lt;std::function&lt;void __cdecl(void)&gt;&gt; mCallbacks;
  std::shared_ptr&lt;CallbackTokenCancelState&gt; mCancelState;
};

</code></pre></div><h3 id="containercomponent-vtbl"><a href="#containercomponent-vtbl" class="header-anchor">#</a> <code>ContainerComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerComponent_vtbl
{
  void (__fastcall *containerContentChanged)(ContainerContentChangeListener *this, int);
  void (__fastcall *~ContainerContentChangeListener)(ContainerContentChangeListener *this);
  void (__fastcall *containerAddCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *containerRemoveCallback)(ContainerContentChangeListener *this, Container *);
};

</code></pre></div><h3 id="cdscopedgameplay"><a href="#cdscopedgameplay" class="header-anchor">#</a> <code>CDScopedGameplay</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CDScopedGameplay
{
  _BYTE mFunc[2];
  _BYTE mTagEnd[2];
  int mClientId;
  int mBuildActionIntention;
};

</code></pre></div><h3 id="callbacktokencontext-std-function-void-cdecl-enum-legacy-retrievestatus"><a href="#callbacktokencontext-std-function-void-cdecl-enum-legacy-retrievestatus" class="header-anchor">#</a> <code>CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::RetrieveStatus)&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::RetrieveStatus)&gt; &gt;
{
  std::vector&lt;std::function&lt;void __cdecl(enum Legacy::RetrieveStatus)&gt;&gt; mCallbacks;
  std::shared_ptr&lt;CallbackTokenCancelState&gt; mCancelState;
};

</code></pre></div><h3 id="callbacktokencontext-std-function-void-cdecl-enum-legacy-importstatus-float-std-shared-ptr-importresult"><a href="#callbacktokencontext-std-function-void-cdecl-enum-legacy-importstatus-float-std-shared-ptr-importresult" class="header-anchor">#</a> <code>CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CallbackTokenContext&lt;std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt; &gt;
{
  std::vector&lt;std::function&lt;void __cdecl(enum Legacy::ImportStatus,float,std::shared_ptr&lt;ImportResult&gt;)&gt;&gt; mCallbacks;
  std::shared_ptr&lt;CallbackTokenCancelState&gt; mCancelState;
};

</code></pre></div><h3 id="chacha"><a href="#chacha" class="header-anchor">#</a> <code>ChaCha</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChaCha
{
  unsigned int m_state[16];
  unsigned int m_mask[16];
  unsigned int m_off;
  unsigned int m_rnd;
};

</code></pre></div><h3 id="crashdumplogutils"><a href="#crashdumplogutils" class="header-anchor">#</a> <code>CrashDumpLogUtils</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CrashDumpLogUtils
{
};

</code></pre></div><h3 id="crashdumplog"><a href="#crashdumplog" class="header-anchor">#</a> <code>CrashDumpLog</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CrashDumpLog
{
};

</code></pre></div><h3 id="compositescenestackview"><a href="#compositescenestackview" class="header-anchor">#</a> <code>CompositeSceneStackView</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompositeSceneStackView
{
  SceneStack *mMainStack;
  SceneStack *mClientInstanceStack;
  ConstCompositeSceneStackView mConstView;
};

</code></pre></div><h3 id="clientinstance-onscreensizevariableschanged-l2-lambda-90393c59d32660745f34e36629dc4206"><a href="#clientinstance-onscreensizevariableschanged-l2-lambda-90393c59d32660745f34e36629dc4206" class="header-anchor">#</a> <code>ClientInstance::_onScreenSizeVariablesChanged::__l2::&lt;lambda_90393c59d32660745f34e36629dc4206&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_onScreenSizeVariablesChanged::__l2::&lt;lambda_90393c59d32660745f34e36629dc4206&gt;
{
  const ScreenSizeData *screenSizeData;
};

</code></pre></div><h3 id="clientinstance-updatecontrollerhandling-l11-lambda-15b5620979f052f9384ec29576b39029"><a href="#clientinstance-updatecontrollerhandling-l11-lambda-15b5620979f052f9384ec29576b39029" class="header-anchor">#</a> <code>ClientInstance::updateControllerHandling::__l11::&lt;lambda_15b5620979f052f9384ec29576b39029&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::updateControllerHandling::__l11::&lt;lambda_15b5620979f052f9384ec29576b39029&gt;
{
  std::weak_ptr&lt;ClientInstance&gt; weakPtr;
};

</code></pre></div><h3 id="clientinstance-tickdestroyblock-l11-lambda-df7287ab01c6507a213cfdfd14b9340d"><a href="#clientinstance-tickdestroyblock-l11-lambda-df7287ab01c6507a213cfdfd14b9340d" class="header-anchor">#</a> <code>ClientInstance::tickDestroyBlock::__l11::&lt;lambda_df7287ab01c6507a213cfdfd14b9340d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::tickDestroyBlock::__l11::&lt;lambda_df7287ab01c6507a213cfdfd14b9340d&gt;
{
  const BlockPos *hitPos;
  const unsigned __int8 hitFace;
  ClientInstance::ClientDestroyBlockState *state;
};

</code></pre></div><h3 id="clientinstance-navigatetostoreseeallbycreatorscreen-l2-lambda-15d8531333f726aeede88a06a28b4fd0-l22-lambda-3f6c191c869f81aace7d27ad31821f7d"><a href="#clientinstance-navigatetostoreseeallbycreatorscreen-l2-lambda-15d8531333f726aeede88a06a28b4fd0-l22-lambda-3f6c191c869f81aace7d27ad31821f7d" class="header-anchor">#</a> <code>ClientInstance::navigateToStoreSeeAllByCreatorScreen::__l2::&lt;lambda_15d8531333f726aeede88a06a28b4fd0&gt;::()::__l22::&lt;lambda_3f6c191c869f81aace7d27ad31821f7d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::navigateToStoreSeeAllByCreatorScreen::__l2::&lt;lambda_15d8531333f726aeede88a06a28b4fd0&gt;::()::__l22::&lt;lambda_3f6c191c869f81aace7d27ad31821f7d&gt;
{
  std::shared_ptr&lt;ClientInstance&gt; sharedThis;
};

</code></pre></div><h3 id="clientinstance-initscenestack-l2-lambda-97650e0fd8d8e2d4ab764eb737bc7498"><a href="#clientinstance-initscenestack-l2-lambda-97650e0fd8d8e2d4ab764eb737bc7498" class="header-anchor">#</a> <code>ClientInstance::_initSceneStack::__l2::&lt;lambda_97650e0fd8d8e2d4ab764eb737bc7498&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_initSceneStack::__l2::&lt;lambda_97650e0fd8d8e2d4ab764eb737bc7498&gt;
{
  ClientInstance *const __this;
};

</code></pre></div><h3 id="clientinstance-initscenestack-l2-lambda-582f79c63c5d93588b6a0221f4853e8c"><a href="#clientinstance-initscenestack-l2-lambda-582f79c63c5d93588b6a0221f4853e8c" class="header-anchor">#</a> <code>ClientInstance::_initSceneStack::__l2::&lt;lambda_582f79c63c5d93588b6a0221f4853e8c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_initSceneStack::__l2::&lt;lambda_582f79c63c5d93588b6a0221f4853e8c&gt;
{
  ClientInstance *const __this;
};

</code></pre></div><h3 id="clientinstance-initscenestack-l2-lambda-878ba9a1bc34c18f3fb6c7370a888ee2"><a href="#clientinstance-initscenestack-l2-lambda-878ba9a1bc34c18f3fb6c7370a888ee2" class="header-anchor">#</a> <code>ClientInstance::_initSceneStack::__l2::&lt;lambda_878ba9a1bc34c18f3fb6c7370a888ee2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_initSceneStack::__l2::&lt;lambda_878ba9a1bc34c18f3fb6c7370a888ee2&gt;
{
  ClientInstance *const __this;
};

</code></pre></div><h3 id="clientinstance-initscenestack-l2-lambda-878ba9a1bc34c18f3fb6c7370a888ee2-l2-lambda-193b3faf9447328a85dac550e43be45e"><a href="#clientinstance-initscenestack-l2-lambda-878ba9a1bc34c18f3fb6c7370a888ee2-l2-lambda-193b3faf9447328a85dac550e43be45e" class="header-anchor">#</a> <code>ClientInstance::_initSceneStack::__l2::&lt;lambda_878ba9a1bc34c18f3fb6c7370a888ee2&gt;::()::__l2::&lt;lambda_193b3faf9447328a85dac550e43be45e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_initSceneStack::__l2::&lt;lambda_878ba9a1bc34c18f3fb6c7370a888ee2&gt;::()::__l2::&lt;lambda_193b3faf9447328a85dac550e43be45e&gt;
{
  std::string *currentNamespace;
  AbstractScene *screen;
};

</code></pre></div><h3 id="clientinstance-initscenestack-l2-lambda-299ba7fd9fe4ee5b945befbd386be495"><a href="#clientinstance-initscenestack-l2-lambda-299ba7fd9fe4ee5b945befbd386be495" class="header-anchor">#</a> <code>ClientInstance::_initSceneStack::__l2::&lt;lambda_299ba7fd9fe4ee5b945befbd386be495&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_initSceneStack::__l2::&lt;lambda_299ba7fd9fe4ee5b945befbd386be495&gt;
{
  ClientInstance *const __this;
};

</code></pre></div><h3 id="clientinstance-createskinrepositoryclientinterface-l5-lambda-1214f5056699946a17be2ec6b86b5a63"><a href="#clientinstance-createskinrepositoryclientinterface-l5-lambda-1214f5056699946a17be2ec6b86b5a63" class="header-anchor">#</a> <code>ClientInstance::_createSkinRepositoryClientInterface::__l5::&lt;lambda_1214f5056699946a17be2ec6b86b5a63&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_createSkinRepositoryClientInterface::__l5::&lt;lambda_1214f5056699946a17be2ec6b86b5a63&gt;
{
  std::weak_ptr&lt;ClientInstance&gt; weakThis;
};

</code></pre></div><h3 id="clientinstance-isshowingmenu-l2-lambda-cfd341f57ab31a2ca42b1aefca30254a"><a href="#clientinstance-isshowingmenu-l2-lambda-cfd341f57ab31a2ca42b1aefca30254a" class="header-anchor">#</a> <code>ClientInstance::isShowingMenu::__l2::&lt;lambda_cfd341f57ab31a2ca42b1aefca30254a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::isShowingMenu::__l2::&lt;lambda_cfd341f57ab31a2ca42b1aefca30254a&gt;
{
  bool *showingMenu;
};

</code></pre></div><h3 id="clientinstance-initcommands-l2-lambda-bb361151b842928025ac08534ab16337"><a href="#clientinstance-initcommands-l2-lambda-bb361151b842928025ac08534ab16337" class="header-anchor">#</a> <code>ClientInstance::initCommands::__l2::&lt;lambda_bb361151b842928025ac08534ab16337&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::initCommands::__l2::&lt;lambda_bb361151b842928025ac08534ab16337&gt;
{
  ClientInstance *const __this;
};

</code></pre></div><h3 id="clientinstance-ontick-l38-lambda-71b0399f4662fd076d571faae3370350"><a href="#clientinstance-ontick-l38-lambda-71b0399f4662fd076d571faae3370350" class="header-anchor">#</a> <code>ClientInstance::onTick::__l38::&lt;lambda_71b0399f4662fd076d571faae3370350&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::onTick::__l38::&lt;lambda_71b0399f4662fd076d571faae3370350&gt;
{
  int *nTick;
  int *maxTick;
};

</code></pre></div><h3 id="clientinstance-joinworldinprogress-l2-lambda-02e2605fd0c5e1a6375f3072765e8e5a"><a href="#clientinstance-joinworldinprogress-l2-lambda-02e2605fd0c5e1a6375f3072765e8e5a" class="header-anchor">#</a> <code>ClientInstance::_joinWorldInProgress::__l2::&lt;lambda_02e2605fd0c5e1a6375f3072765e8e5a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientInstance::_joinWorldInProgress::__l2::&lt;lambda_02e2605fd0c5e1a6375f3072765e8e5a&gt;
{
  std::weak_ptr&lt;ClientInstance&gt; weakThis;
  bool isNetworkGame;
};

</code></pre></div><h3 id="clientinstance-joinworldinprogress-l11-lambda-abecbc1c0e8dcdce57775fbf971d4035"><a href="#clientinstance-joinworldinprogress-l11-lambda-abecbc1c0e8dcdce57775fbf971d4035" class="header-anchor">#</a> <code>ClientInstance::_joinWorldInProgress::__l11::&lt;lambda_abecbc1c0e8dcdce57775fbf971d4035&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_joinWorldInProgress::__l11::&lt;lambda_abecbc1c0e8dcdce57775fbf971d4035&gt;
{
};

</code></pre></div><h3 id="clientinstance-startsubclientlatejoin-l13-lambda-b51ae057fc840348fcf61fa2148e38c6"><a href="#clientinstance-startsubclientlatejoin-l13-lambda-b51ae057fc840348fcf61fa2148e38c6" class="header-anchor">#</a> <code>ClientInstance::startSubClientLateJoin::__l13::&lt;lambda_b51ae057fc840348fcf61fa2148e38c6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientInstance::startSubClientLateJoin::__l13::&lt;lambda_b51ae057fc840348fcf61fa2148e38c6&gt;
{
  ClientInstance *const __this;
  bool isNetworkGame;
};

</code></pre></div><h3 id="clientinstance-update-l42-lambda-2eadb951cae52f74e068bad3dd7fa7f4-l14-lambda-702502096d39b6c5ea025d728e798aee"><a href="#clientinstance-update-l42-lambda-2eadb951cae52f74e068bad3dd7fa7f4-l14-lambda-702502096d39b6c5ea025d728e798aee" class="header-anchor">#</a> <code>ClientInstance::update::__l42::&lt;lambda_2eadb951cae52f74e068bad3dd7fa7f4&gt;::()::__l14::&lt;lambda_702502096d39b6c5ea025d728e798aee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::update::__l42::&lt;lambda_2eadb951cae52f74e068bad3dd7fa7f4&gt;::()::__l14::&lt;lambda_702502096d39b6c5ea025d728e798aee&gt;
{
  std::weak_ptr&lt;ClientInstance&gt; weakPtr;
};

</code></pre></div><h3 id="clientinstance-startleavegame-l2-lambda-2b74ebf9d9d48a05c165bbb31d30842e"><a href="#clientinstance-startleavegame-l2-lambda-2b74ebf9d9d48a05c165bbb31d30842e" class="header-anchor">#</a> <code>ClientInstance::_startLeaveGame::__l2::&lt;lambda_2b74ebf9d9d48a05c165bbb31d30842e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_startLeaveGame::__l2::&lt;lambda_2b74ebf9d9d48a05c165bbb31d30842e&gt;
{
};

</code></pre></div><h3 id="clientinstance-requestleavegame-l2-lambda-4bc0650f4f0405926a0a487036642fde"><a href="#clientinstance-requestleavegame-l2-lambda-4bc0650f4f0405926a0a487036642fde" class="header-anchor">#</a> <code>ClientInstance::requestLeaveGame::__l2::&lt;lambda_4bc0650f4f0405926a0a487036642fde&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ClientInstance::requestLeaveGame::__l2::&lt;lambda_4bc0650f4f0405926a0a487036642fde&gt;
{
  std::weak_ptr&lt;ClientInstance&gt; weakThis;
  bool switchScreen;
  bool sync;
};

</code></pre></div><h3 id="clientinstance-init-l2-lambda-a36354b83242328e7f1f5c5935e0ecaa"><a href="#clientinstance-init-l2-lambda-a36354b83242328e7f1f5c5935e0ecaa" class="header-anchor">#</a> <code>ClientInstance::init::__l2::&lt;lambda_a36354b83242328e7f1f5c5935e0ecaa&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::init::__l2::&lt;lambda_a36354b83242328e7f1f5c5935e0ecaa&gt;
{
  std::weak_ptr&lt;ClientInstance&gt; weakThis;
};

</code></pre></div><h3 id="clientinstance-init-l2-lambda-7d463a3c887b82eef60c5bc398d58571"><a href="#clientinstance-init-l2-lambda-7d463a3c887b82eef60c5bc398d58571" class="header-anchor">#</a> <code>ClientInstance::init::__l2::&lt;lambda_7d463a3c887b82eef60c5bc398d58571&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::init::__l2::&lt;lambda_7d463a3c887b82eef60c5bc398d58571&gt;
{
  std::weak_ptr&lt;ClientInstance&gt; weakThis;
};

</code></pre></div><h3 id="clientinstance-init-l2-lambda-2dbee955e45009a41bd19a4f5d977b90"><a href="#clientinstance-init-l2-lambda-2dbee955e45009a41bd19a4f5d977b90" class="header-anchor">#</a> <code>ClientInstance::init::__l2::&lt;lambda_2dbee955e45009a41bd19a4f5d977b90&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::init::__l2::&lt;lambda_2dbee955e45009a41bd19a4f5d977b90&gt;
{
  ClientInstance *const __this;
};

</code></pre></div><h3 id="clientinputcallbacks-vibrate-l13-lambda-abfe2ccf6929051526d977f1e506ac3d"><a href="#clientinputcallbacks-vibrate-l13-lambda-abfe2ccf6929051526d977f1e506ac3d" class="header-anchor">#</a> <code>ClientInputCallbacks::vibrate::__l13::&lt;lambda_abfe2ccf6929051526d977f1e506ac3d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::vibrate::__l13::&lt;lambda_abfe2ccf6929051526d977f1e506ac3d&gt;
{
  int milliSeconds;
};

</code></pre></div><h3 id="clientinputcallbacks-handlecommandevent-l2-lambda-3ca896b064936e0c3219171a0fd62bea"><a href="#clientinputcallbacks-handlecommandevent-l2-lambda-3ca896b064936e0c3219171a0fd62bea" class="header-anchor">#</a> <code>ClientInputCallbacks::handleCommandEvent::__l2::&lt;lambda_3ca896b064936e0c3219171a0fd62bea&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleCommandEvent::__l2::&lt;lambda_3ca896b064936e0c3219171a0fd62bea&gt;
{
  const VoiceCommand *command;
};

</code></pre></div><h3 id="clientinputcallbacks-handledictationevent-l8-lambda-e6fd729911e6f890df89f1279cd76373"><a href="#clientinputcallbacks-handledictationevent-l8-lambda-e6fd729911e6f890df89f1279cd76373" class="header-anchor">#</a> <code>ClientInputCallbacks::handleDictationEvent::__l8::&lt;lambda_e6fd729911e6f890df89f1279cd76373&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleDictationEvent::__l8::&lt;lambda_e6fd729911e6f890df89f1279cd76373&gt;
{
  const std::string *newDictationStr;
};

</code></pre></div><h3 id="clientinputcallbacks-handlevectorinput-l4-lambda-0f0def3c3c1a653163fbf9c1bccfcf88"><a href="#clientinputcallbacks-handlevectorinput-l4-lambda-0f0def3c3c1a653163fbf9c1bccfcf88" class="header-anchor">#</a> <code>ClientInputCallbacks::handleVectorInput::__l4::&lt;lambda_0f0def3c3c1a653163fbf9c1bccfcf88&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleVectorInput::__l4::&lt;lambda_0f0def3c3c1a653163fbf9c1bccfcf88&gt;
{
  __int16 *id;
  float *x;
  float *y;
  float *z;
  FocusImpact *focusImpact;
};

</code></pre></div><h3 id="clientinputcallbacks-handleholoinputmodechanged-l2-lambda-e79dccabe9c15a9b64dbdfbab7317d1d"><a href="#clientinputcallbacks-handleholoinputmodechanged-l2-lambda-e79dccabe9c15a9b64dbdfbab7317d1d" class="header-anchor">#</a> <code>ClientInputCallbacks::handleHoloInputModeChanged::__l2::&lt;lambda_e79dccabe9c15a9b64dbdfbab7317d1d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleHoloInputModeChanged::__l2::&lt;lambda_e79dccabe9c15a9b64dbdfbab7317d1d&gt;
{
  HoloUIInputMode *inputMode;
};

</code></pre></div><h3 id="clientinputcallbacks-handleinputmodechanged-l2-lambda-86c8143899b89eccea3596158e019ff1"><a href="#clientinputcallbacks-handleinputmodechanged-l2-lambda-86c8143899b89eccea3596158e019ff1" class="header-anchor">#</a> <code>ClientInputCallbacks::handleInputModeChanged::__l2::&lt;lambda_86c8143899b89eccea3596158e019ff1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleInputModeChanged::__l2::&lt;lambda_86c8143899b89eccea3596158e019ff1&gt;
{
  InputMode *inputMode;
};

</code></pre></div><h3 id="clientinputcallbacks-handledirection-l2-lambda-1ca73074d044029f1123f1b8e204c386"><a href="#clientinputcallbacks-handledirection-l2-lambda-1ca73074d044029f1123f1b8e204c386" class="header-anchor">#</a> <code>ClientInputCallbacks::handleDirection::__l2::&lt;lambda_1ca73074d044029f1123f1b8e204c386&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleDirection::__l2::&lt;lambda_1ca73074d044029f1123f1b8e204c386&gt;
{
  DirectionId *stickId;
  float *x;
  float *y;
  FocusImpact *focusImpact;
};

</code></pre></div><h3 id="clientinputcallbacks-handlepointerlocation-l5-lambda-585dae7b1422f8853e1863f4bcfab0ab"><a href="#clientinputcallbacks-handlepointerlocation-l5-lambda-585dae7b1422f8853e1863f4bcfab0ab" class="header-anchor">#</a> <code>ClientInputCallbacks::handlePointerLocation::__l5::&lt;lambda_585dae7b1422f8853e1863f4bcfab0ab&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handlePointerLocation::__l5::&lt;lambda_585dae7b1422f8853e1863f4bcfab0ab&gt;
{
  const PointerLocationEventData *pointerLocationData;
  FocusImpact *focusImpact;
};

</code></pre></div><h3 id="clientinputcallbacks-handlemenubuttonrelease-l2-lambda-d0e4742031c76c6b90374d00cc4059a8"><a href="#clientinputcallbacks-handlemenubuttonrelease-l2-lambda-d0e4742031c76c6b90374d00cc4059a8" class="header-anchor">#</a> <code>ClientInputCallbacks::handleMenuButtonRelease::__l2::&lt;lambda_d0e4742031c76c6b90374d00cc4059a8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleMenuButtonRelease::__l2::&lt;lambda_d0e4742031c76c6b90374d00cc4059a8&gt;
{
  unsigned int *buttonId;
  FocusImpact *focusImpact;
};

</code></pre></div><h3 id="clientinputcallbacks-handlepointerpressedbuttonrelease-l2-lambda-39242d26cf3982dde303d99c138d7fea"><a href="#clientinputcallbacks-handlepointerpressedbuttonrelease-l2-lambda-39242d26cf3982dde303d99c138d7fea" class="header-anchor">#</a> <code>ClientInputCallbacks::handlePointerPressedButtonRelease::__l2::&lt;lambda_39242d26cf3982dde303d99c138d7fea&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handlePointerPressedButtonRelease::__l2::&lt;lambda_39242d26cf3982dde303d99c138d7fea&gt;
{
};

</code></pre></div><h3 id="clientinputcallbacks-handlemenubuttonpress-l2-lambda-21d7273568769b2a2e8a145779122fe2"><a href="#clientinputcallbacks-handlemenubuttonpress-l2-lambda-21d7273568769b2a2e8a145779122fe2" class="header-anchor">#</a> <code>ClientInputCallbacks::handleMenuButtonPress::__l2::&lt;lambda_21d7273568769b2a2e8a145779122fe2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleMenuButtonPress::__l2::&lt;lambda_21d7273568769b2a2e8a145779122fe2&gt;
{
  unsigned int *buttonId;
  FocusImpact *focusImpact;
};

</code></pre></div><h3 id="clientinputcallbacks-handlebuildorattackbuttonpress-l2-lambda-da56761cda2d44f41691415c5db47201"><a href="#clientinputcallbacks-handlebuildorattackbuttonpress-l2-lambda-da56761cda2d44f41691415c5db47201" class="header-anchor">#</a> <code>ClientInputCallbacks::handleBuildOrAttackButtonPress::__l2::&lt;lambda_da56761cda2d44f41691415c5db47201&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleBuildOrAttackButtonPress::__l2::&lt;lambda_da56761cda2d44f41691415c5db47201&gt;
{
};

</code></pre></div><h3 id="clientinputcallbacks-handledestroyorinteractbuttonpress-l2-lambda-30eab25553a0289c6a2e647a94663f5c"><a href="#clientinputcallbacks-handledestroyorinteractbuttonpress-l2-lambda-30eab25553a0289c6a2e647a94663f5c" class="header-anchor">#</a> <code>ClientInputCallbacks::handleDestroyOrInteractButtonPress::__l2::&lt;lambda_30eab25553a0289c6a2e647a94663f5c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleDestroyOrInteractButtonPress::__l2::&lt;lambda_30eab25553a0289c6a2e647a94663f5c&gt;
{
};

</code></pre></div><h3 id="clientinputcallbacks-handlebuildorinteractbuttonpress-l2-lambda-549184ca211057ee986f55f9691f0b5d"><a href="#clientinputcallbacks-handlebuildorinteractbuttonpress-l2-lambda-549184ca211057ee986f55f9691f0b5d" class="header-anchor">#</a> <code>ClientInputCallbacks::handleBuildOrInteractButtonPress::__l2::&lt;lambda_549184ca211057ee986f55f9691f0b5d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleBuildOrInteractButtonPress::__l2::&lt;lambda_549184ca211057ee986f55f9691f0b5d&gt;
{
};

</code></pre></div><h3 id="clientinputcallbacks-handlebuildorinteractbuttonpress-l5-lambda-99d95ad1f219b828a438795fbbae0add"><a href="#clientinputcallbacks-handlebuildorinteractbuttonpress-l5-lambda-99d95ad1f219b828a438795fbbae0add" class="header-anchor">#</a> <code>ClientInputCallbacks::handleBuildOrInteractButtonPress::__l5::&lt;lambda_99d95ad1f219b828a438795fbbae0add&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleBuildOrInteractButtonPress::__l5::&lt;lambda_99d95ad1f219b828a438795fbbae0add&gt;
{
};

</code></pre></div><h3 id="clientinputcallbacks-handledestoryorattackbuttonpress-l2-lambda-a250f32d2aec155df20b3e6b1bd71989"><a href="#clientinputcallbacks-handledestoryorattackbuttonpress-l2-lambda-a250f32d2aec155df20b3e6b1bd71989" class="header-anchor">#</a> <code>ClientInputCallbacks::handleDestoryOrAttackButtonPress::__l2::&lt;lambda_a250f32d2aec155df20b3e6b1bd71989&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleDestoryOrAttackButtonPress::__l2::&lt;lambda_a250f32d2aec155df20b3e6b1bd71989&gt;
{
};

</code></pre></div><h3 id="clientinputcallbacks-handledestoryorattackbuttonpress-l5-lambda-1768354503fc5fcd1469a64b30f27d5c"><a href="#clientinputcallbacks-handledestoryorattackbuttonpress-l5-lambda-1768354503fc5fcd1469a64b30f27d5c" class="header-anchor">#</a> <code>ClientInputCallbacks::handleDestoryOrAttackButtonPress::__l5::&lt;lambda_1768354503fc5fcd1469a64b30f27d5c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleDestoryOrAttackButtonPress::__l5::&lt;lambda_1768354503fc5fcd1469a64b30f27d5c&gt;
{
};

</code></pre></div><h3 id="clientinputcallbacks-handlescreenshotpress-l8-lambda-e70b5943a0b1cecdb66c029e8c0cbe0e"><a href="#clientinputcallbacks-handlescreenshotpress-l8-lambda-e70b5943a0b1cecdb66c029e8c0cbe0e" class="header-anchor">#</a> <code>ClientInputCallbacks::handleScreenshotPress::__l8::&lt;lambda_e70b5943a0b1cecdb66c029e8c0cbe0e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleScreenshotPress::__l8::&lt;lambda_e70b5943a0b1cecdb66c029e8c0cbe0e&gt;
{
  std::string filePath;
  IClientInstance *client;
};

</code></pre></div><h3 id="clientinputcallbacks-handlegotoreportcheatbuttonpress-l8-lambda-82f858da70d941e940912bb30990deca"><a href="#clientinputcallbacks-handlegotoreportcheatbuttonpress-l8-lambda-82f858da70d941e940912bb30990deca" class="header-anchor">#</a> <code>ClientInputCallbacks::handleGoToReportCheatButtonPress::__l8::&lt;lambda_82f858da70d941e940912bb30990deca&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handleGoToReportCheatButtonPress::__l8::&lt;lambda_82f858da70d941e940912bb30990deca&gt;
{
  std::string filePath;
  IClientInstance *client;
};

</code></pre></div><h3 id="clientinputcallbacks-handlepointerpressedbuttonpress-l2-lambda-ed584832a847dcbeef5b61997314db23"><a href="#clientinputcallbacks-handlepointerpressedbuttonpress-l2-lambda-ed584832a847dcbeef5b61997314db23" class="header-anchor">#</a> <code>ClientInputCallbacks::handlePointerPressedButtonPress::__l2::&lt;lambda_ed584832a847dcbeef5b61997314db23&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInputCallbacks::handlePointerPressedButtonPress::__l2::&lt;lambda_ed584832a847dcbeef5b61997314db23&gt;
{
};

</code></pre></div><h3 id="clientskinsystem-updateclientskin-l2-lambda-3edaec2b809ed40c0096426422f09c9f"><a href="#clientskinsystem-updateclientskin-l2-lambda-3edaec2b809ed40c0096426422f09c9f" class="header-anchor">#</a> <code>ClientSkinSystem::_updateClientSkin::__l2::&lt;lambda_3edaec2b809ed40c0096426422f09c9f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientSkinSystem::_updateClientSkin::__l2::&lt;lambda_3edaec2b809ed40c0096426422f09c9f&gt;
{
  std::weak_ptr&lt;IClientInstance&gt; weakClient;
  const std::string skinName;
  std::function&lt;void __cdecl(void)&gt; cb;
};

</code></pre></div><h3 id="clientinstance-startexternalnetworkworld-l2-lambda-2f4e89c11809877f171d784f43a2bb0a-l25-lambda-c3b381cfcfb0e0326cf8436579754cbd"><a href="#clientinstance-startexternalnetworkworld-l2-lambda-2f4e89c11809877f171d784f43a2bb0a-l25-lambda-c3b381cfcfb0e0326cf8436579754cbd" class="header-anchor">#</a> <code>ClientInstance::_startExternalNetworkWorld::__l2::&lt;lambda_2f4e89c11809877f171d784f43a2bb0a&gt;::()::__l25::&lt;lambda_c3b381cfcfb0e0326cf8436579754cbd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::_startExternalNetworkWorld::__l2::&lt;lambda_2f4e89c11809877f171d784f43a2bb0a&gt;::()::__l25::&lt;lambda_c3b381cfcfb0e0326cf8436579754cbd&gt;
{
  Social::GameConnectionInfo connectionInfo;
};

</code></pre></div><h3 id="clientinstance-linktoalloffers-l8-lambda-8c1c471bd4836df2d4db0c759413a7fe"><a href="#clientinstance-linktoalloffers-l8-lambda-8c1c471bd4836df2d4db0c759413a7fe" class="header-anchor">#</a> <code>ClientInstance::linkToAllOffers::__l8::&lt;lambda_8c1c471bd4836df2d4db0c759413a7fe&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::linkToAllOffers::__l8::&lt;lambda_8c1c471bd4836df2d4db0c759413a7fe&gt;
{
  ClientInstance *const __this;
};

</code></pre></div><h3 id="clientinstance-initttsclient-l5-lambda-385529706c5cafdb75cef3e23b3c0d1a"><a href="#clientinstance-initttsclient-l5-lambda-385529706c5cafdb75cef3e23b3c0d1a" class="header-anchor">#</a> <code>ClientInstance::initTTSClient::__l5::&lt;lambda_385529706c5cafdb75cef3e23b3c0d1a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClientInstance::initTTSClient::__l5::&lt;lambda_385529706c5cafdb75cef3e23b3c0d1a&gt;
{
};

</code></pre></div><h3 id="cooldownitemcomponent"><a href="#cooldownitemcomponent" class="header-anchor">#</a> <code>CooldownItemComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CooldownItemComponent : ItemComponent
{
  std::string mCoolDownType;
  float mCooldownTime;
};

</code></pre></div><h3 id="cooldownitemcomponent-vtbl"><a href="#cooldownitemcomponent-vtbl" class="header-anchor">#</a> <code>CooldownItemComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CooldownItemComponent_vtbl
{
  void (__fastcall *~ItemComponent)(ItemComponent *this);
  bool (__fastcall *checkComponentDataForContentErrors)(ItemComponent *this);
  void (__fastcall *writeSettings)(ItemComponent *this);
  bool (__fastcall *useOn)(ItemComponent *this, ItemStack *, Actor *, const BlockPos *, unsigned __int8, const Vec3 *);
  bool (__fastcall *isNetworkComponent)(ItemComponent *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(ItemComponent *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(ItemComponent *this, const CompoundTag *);
};

</code></pre></div><h3 id="channelimageparams"><a href="#channelimageparams" class="header-anchor">#</a> <code>ChannelImageParams</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChannelImageParams
{
  std::string mContentUrl;
};

</code></pre></div><h3 id="cg-details-dispatchtoken-std-shared-ptr-cg-details-worktoken-const-std-shared-ptr-std-function-void-cdecl-std-nullptr-t"><a href="#cg-details-dispatchtoken-std-shared-ptr-cg-details-worktoken-const-std-shared-ptr-std-function-void-cdecl-std-nullptr-t" class="header-anchor">#</a> <code>cg::details::DispatchToken&lt;std::shared_ptr&lt;cg::details::WorkToken const &gt;,std::shared_ptr&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj cg::details::DispatchToken&lt;std::shared_ptr&lt;cg::details::WorkToken const &gt;,std::shared_ptr&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt; &gt; &gt;
{
  std::shared_ptr&lt;cg::details::WorkToken const &gt; mToken;
  std::optional&lt;std::shared_ptr&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt; &gt; &gt; mResult;
};

</code></pre></div><h3 id="commandlistfuture"><a href="#commandlistfuture" class="header-anchor">#</a> <code>CommandListFuture</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommandListFuture
{
  std::variant&lt;std::function&lt;void __cdecl(CommandListTaskContext &amp;)&gt;,std::shared_ptr&lt;cg::details::DispatchToken&lt;std::shared_ptr&lt;cg::details::WorkToken const &gt;,std::shared_ptr&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt; &gt; &gt; const &gt; &gt; mWork;
};

</code></pre></div><h3 id="completionstate"><a href="#completionstate" class="header-anchor">#</a> <code>CompletionState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CompletionState
{
};

</code></pre></div><h3 id="cg-taskdispatcherschedulertraits-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const"><a href="#cg-taskdispatcherschedulertraits-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const" class="header-anchor">#</a> <code>cg::TaskDispatcherSchedulerTraits&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TaskDispatcherSchedulerTraits&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;
{
};

</code></pre></div><h3 id="cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution"><a href="#cg-taskdispatcher-cg-taskscheduler-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-taskdispatcherexecution" class="header-anchor">#</a> <code>cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::TaskDispatcher&lt;cg::TaskScheduler&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt; &gt; &gt;::TaskDispatcherExecution
{
};

</code></pre></div><h3 id="changeuserstage"><a href="#changeuserstage" class="header-anchor">#</a> <code>ChangeUserStage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChangeUserStage : BaseStage
{
};

</code></pre></div><h3 id="changeuserstage-vtbl"><a href="#changeuserstage-vtbl" class="header-anchor">#</a> <code>ChangeUserStage_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChangeUserStage_vtbl
{
  void (__fastcall *~BaseStage)(BaseStage *this);
  void (__fastcall *onAwake)(BaseStage *this);
  void (__fastcall *onUpdate)(BaseStage *this);
  bool (__fastcall *ayncTask)(BaseStage *this);
};

</code></pre></div><h3 id="crypto-random-random"><a href="#crypto-random-random" class="header-anchor">#</a> <code>Crypto::Random::Random</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Crypto::Random::Random
{
  std::random_device rd;
};

</code></pre></div><h3 id="core-filesysteminterfaceimpl"><a href="#core-filesysteminterfaceimpl" class="header-anchor">#</a> <code>Core::FileSystemInterfaceImpl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::FileSystemInterfaceImpl : Core::IFileSystem
{
};

</code></pre></div><h3 id="core-filesysteminterfaceimpl-vtbl"><a href="#core-filesysteminterfaceimpl-vtbl" class="header-anchor">#</a> <code>Core::FileSystemInterfaceImpl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Core::FileSystemInterfaceImpl_vtbl
{
  void (__fastcall *~IFileSystem)(Core::IFileSystem *this);
  std::unique_ptr&lt;Core::IFile&gt; *(__fastcall *openFile)(Core::IFileSystem *this, std::unique_ptr&lt;Core::IFile&gt; *result, Core::Path, Core::FileOpenMode, Core::FileBufferingMode);
  bool (__fastcall *fileExists)(Core::IFileSystem *this, Core::Path);
  Core::Result *(__fastcall *iterateOverDirectory)(Core::IFileSystem *this, Core::Result *result, Core::Path, Core::DirectoryIterationFlags, std::function&lt;Core::Result __cdecl(Core::DirectoryIterationItem const &amp;)&gt;);
  Core::Result *(__fastcall *getDirectoryFiles)(Core::IFileSystem *this, Core::Result *result, std::vector&lt;Core::PathBuffer&lt;std::string &gt;&gt; *, Core::Path);
};

</code></pre></div><h3 id="core-profile-profilesectioncpu"><a href="#core-profile-profilesectioncpu" class="header-anchor">#</a> <code>Core::Profile::ProfileSectionCPU</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Profile::ProfileSectionCPU
{
  const Core::Profile::CPUProfileTokenMicroProfile *mToken;
};

</code></pre></div><h3 id="cg-igraphicsdevicevendorprovider"><a href="#cg-igraphicsdevicevendorprovider" class="header-anchor">#</a> <code>cg::IGraphicsDeviceVendorProvider</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::IGraphicsDeviceVendorProvider : Bedrock::EnableNonOwnerReferences
{
  cg::IGraphicsDeviceVendorProvider_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="cg-igraphicsdevicevendorprovider-vtbl"><a href="#cg-igraphicsdevicevendorprovider-vtbl" class="header-anchor">#</a> <code>cg::IGraphicsDeviceVendorProvider_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ cg::IGraphicsDeviceVendorProvider_vtbl
{
  void (__fastcall *~IGraphicsDeviceVendorProvider)(cg::IGraphicsDeviceVendorProvider *this);
  unsigned int (__fastcall *getVendorID)(cg::IGraphicsDeviceVendorProvider *this);
};

</code></pre></div><h3 id="core-profile-filecounters"><a href="#core-profile-filecounters" class="header-anchor">#</a> <code>Core::Profile::FileCounters</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Core::Profile::FileCounters
{
  unsigned __int64 requests;
  unsigned __int64 retries;
  unsigned __int64 retrySuccess;
  unsigned __int64 failures;
};

</code></pre></div><h3 id="collectioncomponent"><a href="#collectioncomponent" class="header-anchor">#</a> <code>CollectionComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CollectionComponent : UIComponent
{
  int mCurrentLength;
  std::string mCollectionName;
  std::vector&lt;std::string&gt; mControlBindings;
};

</code></pre></div><h3 id="collectioncomponent-vtbl"><a href="#collectioncomponent-vtbl" class="header-anchor">#</a> <code>CollectionComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CollectionComponent_vtbl
{
  void (__fastcall *~UIComponent)(UIComponent *this);
  void (__fastcall *OnScreenPop)(UIComponent *this);
  std::unique_ptr&lt;UIComponent&gt; *(__fastcall *clone)(UIComponent *this, std::unique_ptr&lt;UIComponent&gt; *result, UIControl *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, const ScreenEvent *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, VisualTree *, ScreenInputContext *, UIAnimationController *, const ScreenEvent *);
  void (__fastcall *onNotifyChildAdded)(UIComponent *this);
  void (__fastcall *onNotifyChildRemoved)(UIComponent *this);
  void (__fastcall *onRemoved)(UIComponent *this);
  void (__fastcall *onAdded)(UIComponent *this);
  void (__fastcall *onVisibilityChanged)(UIComponent *this, bool);
  void (__fastcall *onEnabledChanged)(UIComponent *this, bool);
  bool (__fastcall *isRenderableComponent)(UIComponent *this);
  bool (__fastcall *onLayoutChange)(UIComponent *this);
  void (__fastcall *reset)(UIComponent *this);
  void (__fastcall *reload)(UIComponent *this, const UIComponent *);
  const std::string *(__fastcall *getTextToSpeechComponentValue)(UIComponent *this);
};

</code></pre></div><h3 id="collectionitemcomponent"><a href="#collectionitemcomponent" class="header-anchor">#</a> <code>CollectionItemComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CollectionItemComponent : UIComponent
{
  int mCollectionIndex;
};

</code></pre></div><h3 id="collectionitemcomponent-vtbl"><a href="#collectionitemcomponent-vtbl" class="header-anchor">#</a> <code>CollectionItemComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CollectionItemComponent_vtbl
{
  void (__fastcall *~UIComponent)(UIComponent *this);
  void (__fastcall *OnScreenPop)(UIComponent *this);
  std::unique_ptr&lt;UIComponent&gt; *(__fastcall *clone)(UIComponent *this, std::unique_ptr&lt;UIComponent&gt; *result, UIControl *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, const ScreenEvent *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, VisualTree *, ScreenInputContext *, UIAnimationController *, const ScreenEvent *);
  void (__fastcall *onNotifyChildAdded)(UIComponent *this);
  void (__fastcall *onNotifyChildRemoved)(UIComponent *this);
  void (__fastcall *onRemoved)(UIComponent *this);
  void (__fastcall *onAdded)(UIComponent *this);
  void (__fastcall *onVisibilityChanged)(UIComponent *this, bool);
  void (__fastcall *onEnabledChanged)(UIComponent *this, bool);
  bool (__fastcall *isRenderableComponent)(UIComponent *this);
  bool (__fastcall *onLayoutChange)(UIComponent *this);
  void (__fastcall *reset)(UIComponent *this);
  void (__fastcall *reload)(UIComponent *this, const UIComponent *);
  const std::string *(__fastcall *getTextToSpeechComponentValue)(UIComponent *this);
};

</code></pre></div><h3 id="cliparea"><a href="#cliparea" class="header-anchor">#</a> <code>ClipArea</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ClipArea
{
  glm::tvec2&lt;float,0&gt; mTopLeftClip;
  glm::tvec2&lt;float,0&gt; mBottomRightClip;
};

</code></pre></div><h3 id="cg-schedulerexecutiontraits-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-cg-details-worktoken"><a href="#cg-schedulerexecutiontraits-cg-lambdaexecutor-std-nullptr-t-cg-taskpoolgroupexecutionpolicy-std-nullptr-t-1-std-string-const-std-vector-cg-grouppooldescription-const-cg-details-worktoken" class="header-anchor">#</a> <code>cg::SchedulerExecutionTraits&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;,cg::details::WorkToken&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj cg::SchedulerExecutionTraits&lt;cg::LambdaExecutor&lt;std::nullptr_t,cg::TaskPoolGroupExecutionPolicy&lt;std::nullptr_t,1&gt;,std::string const &amp;,std::vector&lt;cg::GroupPoolDescription&gt; const &amp;&gt;,cg::details::WorkToken&gt;
{
};

</code></pre></div><h3 id="creditsrenderer-creditscontent"><a href="#creditsrenderer-creditscontent" class="header-anchor">#</a> <code>CreditsRenderer::CreditsContent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreditsRenderer::CreditsContent
{
  CreditsRenderer::CreditsContent::Type mType;
  int mHeight;
  int mPaddingAfter;
  std::string mText;
  bool mCentered;
  mce::TexturePtr mTexturePtr;
};

</code></pre></div><h3 id="creditsrenderer"><a href="#creditsrenderer" class="header-anchor">#</a> <code>CreditsRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CreditsRenderer : MinecraftUICustomRenderer
{
  bool mInitialized;
  glm::tvec2&lt;float,0&gt; mOwnerSize;
  std::vector&lt;CreditsRenderer::CreditsContent&gt; mContent;
  unsigned int mIndex;
  float mCurrentOffset;
  std::string mPlayerName;
  float mScrollSpeed;
  bool mFinished;
  std::vector&lt;ScreenEvent&gt; mScreenEvents;
  unsigned int mCreditsEndEventId;
  long double mTimeNowSeconds;
  long double mTimeLastSeconds;
  long double mDeltaTimeSeconds;
};

</code></pre></div><h3 id="creditsrenderer-vtbl"><a href="#creditsrenderer-vtbl" class="header-anchor">#</a> <code>CreditsRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CreditsRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="callbackprogresshandler"><a href="#callbackprogresshandler" class="header-anchor">#</a> <code>CallbackProgressHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) CallbackProgressHandler : EmptyProgressHandler
{
  std::function&lt;enum LoadingState __cdecl(void)&gt; mOnStart;
  _BYTE mLoadingState[4];
};

</code></pre></div><h3 id="callbackprogresshandler-vtbl"><a href="#callbackprogresshandler-vtbl" class="header-anchor">#</a> <code>CallbackProgressHandler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CallbackProgressHandler_vtbl
{
  void (__fastcall *~ProgressHandler)(ProgressHandler *this);
  void (__fastcall *onStart)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *tick)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onCancel)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onExit)(ProgressHandler *this, MinecraftScreenModel *);
  LoadingState (__fastcall *getLoadingState)(ProgressHandler *this, MinecraftScreenModel *);
  float (__fastcall *getLoadingProgress)(ProgressHandler *this, MinecraftScreenModel *);
  std::string *(__fastcall *getProgressMessage)(ProgressHandler *this, std::string *result, MinecraftScreenModel *);
  void (__fastcall *addEventProperties)(ProgressHandler *this, std::unordered_map&lt;std::string,std::string&gt; *);
  std::string *(__fastcall *getTTSProgressMessage)(ProgressHandler *this, std::string *result);
  std::string *(__fastcall *getTitleText)(ProgressHandler *this, std::string *result);
  ProgressAnimation (__fastcall *showLoadingBar)(ProgressHandler *this);
};

</code></pre></div><h3 id="contentlogfiledeleteprogresshandler"><a href="#contentlogfiledeleteprogresshandler" class="header-anchor">#</a> <code>ContentLogFileDeleteProgressHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLogFileDeleteProgressHandler : ProgressHandler
{
  std::unique_ptr&lt;TaskGroup&gt; mIOTaskGroup;
};

</code></pre></div><h3 id="contentlogfiledeleteprogresshandler-vtbl"><a href="#contentlogfiledeleteprogresshandler-vtbl" class="header-anchor">#</a> <code>ContentLogFileDeleteProgressHandler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentLogFileDeleteProgressHandler_vtbl
{
  void (__fastcall *~ProgressHandler)(ProgressHandler *this);
  void (__fastcall *onStart)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *tick)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onCancel)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onExit)(ProgressHandler *this, MinecraftScreenModel *);
  LoadingState (__fastcall *getLoadingState)(ProgressHandler *this, MinecraftScreenModel *);
  float (__fastcall *getLoadingProgress)(ProgressHandler *this, MinecraftScreenModel *);
  std::string *(__fastcall *getProgressMessage)(ProgressHandler *this, std::string *result, MinecraftScreenModel *);
  void (__fastcall *addEventProperties)(ProgressHandler *this, std::unordered_map&lt;std::string,std::string&gt; *);
  std::string *(__fastcall *getTTSProgressMessage)(ProgressHandler *this, std::string *result);
  std::string *(__fastcall *getTitleText)(ProgressHandler *this, std::string *result);
  ProgressAnimation (__fastcall *showLoadingBar)(ProgressHandler *this);
};

</code></pre></div><h3 id="contentlogfiledeleteprogresshandler-onstart-l2-lambda-4c44ad55a9de036e094d9593064c39b6"><a href="#contentlogfiledeleteprogresshandler-onstart-l2-lambda-4c44ad55a9de036e094d9593064c39b6" class="header-anchor">#</a> <code>ContentLogFileDeleteProgressHandler::onStart::__l2::&lt;lambda_4c44ad55a9de036e094d9593064c39b6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLogFileDeleteProgressHandler::onStart::__l2::&lt;lambda_4c44ad55a9de036e094d9593064c39b6&gt;
{
  std::weak_ptr&lt;MinecraftScreenModel&gt; weakModel;
};

</code></pre></div><h3 id="contentlogfiledeleteprogresshandler-onstart-l2-lambda-df8545a0f7b237ada6fdb7790c17e3e2"><a href="#contentlogfiledeleteprogresshandler-onstart-l2-lambda-df8545a0f7b237ada6fdb7790c17e3e2" class="header-anchor">#</a> <code>ContentLogFileDeleteProgressHandler::onStart::__l2::&lt;lambda_df8545a0f7b237ada6fdb7790c17e3e2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLogFileDeleteProgressHandler::onStart::__l2::&lt;lambda_df8545a0f7b237ada6fdb7790c17e3e2&gt;
{
  std::weak_ptr&lt;MinecraftScreenModel&gt; weakModel;
};

</code></pre></div><h3 id="checkdoneprogresshandler"><a href="#checkdoneprogresshandler" class="header-anchor">#</a> <code>CheckDoneProgressHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CheckDoneProgressHandler : EmptyProgressHandler
{
};

</code></pre></div><h3 id="checkdoneprogresshandler-vtbl"><a href="#checkdoneprogresshandler-vtbl" class="header-anchor">#</a> <code>CheckDoneProgressHandler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CheckDoneProgressHandler_vtbl
{
  void (__fastcall *~ProgressHandler)(ProgressHandler *this);
  void (__fastcall *onStart)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *tick)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onCancel)(ProgressHandler *this, MinecraftScreenModel *);
  void (__fastcall *onExit)(ProgressHandler *this, MinecraftScreenModel *);
  LoadingState (__fastcall *getLoadingState)(ProgressHandler *this, MinecraftScreenModel *);
  float (__fastcall *getLoadingProgress)(ProgressHandler *this, MinecraftScreenModel *);
  std::string *(__fastcall *getProgressMessage)(ProgressHandler *this, std::string *result, MinecraftScreenModel *);
  void (__fastcall *addEventProperties)(ProgressHandler *this, std::unordered_map&lt;std::string,std::string&gt; *);
  std::string *(__fastcall *getTTSProgressMessage)(ProgressHandler *this, std::string *result);
  std::string *(__fastcall *getTitleText)(ProgressHandler *this, std::string *result);
  ProgressAnimation (__fastcall *showLoadingBar)(ProgressHandler *this);
};

</code></pre></div><h3 id="containerinteractionstatemachine"><a href="#containerinteractionstatemachine" class="header-anchor">#</a> <code>ContainerInteractionStateMachine</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ContainerInteractionStateMachine
{
  Node mCurrentNode;
  _BYTE mCurrentNodeId[4];
  _BYTE mDefaultNodeId[4];
  std::unordered_map&lt;int,Node&gt; mNodes;
  std::unordered_map&lt;int,std::vector&lt;ButtonEdge&gt;&gt; mButtonEdges;
  std::unordered_map&lt;int,std::vector&lt;PointerHeldEdge&gt;&gt; mPointerHeldEdges;
  _BYTE mNodeChangeRequest[4];
};

</code></pre></div><h3 id="cannotusenetworkfeaturesscreencontroller"><a href="#cannotusenetworkfeaturesscreencontroller" class="header-anchor">#</a> <code>CannotUseNetworkFeaturesScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CannotUseNetworkFeaturesScreenController : MinecraftScreenController
{
  std::function&lt;void __cdecl(bool)&gt; mCallback;
};

</code></pre></div><h3 id="cannotusenetworkfeaturesscreencontroller-vtbl"><a href="#cannotusenetworkfeaturesscreencontroller-vtbl" class="header-anchor">#</a> <code>CannotUseNetworkFeaturesScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CannotUseNetworkFeaturesScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="cellulardatawarningscreencontroller"><a href="#cellulardatawarningscreencontroller" class="header-anchor">#</a> <code>CellularDataWarningScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CellularDataWarningScreenController : MinecraftScreenController
{
  std::function&lt;void __cdecl(bool)&gt; mCallback;
};

</code></pre></div><h3 id="cellulardatawarningscreencontroller-vtbl"><a href="#cellulardatawarningscreencontroller-vtbl" class="header-anchor">#</a> <code>CellularDataWarningScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CellularDataWarningScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="chalkboardscreencontroller"><a href="#chalkboardscreencontroller" class="header-anchor">#</a> <code>ChalkboardScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) ChalkboardScreenController : ClientInstanceScreenController
{
  std::unique_ptr&lt;DeferredTextObject&gt; mDeferredTextObject;
  BlockPos mBlockPosition;
  bool mLockVisible;
};

</code></pre></div><h3 id="chalkboardscreencontroller-vtbl"><a href="#chalkboardscreencontroller-vtbl" class="header-anchor">#</a> <code>ChalkboardScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChalkboardScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="chalkboardscreencontroller-registerbindings-l2-lambda-c19ad1e94829ad65b348c00d4b053945"><a href="#chalkboardscreencontroller-registerbindings-l2-lambda-c19ad1e94829ad65b348c00d4b053945" class="header-anchor">#</a> <code>ChalkboardScreenController::_registerBindings::__l2::&lt;lambda_c19ad1e94829ad65b348c00d4b053945&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChalkboardScreenController::_registerBindings::__l2::&lt;lambda_c19ad1e94829ad65b348c00d4b053945&gt;
{
  ChalkboardScreenController *const __this;
};

</code></pre></div><h3 id="chalkboardscreencontroller-registerbindings-l2-lambda-e6cf651c2b9c075e876ca69014ef3811"><a href="#chalkboardscreencontroller-registerbindings-l2-lambda-e6cf651c2b9c075e876ca69014ef3811" class="header-anchor">#</a> <code>ChalkboardScreenController::_registerBindings::__l2::&lt;lambda_e6cf651c2b9c075e876ca69014ef3811&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChalkboardScreenController::_registerBindings::__l2::&lt;lambda_e6cf651c2b9c075e876ca69014ef3811&gt;
{
  ChalkboardScreenController *const __this;
};

</code></pre></div><h3 id="chalkboardscreencontroller-registerbindings-l2-lambda-af391edb9ee7620a22893f79e25173cc"><a href="#chalkboardscreencontroller-registerbindings-l2-lambda-af391edb9ee7620a22893f79e25173cc" class="header-anchor">#</a> <code>ChalkboardScreenController::_registerBindings::__l2::&lt;lambda_af391edb9ee7620a22893f79e25173cc&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChalkboardScreenController::_registerBindings::__l2::&lt;lambda_af391edb9ee7620a22893f79e25173cc&gt;
{
  ChalkboardScreenController *const __this;
};

</code></pre></div><h3 id="chalkboardscreencontroller-registerbindings-l2-lambda-8c03d1cb961bf5361ba907cd86efe50f"><a href="#chalkboardscreencontroller-registerbindings-l2-lambda-8c03d1cb961bf5361ba907cd86efe50f" class="header-anchor">#</a> <code>ChalkboardScreenController::_registerBindings::__l2::&lt;lambda_8c03d1cb961bf5361ba907cd86efe50f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChalkboardScreenController::_registerBindings::__l2::&lt;lambda_8c03d1cb961bf5361ba907cd86efe50f&gt;
{
  ChalkboardScreenController *const __this;
};

</code></pre></div><h3 id="chalkboardscreencontroller-registereventhandlers-l2-lambda-fa542fb72eb60c5ac5c4fac0c505fbf8"><a href="#chalkboardscreencontroller-registereventhandlers-l2-lambda-fa542fb72eb60c5ac5c4fac0c505fbf8" class="header-anchor">#</a> <code>ChalkboardScreenController::_registerEventHandlers::__l2::&lt;lambda_fa542fb72eb60c5ac5c4fac0c505fbf8&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChalkboardScreenController::_registerEventHandlers::__l2::&lt;lambda_fa542fb72eb60c5ac5c4fac0c505fbf8&gt;
{
  ChalkboardScreenController *const __this;
};

</code></pre></div><h3 id="chalkboardscreencontroller-registereventhandlers-l2-lambda-b42cf05c41a2e21b640eb802e5774fa5"><a href="#chalkboardscreencontroller-registereventhandlers-l2-lambda-b42cf05c41a2e21b640eb802e5774fa5" class="header-anchor">#</a> <code>ChalkboardScreenController::_registerEventHandlers::__l2::&lt;lambda_b42cf05c41a2e21b640eb802e5774fa5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChalkboardScreenController::_registerEventHandlers::__l2::&lt;lambda_b42cf05c41a2e21b640eb802e5774fa5&gt;
{
  ChalkboardScreenController *const __this;
};

</code></pre></div><h3 id="chalkboardscreencontroller-ctor-l2-lambda-fff40c3734e5a3c973fe8967245ac69b"><a href="#chalkboardscreencontroller-ctor-l2-lambda-fff40c3734e5a3c973fe8967245ac69b" class="header-anchor">#</a> <code>ChalkboardScreenController::{ctor}::__l2::&lt;lambda_fff40c3734e5a3c973fe8967245ac69b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChalkboardScreenController::{ctor}::__l2::&lt;lambda_fff40c3734e5a3c973fe8967245ac69b&gt;
{
  ChalkboardScreenController *const __this;
};

</code></pre></div><h3 id="cellulardatawarningscreencontroller-onopen-l2-lambda-6d10d2c4851a646b8d330e59b5f34f14"><a href="#cellulardatawarningscreencontroller-onopen-l2-lambda-6d10d2c4851a646b8d330e59b5f34f14" class="header-anchor">#</a> <code>CellularDataWarningScreenController::onOpen::__l2::&lt;lambda_6d10d2c4851a646b8d330e59b5f34f14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CellularDataWarningScreenController::onOpen::__l2::&lt;lambda_6d10d2c4851a646b8d330e59b5f34f14&gt;
{
  std::weak_ptr&lt;CellularDataWarningScreenController&gt; weakThis;
};

</code></pre></div><h3 id="cannotusenetworkfeaturesscreencontroller-onopen-l2-lambda-b48d9a7038debf97dda08a06e326b111"><a href="#cannotusenetworkfeaturesscreencontroller-onopen-l2-lambda-b48d9a7038debf97dda08a06e326b111" class="header-anchor">#</a> <code>CannotUseNetworkFeaturesScreenController::onOpen::__l2::&lt;lambda_b48d9a7038debf97dda08a06e326b111&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CannotUseNetworkFeaturesScreenController::onOpen::__l2::&lt;lambda_b48d9a7038debf97dda08a06e326b111&gt;
{
  std::weak_ptr&lt;CannotUseNetworkFeaturesScreenController&gt; weakThis;
};

</code></pre></div><h3 id="chatsettingsscreencontroller-chatsettings"><a href="#chatsettingsscreencontroller-chatsettings" class="header-anchor">#</a> <code>ChatSettingsScreenController::ChatSettings</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct ChatSettingsScreenController::ChatSettings
{
  bool mIsChatMute;
  bool mIsTTSOn;
  Typeface mTypeface;
  int mFontSize;
  float mLineSpacing;
  int mChatColorCode;
  int mMentionsColorCode;
};

</code></pre></div><h3 id="chatsettingsscreencontroller"><a href="#chatsettingsscreencontroller" class="header-anchor">#</a> <code>ChatSettingsScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChatSettingsScreenController : ClientInstanceScreenController
{
  ChatSettingsScreenController::ChatSettings mInitialSettings;
  ChatSettingsScreenController::ChatSettings mSettings;
  const bool mLanguageCanBeSmooth;
  std::function&lt;void __cdecl(void)&gt; mRefreshChatCallback;
};

</code></pre></div><h3 id="chatsettingsscreencontroller-vtbl"><a href="#chatsettingsscreencontroller-vtbl" class="header-anchor">#</a> <code>ChatSettingsScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChatSettingsScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="chatscreencontroller"><a href="#chatscreencontroller" class="header-anchor">#</a> <code>ChatScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ChatScreenController : ClientInstanceScreenController
{
  std::string mCurrentMessage;
  bool mRefreshChatMessages;
  int mCurrentSentMessageIndex;
  bool mNeedsLayoutUpdate;
  bool mLastKeyboardActive;
  bool mIsDevConsole;
  bool mSendMessage;
  bool mUpdateIntellisense;
  IntellisenseHandler mIntellisense;
  _BYTE mCurrentHostOption[4];
  std::vector&lt;std::string&gt; mHostCommands;
  unsigned int mExpectedCommandDepth;
  std::string mTeleportWhoName;
  std::string mTeleportWhereName;
  std::string mDeferedCollectionFocusName;
  int mDeferedCollectionFocusIndex;
  bool mWaitOneTick;
  std::vector&lt;std::pair&lt;enum HostOptionStates,std::string &gt;&gt; mMainHostButtons;
};

</code></pre></div><h3 id="chatscreencontroller-vtbl"><a href="#chatscreencontroller-vtbl" class="header-anchor">#</a> <code>ChatScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChatScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="chooserealmscreencontroller-realmsworld"><a href="#chooserealmscreencontroller-realmsworld" class="header-anchor">#</a> <code>ChooseRealmScreenController::RealmsWorld</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ChooseRealmScreenController::RealmsWorld
{
  RealmsWorldInfo world;
  bool doneLoading;
};

</code></pre></div><h3 id="chooserealmscreencontroller"><a href="#chooserealmscreencontroller" class="header-anchor">#</a> <code>ChooseRealmScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ChooseRealmScreenController : MainMenuScreenController
{
  bool mDirty;
  std::vector&lt;Realms::World&gt; mRealms;
  std::vector&lt;ChooseRealmScreenController::RealmsWorld&gt; mRealmWorldList;
  std::function&lt;void __cdecl(Realms::World)&gt; mCallback;
  ChooseRealmScreenController::RealmsSubscriptionsLoadingState mRealmsSubscriptionsLoadingState;
};

</code></pre></div><h3 id="chooserealmscreencontroller-vtbl"><a href="#chooserealmscreencontroller-vtbl" class="header-anchor">#</a> <code>ChooseRealmScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ChooseRealmScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="codescreencontrollerproxy"><a href="#codescreencontrollerproxy" class="header-anchor">#</a> <code>CodeScreenControllerProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CodeScreenControllerProxy : ScreenControllerProxy
{
};

</code></pre></div><h3 id="codescreencontrollerproxy-vtbl"><a href="#codescreencontrollerproxy-vtbl" class="header-anchor">#</a> <code>CodeScreenControllerProxy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CodeScreenControllerProxy_vtbl
{
  void (__fastcall *~ScreenControllerProxy)(ScreenControllerProxy *this);
  void (__fastcall *selectCodeButton)(CodeScreenControllerProxy *this, int);
};

</code></pre></div><h3 id="codescreeneditorbutton"><a href="#codescreeneditorbutton" class="header-anchor">#</a> <code>CodeScreenEditorButton</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CodeScreenEditorButton
{
  std::string name;
  std::string description;
  std::string url;
  std::string defaultImage;
};

</code></pre></div><h3 id="codescreencontroller"><a href="#codescreencontroller" class="header-anchor">#</a> <code>CodeScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CodeScreenController : ClientInstanceScreenController, CodeScreenControllerProxy, WebviewObserver
{
  std::vector&lt;CodeScreenEditorButton&gt; mEditorButtons;
  std::string mChosenUrl;
  CodeScreenController::View mView;
  _BYTE mModalView[4];
  bool mNeedsRefresh;
  bool mWebviewLoading;
  bool mHasDefaultUri;
  bool mHasOverrideUri;
  WebviewInterfaceOptions mCodebuilderDef;
};

</code></pre></div><h3 id="codescreencontroller-vtbl"><a href="#codescreencontroller-vtbl" class="header-anchor">#</a> <code>CodeScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CodeScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="codescreencontroller-registerbindings-l2-lambda-16de65ca34e12ac497d252dfd6d10cf9"><a href="#codescreencontroller-registerbindings-l2-lambda-16de65ca34e12ac497d252dfd6d10cf9" class="header-anchor">#</a> <code>CodeScreenController::_registerBindings::__l2::&lt;lambda_16de65ca34e12ac497d252dfd6d10cf9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CodeScreenController::_registerBindings::__l2::&lt;lambda_16de65ca34e12ac497d252dfd6d10cf9&gt;
{
  CodeScreenController *const __this;
};

</code></pre></div><h3 id="commondialoginfoscreencontroller"><a href="#commondialoginfoscreencontroller" class="header-anchor">#</a> <code>CommonDialogInfoScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CommonDialogInfoScreenController : MinecraftScreenController
{
  const std::string mDialogTitle;
  const std::string mDialogBody;
};

</code></pre></div><h3 id="commondialoginfoscreencontroller-vtbl"><a href="#commondialoginfoscreencontroller-vtbl" class="header-anchor">#</a> <code>CommonDialogInfoScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ CommonDialogInfoScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="connectgamepadscreencontroller"><a href="#connectgamepadscreencontroller" class="header-anchor">#</a> <code>ConnectGamepadScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ConnectGamepadScreenController : MinecraftScreenController
{
  std::function&lt;void __cdecl(void)&gt; mOnCompleteCallback;
};

</code></pre></div><h3 id="connectgamepadscreencontroller-vtbl"><a href="#connectgamepadscreencontroller-vtbl" class="header-anchor">#</a> <code>ConnectGamepadScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConnectGamepadScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="containerscreencontroller"><a href="#containerscreencontroller" class="header-anchor">#</a> <code>ContainerScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ContainerScreenController : ClientInstanceScreenController
{
  BlockPos mBlockPos;
  ActorUniqueID mEntityUniqueID;
  _BYTE mTypeInContainer[4];
  bool mShowItemCategory;
  ContainerInteractionStateMachine mContainerStateMachine;
  SlotData mLastStateSlot;
  int mLastPlacedAmount;
  bool mSingleSplit;
  SlotData mTouchSplitData;
  ItemGroup mSelectedSplitTarget;
  ProgressiveTakeButtonData mProgressiveTakeButton;
  unsigned int mTouchProgressiveSelectButton;
  std::vector&lt;ItemStateData&gt; mPreviousState;
  SlotData mSelectedSlotData;
  SlotData mLastSelectedSlotData;
  SlotData mHoveredSlotData;
  std::unordered_map&lt;std::string,std::vector&lt;std::string&gt;&gt; mCoalesceOrderMap;
  std::unordered_map&lt;std::string,std::vector&lt;AutoPlaceItem&gt;&gt; mAutoPlaceOrderMap;
  InteractionModel mInteractionModel;
  std::shared_ptr&lt;ContainerManagerController&gt; mContainerManagerController;
  bool mNeedsUpdatedBinds;
};

</code></pre></div><h3 id="containerscreencontroller-vtbl"><a href="#containerscreencontroller-vtbl" class="header-anchor">#</a> <code>ContainerScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
  void (__fastcall *_handlePlaceAll)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_handlePlaceOne)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_handleSelectSlot)(ContainerScreenController *this, const std::string *, int);
  const SelectedSlotInfo *(__fastcall *_getSelectedSlotInfo)(ContainerScreenController *this, const SelectedSlotInfo *result);
  const ItemStack *(__fastcall *_getItemStack)(ContainerScreenController *this, const std::string *, int);
  const ItemStackBase *(__fastcall *_getVisualItemStack)(ContainerScreenController *this, const std::string *, int);
  const ItemStackBase *(__fastcall *_getTakeableItemStackBase)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotHovered)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotSelected)(ContainerScreenController *this, const std::string *, int);
  ui::ViewRequest (__fastcall *_onContainerSlotPressed)(ContainerScreenController *this, const std::string *, int);
  bool (__fastcall *_shouldSwap)(ContainerScreenController *this, const std::string *, int, const std::string *, int);
  std::string *(__fastcall *_getCollectionName)(ContainerScreenController *this, std::string *result, UIPropertyBag *);
  bool (__fastcall *_canSplit)(ContainerScreenController *this, const std::string *, int);
  void (__fastcall *_sendFlyingItem)(ContainerScreenController *this, const ItemStackBase *, const std::string *, int, const std::string *, int);
  void (__fastcall *_registerCoalesceOrder)(ContainerScreenController *this);
  void (__fastcall *_registerAutoPlaceOrder)(ContainerScreenController *this);
};

</code></pre></div><h3 id="containerfactory"><a href="#containerfactory" class="header-anchor">#</a> <code>ContainerFactory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerFactory
{
};

</code></pre></div><h3 id="containerscreencontrollerproxycallbacks"><a href="#containerscreencontrollerproxycallbacks" class="header-anchor">#</a> <code>ContainerScreenControllerProxyCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerScreenControllerProxyCallbacks
{
  std::function&lt;ItemStack const &amp; __cdecl(std::string const &amp;,int)&gt; mGetItemInstance;
  std::function&lt;void __cdecl(int,std::string const &amp;,int)&gt; mAutoPlace;
  std::function&lt;unsigned int __cdecl(std::string const &amp;)&gt; mGetNameId;
  std::function&lt;enum NodeId __cdecl(unsigned int,enum ButtonEventType,std::string const &amp;,int)&gt; mReceiveEvent;
};

</code></pre></div><h3 id="containerscreencontrollerproxy"><a href="#containerscreencontrollerproxy" class="header-anchor">#</a> <code>ContainerScreenControllerProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContainerScreenControllerProxy : ScreenControllerProxy
{
  const ContainerScreenControllerProxyCallbacks mCallbacks;
};

</code></pre></div><h3 id="containerscreencontrollerproxy-vtbl"><a href="#containerscreencontrollerproxy-vtbl" class="header-anchor">#</a> <code>ContainerScreenControllerProxy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContainerScreenControllerProxy_vtbl
{
  void (__fastcall *~ScreenControllerProxy)(ScreenControllerProxy *this);
};

</code></pre></div><h3 id="contentlogscreencontroller"><a href="#contentlogscreencontroller" class="header-anchor">#</a> <code>ContentLogScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLogScreenController : MinecraftScreenController
{
};

</code></pre></div><h3 id="contentlogscreencontroller-vtbl"><a href="#contentlogscreencontroller-vtbl" class="header-anchor">#</a> <code>ContentLogScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentLogScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="contentloghistoryscreencontroller"><a href="#contentloghistoryscreencontroller" class="header-anchor">#</a> <code>ContentLogHistoryScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ContentLogHistoryScreenController : MinecraftScreenController
{
};

</code></pre></div><h3 id="contentloghistoryscreencontroller-vtbl"><a href="#contentloghistoryscreencontroller-vtbl" class="header-anchor">#</a> <code>ContentLogHistoryScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ContentLogHistoryScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="controlssettingsscreencontroller"><a href="#controlssettingsscreencontroller" class="header-anchor">#</a> <code>ControlsSettingsScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ControlsSettingsScreenController : SettingsScreenControllerBase
{
  GamePadRemappingLayout *mGamepadLayout;
  std::vector&lt;ControlsSettingsScreenController::BindingInfo&gt; mGamepadBindings;
  KeyboardType mCurrentKeyboardType;
  std::vector&lt;ControlsSettingsScreenController::KeyboardLayoutInfo&gt; mKeyboardLayoutInformation;
  int mSelectedIndex;
  InputBindingMode mActiveBindingMode;
  const std::vector&lt;std::string&gt; *mDisabledInputMappings;
};

</code></pre></div><h3 id="controlssettingsscreencontroller-bindinginfo"><a href="#controlssettingsscreencontroller-bindinginfo" class="header-anchor">#</a> <code>ControlsSettingsScreenController::BindingInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ControlsSettingsScreenController::BindingInfo
{
  std::string mAction;
  std::string mIcon;
  std::vector&lt;int&gt; mKeys;
  bool mActive;
};

</code></pre></div><h3 id="controlssettingsscreencontroller-vtbl"><a href="#controlssettingsscreencontroller-vtbl" class="header-anchor">#</a> <code>ControlsSettingsScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ControlsSettingsScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
  void (__fastcall *_registerControllerCallbacks)(ControlsSettingsScreenController *this);
};

</code></pre></div><h3 id="convertpurchasestoxblscreencontroller"><a href="#convertpurchasestoxblscreencontroller" class="header-anchor">#</a> <code>ConvertPurchasesToXBLScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ConvertPurchasesToXBLScreenController : MinecraftScreenController
{
  std::function&lt;void __cdecl(bool)&gt; mExitScreenCallback;
  bool mTryConversionAgain;
};

</code></pre></div><h3 id="convertpurchasestoxblscreencontroller-vtbl"><a href="#convertpurchasestoxblscreencontroller-vtbl" class="header-anchor">#</a> <code>ConvertPurchasesToXBLScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ConvertPurchasesToXBLScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="coursescreencontroller"><a href="#coursescreencontroller" class="header-anchor">#</a> <code>CourseScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj CourseScreenController : MainMenuScreenController
{
  std::shared_ptr&lt;TutorialCollection&gt; mTutorialCollection;
  int mActiveItemIndex;
  std::string mCourseTitle;
  std::string mCourseId;
  bool mHasComputedInitialActiveIndex;
  CourseScreenController::LoadingProgress mLocalWorldLoadingProgress;
  int mHoveredItemIndex;
  std::shared_ptr&lt;PlayScreenModel&gt; mPlayScreenModel;
  std::shared_ptr&lt;MultiplayerLessonScreenController&gt; mMultiplayerLessonScreenController;
  std::shared_ptr&lt;EducationContentManagerScreenController&gt; mEducationContentManagerScreenController;
  std::shared_ptr&lt;LessonProgressionService&gt; mLessonProgressionService;
};

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mcstructure/1.16.201/structure/B~2.html" class="prev">
        B~2
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/C~1.html">
        C~1
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.4c02fc69.js" defer></script><script src="/mcstructure/assets/js/2.ab15d2b7.js" defer></script><script src="/mcstructure/assets/js/1.9734fe39.js" defer></script><script src="/mcstructure/assets/js/108.289ea0ab.js" defer></script>
  </body>
</html>
