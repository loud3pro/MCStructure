<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>B | MC TIL</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Some structure and enum information for minecraft bedrock edition.">
    
    <link rel="preload" href="/mcstructure/assets/css/0.styles.0484522b.css" as="style"><link rel="preload" href="/mcstructure/assets/js/app.4c02fc69.js" as="script"><link rel="preload" href="/mcstructure/assets/js/2.ab15d2b7.js" as="script"><link rel="preload" href="/mcstructure/assets/js/1.9734fe39.js" as="script"><link rel="preload" href="/mcstructure/assets/js/105.a60ad729.js" as="script"><link rel="prefetch" href="/mcstructure/assets/js/10.102fb00e.js"><link rel="prefetch" href="/mcstructure/assets/js/100.9f4887ee.js"><link rel="prefetch" href="/mcstructure/assets/js/101.38d4e8ed.js"><link rel="prefetch" href="/mcstructure/assets/js/102.4cf4c505.js"><link rel="prefetch" href="/mcstructure/assets/js/103.254bae32.js"><link rel="prefetch" href="/mcstructure/assets/js/104.3a611fe2.js"><link rel="prefetch" href="/mcstructure/assets/js/106.a9dadd40.js"><link rel="prefetch" href="/mcstructure/assets/js/107.1cdafa8f.js"><link rel="prefetch" href="/mcstructure/assets/js/108.289ea0ab.js"><link rel="prefetch" href="/mcstructure/assets/js/109.35965d89.js"><link rel="prefetch" href="/mcstructure/assets/js/11.1efdebfb.js"><link rel="prefetch" href="/mcstructure/assets/js/110.86d45285.js"><link rel="prefetch" href="/mcstructure/assets/js/111.bce93ce8.js"><link rel="prefetch" href="/mcstructure/assets/js/112.b1df2988.js"><link rel="prefetch" href="/mcstructure/assets/js/113.a8d28c8d.js"><link rel="prefetch" href="/mcstructure/assets/js/114.2f28a2d8.js"><link rel="prefetch" href="/mcstructure/assets/js/115.0b9455a1.js"><link rel="prefetch" href="/mcstructure/assets/js/116.54d2cbea.js"><link rel="prefetch" href="/mcstructure/assets/js/117.84dece67.js"><link rel="prefetch" href="/mcstructure/assets/js/118.fd23f544.js"><link rel="prefetch" href="/mcstructure/assets/js/119.0c82af99.js"><link rel="prefetch" href="/mcstructure/assets/js/12.1500ecd9.js"><link rel="prefetch" href="/mcstructure/assets/js/120.df319818.js"><link rel="prefetch" href="/mcstructure/assets/js/121.fe8d085a.js"><link rel="prefetch" href="/mcstructure/assets/js/122.380a2c51.js"><link rel="prefetch" href="/mcstructure/assets/js/123.a24da413.js"><link rel="prefetch" href="/mcstructure/assets/js/124.c2532fc0.js"><link rel="prefetch" href="/mcstructure/assets/js/125.2985dc5d.js"><link rel="prefetch" href="/mcstructure/assets/js/126.6ba94262.js"><link rel="prefetch" href="/mcstructure/assets/js/127.735fef00.js"><link rel="prefetch" href="/mcstructure/assets/js/128.f3e3fa5d.js"><link rel="prefetch" href="/mcstructure/assets/js/129.0d417975.js"><link rel="prefetch" href="/mcstructure/assets/js/13.f04054ca.js"><link rel="prefetch" href="/mcstructure/assets/js/130.0b77cd0e.js"><link rel="prefetch" href="/mcstructure/assets/js/131.2254c64b.js"><link rel="prefetch" href="/mcstructure/assets/js/132.935cc4b6.js"><link rel="prefetch" href="/mcstructure/assets/js/133.0ecb333e.js"><link rel="prefetch" href="/mcstructure/assets/js/134.5715673e.js"><link rel="prefetch" href="/mcstructure/assets/js/135.0027dfea.js"><link rel="prefetch" href="/mcstructure/assets/js/136.42d83b87.js"><link rel="prefetch" href="/mcstructure/assets/js/137.da3ee6d4.js"><link rel="prefetch" href="/mcstructure/assets/js/138.e266fbe7.js"><link rel="prefetch" href="/mcstructure/assets/js/139.c24aa491.js"><link rel="prefetch" href="/mcstructure/assets/js/14.20d1c79c.js"><link rel="prefetch" href="/mcstructure/assets/js/140.88d83e32.js"><link rel="prefetch" href="/mcstructure/assets/js/141.ea97500c.js"><link rel="prefetch" href="/mcstructure/assets/js/142.12103437.js"><link rel="prefetch" href="/mcstructure/assets/js/143.073b2a3f.js"><link rel="prefetch" href="/mcstructure/assets/js/144.5de16957.js"><link rel="prefetch" href="/mcstructure/assets/js/145.6bbe053a.js"><link rel="prefetch" href="/mcstructure/assets/js/146.85aca5e2.js"><link rel="prefetch" href="/mcstructure/assets/js/147.4bca9cc3.js"><link rel="prefetch" href="/mcstructure/assets/js/148.37d63b3a.js"><link rel="prefetch" href="/mcstructure/assets/js/149.222704e4.js"><link rel="prefetch" href="/mcstructure/assets/js/15.9d8ff414.js"><link rel="prefetch" href="/mcstructure/assets/js/150.c5e7d45c.js"><link rel="prefetch" href="/mcstructure/assets/js/151.2ee19433.js"><link rel="prefetch" href="/mcstructure/assets/js/152.933845cb.js"><link rel="prefetch" href="/mcstructure/assets/js/153.f005156d.js"><link rel="prefetch" href="/mcstructure/assets/js/154.6fc09a83.js"><link rel="prefetch" href="/mcstructure/assets/js/155.b6c305d1.js"><link rel="prefetch" href="/mcstructure/assets/js/156.0910151a.js"><link rel="prefetch" href="/mcstructure/assets/js/157.5dab16c5.js"><link rel="prefetch" href="/mcstructure/assets/js/158.de7f170f.js"><link rel="prefetch" href="/mcstructure/assets/js/159.a5c718e7.js"><link rel="prefetch" href="/mcstructure/assets/js/16.9d3aa9da.js"><link rel="prefetch" href="/mcstructure/assets/js/160.38fc5a00.js"><link rel="prefetch" href="/mcstructure/assets/js/161.493ae65d.js"><link rel="prefetch" href="/mcstructure/assets/js/162.2b7257ff.js"><link rel="prefetch" href="/mcstructure/assets/js/163.24187ca7.js"><link rel="prefetch" href="/mcstructure/assets/js/164.560a9bc3.js"><link rel="prefetch" href="/mcstructure/assets/js/17.0889d1c8.js"><link rel="prefetch" href="/mcstructure/assets/js/18.df0372db.js"><link rel="prefetch" href="/mcstructure/assets/js/19.af158d36.js"><link rel="prefetch" href="/mcstructure/assets/js/20.97f59a2a.js"><link rel="prefetch" href="/mcstructure/assets/js/21.5962fd4e.js"><link rel="prefetch" href="/mcstructure/assets/js/22.4d3522c5.js"><link rel="prefetch" href="/mcstructure/assets/js/23.3537cb24.js"><link rel="prefetch" href="/mcstructure/assets/js/24.c75bf0ca.js"><link rel="prefetch" href="/mcstructure/assets/js/25.24e24560.js"><link rel="prefetch" href="/mcstructure/assets/js/26.7766e0fb.js"><link rel="prefetch" href="/mcstructure/assets/js/27.e9f6074c.js"><link rel="prefetch" href="/mcstructure/assets/js/28.fa15c259.js"><link rel="prefetch" href="/mcstructure/assets/js/29.618d33e1.js"><link rel="prefetch" href="/mcstructure/assets/js/3.78f10f89.js"><link rel="prefetch" href="/mcstructure/assets/js/30.6cf1500b.js"><link rel="prefetch" href="/mcstructure/assets/js/31.22856a35.js"><link rel="prefetch" href="/mcstructure/assets/js/32.bffe7ab8.js"><link rel="prefetch" href="/mcstructure/assets/js/33.7806de32.js"><link rel="prefetch" href="/mcstructure/assets/js/34.c50997a1.js"><link rel="prefetch" href="/mcstructure/assets/js/35.50d88856.js"><link rel="prefetch" href="/mcstructure/assets/js/36.0a3b9225.js"><link rel="prefetch" href="/mcstructure/assets/js/37.892173e1.js"><link rel="prefetch" href="/mcstructure/assets/js/38.faa710ad.js"><link rel="prefetch" href="/mcstructure/assets/js/39.08679ec0.js"><link rel="prefetch" href="/mcstructure/assets/js/4.891576c8.js"><link rel="prefetch" href="/mcstructure/assets/js/40.1b76e3aa.js"><link rel="prefetch" href="/mcstructure/assets/js/41.ab86d7dd.js"><link rel="prefetch" href="/mcstructure/assets/js/42.5f6b9020.js"><link rel="prefetch" href="/mcstructure/assets/js/43.74c52cc7.js"><link rel="prefetch" href="/mcstructure/assets/js/44.29f933bd.js"><link rel="prefetch" href="/mcstructure/assets/js/45.89046872.js"><link rel="prefetch" href="/mcstructure/assets/js/46.927693bf.js"><link rel="prefetch" href="/mcstructure/assets/js/47.6c5e2eb5.js"><link rel="prefetch" href="/mcstructure/assets/js/48.fc418a99.js"><link rel="prefetch" href="/mcstructure/assets/js/49.ab1bff3b.js"><link rel="prefetch" href="/mcstructure/assets/js/5.12550f3f.js"><link rel="prefetch" href="/mcstructure/assets/js/50.34a77e29.js"><link rel="prefetch" href="/mcstructure/assets/js/51.cdab9fd0.js"><link rel="prefetch" href="/mcstructure/assets/js/52.eabfd13f.js"><link rel="prefetch" href="/mcstructure/assets/js/53.f32740a7.js"><link rel="prefetch" href="/mcstructure/assets/js/54.fcfdf201.js"><link rel="prefetch" href="/mcstructure/assets/js/55.dd20532e.js"><link rel="prefetch" href="/mcstructure/assets/js/56.a78e3680.js"><link rel="prefetch" href="/mcstructure/assets/js/57.89305262.js"><link rel="prefetch" href="/mcstructure/assets/js/58.35b65b37.js"><link rel="prefetch" href="/mcstructure/assets/js/59.3817674a.js"><link rel="prefetch" href="/mcstructure/assets/js/6.436e88f9.js"><link rel="prefetch" href="/mcstructure/assets/js/60.2398d268.js"><link rel="prefetch" href="/mcstructure/assets/js/61.61cad8b5.js"><link rel="prefetch" href="/mcstructure/assets/js/62.c2d852d2.js"><link rel="prefetch" href="/mcstructure/assets/js/63.168d8107.js"><link rel="prefetch" href="/mcstructure/assets/js/64.db4e10ba.js"><link rel="prefetch" href="/mcstructure/assets/js/65.17e2ed8f.js"><link rel="prefetch" href="/mcstructure/assets/js/66.0ad691e0.js"><link rel="prefetch" href="/mcstructure/assets/js/67.1e9ccecd.js"><link rel="prefetch" href="/mcstructure/assets/js/68.3d418c4b.js"><link rel="prefetch" href="/mcstructure/assets/js/69.bf6a0b1f.js"><link rel="prefetch" href="/mcstructure/assets/js/7.c2acc470.js"><link rel="prefetch" href="/mcstructure/assets/js/70.f9e2f365.js"><link rel="prefetch" href="/mcstructure/assets/js/71.d7256b61.js"><link rel="prefetch" href="/mcstructure/assets/js/72.0282cd39.js"><link rel="prefetch" href="/mcstructure/assets/js/73.b28cf744.js"><link rel="prefetch" href="/mcstructure/assets/js/74.0aab40c1.js"><link rel="prefetch" href="/mcstructure/assets/js/75.11a8476b.js"><link rel="prefetch" href="/mcstructure/assets/js/76.234564da.js"><link rel="prefetch" href="/mcstructure/assets/js/77.89613781.js"><link rel="prefetch" href="/mcstructure/assets/js/78.8cbc90e7.js"><link rel="prefetch" href="/mcstructure/assets/js/79.8dec18f0.js"><link rel="prefetch" href="/mcstructure/assets/js/80.bc89e0ad.js"><link rel="prefetch" href="/mcstructure/assets/js/81.46cda844.js"><link rel="prefetch" href="/mcstructure/assets/js/82.b1dae669.js"><link rel="prefetch" href="/mcstructure/assets/js/83.3a44a1c4.js"><link rel="prefetch" href="/mcstructure/assets/js/84.9604e4ea.js"><link rel="prefetch" href="/mcstructure/assets/js/85.0b6985d2.js"><link rel="prefetch" href="/mcstructure/assets/js/86.0a705d22.js"><link rel="prefetch" href="/mcstructure/assets/js/87.7d036791.js"><link rel="prefetch" href="/mcstructure/assets/js/88.f4f57b27.js"><link rel="prefetch" href="/mcstructure/assets/js/89.d107adcd.js"><link rel="prefetch" href="/mcstructure/assets/js/90.c6964cf1.js"><link rel="prefetch" href="/mcstructure/assets/js/91.461e7454.js"><link rel="prefetch" href="/mcstructure/assets/js/92.ea6588b8.js"><link rel="prefetch" href="/mcstructure/assets/js/93.12f08abd.js"><link rel="prefetch" href="/mcstructure/assets/js/94.ec163f63.js"><link rel="prefetch" href="/mcstructure/assets/js/95.898bdf72.js"><link rel="prefetch" href="/mcstructure/assets/js/96.63aead8b.js"><link rel="prefetch" href="/mcstructure/assets/js/97.e24085ec.js"><link rel="prefetch" href="/mcstructure/assets/js/98.8e55a83d.js"><link rel="prefetch" href="/mcstructure/assets/js/99.8ccfc759.js"><link rel="prefetch" href="/mcstructure/assets/js/vendors~docsearch.d856fa52.js">
    <link rel="stylesheet" href="/mcstructure/assets/css/0.styles.0484522b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mcstructure/" class="home-link router-link-active"><!----> <span class="site-name">MC TIL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mcstructure/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/Redbeanw44602/mcstructure" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Struct</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mcstructure/1.16.201/structure/A.html" class="sidebar-link">A</a></li><li><a href="/mcstructure/1.16.201/structure/A~1.html" class="sidebar-link">A~1</a></li><li><a href="/mcstructure/1.16.201/structure/B.html" aria-current="page" class="active sidebar-link">B</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/mcstructure/1.16.201/structure/B~1.html" class="sidebar-link">B~1</a></li><li><a href="/mcstructure/1.16.201/structure/B~2.html" class="sidebar-link">B~2</a></li><li><a href="/mcstructure/1.16.201/structure/C.html" class="sidebar-link">C</a></li><li><a href="/mcstructure/1.16.201/structure/C~1.html" class="sidebar-link">C~1</a></li><li><a href="/mcstructure/1.16.201/structure/C~2.html" class="sidebar-link">C~2</a></li><li><a href="/mcstructure/1.16.201/structure/C~3.html" class="sidebar-link">C~3</a></li><li><a href="/mcstructure/1.16.201/structure/D.html" class="sidebar-link">D</a></li><li><a href="/mcstructure/1.16.201/structure/D~1.html" class="sidebar-link">D~1</a></li><li><a href="/mcstructure/1.16.201/structure/D~2.html" class="sidebar-link">D~2</a></li><li><a href="/mcstructure/1.16.201/structure/D~3.html" class="sidebar-link">D~3</a></li><li><a href="/mcstructure/1.16.201/structure/D~4.html" class="sidebar-link">D~4</a></li><li><a href="/mcstructure/1.16.201/structure/D~5.html" class="sidebar-link">D~5</a></li><li><a href="/mcstructure/1.16.201/structure/D~6.html" class="sidebar-link">D~6</a></li><li><a href="/mcstructure/1.16.201/structure/D~7.html" class="sidebar-link">D~7</a></li><li><a href="/mcstructure/1.16.201/structure/D~8.html" class="sidebar-link">D~8</a></li><li><a href="/mcstructure/1.16.201/structure/D~9.html" class="sidebar-link">D~9</a></li><li><a href="/mcstructure/1.16.201/structure/D~10.html" class="sidebar-link">D~10</a></li><li><a href="/mcstructure/1.16.201/structure/E.html" class="sidebar-link">E</a></li><li><a href="/mcstructure/1.16.201/structure/E~1.html" class="sidebar-link">E~1</a></li><li><a href="/mcstructure/1.16.201/structure/F.html" class="sidebar-link">F</a></li><li><a href="/mcstructure/1.16.201/structure/F~1.html" class="sidebar-link">F~1</a></li><li><a href="/mcstructure/1.16.201/structure/G.html" class="sidebar-link">G</a></li><li><a href="/mcstructure/1.16.201/structure/H.html" class="sidebar-link">H</a></li><li><a href="/mcstructure/1.16.201/structure/I.html" class="sidebar-link">I</a></li><li><a href="/mcstructure/1.16.201/structure/I~1.html" class="sidebar-link">I~1</a></li><li><a href="/mcstructure/1.16.201/structure/I~2.html" class="sidebar-link">I~2</a></li><li><a href="/mcstructure/1.16.201/structure/J.html" class="sidebar-link">J</a></li><li><a href="/mcstructure/1.16.201/structure/K.html" class="sidebar-link">K</a></li><li><a href="/mcstructure/1.16.201/structure/L.html" class="sidebar-link">L</a></li><li><a href="/mcstructure/1.16.201/structure/L~1.html" class="sidebar-link">L~1</a></li><li><a href="/mcstructure/1.16.201/structure/M.html" class="sidebar-link">M</a></li><li><a href="/mcstructure/1.16.201/structure/M~1.html" class="sidebar-link">M~1</a></li><li><a href="/mcstructure/1.16.201/structure/M~2.html" class="sidebar-link">M~2</a></li><li><a href="/mcstructure/1.16.201/structure/M~3.html" class="sidebar-link">M~3</a></li><li><a href="/mcstructure/1.16.201/structure/N.html" class="sidebar-link">N</a></li><li><a href="/mcstructure/1.16.201/structure/O.html" class="sidebar-link">O</a></li><li><a href="/mcstructure/1.16.201/structure/P.html" class="sidebar-link">P</a></li><li><a href="/mcstructure/1.16.201/structure/P~1.html" class="sidebar-link">P~1</a></li><li><a href="/mcstructure/1.16.201/structure/P~2.html" class="sidebar-link">P~2</a></li><li><a href="/mcstructure/1.16.201/structure/P~3.html" class="sidebar-link">P~3</a></li><li><a href="/mcstructure/1.16.201/structure/Q.html" class="sidebar-link">Q</a></li><li><a href="/mcstructure/1.16.201/structure/R.html" class="sidebar-link">R</a></li><li><a href="/mcstructure/1.16.201/structure/R~1.html" class="sidebar-link">R~1</a></li><li><a href="/mcstructure/1.16.201/structure/R~2.html" class="sidebar-link">R~2</a></li><li><a href="/mcstructure/1.16.201/structure/R~3.html" class="sidebar-link">R~3</a></li><li><a href="/mcstructure/1.16.201/structure/S.html" class="sidebar-link">S</a></li><li><a href="/mcstructure/1.16.201/structure/S~1.html" class="sidebar-link">S~1</a></li><li><a href="/mcstructure/1.16.201/structure/S~2.html" class="sidebar-link">S~2</a></li><li><a href="/mcstructure/1.16.201/structure/S~3.html" class="sidebar-link">S~3</a></li><li><a href="/mcstructure/1.16.201/structure/S~4.html" class="sidebar-link">S~4</a></li><li><a href="/mcstructure/1.16.201/structure/T.html" class="sidebar-link">T</a></li><li><a href="/mcstructure/1.16.201/structure/T~1.html" class="sidebar-link">T~1</a></li><li><a href="/mcstructure/1.16.201/structure/U.html" class="sidebar-link">U</a></li><li><a href="/mcstructure/1.16.201/structure/V.html" class="sidebar-link">V</a></li><li><a href="/mcstructure/1.16.201/structure/W.html" class="sidebar-link">W</a></li><li><a href="/mcstructure/1.16.201/structure/W~1.html" class="sidebar-link">W~1</a></li><li><a href="/mcstructure/1.16.201/structure/X.html" class="sidebar-link">X</a></li><li><a href="/mcstructure/1.16.201/structure/Z.html" class="sidebar-link">Z</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Enums</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="b"><a href="#b" class="header-anchor">#</a> B</h1> <h3 id="booloption"><a href="#booloption" class="header-anchor">#</a> <code>BoolOption</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(488) <code>Option</code></td> <td>baseclass_0</td></tr> <tr><td>488</td> <td>(1) <code>bool</code></td> <td>mValue</td></tr> <tr><td>489</td> <td>(1) <code>bool</code></td> <td>mDefaultValue</td></tr> <tr><td>496</td> <td>(64) <code>std::function&lt;bool __cdecl(bool)&gt;</code></td> <td>mCoerceValueCallback</td></tr></tbody></table> <h3 id="bedrock-pubsub-publisher-void-cdecl-option-const-bedrock-pubsub-threadmodel-multithreaded-void"><a href="#bedrock-pubsub-publisher-void-cdecl-option-const-bedrock-pubsub-threadmodel-multithreaded-void" class="header-anchor">#</a> <code>Bedrock::PubSub::Publisher&lt;void __cdecl(Option const &amp;),Bedrock::PubSub::ThreadModel::MultiThreaded,void&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(120) <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::list&lt;std::shared_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;::SubscriptionBody&gt;&gt;</code></td> <td>mSubscriptions</td></tr> <tr><td>16</td> <td>(80) <code>std::mutex</code></td> <td>mMutex</td></tr> <tr><td>96</td> <td>(16) <code>std::weak_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;::SubscriptionBody&gt;</code></td> <td>mSingleSubscriber</td></tr> <tr><td>112</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mSubscriberCount</td></tr></tbody></table> <h3 id="bedrock-pubsub-publisher-void-cdecl-option-const-enum-inputmode-bedrock-pubsub-threadmodel-multithreaded-void"><a href="#bedrock-pubsub-publisher-void-cdecl-option-const-enum-inputmode-bedrock-pubsub-threadmodel-multithreaded-void" class="header-anchor">#</a> <code>Bedrock::PubSub::Publisher&lt;void __cdecl(Option const &amp;,enum InputMode),Bedrock::PubSub::ThreadModel::MultiThreaded,void&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(120) <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-enum-inputmode"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-enum-inputmode" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::list&lt;std::shared_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;::SubscriptionBody&gt;&gt;</code></td> <td>mSubscriptions</td></tr> <tr><td>16</td> <td>(80) <code>std::mutex</code></td> <td>mMutex</td></tr> <tr><td>96</td> <td>(16) <code>std::weak_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;::SubscriptionBody&gt;</code></td> <td>mSingleSubscriber</td></tr> <tr><td>112</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mSubscriberCount</td></tr></tbody></table> <h3 id="bedrock-pubsub-scopedsubscription"><a href="#bedrock-pubsub-scopedsubscription" class="header-anchor">#</a> <code>Bedrock::PubSub::ScopedSubscription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>Bedrock::PubSub::Subscription</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bedrock-pubsub-subscription"><a href="#bedrock-pubsub-subscription" class="header-anchor">#</a> <code>Bedrock::PubSub::Subscription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::weak_ptr&lt;Bedrock::PubSub::Detail::SubscriptionBodyInterface&gt;</code></td> <td>mBody</td></tr></tbody></table> <h3 id="brightness"><a href="#brightness" class="header-anchor">#</a> <code>Brightness</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>NewType&lt;unsigned char&gt;</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="blockpos"><a href="#blockpos" class="header-anchor">#</a> <code>BlockPos</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>x</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>y</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>z</td></tr></tbody></table> <h3 id="basegameversion"><a href="#basegameversion" class="header-anchor">#</a> <code>BaseGameVersion</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(112) <code>SemVersion</code></td> <td>mSemVersion</td></tr></tbody></table> <h3 id="bedrock-threading-osthreadpriority"><a href="#bedrock-threading-osthreadpriority" class="header-anchor">#</a> <code>Bedrock::Threading::OSThreadPriority</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mPriority</td></tr></tbody></table> <h3 id="bedrock-enablenonownerreferences"><a href="#bedrock-enablenonownerreferences" class="header-anchor">#</a> <code>Bedrock::EnableNonOwnerReferences</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-application-threadowner-core-random"><a href="#bedrock-application-threadowner-core-random" class="header-anchor">#</a> <code>Bedrock::Application::ThreadOwner&lt;Core::Random&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2516) <code>Core::Random</code></td> <td>mObject</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-std-basic-string-char-std-char-traits-char-std-allocator-char-enum-actordamagecause"><a href="#bidirectionalunorderedmap-std-basic-string-char-std-char-traits-char-std-allocator-char-enum-actordamagecause" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;,enum ActorDamageCause&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ActorDamageCause&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;enum ActorDamageCause,std::string&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bucketabledescription"><a href="#bucketabledescription" class="header-anchor">#</a> <code>BucketableDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ComponentDescription</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="boneanimationchannel-sortkeyframes-l2-keyframecompare"><a href="#boneanimationchannel-sortkeyframes-l2-keyframecompare" class="header-anchor">#</a> <code>BoneAnimationChannel::sortKeyFrames::__l2::KeyFrameCompare</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="boneorientation"><a href="#boneorientation" class="header-anchor">#</a> <code>BoneOrientation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mUseMatrixFromOwningActor</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mParentBoneIndex</td></tr> <tr><td>8</td> <td>(4) <code>_BYTE[4]</code></td> <td>mParentSkeletalHierarchyIndex</td></tr> <tr><td>16</td> <td>(48) <code>HashedString</code></td> <td>mName</td></tr> <tr><td>64</td> <td>(48) <code>HashedString</code></td> <td>mParentName</td></tr> <tr><td>112</td> <td>(64) <code>Matrix</code></td> <td>mLocalPreTransformMatrix</td></tr> <tr><td>176</td> <td>(64) <code>Matrix</code></td> <td>mMatrix</td></tr> <tr><td>240</td> <td>(4) <code>_BYTE[4]</code></td> <td>mRotationRelativeMode</td></tr> <tr><td>244</td> <td>(36) <code>BoneOrientationTransform</code></td> <td>mTransform</td></tr> <tr><td>280</td> <td>(36) <code>BoneOrientationTransform</code></td> <td>mDefaultTransform</td></tr> <tr><td>316</td> <td>(12) <code>Vec3</code></td> <td>mPivot</td></tr> <tr><td>328</td> <td>(1) <code>bool</code></td> <td>mOverrideStackMatrix</td></tr> <tr><td>329</td> <td>(1) <code>bool</code></td> <td>mApplyLocalPreTransformMatrix</td></tr></tbody></table> <h3 id="boneorientationtransform"><a href="#boneorientationtransform" class="header-anchor">#</a> <code>BoneOrientationTransform</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(36) <code>Vec3[3]</code></td> <td>mData</td></tr></tbody></table> <h3 id="blockserializationutils-nbttoblockcache"><a href="#blockserializationutils-nbttoblockcache" class="header-anchor">#</a> <code>BlockSerializationUtils::NbtToBlockCache</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::map&lt;unsigned __int64,Block const *&gt;</code></td> <td>mCache</td></tr> <tr><td>16</td> <td>(80) <code>std::mutex</code></td> <td>mMutex</td></tr></tbody></table> <h3 id="blocksource-fetchblocksincylindersorted-l2-lambda-162be0394a410a4558b7b369e9c9236e"><a href="#blocksource-fetchblocksincylindersorted-l2-lambda-162be0394a410a4558b7b369e9c9236e" class="header-anchor">#</a> <code>BlockSource::fetchBlocksInCylinderSorted::__l2::&lt;lambda_162be0394a410a4558b7b369e9c9236e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="bedrock-detail-datastoreinfo"><a href="#bedrock-detail-datastoreinfo" class="header-anchor">#</a> <code>Bedrock::Detail::DataStoreInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;Core::PathBuffer&lt;std::string &gt; __cdecl(gsl::not_null&lt;AppPlatform *&gt;)&gt;</code></td> <td>mFilePathFn</td></tr></tbody></table> <h3 id="bgfx-toplevelinstancedesc"><a href="#bgfx-toplevelinstancedesc" class="header-anchor">#</a> <code>bgfx::TopLevelInstanceDesc</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>bgfx::AccelerationStructureHandle</code></td> <td>bottomLevelAS</td></tr> <tr><td>4</td> <td>(4) <code>bgfx::RtObjectCategory</code></td> <td>objectCategory</td></tr> <tr><td>8</td> <td>(4) <code>bgfx::RtMediaType</code></td> <td>mediaType</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>hitGroupIdx</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>mask</td></tr> <tr><td>20</td> <td>(6) <code>bgfx::TextureHandle[3]</code></td> <td>hTextures</td></tr> <tr><td>28</td> <td>(8) <code>unsigned int[2]</code></td> <td>tintColours</td></tr> <tr><td>36</td> <td>(2) <code>unsigned __int16</code></td> <td>materialFlags</td></tr> <tr><td>38</td> <td>(1) <code>bool</code></td> <td>useIrradianceCache</td></tr> <tr><td>40</td> <td>(48) <code>float[3][4]</code></td> <td>transform</td></tr> <tr><td>88</td> <td>(8) <code>__int64</code></td> <td>uniqueId</td></tr></tbody></table> <h3 id="bgfx-accelerationstructurehandle"><a href="#bgfx-accelerationstructurehandle" class="header-anchor">#</a> <code>bgfx::AccelerationStructureHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-texturehandle"><a href="#bgfx-texturehandle" class="header-anchor">#</a> <code>bgfx::TextureHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-raytracingconfiguration"><a href="#bgfx-raytracingconfiguration" class="header-anchor">#</a> <code>bgfx::RayTracingConfiguration</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mRtxOn</td></tr> <tr><td>4</td> <td>(16) <code>bgfx::DLSSOptions</code></td> <td>mDLSSOptions</td></tr> <tr><td>20</td> <td>(4) <code>float</code></td> <td>mEmissiveBrightnessMultiplier</td></tr> <tr><td>24</td> <td>(4) <code>float</code></td> <td>mEmissiveDesaturation</td></tr> <tr><td>28</td> <td>(4) <code>float</code></td> <td>mIndirectEmissiveBoostMultiplier</td></tr> <tr><td>32</td> <td>(4) <code>float</code></td> <td>mSurfaceWetness</td></tr> <tr><td>36</td> <td>(4) <code>unsigned int</code></td> <td>mIrradianceCacheMaxHistoryLength</td></tr> <tr><td>40</td> <td>(4) <code>float</code></td> <td>mRayCountMultiplier</td></tr> <tr><td>44</td> <td>(4) <code>unsigned int</code></td> <td>mDoubleBufferWriteIdx</td></tr> <tr><td>48</td> <td>(8) <code>float[2]</code></td> <td>mSubPixelJitterOffset</td></tr> <tr><td>56</td> <td>(8) <code>float[2]</code></td> <td>mPreviousSubPixelJitterOffset</td></tr> <tr><td>64</td> <td>(1) <code>bool</code></td> <td>mCameraIsUnderWater</td></tr> <tr><td>65</td> <td>(1) <code>bool</code></td> <td>mCameraIsUnderLava</td></tr> <tr><td>68</td> <td>(4) <code>unsigned int</code></td> <td>mDimensionIdx</td></tr> <tr><td>72</td> <td>(12) <code>float[3]</code></td> <td>mFogAbsorbtion</td></tr> <tr><td>84</td> <td>(12) <code>float[3]</code></td> <td>mFogScattering</td></tr> <tr><td>96</td> <td>(12) <code>float[3]</code></td> <td>mWaterAbsorbtion</td></tr> <tr><td>108</td> <td>(12) <code>float[3]</code></td> <td>mWaterScattering</td></tr> <tr><td>120</td> <td>(12) <code>float[3]</code></td> <td>mCloudAbsorbtion</td></tr> <tr><td>132</td> <td>(12) <code>float[3]</code></td> <td>mCloudScattering</td></tr> <tr><td>144</td> <td>(12) <code>float[3]</code></td> <td>mDirectionToSun</td></tr> <tr><td>156</td> <td>(4) <code>float</code></td> <td>mTweakableSunAzimuthRotation</td></tr> <tr><td>160</td> <td>(4) <code>float</code></td> <td>mHeightMapPixelEdgeWidth</td></tr> <tr><td>164</td> <td>(4) <code>float</code></td> <td>mHeightMapDepth</td></tr> <tr><td>168</td> <td>(4) <code>float</code></td> <td>mHeightFogFalloffHeight</td></tr> <tr><td>172</td> <td>(4) <code>float</code></td> <td>mHeightFogStart</td></tr> <tr><td>176</td> <td>(4) <code>float</code></td> <td>mFogHenyeyGreensteinG</td></tr> <tr><td>180</td> <td>(4) <code>float</code></td> <td>mWaterHenyeyGreensteinG</td></tr> <tr><td>184</td> <td>(4) <code>float</code></td> <td>mFogDensityMultiplier</td></tr> <tr><td>188</td> <td>(1) <code>bool</code></td> <td>mInjectGlobalIlluminationIntoFog</td></tr> <tr><td>192</td> <td>(4) <code>float</code></td> <td>mFogStart</td></tr> <tr><td>196</td> <td>(4) <code>float</code></td> <td>mFogEnd</td></tr> <tr><td>200</td> <td>(4) <code>float</code></td> <td>mRenderDistance</td></tr> <tr><td>204</td> <td>(4) <code>float</code></td> <td>mWeatherFogLevel</td></tr> <tr><td>208</td> <td>(4) <code>float</code></td> <td>mRainLevel</td></tr> <tr><td>212</td> <td>(2) <code>bgfx::TextureHandle</code></td> <td>mSkyTexture</td></tr> <tr><td>216</td> <td>(16) <code>float[4]</code></td> <td>mSkyColor</td></tr> <tr><td>232</td> <td>(8) <code>float[2]</code></td> <td>mSkyUVScale</td></tr> <tr><td>240</td> <td>(12) <code>float[3]</code></td> <td>mFinalCombineSkyColourOverride</td></tr> <tr><td>252</td> <td>(4) <code>float</code></td> <td>mFinalCombineSkyColourOverrideStrength</td></tr> <tr><td>256</td> <td>(12) <code>float[3]</code></td> <td>mPreviousFrameWorldOrigin</td></tr> <tr><td>268</td> <td>(12) <code>float[3]</code></td> <td>mWorldOrigin</td></tr> <tr><td>280</td> <td>(1) <code>bool</code></td> <td>mNightVisionEnabled</td></tr> <tr><td>284</td> <td>(4) <code>float</code></td> <td>mNightVisionScale</td></tr> <tr><td>288</td> <td>(4) <code>float</code></td> <td>mExposureModifierEv</td></tr> <tr><td>292</td> <td>(4) <code>float</code></td> <td>mAutoExposureTemporalFitlerAlpha</td></tr> <tr><td>296</td> <td>(4) <code>float</code></td> <td>mAutoExposureMinEV</td></tr> <tr><td>300</td> <td>(4) <code>float</code></td> <td>mAutoExposureMaxEV</td></tr> <tr><td>304</td> <td>(4) <code>float</code></td> <td>mAutoExposureLobeDifferenceThreshold</td></tr> <tr><td>308</td> <td>(4) <code>float</code></td> <td>mAutoExposureLobeMixingMin</td></tr> <tr><td>312</td> <td>(4) <code>float</code></td> <td>mAutoExposureLobeMixingMax</td></tr> <tr><td>316</td> <td>(4) <code>float</code></td> <td>mSkyBrightnessAdjustment</td></tr> <tr><td>320</td> <td>(4) <code>float</code></td> <td>mMoonMeshIntensity</td></tr> <tr><td>324</td> <td>(4) <code>float</code></td> <td>mSunMeshIntensity</td></tr> <tr><td>328</td> <td>(4) <code>_BYTE[4]</code></td> <td>mDebugMode</td></tr> <tr><td>332</td> <td>(4) <code>bgfx::RtRenderMethod</code></td> <td>mRenderMethod</td></tr> <tr><td>336</td> <td>(4) <code>float</code></td> <td>mSmoothertron</td></tr> <tr><td>340</td> <td>(1) <code>bool</code></td> <td>mEnableDenoising</td></tr> <tr><td>341</td> <td>(1) <code>bool</code></td> <td>mEnableGlassOpacityHack</td></tr> <tr><td>342</td> <td>(1) <code>bool</code></td> <td>mRequestRecompileShaders</td></tr> <tr><td>343</td> <td>(1) <code>bool</code></td> <td>mEnableProfiling</td></tr> <tr><td>344</td> <td>(1) <code>bool</code></td> <td>mEnableIrradianceCache</td></tr> <tr><td>345</td> <td>(1) <code>bool</code></td> <td>mProbabilityBasedRaycasts</td></tr> <tr><td>346</td> <td>(1) <code>bool</code></td> <td>mEnableTraceRayInline</td></tr> <tr><td>347</td> <td>(1) <code>bool</code></td> <td>mEnableCausticsStabilizationInRefMode</td></tr> <tr><td>348</td> <td>(1) <code>bool</code></td> <td>mEnableRayReordering</td></tr> <tr><td>349</td> <td>(1) <code>bool</code></td> <td>mEnableSHDiffuse</td></tr> <tr><td>350</td> <td>(1) <code>bool</code></td> <td>mEnableWFTest</td></tr> <tr><td>351</td> <td>(1) <code>bool</code></td> <td>mVisualizeLights</td></tr> <tr><td>352</td> <td>(1) <code>bool</code></td> <td>mEnableExplicitLightSampling</td></tr> <tr><td>356</td> <td>(4) <code>float</code></td> <td>mExplicitLightsIntensityBias</td></tr> <tr><td>360</td> <td>(4) <code>unsigned int</code></td> <td>mMaxLightCount</td></tr> <tr><td>364</td> <td>(4) <code>_BYTE[4]</code></td> <td>mLevelCuller</td></tr> <tr><td>368</td> <td>(4) <code>_BYTE[4]</code></td> <td>mFrustumCuller</td></tr> <tr><td>372</td> <td>(4) <code>float</code></td> <td>mFocalDistance</td></tr> <tr><td>376</td> <td>(4) <code>float</code></td> <td>mApertureSize</td></tr> <tr><td>380</td> <td>(4) <code>float</code></td> <td>mApertureType</td></tr> <tr><td>384</td> <td>(4) <code>float</code></td> <td>mDiffuseDespeckleFilterRelativeDifferenceEpsilon</td></tr> <tr><td>388</td> <td>(4) <code>float</code></td> <td>mSpecularDespeckleFilterRelativeDifferenceEpsilon</td></tr> <tr><td>392</td> <td>(4) <code>float</code></td> <td>mSVGFDiffuseAlpha</td></tr> <tr><td>396</td> <td>(4) <code>float</code></td> <td>mSVGFDiffuseAlphaMoments</td></tr> <tr><td>400</td> <td>(4) <code>float</code></td> <td>mSVGFDiffusePhiLuminance</td></tr> <tr><td>404</td> <td>(4) <code>float</code></td> <td>mSVGFSpecularAlpha</td></tr> <tr><td>408</td> <td>(4) <code>float</code></td> <td>mSVGFSpecularAlphaMoments</td></tr> <tr><td>412</td> <td>(4) <code>float</code></td> <td>mSVGFSpecularPhiLuminance</td></tr> <tr><td>416</td> <td>(4) <code>float</code></td> <td>mSVGFDiffusePhiNormal</td></tr> <tr><td>420</td> <td>(4) <code>float</code></td> <td>mSVGFSpecularPhiNormal</td></tr> <tr><td>424</td> <td>(4) <code>float</code></td> <td>mSVGFPhiDepth</td></tr> <tr><td>428</td> <td>(4) <code>int</code></td> <td>mSVGFAtrousIterationCountDiffuse</td></tr> <tr><td>432</td> <td>(4) <code>int</code></td> <td>mSVGFAtrousIterationCountSpecular</td></tr> <tr><td>436</td> <td>(4) <code>int</code></td> <td>mSVGFDiffuseTemporalFeedbackIterationIdx</td></tr> <tr><td>440</td> <td>(4) <code>int</code></td> <td>mSVGFSpecularTemporalFeedbackIterationIdx</td></tr> <tr><td>444</td> <td>(1) <code>bool</code></td> <td>mSVGFEnableFireflyFilterDiffuse</td></tr> <tr><td>445</td> <td>(1) <code>bool</code></td> <td>mSVGFEnableFireflyFilterSpecular</td></tr> <tr><td>446</td> <td>(1) <code>bool</code></td> <td>mEnableAdaptiveDenoiser</td></tr> <tr><td>448</td> <td>(8) <code>const bgfx::RtLightInfo *</code></td> <td>mPointLights</td></tr> <tr><td>456</td> <td>(8) <code>unsigned __int64</code></td> <td>mPointLightsCount</td></tr> <tr><td>464</td> <td>(8) <code>unsigned int *</code></td> <td>mLightDistanceHistogram</td></tr> <tr><td>472</td> <td>(16) <code>std::shared_ptr&lt;std::vector&lt;bgfx::PBRTextureData&gt; &gt;</code></td> <td>mPBRTextureData</td></tr> <tr><td>488</td> <td>(4) <code>float</code></td> <td>mToneMappingShadowContrast</td></tr> <tr><td>492</td> <td>(4) <code>float</code></td> <td>mToneMappingShadowContrastEnd</td></tr> <tr><td>496</td> <td>(4) <code>float</code></td> <td>mToneMappingCurveShift</td></tr> <tr><td>500</td> <td>(4) <code>float</code></td> <td>mToneMappingDynamicRange</td></tr> <tr><td>504</td> <td>(4) <code>float</code></td> <td>mToneMappingShadowMinSlope</td></tr> <tr><td>508</td> <td>(4) <code>float</code></td> <td>mToneMappingMaxExposureIncrease</td></tr> <tr><td>512</td> <td>(4) <code>float</code></td> <td>mToneMappingFilmicSaturationCorrection</td></tr> <tr><td>516</td> <td>(1) <code>bool</code></td> <td>mPrioritizeVisibleChunksForIrradianceCache</td></tr> <tr><td>520</td> <td>(16) <code>float[4]</code></td> <td>mGenericDebugSliders</td></tr></tbody></table> <h3 id="bgfx-dlssoptions"><a href="#bgfx-dlssoptions" class="header-anchor">#</a> <code>bgfx::DLSSOptions</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::DLSSOptions::Mode</code></td> <td>mMode</td></tr> <tr><td>4</td> <td>(4) <code>bgfx::DLSSOptions::Scaling</code></td> <td>mQuality</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mSharpness</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mMipmapBias</td></tr></tbody></table> <h3 id="buttoncolors"><a href="#buttoncolors" class="header-anchor">#</a> <code>ButtonColors</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>mce::Color</code></td> <td>pressed</td></tr> <tr><td>16</td> <td>(16) <code>mce::Color</code></td> <td>released</td></tr></tbody></table> <h3 id="bedrocklog-categorylogs"><a href="#bedrocklog-categorylogs" class="header-anchor">#</a> <code>BedrockLog::CategoryLogs</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(504) <code>std::array&lt;BedrockLog::CategoryLogFile,7&gt;</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bedrocklog-categorylogfile"><a href="#bedrocklog-categorylogfile" class="header-anchor">#</a> <code>BedrockLog::CategoryLogFile</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum BedrockLog::LogChannel,std::unique_ptr&lt;BedrockLog::LogDetails&gt;,std::enum_hash&lt;enum BedrockLog::LogChannel&gt;,std::equal_to&lt;enum BedrockLog::LogChannel&gt;,std::allocator&lt;std::pair&lt;enum BedrockLog::LogChannel const ,std::unique_ptr&lt;BedrockLog::LogDetails&gt; &gt; &gt; &gt;</code></td> <td>mChannel</td></tr> <tr><td>64</td> <td>(4) <code>std::bitset&lt;3&gt;</code></td> <td>mCombinedChannelMask</td></tr> <tr><td>68</td> <td>(4) <code>int</code></td> <td>mMessageCount</td></tr></tbody></table> <h3 id="bedrock-memory-internalheapallocator"><a href="#bedrock-memory-internalheapallocator" class="header-anchor">#</a> <code>Bedrock::Memory::InternalHeapAllocator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Bedrock::Memory::IMemoryAllocator</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bedrock-memory-imemoryallocator"><a href="#bedrock-memory-imemoryallocator" class="header-anchor">#</a> <code>Bedrock::Memory::IMemoryAllocator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Bedrock::Memory::IMemoryAllocator_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="backgroundtaskbase-prioritycomparer"><a href="#backgroundtaskbase-prioritycomparer" class="header-anchor">#</a> <code>BackgroundTaskBase::PriorityComparer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="bedrock-threading-customtls-tlsmanager"><a href="#bedrock-threading-customtls-tlsmanager" class="header-anchor">#</a> <code>Bedrock::Threading::CustomTLS::TLSManager</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mNativeKey</td></tr> <tr><td>8</td> <td>(16384) <code>Bedrock::Threading::CustomTLS::TLSManager::KeyInfo[1024]</code></td> <td>mKeyInfo</td></tr> <tr><td>16392</td> <td>(8208) <code>Bedrock::Threading::LFFixedRingBuffer&lt;unsigned __int64,1024&gt;</code></td> <td>mFreeList</td></tr> <tr><td>24600</td> <td>(4) <code>std::atomic&lt;int&gt;</code></td> <td>mFreeListSize</td></tr> <tr><td>24604</td> <td>(1) <code>bool</code></td> <td>mInitialized</td></tr></tbody></table> <h3 id="bedrock-threading-customtls-tlsmanager-keyinfo"><a href="#bedrock-threading-customtls-tlsmanager-keyinfo" class="header-anchor">#</a> <code>Bedrock::Threading::CustomTLS::TLSManager::KeyInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void (__fastcall *)(void *)</code></td> <td>mDestructor</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>mVersionId</td></tr></tbody></table> <h3 id="bedrock-threading-lffixedringbuffer-unsigned-int64-1024"><a href="#bedrock-threading-lffixedringbuffer-unsigned-int64-1024" class="header-anchor">#</a> <code>Bedrock::Threading::LFFixedRingBuffer&lt;unsigned __int64,1024&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8192) <code>unsigned __int64[1024]</code></td> <td>mItems</td></tr> <tr><td>8192</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mReadPos</td></tr> <tr><td>8200</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mWritePos</td></tr></tbody></table> <h3 id="backgroundtaskbase-pendingcomparer"><a href="#backgroundtaskbase-pendingcomparer" class="header-anchor">#</a> <code>BackgroundTaskBase::PendingComparer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="bedrock-jsonobject-nodefunctiontable"><a href="#bedrock-jsonobject-nodefunctiontable" class="header-anchor">#</a> <code>Bedrock::JSONObject::NodeFunctionTable</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void (__fastcall *)(bool *, const Bedrock::JSONObject::Node *)</code></td> <td>mBoolean</td></tr> <tr><td>8</td> <td>(8) <code>void (__fastcall *)(unsigned int *, const Bedrock::JSONObject::Node *)</code></td> <td>mUInt32</td></tr> <tr><td>16</td> <td>(8) <code>void (__fastcall *)(int *, const Bedrock::JSONObject::Node *)</code></td> <td>mSInt32</td></tr> <tr><td>24</td> <td>(8) <code>void (__fastcall *)(unsigned __int64 *, const Bedrock::JSONObject::Node *)</code></td> <td>mUInt64</td></tr> <tr><td>32</td> <td>(8) <code>void (__fastcall *)(__int64 *, const Bedrock::JSONObject::Node *)</code></td> <td>mSInt64</td></tr> <tr><td>40</td> <td>(8) <code>void (__fastcall *)(float *, const Bedrock::JSONObject::Node *)</code></td> <td>mFloat</td></tr> <tr><td>48</td> <td>(8) <code>void (__fastcall *)(long double *, const Bedrock::JSONObject::Node *)</code></td> <td>mDouble</td></tr> <tr><td>56</td> <td>(8) <code>void (__fastcall *)(std::ostream *, const Bedrock::JSONObject::Node *)</code></td> <td>mStream</td></tr> <tr><td>64</td> <td>(8) <code>void (__fastcall *)(std::ostream *, const Bedrock::JSONObject::Node *)</code></td> <td>mJSONStream</td></tr> <tr><td>72</td> <td>(8) <code>void (__fastcall *)(const Bedrock::JSONObject::ArrayNode **, const Bedrock::JSONObject::Node *)</code></td> <td>mArray</td></tr> <tr><td>80</td> <td>(8) <code>void (__fastcall *)(const Bedrock::JSONObject::ObjectNode **, const Bedrock::JSONObject::Node *)</code></td> <td>mObject</td></tr> <tr><td>88</td> <td>(8) <code>bool (__fastcall *)(Bedrock::JSONObject::Node *, const Bedrock::JSONObject::ValueWrapper *)</code></td> <td>mAssignment</td></tr> <tr><td>96</td> <td>(8) <code>bool (__fastcall *)(const Bedrock::JSONObject::Node *, const Bedrock::JSONObject::Node *)</code></td> <td>mCompareEqual</td></tr></tbody></table> <h3 id="bdf-options-t"><a href="#bdf-options-t" class="header-anchor">#</a> <code>bdf_options_t_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>correct_metrics</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>keep_unencoded</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>keep_comments</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>font_spacing</td></tr></tbody></table> <h3 id="bdf-property-t"><a href="#bdf-property-t" class="header-anchor">#</a> <code>bdf_property_t_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>format</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>builtin</td></tr> <tr><td>16</td> <td>(8) <code>union {char *atom;int l;unsigned int ul;}</code></td> <td>value</td></tr></tbody></table> <h3 id="bx-errorresult"><a href="#bx-errorresult" class="header-anchor">#</a> <code>bx::ErrorResult</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>code</td></tr></tbody></table> <h3 id="bgfx-embeddedshader"><a href="#bgfx-embeddedshader" class="header-anchor">#</a> <code>bgfx::EmbeddedShader</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(264) <code>bgfx::EmbeddedShader::Data[11]</code></td> <td>data</td></tr></tbody></table> <h3 id="bgfx-embeddedshader-data"><a href="#bgfx-embeddedshader-data" class="header-anchor">#</a> <code>bgfx::EmbeddedShader::Data</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::RendererType::Enum</code></td> <td>type</td></tr> <tr><td>8</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>data</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>size</td></tr></tbody></table> <h3 id="bgfx-renderercreator"><a href="#bgfx-renderercreator" class="header-anchor">#</a> <code>bgfx::RendererCreator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::RendererContextI *(__fastcall *)(const bgfx::Init *)</code></td> <td>createFn</td></tr> <tr><td>8</td> <td>(8) <code>void (__fastcall *)()</code></td> <td>destroyFn</td></tr> <tr><td>16</td> <td>(8) <code>const char *</code></td> <td>name</td></tr> <tr><td>24</td> <td>(1) <code>bool</code></td> <td>supported</td></tr></tbody></table> <h3 id="bgfx-capsflags"><a href="#bgfx-capsflags" class="header-anchor">#</a> <code>bgfx::CapsFlags</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>m_flag</td></tr> <tr><td>8</td> <td>(8) <code>const char *</code></td> <td>m_str</td></tr></tbody></table> <h3 id="bgfx-indexbufferhandle"><a href="#bgfx-indexbufferhandle" class="header-anchor">#</a> <code>bgfx::IndexBufferHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-d3d11-uavformat"><a href="#bgfx-d3d11-uavformat" class="header-anchor">#</a> <code>bgfx::d3d11::UavFormat</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>DXGI_FORMAT[3]</code></td> <td>format</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>stride</td></tr></tbody></table> <h3 id="bgfx-d3d11-priminfo"><a href="#bgfx-d3d11-priminfo" class="header-anchor">#</a> <code>bgfx::d3d11::PrimInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>D3D_PRIMITIVE_TOPOLOGY</code></td> <td>m_type</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_min</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_div</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_sub</td></tr></tbody></table> <h3 id="bgfx-d3d11-textureformatinfo"><a href="#bgfx-d3d11-textureformatinfo" class="header-anchor">#</a> <code>bgfx::d3d11::TextureFormatInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>m_fmt</td></tr> <tr><td>4</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>m_fmtSrv</td></tr> <tr><td>8</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>m_fmtDsv</td></tr> <tr><td>12</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>m_fmtSrgb</td></tr></tbody></table> <h3 id="bgfx-d3d11-intelextension"><a href="#bgfx-d3d11-intelextension" class="header-anchor">#</a> <code>bgfx::d3d11::IntelExtension</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>char[16]</code></td> <td>key</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>version</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>type</td></tr> <tr><td>24</td> <td>(64) <code>unsigned int[16]</code></td> <td>data</td></tr></tbody></table> <h3 id="bgfx-d3d11-zero"><a href="#bgfx-d3d11-zero" class="header-anchor">#</a> <code>bgfx::d3d11::Zero</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(256) <code>ID3D11Buffer *[32]</code></td> <td>m_buffer</td></tr> <tr><td>1</td> <td>(64) <code>ID3D11UnorderedAccessView *[8]</code></td> <td>m_uav</td></tr> <tr><td>2</td> <td>(1024) <code>ID3D11ShaderResourceView *[128]</code></td> <td>m_srv</td></tr> <tr><td>3</td> <td>(128) <code>ID3D11SamplerState *[16]</code></td> <td>m_sampler</td></tr> <tr><td>4</td> <td>(1024) <code>ID3D11RenderTargetView *[128]</code></td> <td>m_rtv</td></tr> <tr><td>5</td> <td>(128) <code>unsigned int[32]</code></td> <td>m_zero</td></tr> <tr><td>6</td> <td>(128) <code>float[32]</code></td> <td>m_zerof</td></tr></tbody></table> <h3 id="bgfx-viewstate"><a href="#bgfx-viewstate" class="header-anchor">#</a> <code>bgfx::ViewState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32768) <code>bgfx::Matrix4[2][256]</code></td> <td>m_viewTmp</td></tr> <tr><td>32768</td> <td>(32768) <code>bgfx::Matrix4[2][256]</code></td> <td>m_viewProj</td></tr> <tr><td>65536</td> <td>(16) <code>bgfx::Matrix4 *[2]</code></td> <td>m_view</td></tr> <tr><td>65552</td> <td>(8) <code>bgfx::Rect</code></td> <td>m_rect</td></tr> <tr><td>65568</td> <td>(64) <code>bgfx::Matrix4</code></td> <td>m_invView</td></tr> <tr><td>65632</td> <td>(64) <code>bgfx::Matrix4</code></td> <td>m_invProj</td></tr> <tr><td>65696</td> <td>(64) <code>bgfx::Matrix4</code></td> <td>m_invViewProj</td></tr> <tr><td>65760</td> <td>(4) <code>float</code></td> <td>m_alphaRef</td></tr> <tr><td>65764</td> <td>(2) <code>unsigned __int16</code></td> <td>m_invViewCached</td></tr> <tr><td>65766</td> <td>(2) <code>unsigned __int16</code></td> <td>m_invProjCached</td></tr> <tr><td>65768</td> <td>(2) <code>unsigned __int16</code></td> <td>m_invViewProjCached</td></tr></tbody></table> <h3 id="bgfx-matrix4"><a href="#bgfx-matrix4" class="header-anchor">#</a> <code>bgfx::Matrix4</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>bgfx::Matrix4::&lt;unnamed_type_un&gt;</code></td> <td>un</td></tr></tbody></table> <h3 id="bgfx-matrix4-unnamed-type-un"><a href="#bgfx-matrix4-unnamed-type-un" class="header-anchor">#</a> <code>bgfx::Matrix4::&lt;unnamed_type_un&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>float[16]</code></td> <td>val</td></tr> <tr><td>1</td> <td>(64) <code>bx::float4x4_t</code></td> <td>f4x4</td></tr></tbody></table> <h3 id="bx-float4x4-t"><a href="#bx-float4x4-t" class="header-anchor">#</a> <code>bx::float4x4_t</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>__m128[4]</code></td> <td>col</td></tr></tbody></table> <h3 id="bgfx-rect"><a href="#bgfx-rect" class="header-anchor">#</a> <code>bgfx::Rect</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>m_x</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>m_y</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>m_width</td></tr> <tr><td>6</td> <td>(2) <code>unsigned __int16</code></td> <td>m_height</td></tr></tbody></table> <h3 id="bgfx-d3d12-heapproperty"><a href="#bgfx-d3d12-heapproperty" class="header-anchor">#</a> <code>bgfx::d3d12::HeapProperty</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(20) <code>D3D12_HEAP_PROPERTIES</code></td> <td>m_properties</td></tr> <tr><td>20</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_state</td></tr></tbody></table> <h3 id="bgfx-d3d12-uavformat"><a href="#bgfx-d3d12-uavformat" class="header-anchor">#</a> <code>bgfx::d3d12::UavFormat</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>DXGI_FORMAT[3]</code></td> <td>format</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>stride</td></tr></tbody></table> <h3 id="bgfx-d3d12-priminfo"><a href="#bgfx-d3d12-priminfo" class="header-anchor">#</a> <code>bgfx::d3d12::PrimInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>D3D_PRIMITIVE_TOPOLOGY</code></td> <td>m_topology</td></tr> <tr><td>4</td> <td>(4) <code>D3D12_PRIMITIVE_TOPOLOGY_TYPE</code></td> <td>m_topologyType</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_min</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_div</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_sub</td></tr></tbody></table> <h3 id="bgfx-d3d12-textureformatinfo"><a href="#bgfx-d3d12-textureformatinfo" class="header-anchor">#</a> <code>bgfx::d3d12::TextureFormatInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>m_fmt</td></tr> <tr><td>4</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>m_fmtSrv</td></tr> <tr><td>8</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>m_fmtDsv</td></tr> <tr><td>12</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>m_fmtSrgb</td></tr></tbody></table> <h3 id="bgfx-framebufferhandle"><a href="#bgfx-framebufferhandle" class="header-anchor">#</a> <code>bgfx::FrameBufferHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-renderercontextd3d12rtx-runraytracingshader-l2-raytracingshaderinfo"><a href="#bgfx-d3d12rtx-renderercontextd3d12rtx-runraytracingshader-l2-raytracingshaderinfo" class="header-anchor">#</a> <code>bgfx::d3d12rtx::RendererContextD3D12RTX::runRayTracingShader::__l2::RayTracingShaderInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::d3d12rtx::RTRayGenShader</code></td> <td>mRayGenShader</td></tr> <tr><td>4</td> <td>(4) <code>bgfx::d3d12rtx::RTComputeShader</code></td> <td>mComputeShader</td></tr> <tr><td>8</td> <td>(4) <code>bgfx::d3d12rtx::RTDispatchSize</code></td> <td>mDispatchSize</td></tr></tbody></table> <h3 id="bgfx-d3d9-blend"><a href="#bgfx-d3d9-blend" class="header-anchor">#</a> <code>bgfx::d3d9::Blend</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>_D3DBLEND</code></td> <td>m_src</td></tr> <tr><td>4</td> <td>(4) <code>_D3DBLEND</code></td> <td>m_dst</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>m_factor</td></tr></tbody></table> <h3 id="bgfx-d3d9-msaa"><a href="#bgfx-d3d9-msaa" class="header-anchor">#</a> <code>bgfx::d3d9::Msaa</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>_D3DMULTISAMPLE_TYPE</code></td> <td>m_type</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_quality</td></tr></tbody></table> <h3 id="bgfx-d3d9-extendedformat"><a href="#bgfx-d3d9-extendedformat" class="header-anchor">#</a> <code>bgfx::d3d9::ExtendedFormat</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>_D3DFORMAT</code></td> <td>m_fmt</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_usage</td></tr> <tr><td>8</td> <td>(4) <code>_D3DRESOURCETYPE</code></td> <td>m_type</td></tr> <tr><td>12</td> <td>(1) <code>bool</code></td> <td>m_supported</td></tr></tbody></table> <h3 id="bgfx-d3d9-priminfo"><a href="#bgfx-d3d9-priminfo" class="header-anchor">#</a> <code>bgfx::d3d9::PrimInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>_D3DPRIMITIVETYPE</code></td> <td>m_type</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_min</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_div</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_sub</td></tr></tbody></table> <h3 id="bgfx-d3d9-textureformatinfo"><a href="#bgfx-d3d9-textureformatinfo" class="header-anchor">#</a> <code>bgfx::d3d9::TextureFormatInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>_D3DFORMAT</code></td> <td>m_fmt</td></tr></tbody></table> <h3 id="bgfx-gl-blend"><a href="#bgfx-gl-blend" class="header-anchor">#</a> <code>bgfx::gl::Blend</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_src</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_dst</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>m_factor</td></tr></tbody></table> <h3 id="bgfx-gl-extension"><a href="#bgfx-gl-extension" class="header-anchor">#</a> <code>bgfx::gl::Extension</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>m_name</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>m_supported</td></tr> <tr><td>9</td> <td>(1) <code>bool</code></td> <td>m_initialize</td></tr></tbody></table> <h3 id="bgfx-gl-priminfo"><a href="#bgfx-gl-priminfo" class="header-anchor">#</a> <code>bgfx::gl::PrimInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_type</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_min</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_div</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_sub</td></tr></tbody></table> <h3 id="bgfx-gl-vendorid"><a href="#bgfx-gl-vendorid" class="header-anchor">#</a> <code>bgfx::gl::VendorId</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>name</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>id</td></tr></tbody></table> <h3 id="bgfx-gl-textureformatinfo"><a href="#bgfx-gl-textureformatinfo" class="header-anchor">#</a> <code>bgfx::gl::TextureFormatInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_internalFmt</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_internalFmtSrgb</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_fmt</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_type</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>m_supported</td></tr></tbody></table> <h3 id="bgfx-vk-extension"><a href="#bgfx-vk-extension" class="header-anchor">#</a> <code>bgfx::vk::Extension</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>m_name</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_minVersion</td></tr> <tr><td>12</td> <td>(1) <code>bool</code></td> <td>m_instanceExt</td></tr> <tr><td>13</td> <td>(1) <code>bool</code></td> <td>m_supported</td></tr> <tr><td>14</td> <td>(1) <code>bool</code></td> <td>m_initialize</td></tr></tbody></table> <h3 id="bgfx-vk-priminfo"><a href="#bgfx-vk-priminfo" class="header-anchor">#</a> <code>bgfx::vk::PrimInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>VkPrimitiveTopology</code></td> <td>m_topology</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_min</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_div</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_sub</td></tr></tbody></table> <h3 id="bgfx-vk-textureformatinfo"><a href="#bgfx-vk-textureformatinfo" class="header-anchor">#</a> <code>bgfx::vk::TextureFormatInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>VkFormat</code></td> <td>m_fmt</td></tr> <tr><td>4</td> <td>(4) <code>VkFormat</code></td> <td>m_fmtSrv</td></tr> <tr><td>8</td> <td>(4) <code>VkFormat</code></td> <td>m_fmtDsv</td></tr> <tr><td>12</td> <td>(4) <code>VkFormat</code></td> <td>m_fmtSrgb</td></tr></tbody></table> <h3 id="bgfx-dx9bcopcodeinfo"><a href="#bgfx-dx9bcopcodeinfo" class="header-anchor">#</a> <code>bgfx::Dx9bcOpcodeInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>numOperands</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>numValues</td></tr></tbody></table> <h3 id="bgfx-dxbcopcodeinfo"><a href="#bgfx-dxbcopcodeinfo" class="header-anchor">#</a> <code>bgfx::DxbcOpcodeInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>numOperands</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>numValues</td></tr></tbody></table> <h3 id="bgfx-spvopcodeinfo"><a href="#bgfx-spvopcodeinfo" class="header-anchor">#</a> <code>bgfx::SpvOpcodeInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>hasType</td></tr> <tr><td>1</td> <td>(1) <code>bool</code></td> <td>hasResult</td></tr> <tr><td>4</td> <td>(32) <code>bgfx::SpvOperand::Enum[8]</code></td> <td>operands</td></tr></tbody></table> <h3 id="bgfx-spvdecorationinfo"><a href="#bgfx-spvdecorationinfo" class="header-anchor">#</a> <code>bgfx::SpvDecorationInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::SpvOperand::Enum[2]</code></td> <td>operands</td></tr></tbody></table> <h3 id="bgfx-attribtoid"><a href="#bgfx-attribtoid" class="header-anchor">#</a> <code>bgfx::AttribToId</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::Attrib::Enum</code></td> <td>attr</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>id</td></tr></tbody></table> <h3 id="bimg-translatepvr3format"><a href="#bimg-translatepvr3format" class="header-anchor">#</a> <code>bimg::TranslatePvr3Format</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>m_format</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_channelTypeMask</td></tr> <tr><td>12</td> <td>(4) <code>_BYTE[4]</code></td> <td>m_textureFormat</td></tr></tbody></table> <h3 id="bimg-translateddsformat"><a href="#bimg-translateddsformat" class="header-anchor">#</a> <code>bimg::TranslateDdsFormat</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_format</td></tr> <tr><td>4</td> <td>(4) <code>_BYTE[4]</code></td> <td>m_textureFormat</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>m_srgb</td></tr></tbody></table> <h3 id="bimg-imageblockinfo"><a href="#bimg-imageblockinfo" class="header-anchor">#</a> <code>bimg::ImageBlockInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>bitsPerPixel</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>blockWidth</td></tr> <tr><td>2</td> <td>(1) <code>unsigned __int8</code></td> <td>blockHeight</td></tr> <tr><td>3</td> <td>(1) <code>unsigned __int8</code></td> <td>blockSize</td></tr> <tr><td>4</td> <td>(1) <code>unsigned __int8</code></td> <td>minBlockX</td></tr> <tr><td>5</td> <td>(1) <code>unsigned __int8</code></td> <td>minBlockY</td></tr> <tr><td>6</td> <td>(1) <code>unsigned __int8</code></td> <td>depthBits</td></tr> <tr><td>7</td> <td>(1) <code>unsigned __int8</code></td> <td>stencilBits</td></tr> <tr><td>8</td> <td>(1) <code>unsigned __int8</code></td> <td>rBits</td></tr> <tr><td>9</td> <td>(1) <code>unsigned __int8</code></td> <td>gBits</td></tr> <tr><td>10</td> <td>(1) <code>unsigned __int8</code></td> <td>bBits</td></tr> <tr><td>11</td> <td>(1) <code>unsigned __int8</code></td> <td>aBits</td></tr> <tr><td>12</td> <td>(1) <code>unsigned __int8</code></td> <td>encoding</td></tr></tbody></table> <h3 id="bimg-bc7modeinfo"><a href="#bimg-bc7modeinfo" class="header-anchor">#</a> <code>bimg::Bc7ModeInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>numSubsets</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>partitionBits</td></tr> <tr><td>2</td> <td>(1) <code>unsigned __int8</code></td> <td>rotationBits</td></tr> <tr><td>3</td> <td>(1) <code>unsigned __int8</code></td> <td>indexSelectionBits</td></tr> <tr><td>4</td> <td>(1) <code>unsigned __int8</code></td> <td>colorBits</td></tr> <tr><td>5</td> <td>(1) <code>unsigned __int8</code></td> <td>alphaBits</td></tr> <tr><td>6</td> <td>(1) <code>unsigned __int8</code></td> <td>endpointPBits</td></tr> <tr><td>7</td> <td>(1) <code>unsigned __int8</code></td> <td>sharedPBits</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int8[2]</code></td> <td>indexBits</td></tr></tbody></table> <h3 id="bimg-bc6hmodeinfo"><a href="#bimg-bc6hmodeinfo" class="header-anchor">#</a> <code>bimg::Bc6hModeInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>transformed</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>partitionBits</td></tr> <tr><td>2</td> <td>(1) <code>unsigned __int8</code></td> <td>endpointBits</td></tr> <tr><td>3</td> <td>(3) <code>unsigned __int8[3]</code></td> <td>deltaBits</td></tr></tbody></table> <h3 id="bimg-ktxformatinfo2"><a href="#bimg-ktxformatinfo2" class="header-anchor">#</a> <code>bimg::KtxFormatInfo2</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_internalFmt</td></tr> <tr><td>4</td> <td>(4) <code>_BYTE[4]</code></td> <td>m_format</td></tr></tbody></table> <h3 id="bimg-ktxformatinfo"><a href="#bimg-ktxformatinfo" class="header-anchor">#</a> <code>bimg::KtxFormatInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_internalFmt</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_internalFmtSrgb</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_fmt</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_type</td></tr></tbody></table> <h3 id="bimg-translateddspixelformat"><a href="#bimg-translateddspixelformat" class="header-anchor">#</a> <code>bimg::TranslateDdsPixelFormat</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_bitCount</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_flags</td></tr> <tr><td>8</td> <td>(16) <code>unsigned int[4]</code></td> <td>m_bitmask</td></tr> <tr><td>24</td> <td>(4) <code>_BYTE[4]</code></td> <td>m_textureFormat</td></tr></tbody></table> <h3 id="bimg-packunpack"><a href="#bimg-packunpack" class="header-anchor">#</a> <code>bimg::PackUnpack</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void (__fastcall *)(void *, const float *)</code></td> <td>pack</td></tr> <tr><td>8</td> <td>(8) <code>void (__fastcall *)(float *, const void *)</code></td> <td>unpack</td></tr></tbody></table> <h3 id="bimg-cubemapface-neighbour"><a href="#bimg-cubemapface-neighbour" class="header-anchor">#</a> <code>bimg::CubeMapFace::Neighbour</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>m_faceIdx</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>m_faceEdge</td></tr></tbody></table> <h3 id="bimg-cubemapface"><a href="#bimg-cubemapface" class="header-anchor">#</a> <code>bimg::CubeMapFace</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(36) <code>float[3][3]</code></td> <td>uv</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-mce-shadergroup"><a href="#bedrock-nonownerpointer-mce-shadergroup" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;mce::ShaderGroup&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="burnodds"><a href="#burnodds" class="header-anchor">#</a> <code>BurnOdds</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mChance</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-appconfigs"><a href="#bedrock-nonownerpointer-appconfigs" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;AppConfigs&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-bedrock-iapplicationdatastores"><a href="#bedrock-nonownerpointer-bedrock-iapplicationdatastores" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Bedrock::IApplicationDataStores&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-int-automaticid-dimension-int"><a href="#bidirectionalunorderedmap-int-automaticid-dimension-int" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;int,AutomaticID&lt;Dimension,int&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;int,AutomaticID&lt;Dimension,int&gt;&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;AutomaticID&lt;Dimension,int&gt;,int,std::hash&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::equal_to&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::allocator&lt;std::pair&lt;AutomaticID&lt;Dimension,int&gt; const ,int&gt; &gt; &gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-cg-igraphicsdevicevendorprovider"><a href="#bedrock-nonownerpointer-cg-igraphicsdevicevendorprovider" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;cg::IGraphicsDeviceVendorProvider&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-profilingmanager"><a href="#bedrock-nonownerpointer-profilingmanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ProfilingManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-complexinventorytransaction-type-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-complexinventorytransaction-type-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ComplexInventoryTransaction::Type,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum ComplexInventoryTransaction::Type,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ComplexInventoryTransaction::Type&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="backwardscompattextureinfo"><a href="#backwardscompattextureinfo" class="header-anchor">#</a> <code>BackwardsCompatTextureInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mUse</td></tr> <tr><td>4</td> <td>(8) <code>glm::tvec2&lt;float,0&gt;</code></td> <td>mUVSize</td></tr> <tr><td>12</td> <td>(8) <code>glm::tvec2&lt;float,0&gt;</code></td> <td>mUV</td></tr> <tr><td>20</td> <td>(8) <code>glm::tvec2&lt;float,0&gt;</code></td> <td>mBaseSize</td></tr> <tr><td>32</td> <td>(32) <code>Core::PathBuffer&lt;std::string &gt;</code></td> <td>mBackCompatTexture</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-cg-igraphicsdeviceplatformprovider"><a href="#bedrock-nonownerpointer-cg-igraphicsdeviceplatformprovider" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;cg::IGraphicsDevicePlatformProvider&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="behaviortreedefinitionptr"><a href="#behaviortreedefinitionptr" class="header-anchor">#</a> <code>BehaviorTreeDefinitionPtr</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BehaviorTreeGroup *</code></td> <td>mGroup</td></tr> <tr><td>8</td> <td>(8) <code>BehaviorTreeDefinition *</code></td> <td>mPtr</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-serviceclientscheduler"><a href="#bedrock-nonownerpointer-serviceclientscheduler" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ServiceClientScheduler&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-social-multiplayerservicemanager"><a href="#bedrock-nonownerpointer-social-multiplayerservicemanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Social::MultiplayerServiceManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="beardkernel"><a href="#beardkernel" class="header-anchor">#</a> <code>BeardKernel</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(55296) <code>const std::array&lt;float,13824&gt;</code></td> <td>mKernel</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-ientitlementmanager"><a href="#bedrock-nonownerpointer-ientitlementmanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;IEntitlementManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-itemuseinventorytransaction-actiontype-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-itemuseinventorytransaction-actiontype-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemUseInventoryTransaction::ActionType,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum ItemUseInventoryTransaction::ActionType,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ItemUseInventoryTransaction::ActionType&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-datemanager"><a href="#bedrock-nonownerpointer-datemanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;DateManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-std-basic-string-char-std-char-traits-char-std-allocator-char-automaticid-dimension-int"><a href="#bidirectionalunorderedmap-std-basic-string-char-std-char-traits-char-std-allocator-char-automaticid-dimension-int" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;,AutomaticID&lt;Dimension,int&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;std::string,AutomaticID&lt;Dimension,int&gt;&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;AutomaticID&lt;Dimension,int&gt;,std::string,std::hash&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::equal_to&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::allocator&lt;std::pair&lt;AutomaticID&lt;Dimension,int&gt; const ,std::string &gt; &gt; &gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-itemacquisitionmethod-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-itemacquisitionmethod-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemAcquisitionMethod,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum ItemAcquisitionMethod,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ItemAcquisitionMethod&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-offerrepository"><a href="#bedrock-nonownerpointer-offerrepository" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;OfferRepository&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bgfx-caps"><a href="#bgfx-caps" class="header-anchor">#</a> <code>bgfx::Caps</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::RendererType::Enum</code></td> <td>rendererType</td></tr> <tr><td>4</td> <td>(32) <code>char[32]</code></td> <td>rendererVersion</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>rendererFeatureVersion</td></tr> <tr><td>48</td> <td>(8) <code>unsigned __int64</code></td> <td>supported</td></tr> <tr><td>56</td> <td>(2) <code>unsigned __int16</code></td> <td>vendorId</td></tr> <tr><td>58</td> <td>(2) <code>unsigned __int16</code></td> <td>deviceId</td></tr> <tr><td>60</td> <td>(4) <code>unsigned int</code></td> <td>subSysId</td></tr> <tr><td>64</td> <td>(4) <code>unsigned int</code></td> <td>revision</td></tr> <tr><td>72</td> <td>(8) <code>unsigned __int64</code></td> <td>dedicatedVideoMemory</td></tr> <tr><td>80</td> <td>(8) <code>unsigned __int64</code></td> <td>dedicatedSystemMemory</td></tr> <tr><td>88</td> <td>(8) <code>unsigned __int64</code></td> <td>sharedSystemMemory</td></tr> <tr><td>96</td> <td>(8) <code>unsigned __int64</code></td> <td>reservedVideoMemory</td></tr> <tr><td>104</td> <td>(512) <code>char[512]</code></td> <td>chipsetName</td></tr> <tr><td>616</td> <td>(1) <code>bool</code></td> <td>homogeneousDepth</td></tr> <tr><td>617</td> <td>(1) <code>bool</code></td> <td>originBottomLeft</td></tr> <tr><td>618</td> <td>(1) <code>unsigned __int8</code></td> <td>numGPUs</td></tr> <tr><td>620</td> <td>(4) <code>unsigned int</code></td> <td>displayWidth</td></tr> <tr><td>624</td> <td>(4) <code>unsigned int</code></td> <td>displayHeight</td></tr> <tr><td>632</td> <td>(2240) <code>bgfx::Caps::GPU[4]</code></td> <td>gpu</td></tr> <tr><td>2872</td> <td>(96) <code>bgfx::Caps::Limits</code></td> <td>limits</td></tr> <tr><td>2968</td> <td>(170) <code>unsigned __int16[85]</code></td> <td>formats</td></tr></tbody></table> <h3 id="bgfx-caps-gpu"><a href="#bgfx-caps-gpu" class="header-anchor">#</a> <code>bgfx::Caps::GPU</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>vendorId</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>deviceId</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>subSysId</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>revision</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>dedicatedVideoMemory</td></tr> <tr><td>24</td> <td>(8) <code>unsigned __int64</code></td> <td>dedicatedSystemMemory</td></tr> <tr><td>32</td> <td>(8) <code>unsigned __int64</code></td> <td>sharedSystemMemory</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>reservedVideoMemory</td></tr> <tr><td>48</td> <td>(512) <code>char[512]</code></td> <td>chipsetName</td></tr></tbody></table> <h3 id="bgfx-caps-limits"><a href="#bgfx-caps-limits" class="header-anchor">#</a> <code>bgfx::Caps::Limits</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>maxDrawCalls</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>maxBlits</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>maxTextureSize</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>maxTextureLayers</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>maxViews</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>maxFrameBuffers</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>maxFBAttachments</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>maxPrograms</td></tr> <tr><td>32</td> <td>(4) <code>unsigned int</code></td> <td>maxShaders</td></tr> <tr><td>36</td> <td>(4) <code>unsigned int</code></td> <td>maxTextures</td></tr> <tr><td>40</td> <td>(4) <code>unsigned int</code></td> <td>maxTextureSamplers</td></tr> <tr><td>44</td> <td>(4) <code>unsigned int</code></td> <td>maxVertexDecls</td></tr> <tr><td>48</td> <td>(4) <code>unsigned int</code></td> <td>maxVertexStreams</td></tr> <tr><td>52</td> <td>(4) <code>unsigned int</code></td> <td>maxIndexBuffers</td></tr> <tr><td>56</td> <td>(4) <code>unsigned int</code></td> <td>maxVertexBuffers</td></tr> <tr><td>60</td> <td>(4) <code>unsigned int</code></td> <td>maxDynamicIndexBuffers</td></tr> <tr><td>64</td> <td>(4) <code>unsigned int</code></td> <td>maxDynamicVertexBuffers</td></tr> <tr><td>68</td> <td>(4) <code>unsigned int</code></td> <td>maxUniforms</td></tr> <tr><td>72</td> <td>(4) <code>unsigned int</code></td> <td>maxOcclusionQueries</td></tr> <tr><td>76</td> <td>(4) <code>unsigned int</code></td> <td>maxEncoders</td></tr> <tr><td>80</td> <td>(4) <code>unsigned int</code></td> <td>transientVbSize</td></tr> <tr><td>84</td> <td>(4) <code>unsigned int</code></td> <td>transientIbSize</td></tr> <tr><td>88</td> <td>(4) <code>unsigned int</code></td> <td>maxAccelerationStructures</td></tr> <tr><td>92</td> <td>(4) <code>unsigned int</code></td> <td>avgAccelerationStructureSize</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-social-usermanager"><a href="#bedrock-nonownerpointer-social-usermanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Social::UserManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-mce-filewatchernull"><a href="#bedrock-nonownerpointer-mce-filewatchernull" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;mce::FileWatcherNull&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-particletype-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-particletype-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ParticleType,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum ParticleType,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ParticleType&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-iminecrafteventing"><a href="#bedrock-nonownerpointer-iminecrafteventing" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;IMinecraftEventing&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-serverinstance"><a href="#bedrock-nonownerpointer-serverinstance" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ServerInstance&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-iapp"><a href="#bedrock-nonownerpointer-iapp" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;IApp&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-basictestprofilestats"><a href="#bedrock-nonownerpointer-basictestprofilestats" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;BasicTestProfileStats&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-gamerelightingtestdata"><a href="#bedrock-nonownerpointer-gamerelightingtestdata" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;GameRelightingTestData&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-core-loadtimeprofiler"><a href="#bedrock-nonownerpointer-core-loadtimeprofiler" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Core::LoadTimeProfiler&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-networkdebugmanager"><a href="#bedrock-nonownerpointer-networkdebugmanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;NetworkDebugManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-iraytracingoptions"><a href="#bedrock-nonownerpointer-iraytracingoptions" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;IRayTracingOptions&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-std-basic-string-char-std-char-traits-char-std-allocator-char-enum-levelsoundevent"><a href="#bidirectionalunorderedmap-std-basic-string-char-std-char-traits-char-std-allocator-char-enum-levelsoundevent" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;,enum LevelSoundEvent&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;std::string,enum LevelSoundEvent&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;enum LevelSoundEvent,std::string&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-appplatform"><a href="#bedrock-nonownerpointer-appplatform" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;AppPlatform&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-std-basic-string-char-std-char-traits-char-std-allocator-char-enum-filtersubject"><a href="#bidirectionalunorderedmap-std-basic-string-char-std-char-traits-char-std-allocator-char-enum-filtersubject" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;,enum FilterSubject&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;std::string,enum FilterSubject&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;enum FilterSubject,std::string&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bgfx-dreddata"><a href="#bgfx-dreddata" class="header-anchor">#</a> <code>bgfx::DREDData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>m_enableDRED</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>m_breadCrumbStrings</td></tr> <tr><td>32</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>m_pageFaultFreedDataStrings</td></tr> <tr><td>56</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>m_pageFaultExistingDataStrings</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-itemusemethod-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-itemusemethod-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemUseMethod,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum ItemUseMethod,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ItemUseMethod&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-chunkperformancedata"><a href="#bedrock-nonownerpointer-chunkperformancedata" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ChunkPerformanceData&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-contenttiermanager-validatorregistry"><a href="#bedrock-nonownerpointer-contenttiermanager-validatorregistry" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ContentTierManager::ValidatorRegistry&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-mce-framebuilder-framebuilder"><a href="#bedrock-nonownerpointer-mce-framebuilder-framebuilder" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;mce::framebuilder::FrameBuilder&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-itemstacknetresult-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-itemstacknetresult-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemStackNetResult,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum ItemStackNetResult,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ItemStackNetResult&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-gamestore"><a href="#bedrock-nonownerpointer-gamestore" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;GameStore&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-datautils-miscdata"><a href="#bedrock-nonownerpointer-datautils-miscdata" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;DataUtils::MiscData&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-threading-instancedthreadlocal-bool-cdecl-asserthandlercontext-const-std-allocator-bool-cdecl-asserthandlercontext-const"><a href="#bedrock-threading-instancedthreadlocal-bool-cdecl-asserthandlercontext-const-std-allocator-bool-cdecl-asserthandlercontext-const" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;bool (__cdecl**)(AssertHandlerContext const &amp;),std::allocator&lt;bool (__cdecl**)(AssertHandlerContext const &amp;)&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;void __cdecl(bool (__cdecl** *)(AssertHandlerContext const &amp;))&gt;</code></td> <td>mConstructor</td></tr> <tr><td>64</td> <td>(16) <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;bool (__cdecl**)(AssertHandlerContext const &amp;),std::allocator&lt;bool (__cdecl**)(AssertHandlerContext const &amp;)&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;</code></td> <td>mItems</td></tr> <tr><td>80</td> <td>(80) <code>std::mutex</code></td> <td>mMutex</td></tr> <tr><td>160</td> <td>(4) <code>unsigned int</code></td> <td>mKey</td></tr> <tr><td>164</td> <td>(1) <code>bool</code></td> <td>mInitialized</td></tr></tbody></table> <h3 id="bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-bool-cdecl-asserthandlercontext-const-std-allocator-bool-cdecl-asserthandlercontext-const-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void"><a href="#bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-bool-cdecl-asserthandlercontext-const-std-allocator-bool-cdecl-asserthandlercontext-const-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;bool (__cdecl**)(AssertHandlerContext const &amp;),std::allocator&lt;bool (__cdecl**)(AssertHandlerContext const &amp;)&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>Bedrock::Intrusive::list_base_hook&lt;void&gt;</code></td> <td>mSentinel</td></tr></tbody></table> <h3 id="bedrock-intrusive-list-base-hook-void"><a href="#bedrock-intrusive-list-base-hook-void" class="header-anchor">#</a> <code>Bedrock::Intrusive::list_base_hook&lt;void&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Bedrock::Intrusive::list_base_hook&lt;void&gt; *</code></td> <td>mNext</td></tr> <tr><td>8</td> <td>(8) <code>Bedrock::Intrusive::list_base_hook&lt;void&gt; *</code></td> <td>mPrev</td></tr></tbody></table> <h3 id="bedrocktexturedata"><a href="#bedrocktexturedata" class="header-anchor">#</a> <code>BedrockTextureData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>mce::ClientTexture</code></td> <td>mClientTexture</td></tr> <tr><td>16</td> <td>(112) <code>mce::TextureDescription</code></td> <td>mTextureDescription</td></tr> <tr><td>128</td> <td>(1) <code>IsMissingTexture</code></td> <td>mIsMissingTexture</td></tr> <tr><td>129</td> <td>(1) <code>TextureLoadState</code></td> <td>mTextureLoadState</td></tr> <tr><td>136</td> <td>(24) <code>cg::TextureSetImageDescription</code></td> <td>mTextureSetDescription</td></tr></tbody></table> <h3 id="bgfx-platformdata"><a href="#bgfx-platformdata" class="header-anchor">#</a> <code>bgfx::PlatformData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void *</code></td> <td>ndt</td></tr> <tr><td>8</td> <td>(8) <code>void *</code></td> <td>nwh</td></tr> <tr><td>16</td> <td>(8) <code>void *</code></td> <td>context</td></tr> <tr><td>24</td> <td>(8) <code>void *</code></td> <td>backBuffer</td></tr> <tr><td>32</td> <td>(8) <code>void *</code></td> <td>backBufferDS</td></tr> <tr><td>40</td> <td>(8) <code>void *</code></td> <td>session</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-inventorytransactionerror-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-inventorytransactionerror-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum InventoryTransactionError,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum InventoryTransactionError,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum InventoryTransactionError&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-itemstackrequestactiontype-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-itemstackrequestactiontype-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemStackRequestActionType,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum ItemStackRequestActionType,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ItemStackRequestActionType&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-featuretoggles"><a href="#bedrock-nonownerpointer-featuretoggles" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;FeatureToggles&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-bedrock-threading-pendingconditionals"><a href="#bedrock-nonownerpointer-bedrock-threading-pendingconditionals" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Bedrock::Threading::PendingConditionals&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="backwardscompattexturegroup"><a href="#backwardscompattexturegroup" class="header-anchor">#</a> <code>BackwardsCompatTextureGroup</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;ResourceLocation,BackwardsCompatTextureInfo&gt;</code></td> <td>mBackCompatMap</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-educationoptions"><a href="#bedrock-nonownerpointer-educationoptions" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;EducationOptions&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-resourceloadmanager"><a href="#bedrock-nonownerpointer-resourceloadmanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ResourceLoadManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-sparsecontainer-pushslotpredictionresult-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-sparsecontainer-pushslotpredictionresult-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum SparseContainer::PushSlotPredictionResult,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum SparseContainer::PushSlotPredictionResult,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum SparseContainer::PushSlotPredictionResult&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-packmanifest-capabilityregistry"><a href="#bedrock-nonownerpointer-packmanifest-capabilityregistry" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;PackManifest::CapabilityRegistry&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-contentlog"><a href="#bedrock-nonownerpointer-contentlog" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ContentLog&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-enum-containertype-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#bidirectionalunorderedmap-enum-containertype-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ContainerType,std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;enum ContainerType,std::string&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;std::string,enum ContainerType&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="bgfx-internaldata"><a href="#bgfx-internaldata" class="header-anchor">#</a> <code>bgfx::InternalData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const bgfx::Caps *</code></td> <td>caps</td></tr> <tr><td>8</td> <td>(8) <code>void *</code></td> <td>context</td></tr></tbody></table> <h3 id="bedrock-threading-burst-details-workertaskstats-std-atomic-unsigned-int64"><a href="#bedrock-threading-burst-details-workertaskstats-std-atomic-unsigned-int64" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Details::WorkerTaskStats&lt;std::atomic&lt;unsigned __int64&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mTasksQueued</td></tr> <tr><td>8</td> <td>(8) <code>std::atomic&lt;unsigned __int64&gt;</code></td> <td>mTasksCompleted</td></tr></tbody></table> <h3 id="bgfx-vk-renderercontextvk"><a href="#bgfx-vk-renderercontextvk" class="header-anchor">#</a> <code>bgfx::vk::RendererContextVK</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::RendererContextI</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>VkAllocationCallbacks *</code></td> <td>m_allocatorCb</td></tr> <tr><td>16</td> <td>(8) <code>struct VkDebugReportCallbackEXT_T *</code></td> <td>m_debugReportCallback</td></tr> <tr><td>24</td> <td>(8) <code>VkInstance_T *</code></td> <td>m_instance</td></tr> <tr><td>32</td> <td>(8) <code>VkPhysicalDevice_T *</code></td> <td>m_physicalDevice</td></tr> <tr><td>40</td> <td>(824) <code>VkPhysicalDeviceProperties</code></td> <td>m_deviceProperties</td></tr> <tr><td>864</td> <td>(520) <code>VkPhysicalDeviceMemoryProperties</code></td> <td>m_memoryProperties</td></tr> <tr><td>1384</td> <td>(220) <code>VkPhysicalDeviceFeatures</code></td> <td>m_deviceFeatures</td></tr> <tr><td>1608</td> <td>(104) <code>VkSwapchainCreateInfoKHR</code></td> <td>m_sci</td></tr> <tr><td>1712</td> <td>(8) <code>VkSurfaceKHR_T *</code></td> <td>m_surface</td></tr> <tr><td>1720</td> <td>(8) <code>bgfx::vk::VkSwapchainKHR</code></td> <td>m_swapchain</td></tr> <tr><td>1728</td> <td>(4) <code>unsigned int</code></td> <td>m_numSwapchainImages</td></tr> <tr><td>1732</td> <td>(16) <code>VkImageLayout[4]</code></td> <td>m_backBufferColorImageLayout</td></tr> <tr><td>1752</td> <td>(32) <code>bgfx::vk::VkImage[4]</code></td> <td>m_backBufferColorImage</td></tr> <tr><td>1784</td> <td>(32) <code>bgfx::vk::VkImageView[4]</code></td> <td>m_backBufferColorImageView</td></tr> <tr><td>1816</td> <td>(32) <code>bgfx::vk::VkFramebuffer[4]</code></td> <td>m_backBufferColor</td></tr> <tr><td>1848</td> <td>(32) <code>VkCommandBuffer_T *[4]</code></td> <td>m_commandBuffers</td></tr> <tr><td>1880</td> <td>(8) <code>VkCommandBuffer_T *</code></td> <td>m_commandBuffer</td></tr> <tr><td>1888</td> <td>(1) <code>bool</code></td> <td>m_needToRefreshSwapchain</td></tr> <tr><td>1892</td> <td>(4) <code>VkFormat</code></td> <td>m_backBufferDepthStencilFormat</td></tr> <tr><td>1896</td> <td>(8) <code>VkDeviceMemory_T *</code></td> <td>m_backBufferDepthStencilMemory</td></tr> <tr><td>1904</td> <td>(8) <code>bgfx::vk::VkImage</code></td> <td>m_backBufferDepthStencilImage</td></tr> <tr><td>1912</td> <td>(8) <code>bgfx::vk::VkImageView</code></td> <td>m_backBufferDepthStencilImageView</td></tr> <tr><td>1920</td> <td>(192) <code>bgfx::vk::ScratchBufferVK[4]</code></td> <td>m_scratchBuffer</td></tr> <tr><td>2112</td> <td>(32) <code>bgfx::vk::VkSemaphore[4]</code></td> <td>m_presentDone</td></tr> <tr><td>2144</td> <td>(4) <code>unsigned int</code></td> <td>m_qfiGraphics</td></tr> <tr><td>2148</td> <td>(4) <code>unsigned int</code></td> <td>m_qfiCompute</td></tr> <tr><td>2152</td> <td>(8) <code>VkDevice_T *</code></td> <td>m_device</td></tr> <tr><td>2160</td> <td>(8) <code>VkQueue_T *</code></td> <td>m_queueGraphics</td></tr> <tr><td>2168</td> <td>(8) <code>VkQueue_T *</code></td> <td>m_queueCompute</td></tr> <tr><td>2176</td> <td>(8) <code>bgfx::vk::VkFence</code></td> <td>m_fence</td></tr> <tr><td>2184</td> <td>(8) <code>bgfx::vk::VkRenderPass</code></td> <td>m_renderPass</td></tr> <tr><td>2192</td> <td>(8) <code>bgfx::vk::VkDescriptorPool</code></td> <td>m_descriptorPool</td></tr> <tr><td>2200</td> <td>(8) <code>bgfx::vk::VkPipelineCache</code></td> <td>m_pipelineCache</td></tr> <tr><td>2208</td> <td>(8) <code>bgfx::vk::VkCommandPool</code></td> <td>m_commandPool</td></tr> <tr><td>2216</td> <td>(8) <code>void *</code></td> <td>m_renderDocDll</td></tr> <tr><td>2224</td> <td>(8) <code>void *</code></td> <td>m_vulkan1Dll</td></tr> <tr><td>2232</td> <td>(98304) <code>bgfx::vk::BufferVK[4096]</code></td> <td>m_indexBuffers</td></tr> <tr><td>100536</td> <td>(131072) <code>bgfx::vk::VertexBufferVK[4096]</code></td> <td>m_vertexBuffers</td></tr> <tr><td>231608</td> <td>(8159232) <code>bgfx::vk::ShaderVK[4096]</code></td> <td>m_shaders</td></tr> <tr><td>8390840</td> <td>(458752) <code>bgfx::vk::ProgramVK[2048]</code></td> <td>m_program</td></tr> <tr><td>8849592</td> <td>(425984) <code>bgfx::vk::TextureVK[4096]</code></td> <td>m_textures</td></tr> <tr><td>9275576</td> <td>(5120) <code>bgfx::VertexDecl[64]</code></td> <td>m_vertexDecls</td></tr> <tr><td>9280696</td> <td>(13312) <code>bgfx::vk::FrameBufferVK[128]</code></td> <td>m_frameBuffers</td></tr> <tr><td>9294008</td> <td>(4096) <code>void *[512]</code></td> <td>m_uniforms</td></tr> <tr><td>9298104</td> <td>(7176) <code>bgfx::UniformRegistry</code></td> <td>m_uniformReg</td></tr> <tr><td>9305280</td> <td>(32) <code>bgfx::vk::StateCacheT&lt;bgfx::vk::VkPipeline&gt;</code></td> <td>m_pipelineStateCache</td></tr> <tr><td>9305312</td> <td>(32) <code>bgfx::vk::StateCacheT&lt;bgfx::vk::VkDescriptorSetLayout&gt;</code></td> <td>m_descriptorSetLayoutCache</td></tr> <tr><td>9305344</td> <td>(32) <code>bgfx::vk::StateCacheT&lt;bgfx::vk::VkRenderPass&gt;</code></td> <td>m_renderPassCache</td></tr> <tr><td>9305376</td> <td>(32) <code>bgfx::vk::StateCacheT&lt;bgfx::vk::VkSampler&gt;</code></td> <td>m_samplerCache</td></tr> <tr><td>9305408</td> <td>(12) <code>bgfx::Resolution</code></td> <td>m_resolution</td></tr> <tr><td>9305420</td> <td>(4) <code>unsigned int</code></td> <td>m_maxAnisotropy</td></tr> <tr><td>9305424</td> <td>(1) <code>bool</code></td> <td>m_depthClamp</td></tr> <tr><td>9305425</td> <td>(1) <code>bool</code></td> <td>m_wireframe</td></tr> <tr><td>9305432</td> <td>(24) <code>bgfx::TextVideoMem</code></td> <td>m_textVideoMem</td></tr> <tr><td>9305456</td> <td>(65536) <code>unsigned __int8[65536]</code></td> <td>m_fsScratch</td></tr> <tr><td>9370992</td> <td>(65536) <code>unsigned __int8[65536]</code></td> <td>m_vsScratch</td></tr> <tr><td>9436528</td> <td>(4) <code>unsigned int</code></td> <td>m_fsChanges</td></tr> <tr><td>9436532</td> <td>(4) <code>unsigned int</code></td> <td>m_vsChanges</td></tr> <tr><td>9436536</td> <td>(4) <code>unsigned int</code></td> <td>m_backBufferColorIdx</td></tr> <tr><td>9436540</td> <td>(2) <code>bgfx::FrameBufferHandle</code></td> <td>m_fbh</td></tr></tbody></table> <h3 id="bgfx-renderercontexti"><a href="#bgfx-renderercontexti" class="header-anchor">#</a> <code>bgfx::RendererContextI</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::RendererContextI_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="bgfx-vk-vkswapchainkhr"><a href="#bgfx-vk-vkswapchainkhr" class="header-anchor">#</a> <code>bgfx::vk::VkSwapchainKHR</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkSwapchainKHR_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vkimage"><a href="#bgfx-vk-vkimage" class="header-anchor">#</a> <code>bgfx::vk::VkImage</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkImage_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vkimageview"><a href="#bgfx-vk-vkimageview" class="header-anchor">#</a> <code>bgfx::vk::VkImageView</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkImageView_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vkframebuffer"><a href="#bgfx-vk-vkframebuffer" class="header-anchor">#</a> <code>bgfx::vk::VkFramebuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkFramebuffer_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-scratchbuffervk"><a href="#bgfx-vk-scratchbuffervk" class="header-anchor">#</a> <code>bgfx::vk::ScratchBufferVK</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkDescriptorSet_T **</code></td> <td>m_descriptorSet</td></tr> <tr><td>8</td> <td>(8) <code>bgfx::vk::VkBuffer</code></td> <td>m_buffer</td></tr> <tr><td>16</td> <td>(8) <code>VkDeviceMemory_T *</code></td> <td>m_deviceMem</td></tr> <tr><td>24</td> <td>(8) <code>unsigned __int8 *</code></td> <td>m_data</td></tr> <tr><td>32</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>36</td> <td>(4) <code>unsigned int</code></td> <td>m_pos</td></tr> <tr><td>40</td> <td>(4) <code>unsigned int</code></td> <td>m_currentDs</td></tr> <tr><td>44</td> <td>(4) <code>unsigned int</code></td> <td>m_maxDescriptors</td></tr></tbody></table> <h3 id="bgfx-vk-vkbuffer"><a href="#bgfx-vk-vkbuffer" class="header-anchor">#</a> <code>bgfx::vk::VkBuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkBuffer_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vksemaphore"><a href="#bgfx-vk-vksemaphore" class="header-anchor">#</a> <code>bgfx::vk::VkSemaphore</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkSemaphore_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vkfence"><a href="#bgfx-vk-vkfence" class="header-anchor">#</a> <code>bgfx::vk::VkFence</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkFence_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vkrenderpass"><a href="#bgfx-vk-vkrenderpass" class="header-anchor">#</a> <code>bgfx::vk::VkRenderPass</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkRenderPass_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vkdescriptorpool"><a href="#bgfx-vk-vkdescriptorpool" class="header-anchor">#</a> <code>bgfx::vk::VkDescriptorPool</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkDescriptorPool_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vkpipelinecache"><a href="#bgfx-vk-vkpipelinecache" class="header-anchor">#</a> <code>bgfx::vk::VkPipelineCache</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkPipelineCache_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-vkcommandpool"><a href="#bgfx-vk-vkcommandpool" class="header-anchor">#</a> <code>bgfx::vk::VkCommandPool</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkCommandPool_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-buffervk"><a href="#bgfx-vk-buffervk" class="header-anchor">#</a> <code>bgfx::vk::BufferVK</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::vk::VkBuffer</code></td> <td>m_buffer</td></tr> <tr><td>8</td> <td>(8) <code>VkDeviceMemory_T *</code></td> <td>m_deviceMem</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>20</td> <td>(2) <code>unsigned __int16</code></td> <td>m_flags</td></tr> <tr><td>22</td> <td>(1) <code>bool</code></td> <td>m_dynamic</td></tr></tbody></table> <h3 id="bgfx-vk-vertexbuffervk"><a href="#bgfx-vk-vertexbuffervk" class="header-anchor">#</a> <code>bgfx::vk::VertexBufferVK</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>bgfx::vk::BufferVK</code></td> <td>baseclass_0</td></tr> <tr><td>24</td> <td>(2) <code>bgfx::VertexDeclHandle</code></td> <td>m_decl</td></tr></tbody></table> <h3 id="bgfx-vertexdeclhandle"><a href="#bgfx-vertexdeclhandle" class="header-anchor">#</a> <code>bgfx::VertexDeclHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-vk-shadervk"><a href="#bgfx-vk-shadervk" class="header-anchor">#</a> <code>bgfx::vk::ShaderVK</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const bgfx::Memory *</code></td> <td>m_code</td></tr> <tr><td>8</td> <td>(8) <code>bgfx::vk::VkShaderModule</code></td> <td>m_module</td></tr> <tr><td>16</td> <td>(8) <code>bgfx::UniformBuffer *</code></td> <td>m_constantBuffer</td></tr> <tr><td>24</td> <td>(96) <code>bgfx::PredefinedUniform[12]</code></td> <td>m_predefined</td></tr> <tr><td>120</td> <td>(36) <code>unsigned __int16[18]</code></td> <td>m_attrMask</td></tr> <tr><td>156</td> <td>(18) <code>unsigned __int8[18]</code></td> <td>m_attrRemap</td></tr> <tr><td>176</td> <td>(4) <code>unsigned int</code></td> <td>m_hash</td></tr> <tr><td>180</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numUniforms</td></tr> <tr><td>182</td> <td>(2) <code>unsigned __int16</code></td> <td>m_size</td></tr> <tr><td>184</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numPredefined</td></tr> <tr><td>185</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numAttrs</td></tr> <tr><td>188</td> <td>(1024) <code>bgfx::vk::ShaderVK::BindInfo[64]</code></td> <td>m_bindInfo</td></tr> <tr><td>1212</td> <td>(4) <code>unsigned int</code></td> <td>m_uniformBinding</td></tr> <tr><td>1216</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numBindings</td></tr> <tr><td>1224</td> <td>(768) <code>VkDescriptorSetLayoutBinding[32]</code></td> <td>m_bindings</td></tr></tbody></table> <h3 id="bgfx-vk-vkshadermodule"><a href="#bgfx-vk-vkshadermodule" class="header-anchor">#</a> <code>bgfx::vk::VkShaderModule</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkShaderModule_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-predefineduniform"><a href="#bgfx-predefineduniform" class="header-anchor">#</a> <code>bgfx::PredefinedUniform</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_loc</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>m_count</td></tr> <tr><td>6</td> <td>(1) <code>unsigned __int8</code></td> <td>m_type</td></tr></tbody></table> <h3 id="bgfx-vk-shadervk-bindinfo"><a href="#bgfx-vk-shadervk-bindinfo" class="header-anchor">#</a> <code>bgfx::vk::ShaderVK::BindInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>bgfx::UniformHandle</code></td> <td>uniformHandle</td></tr> <tr><td>4</td> <td>(4) <code>_BYTE[4]</code></td> <td>type</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>binding</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>samplerBinding</td></tr></tbody></table> <h3 id="bgfx-uniformhandle"><a href="#bgfx-uniformhandle" class="header-anchor">#</a> <code>bgfx::UniformHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-vk-programvk"><a href="#bgfx-vk-programvk" class="header-anchor">#</a> <code>bgfx::vk::ProgramVK</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const bgfx::vk::ShaderVK *</code></td> <td>m_vsh</td></tr> <tr><td>8</td> <td>(8) <code>const bgfx::vk::ShaderVK *</code></td> <td>m_fsh</td></tr> <tr><td>16</td> <td>(192) <code>bgfx::PredefinedUniform[24]</code></td> <td>m_predefined</td></tr> <tr><td>208</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numPredefined</td></tr> <tr><td>212</td> <td>(4) <code>unsigned int</code></td> <td>m_descriptorSetLayoutHash</td></tr> <tr><td>216</td> <td>(8) <code>bgfx::vk::VkPipelineLayout</code></td> <td>m_pipelineLayout</td></tr></tbody></table> <h3 id="bgfx-vk-vkpipelinelayout"><a href="#bgfx-vk-vkpipelinelayout" class="header-anchor">#</a> <code>bgfx::vk::VkPipelineLayout</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>VkPipelineLayout_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-vk-texturevk"><a href="#bgfx-vk-texturevk" class="header-anchor">#</a> <code>bgfx::vk::TextureVK</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void *</code></td> <td>m_directAccessPtr</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>m_flags</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_width</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>m_height</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_depth</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>m_numLayers</td></tr> <tr><td>32</td> <td>(4) <code>unsigned int</code></td> <td>m_numSides</td></tr> <tr><td>36</td> <td>(4) <code>VkImageViewType</code></td> <td>m_type</td></tr> <tr><td>40</td> <td>(1) <code>unsigned __int8</code></td> <td>m_requestedFormat</td></tr> <tr><td>41</td> <td>(1) <code>unsigned __int8</code></td> <td>m_textureFormat</td></tr> <tr><td>42</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numMips</td></tr> <tr><td>44</td> <td>(4) <code>VkFormat</code></td> <td>m_vkTextureFormat</td></tr> <tr><td>48</td> <td>(4) <code>unsigned int</code></td> <td>m_vkTextureAspect</td></tr> <tr><td>56</td> <td>(8) <code>bgfx::vk::VkImage</code></td> <td>m_textureImage</td></tr> <tr><td>64</td> <td>(8) <code>VkDeviceMemory_T *</code></td> <td>m_textureDeviceMem</td></tr> <tr><td>72</td> <td>(8) <code>bgfx::vk::VkImageView</code></td> <td>m_textureImageView</td></tr> <tr><td>80</td> <td>(8) <code>bgfx::vk::VkImageView</code></td> <td>m_textureImageDepthView</td></tr> <tr><td>88</td> <td>(8) <code>bgfx::vk::VkImageView</code></td> <td>m_textureImageStorageView</td></tr> <tr><td>96</td> <td>(4) <code>VkImageLayout</code></td> <td>m_currentImageLayout</td></tr></tbody></table> <h3 id="bgfx-vertexdecl"><a href="#bgfx-vertexdecl" class="header-anchor">#</a> <code>bgfx::VertexDecl</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_hash</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>m_stride</td></tr> <tr><td>6</td> <td>(36) <code>unsigned __int16[18]</code></td> <td>m_offset</td></tr> <tr><td>42</td> <td>(36) <code>unsigned __int16[18]</code></td> <td>m_attributes</td></tr></tbody></table> <h3 id="bgfx-vk-framebuffervk"><a href="#bgfx-vk-framebuffervk" class="header-anchor">#</a> <code>bgfx::vk::FrameBufferVK</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bgfx::TextureHandle[8]</code></td> <td>m_texture</td></tr> <tr><td>16</td> <td>(2) <code>bgfx::TextureHandle</code></td> <td>m_depth</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>m_width</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_height</td></tr> <tr><td>28</td> <td>(2) <code>unsigned __int16</code></td> <td>m_denseIdx</td></tr> <tr><td>30</td> <td>(1) <code>unsigned __int8</code></td> <td>m_num</td></tr> <tr><td>31</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numTh</td></tr> <tr><td>32</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numAttachment</td></tr> <tr><td>34</td> <td>(48) <code>bgfx::Attachment[8]</code></td> <td>m_attachment</td></tr> <tr><td>88</td> <td>(8) <code>bgfx::vk::VkFramebuffer</code></td> <td>m_framebuffer</td></tr> <tr><td>96</td> <td>(8) <code>bgfx::vk::VkRenderPass</code></td> <td>m_renderPass</td></tr></tbody></table> <h3 id="bgfx-attachment"><a href="#bgfx-attachment" class="header-anchor">#</a> <code>bgfx::Attachment</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>bgfx::TextureHandle</code></td> <td>handle</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>mip</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>layer</td></tr></tbody></table> <h3 id="bgfx-uniformregistry"><a href="#bgfx-uniformregistry" class="header-anchor">#</a> <code>bgfx::UniformRegistry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(6152) <code>bx::HandleHashMapT&lt;1024,unsigned int&gt;</code></td> <td>m_uniforms</td></tr> <tr><td>6152</td> <td>(1024) <code>bgfx::UniformRegInfo[512]</code></td> <td>m_info</td></tr></tbody></table> <h3 id="bx-handlehashmapt-1024-unsigned-int"><a href="#bx-handlehashmapt-1024-unsigned-int" class="header-anchor">#</a> <code>bx::HandleHashMapT&lt;1024,unsigned int&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_maxCapacity</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_numElements</td></tr> <tr><td>8</td> <td>(4096) <code>unsigned int[1024]</code></td> <td>m_key</td></tr> <tr><td>4104</td> <td>(2048) <code>unsigned __int16[1024]</code></td> <td>m_handle</td></tr></tbody></table> <h3 id="bgfx-uniformreginfo"><a href="#bgfx-uniformreginfo" class="header-anchor">#</a> <code>bgfx::UniformRegInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>bgfx::UniformHandle</code></td> <td>m_handle</td></tr></tbody></table> <h3 id="bgfx-vk-statecachet-bgfx-vk-vkpipeline"><a href="#bgfx-vk-statecachet-bgfx-vk-vkpipeline" class="header-anchor">#</a> <code>bgfx::vk::StateCacheT&lt;bgfx::vk::VkPipeline&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>tinystl::unordered_map&lt;unsigned __int64,bgfx::vk::VkPipeline,bgfx::TinyStlAllocator&gt;</code></td> <td>m_hashMap</td></tr></tbody></table> <h3 id="bgfx-vk-statecachet-bgfx-vk-vkdescriptorsetlayout"><a href="#bgfx-vk-statecachet-bgfx-vk-vkdescriptorsetlayout" class="header-anchor">#</a> <code>bgfx::vk::StateCacheT&lt;bgfx::vk::VkDescriptorSetLayout&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>tinystl::unordered_map&lt;unsigned __int64,bgfx::vk::VkDescriptorSetLayout,bgfx::TinyStlAllocator&gt;</code></td> <td>m_hashMap</td></tr></tbody></table> <h3 id="bgfx-vk-statecachet-bgfx-vk-vkrenderpass"><a href="#bgfx-vk-statecachet-bgfx-vk-vkrenderpass" class="header-anchor">#</a> <code>bgfx::vk::StateCacheT&lt;bgfx::vk::VkRenderPass&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>tinystl::unordered_map&lt;unsigned __int64,bgfx::vk::VkRenderPass,bgfx::TinyStlAllocator&gt;</code></td> <td>m_hashMap</td></tr></tbody></table> <h3 id="bgfx-vk-statecachet-bgfx-vk-vksampler"><a href="#bgfx-vk-statecachet-bgfx-vk-vksampler" class="header-anchor">#</a> <code>bgfx::vk::StateCacheT&lt;bgfx::vk::VkSampler&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>tinystl::unordered_map&lt;unsigned __int64,bgfx::vk::VkSampler,bgfx::TinyStlAllocator&gt;</code></td> <td>m_hashMap</td></tr></tbody></table> <h3 id="bgfx-resolution"><a href="#bgfx-resolution" class="header-anchor">#</a> <code>bgfx::Resolution</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>width</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>height</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>reset</td></tr></tbody></table> <h3 id="bgfx-textvideomem"><a href="#bgfx-textvideomem" class="header-anchor">#</a> <code>bgfx::TextVideoMem</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::TextVideoMem::MemSlot *</code></td> <td>m_mem</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>12</td> <td>(2) <code>unsigned __int16</code></td> <td>m_width</td></tr> <tr><td>14</td> <td>(2) <code>unsigned __int16</code></td> <td>m_height</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>m_small</td></tr></tbody></table> <h3 id="blockserializationutils-lambda-c386b27b51dd5988e6b0ca8a8aac9607"><a href="#blockserializationutils-lambda-c386b27b51dd5988e6b0ca8a8aac9607" class="header-anchor">#</a> <code>BlockSerializationUtils::&lt;lambda_c386b27b51dd5988e6b0ca8a8aac9607&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="bgfx-d3d12-programd3d12"><a href="#bgfx-d3d12-programd3d12" class="header-anchor">#</a> <code>bgfx::d3d12::ProgramD3D12</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const bgfx::d3d12::ShaderD3D12 *</code></td> <td>m_vsh</td></tr> <tr><td>8</td> <td>(8) <code>const bgfx::d3d12::ShaderD3D12 *</code></td> <td>m_fsh</td></tr> <tr><td>16</td> <td>(192) <code>bgfx::PredefinedUniform[24]</code></td> <td>m_predefined</td></tr> <tr><td>208</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numPredefined</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-workerpool"><a href="#bedrock-nonownerpointer-workerpool" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;WorkerPool&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-social-iusermanager"><a href="#bedrock-nonownerpointer-social-iusermanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Social::IUserManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="buffer-span-std-basic-string-char-std-char-traits-char-std-allocator-char"><a href="#buffer-span-std-basic-string-char-std-char-traits-char-std-allocator-char" class="header-anchor">#</a> <code>buffer_span&lt;std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const std::string *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>const std::string *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="baseattributemap"><a href="#baseattributemap" class="header-anchor">#</a> <code>BaseAttributeMap</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;unsigned int,AttributeInstance&gt;</code></td> <td>mInstanceMap</td></tr> <tr><td>64</td> <td>(24) <code>std::vector&lt;AttributeInstanceHandle&gt;</code></td> <td>mDirtyAttributes</td></tr></tbody></table> <h3 id="blockmaterialinstancescomponent"><a href="#blockmaterialinstancescomponent" class="header-anchor">#</a> <code>BlockMaterialInstancesComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;std::string,BlockMaterialInstance&gt;</code></td> <td>mMaterials</td></tr></tbody></table> <h3 id="buffer-span-mut-brightnesspair-const"><a href="#buffer-span-mut-brightnesspair-const" class="header-anchor">#</a> <code>buffer_span_mut&lt;BrightnessPair const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const BrightnessPair *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>const BrightnessPair *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="bgfx-gl-shadergl"><a href="#bgfx-gl-shadergl" class="header-anchor">#</a> <code>bgfx::gl::ShaderGL</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_id</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_type</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_hash</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-128-bgfx-framebufferhandle-bgfx-d3d12-framebufferd3d12-bgfx-d3d12-framebufferd3d12-128-resourcestateentry"><a href="#bgfx-d3d12-indexedresourcestatesmanager-128-bgfx-framebufferhandle-bgfx-d3d12-framebufferd3d12-bgfx-d3d12-framebufferd3d12-128-resourcestateentry" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;128,bgfx::FrameBufferHandle,bgfx::d3d12::FrameBufferD3D12,bgfx::d3d12::FrameBufferD3D12 [128]&gt;::ResourceStateEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_initialState</td></tr> <tr><td>4</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_currentState</td></tr></tbody></table> <h3 id="bgfx-vertexbufferhandle"><a href="#bgfx-vertexbufferhandle" class="header-anchor">#</a> <code>bgfx::VertexBufferHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-dynamicindexbufferhandle"><a href="#bgfx-dynamicindexbufferhandle" class="header-anchor">#</a> <code>bgfx::DynamicIndexBufferHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-dynamicvertexbufferhandle"><a href="#bgfx-dynamicvertexbufferhandle" class="header-anchor">#</a> <code>bgfx::DynamicVertexBufferHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-indirectbufferhandle"><a href="#bgfx-indirectbufferhandle" class="header-anchor">#</a> <code>bgfx::IndirectBufferHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-shaderbufferhandle"><a href="#bgfx-shaderbufferhandle" class="header-anchor">#</a> <code>bgfx::ShaderBufferHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="buffer-span-mut-clientblockpipeline-blockschematiccell-const"><a href="#buffer-span-mut-clientblockpipeline-blockschematiccell-const" class="header-anchor">#</a> <code>buffer_span_mut&lt;ClientBlockPipeline::BlockSchematicCell const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBlockPipeline::BlockSchematicCell *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>const ClientBlockPipeline::BlockSchematicCell *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="buffer-span-mut-clientblockpipeline-blockcell-const"><a href="#buffer-span-mut-clientblockpipeline-blockcell-const" class="header-anchor">#</a> <code>buffer_span_mut&lt;ClientBlockPipeline::BlockCell const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBlockPipeline::BlockCell *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>const ClientBlockPipeline::BlockCell *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="buffer-span-mut-clientblockpipeline-blockopacitydata-const"><a href="#buffer-span-mut-clientblockpipeline-blockopacitydata-const" class="header-anchor">#</a> <code>buffer_span_mut&lt;ClientBlockPipeline::BlockOpacityData const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const ClientBlockPipeline::BlockOpacityData *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>const ClientBlockPipeline::BlockOpacityData *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="buffer-span-mut-float-const"><a href="#buffer-span-mut-float-const" class="header-anchor">#</a> <code>buffer_span_mut&lt;float const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const float *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>const float *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="blockbakedmaterialdatacomponent"><a href="#blockbakedmaterialdatacomponent" class="header-anchor">#</a> <code>BlockBakedMaterialDataComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>ClientBlockPipeline::BakedMaterialMap</code></td> <td>mBakedMaterials</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>mIsSolidOpaque</td></tr></tbody></table> <h3 id="blocksource"><a href="#blocksource" class="header-anchor">#</a> <code>BlockSource</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockSource_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(4) <code>const std::thread::id</code></td> <td>mOwnerThreadID</td></tr> <tr><td>12</td> <td>(1) <code>const bool</code></td> <td>mAllowUnpopulatedChunks</td></tr> <tr><td>13</td> <td>(1) <code>const bool</code></td> <td>mPublicSource</td></tr> <tr><td>16</td> <td>(8) <code>Level *</code></td> <td>mLevel</td></tr> <tr><td>24</td> <td>(8) <code>ChunkSource *</code></td> <td>mChunkSource</td></tr> <tr><td>32</td> <td>(8) <code>Dimension *</code></td> <td>mDimension</td></tr> <tr><td>40</td> <td>(2) <code>const __int16</code></td> <td>mMaxHeight</td></tr> <tr><td>42</td> <td>(2) <code>const __int16</code></td> <td>mMinHeight</td></tr> <tr><td>48</td> <td>(24) <code>std::vector&lt;BlockFetchResult&gt;</code></td> <td>mTempBlockFetchResult</td></tr> <tr><td>72</td> <td>(12) <code>BlockPos</code></td> <td>mPlaceChunkPos</td></tr> <tr><td>88</td> <td>(24) <code>std::vector&lt;BlockSourceListener *&gt;</code></td> <td>mListeners</td></tr> <tr><td>112</td> <td>(8) <code>ChunkPos</code></td> <td>mLastChunkPos</td></tr> <tr><td>120</td> <td>(1) <code>bool</code></td> <td>mForbidSetBlock</td></tr> <tr><td>128</td> <td>(16) <code>std::weak_ptr&lt;LevelChunk&gt;</code></td> <td>mLastChunkWeakPtr</td></tr> <tr><td>144</td> <td>(8) <code>LevelChunk *</code></td> <td>mLastChunkDirectPtr</td></tr> <tr><td>152</td> <td>(8) <code>BlockTickingQueue *</code></td> <td>mRandomTickQueue</td></tr> <tr><td>160</td> <td>(8) <code>BlockTickingQueue *</code></td> <td>mTickQueue</td></tr> <tr><td>168</td> <td>(2) <code>const BrightnessPair</code></td> <td>mDefaultBrightness</td></tr> <tr><td>176</td> <td>(24) <code>std::vector&lt;Actor *&gt;</code></td> <td>mTempEntityList</td></tr> <tr><td>200</td> <td>(24) <code>std::vector&lt;BlockActor *&gt;</code></td> <td>mTempBlockEntityList</td></tr> <tr><td>224</td> <td>(24) <code>std::vector&lt;AABB&gt;</code></td> <td>mTempCubeList</td></tr></tbody></table> <h3 id="brightnesspair"><a href="#brightnesspair" class="header-anchor">#</a> <code>BrightnessPair</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>Brightness</code></td> <td>sky</td></tr> <tr><td>1</td> <td>(1) <code>Brightness</code></td> <td>block</td></tr></tbody></table> <h3 id="baseactorrendercontext"><a href="#baseactorrendercontext" class="header-anchor">#</a> <code>BaseActorRenderContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BaseActorRenderContext_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mNumEntitiesRenderedThisFrame</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mLastFrameTime</td></tr> <tr><td>16</td> <td>(4) <code>const float</code></td> <td>mFrameAlpha</td></tr> <tr><td>24</td> <td>(8) <code>SortedMeshDrawList *</code></td> <td>mSortedMeshDrawList</td></tr> <tr><td>32</td> <td>(8) <code>IClientInstance *</code></td> <td>mClientInstance</td></tr> <tr><td>40</td> <td>(8) <code>IMinecraftGame *</code></td> <td>mMinecraftGame</td></tr> <tr><td>48</td> <td>(8) <code>ScreenContext *</code></td> <td>mScreenContext</td></tr> <tr><td>56</td> <td>(8) <code>BlockActorRenderDispatcher *</code></td> <td>mBlockEntityRenderDispatcher</td></tr> <tr><td>64</td> <td>(8) <code>ActorRenderDispatcher *</code></td> <td>mEntityRenderDispatcher</td></tr> <tr><td>72</td> <td>(8) <code>ActorBlockRenderer *</code></td> <td>mEntityBlockRenderer</td></tr> <tr><td>80</td> <td>(8) <code>ItemInHandRenderer *</code></td> <td>mItemInHandRenderer</td></tr> <tr><td>88</td> <td>(8) <code>ItemRenderer *</code></td> <td>mItemRenderer</td></tr> <tr><td>96</td> <td>(8) <code>ParticleSystemEngine *</code></td> <td>mParticleSystemEngine</td></tr> <tr><td>104</td> <td>(16) <code>std::optional&lt;__int64&gt;</code></td> <td>mRenderUniqueIdOverride</td></tr> <tr><td>120</td> <td>(12) <code>Vec3</code></td> <td>mCameraTargetPosition</td></tr> <tr><td>132</td> <td>(12) <code>Vec3</code></td> <td>mCameraPosition</td></tr> <tr><td>144</td> <td>(28) <code>AABB</code></td> <td>mWorldClipRegion</td></tr> <tr><td>172</td> <td>(1) <code>bool</code></td> <td>mIsOnScreen</td></tr> <tr><td>173</td> <td>(1) <code>bool</code></td> <td>mUpdateBonesAndEffects</td></tr> <tr><td>174</td> <td>(1) <code>bool</code></td> <td>mUpdateEffects</td></tr> <tr><td>175</td> <td>(1) <code>bool</code></td> <td>mIgnoresLightning</td></tr> <tr><td>176</td> <td>(488) <code>HistoricalFrameTimes</code></td> <td>mHistoricalFrameTimes</td></tr></tbody></table> <h3 id="bounds"><a href="#bounds" class="header-anchor">#</a> <code>Bounds</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Pos</code></td> <td>mMin</td></tr> <tr><td>12</td> <td>(12) <code>Pos</code></td> <td>mMax</td></tr> <tr><td>24</td> <td>(12) <code>Pos</code></td> <td>mDim</td></tr> <tr><td>36</td> <td>(4) <code>int</code></td> <td>mArea</td></tr> <tr><td>40</td> <td>(4) <code>int</code></td> <td>mVolume</td></tr> <tr><td>44</td> <td>(4) <code>int</code></td> <td>mSide</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-soundengine"><a href="#bedrock-nonownerpointer-soundengine" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;SoundEngine&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-soundplayerinterface"><a href="#bedrock-nonownerpointer-soundplayerinterface" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;SoundPlayerInterface&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-textureatlas-const"><a href="#bedrock-nonownerpointer-textureatlas-const" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;TextureAtlas const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrocktexture"><a href="#bedrocktexture" class="header-anchor">#</a> <code>BedrockTexture</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;BedrockTextureData&gt;</code></td> <td>mBedrockTextureData</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-levelloader"><a href="#bedrock-nonownerpointer-levelloader" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;LevelLoader&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-datemanager-const"><a href="#bedrock-nonownerpointer-datemanager-const" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;DateManager const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-music"><a href="#bedrock-nonownerpointer-music" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Music&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-contentacquisition"><a href="#bedrock-nonownerpointer-contentacquisition" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ContentAcquisition&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-websocketcommmanager"><a href="#bedrock-nonownerpointer-websocketcommmanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;WebSocketCommManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-trialmanager"><a href="#bedrock-nonownerpointer-trialmanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;TrialManager&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="buttonuprightoffirstrefusalrequest"><a href="#buttonuprightoffirstrefusalrequest" class="header-anchor">#</a> <code>ButtonUpRightOfFirstRefusalRequest</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>buttonId</td></tr> <tr><td>8</td> <td>(16) <code>std::weak_ptr&lt;UIControl&gt;</code></td> <td>control</td></tr></tbody></table> <h3 id="buttonscreeneventdata"><a href="#buttonscreeneventdata" class="header-anchor">#</a> <code>ButtonScreenEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>id</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>fromButtonId</td></tr> <tr><td>8</td> <td>(1) <code>ButtonState</code></td> <td>previousState</td></tr> <tr><td>9</td> <td>(1) <code>ButtonState</code></td> <td>state</td></tr> <tr><td>10</td> <td>(1) <code>bool</code></td> <td>handleDeselection</td></tr> <tr><td>11</td> <td>(1) <code>bool</code></td> <td>handleSelection</td></tr> <tr><td>16</td> <td>(8) <code>UIPropertyBag *</code></td> <td>properties</td></tr> <tr><td>24</td> <td>(8) <code>float[2]</code></td> <td>cursorPosition</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>isInteracted</td></tr> <tr><td>36</td> <td>(4) <code>InputMode</code></td> <td>inputMode</td></tr> <tr><td>40</td> <td>(1) <code>bool</code></td> <td>outOfClip</td></tr> <tr><td>48</td> <td>(8) <code>std::string *</code></td> <td>path</td></tr></tbody></table> <h3 id="bgfx-fencedringbuffer-bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-0-ringbufferresourceallocator-0-scopedallocation"><a href="#bgfx-fencedringbuffer-bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-0-ringbufferresourceallocator-0-scopedallocation" class="header-anchor">#</a> <code>bgfx::FencedRingBuffer&lt;bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;0&gt; &gt;::RingBufferResourceAllocator,0&gt;::ScopedAllocation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;0&gt; &gt;::RingBufferResourceAllocator::Buffer&gt;</code></td> <td>m_buffer</td></tr> <tr><td>16</td> <td>(8) <code>const unsigned __int64</code></td> <td>m_offset</td></tr> <tr><td>24</td> <td>(8) <code>const unsigned __int64</code></td> <td>m_size</td></tr> <tr><td>32</td> <td>(8) <code>const unsigned __int64</code></td> <td>m_alignmentPrefixSize</td></tr> <tr><td>40</td> <td>(8) <code>const unsigned __int64</code></td> <td>m_fenceValue</td></tr></tbody></table> <h3 id="buffer-span-int"><a href="#buffer-span-int" class="header-anchor">#</a> <code>buffer_span&lt;int&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const int *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>const int *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="buffer-span-mut-std-shared-ptr-levelchunk"><a href="#buffer-span-mut-std-shared-ptr-levelchunk" class="header-anchor">#</a> <code>buffer_span_mut&lt;std::shared_ptr&lt;LevelChunk&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::shared_ptr&lt;LevelChunk&gt; *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>std::shared_ptr&lt;LevelChunk&gt; *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="basictimer"><a href="#basictimer" class="header-anchor">#</a> <code>BasicTimer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>long double</code></td> <td>mTimeDelay</td></tr> <tr><td>8</td> <td>(8) <code>long double</code></td> <td>mStartTime</td></tr> <tr><td>16</td> <td>(64) <code>std::function&lt;double __cdecl(void)&gt;</code></td> <td>mGetCurrentTimeCallback</td></tr></tbody></table> <h3 id="bossinfo"><a href="#bossinfo" class="header-anchor">#</a> <code>BossInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>32</td> <td>(4) <code>float</code></td> <td>mHealth</td></tr></tbody></table> <h3 id="bosseventlistener"><a href="#bosseventlistener" class="header-anchor">#</a> <code>BossEventListener</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BossEventListener_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="bgfx-d3d12-resourcestatesmananger"><a href="#bgfx-d3d12-resourcestatesmananger" class="header-anchor">#</a> <code>bgfx::d3d12::ResourceStatesMananger</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(41488) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::IndexBufferHandle,bgfx::d3d12::BufferD3D12,bgfx::d3d12::BufferD3D12 [4096]&gt;</code></td> <td>m_indexBuffers</td></tr> <tr><td>41488</td> <td>(41488) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::VertexBufferHandle,bgfx::d3d12::VertexBufferD3D12,bgfx::d3d12::VertexBufferD3D12 [4096]&gt;</code></td> <td>m_vertexBuffers</td></tr> <tr><td>82976</td> <td>(41488) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::TextureHandle,bgfx::d3d12::TextureD3D12,bgfx::d3d12::TextureD3D12 [4096]&gt;</code></td> <td>m_textures</td></tr> <tr><td>124464</td> <td>(41488) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::ShaderBufferHandle,bgfx::d3d12::BufferD3D12,bgfx::d3d12::BufferD3D12 [4096]&gt;</code></td> <td>m_shaderBuffers</td></tr> <tr><td>165952</td> <td>(1312) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;128,bgfx::FrameBufferHandle,bgfx::d3d12::FrameBufferD3D12,bgfx::d3d12::FrameBufferD3D12 [128]&gt;</code></td> <td>m_frameBuffers</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-indexbufferhandle-bgfx-d3d12-bufferd3d12-bgfx-d3d12-bufferd3d12-4096"><a href="#bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-indexbufferhandle-bgfx-d3d12-bufferd3d12-bgfx-d3d12-bufferd3d12-4096" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::IndexBufferHandle,bgfx::d3d12::BufferD3D12,bgfx::d3d12::BufferD3D12 [4096]&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::d3d12::BufferD3D12 (*)[4096]</code></td> <td>m_resources</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>m_count</td></tr> <tr><td>16</td> <td>(512) <code>std::bitset&lt;4096&gt;</code></td> <td>m_sets</td></tr> <tr><td>528</td> <td>(32768) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::IndexBufferHandle,bgfx::d3d12::BufferD3D12,bgfx::d3d12::BufferD3D12 [4096]&gt;::ResourceStateEntry[4096]</code></td> <td>m_states</td></tr> <tr><td>33296</td> <td>(8192) <code>unsigned __int16[4096]</code></td> <td>m_setIndices</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-indexbufferhandle-bgfx-d3d12-bufferd3d12-bgfx-d3d12-bufferd3d12-4096-resourcestateentry"><a href="#bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-indexbufferhandle-bgfx-d3d12-bufferd3d12-bgfx-d3d12-bufferd3d12-4096-resourcestateentry" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::IndexBufferHandle,bgfx::d3d12::BufferD3D12,bgfx::d3d12::BufferD3D12 [4096]&gt;::ResourceStateEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_initialState</td></tr> <tr><td>4</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_currentState</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-vertexbufferhandle-bgfx-d3d12-vertexbufferd3d12-bgfx-d3d12-vertexbufferd3d12-4096"><a href="#bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-vertexbufferhandle-bgfx-d3d12-vertexbufferd3d12-bgfx-d3d12-vertexbufferd3d12-4096" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::VertexBufferHandle,bgfx::d3d12::VertexBufferD3D12,bgfx::d3d12::VertexBufferD3D12 [4096]&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::d3d12::VertexBufferD3D12 (*)[4096]</code></td> <td>m_resources</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>m_count</td></tr> <tr><td>16</td> <td>(512) <code>std::bitset&lt;4096&gt;</code></td> <td>m_sets</td></tr> <tr><td>528</td> <td>(32768) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::VertexBufferHandle,bgfx::d3d12::VertexBufferD3D12,bgfx::d3d12::VertexBufferD3D12 [4096]&gt;::ResourceStateEntry[4096]</code></td> <td>m_states</td></tr> <tr><td>33296</td> <td>(8192) <code>unsigned __int16[4096]</code></td> <td>m_setIndices</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-vertexbufferhandle-bgfx-d3d12-vertexbufferd3d12-bgfx-d3d12-vertexbufferd3d12-4096-resourcestateentry"><a href="#bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-vertexbufferhandle-bgfx-d3d12-vertexbufferd3d12-bgfx-d3d12-vertexbufferd3d12-4096-resourcestateentry" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::VertexBufferHandle,bgfx::d3d12::VertexBufferD3D12,bgfx::d3d12::VertexBufferD3D12 [4096]&gt;::ResourceStateEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_initialState</td></tr> <tr><td>4</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_currentState</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-texturehandle-bgfx-d3d12-textured3d12-bgfx-d3d12-textured3d12-4096"><a href="#bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-texturehandle-bgfx-d3d12-textured3d12-bgfx-d3d12-textured3d12-4096" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::TextureHandle,bgfx::d3d12::TextureD3D12,bgfx::d3d12::TextureD3D12 [4096]&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::d3d12::TextureD3D12 (*)[4096]</code></td> <td>m_resources</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>m_count</td></tr> <tr><td>16</td> <td>(512) <code>std::bitset&lt;4096&gt;</code></td> <td>m_sets</td></tr> <tr><td>528</td> <td>(32768) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::TextureHandle,bgfx::d3d12::TextureD3D12,bgfx::d3d12::TextureD3D12 [4096]&gt;::ResourceStateEntry[4096]</code></td> <td>m_states</td></tr> <tr><td>33296</td> <td>(8192) <code>unsigned __int16[4096]</code></td> <td>m_setIndices</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-texturehandle-bgfx-d3d12-textured3d12-bgfx-d3d12-textured3d12-4096-resourcestateentry"><a href="#bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-texturehandle-bgfx-d3d12-textured3d12-bgfx-d3d12-textured3d12-4096-resourcestateentry" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::TextureHandle,bgfx::d3d12::TextureD3D12,bgfx::d3d12::TextureD3D12 [4096]&gt;::ResourceStateEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_initialState</td></tr> <tr><td>4</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_currentState</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-shaderbufferhandle-bgfx-d3d12-bufferd3d12-bgfx-d3d12-bufferd3d12-4096"><a href="#bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-shaderbufferhandle-bgfx-d3d12-bufferd3d12-bgfx-d3d12-bufferd3d12-4096" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::ShaderBufferHandle,bgfx::d3d12::BufferD3D12,bgfx::d3d12::BufferD3D12 [4096]&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::d3d12::BufferD3D12 (*)[4096]</code></td> <td>m_resources</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>m_count</td></tr> <tr><td>16</td> <td>(512) <code>std::bitset&lt;4096&gt;</code></td> <td>m_sets</td></tr> <tr><td>528</td> <td>(32768) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::ShaderBufferHandle,bgfx::d3d12::BufferD3D12,bgfx::d3d12::BufferD3D12 [4096]&gt;::ResourceStateEntry[4096]</code></td> <td>m_states</td></tr> <tr><td>33296</td> <td>(8192) <code>unsigned __int16[4096]</code></td> <td>m_setIndices</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-shaderbufferhandle-bgfx-d3d12-bufferd3d12-bgfx-d3d12-bufferd3d12-4096-resourcestateentry"><a href="#bgfx-d3d12-indexedresourcestatesmanager-4096-bgfx-shaderbufferhandle-bgfx-d3d12-bufferd3d12-bgfx-d3d12-bufferd3d12-4096-resourcestateentry" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;4096,bgfx::ShaderBufferHandle,bgfx::d3d12::BufferD3D12,bgfx::d3d12::BufferD3D12 [4096]&gt;::ResourceStateEntry</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_initialState</td></tr> <tr><td>4</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_currentState</td></tr></tbody></table> <h3 id="bgfx-d3d12-indexedresourcestatesmanager-128-bgfx-framebufferhandle-bgfx-d3d12-framebufferd3d12-bgfx-d3d12-framebufferd3d12-128"><a href="#bgfx-d3d12-indexedresourcestatesmanager-128-bgfx-framebufferhandle-bgfx-d3d12-framebufferd3d12-bgfx-d3d12-framebufferd3d12-128" class="header-anchor">#</a> <code>bgfx::d3d12::IndexedResourceStatesManager&lt;128,bgfx::FrameBufferHandle,bgfx::d3d12::FrameBufferD3D12,bgfx::d3d12::FrameBufferD3D12 [128]&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::d3d12::FrameBufferD3D12 (*)[128]</code></td> <td>m_resources</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>m_count</td></tr> <tr><td>16</td> <td>(16) <code>std::bitset&lt;128&gt;</code></td> <td>m_sets</td></tr> <tr><td>32</td> <td>(1024) <code>bgfx::d3d12::IndexedResourceStatesManager&lt;128,bgfx::FrameBufferHandle,bgfx::d3d12::FrameBufferD3D12,bgfx::d3d12::FrameBufferD3D12 [128]&gt;::ResourceStateEntry[128]</code></td> <td>m_states</td></tr> <tr><td>1056</td> <td>(256) <code>unsigned __int16[128]</code></td> <td>m_setIndices</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-contentcatalogservice"><a href="#bedrock-nonownerpointer-contentcatalogservice" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ContentCatalogService&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-storecatalogrepository"><a href="#bedrock-nonownerpointer-storecatalogrepository" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;StoreCatalogRepository&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="basecommandblock"><a href="#basecommandblock" class="header-anchor">#</a> <code>BaseCommandBlock</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mLastOutputId</td></tr> <tr><td>32</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>mLastOutputParams</td></tr> <tr><td>56</td> <td>(32) <code>std::string</code></td> <td>mCommand</td></tr> <tr><td>88</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>120</td> <td>(8) <code>std::unique_ptr&lt;Command&gt;</code></td> <td>mCompiledCommand</td></tr> <tr><td>128</td> <td>(8) <code>unsigned __int64</code></td> <td>mLastExecution</td></tr> <tr><td>136</td> <td>(4) <code>int</code></td> <td>mVersion</td></tr> <tr><td>140</td> <td>(4) <code>int</code></td> <td>mSuccessCount</td></tr> <tr><td>144</td> <td>(4) <code>int</code></td> <td>mTickDelay</td></tr> <tr><td>148</td> <td>(1) <code>bool</code></td> <td>mExecuteOnFirstTick</td></tr> <tr><td>149</td> <td>(1) <code>bool</code></td> <td>mTrackOutput</td></tr></tbody></table> <h3 id="batchclippingstate"><a href="#batchclippingstate" class="header-anchor">#</a> <code>BatchClippingState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>glm::tvec2&lt;float,0&gt;</code></td> <td>mTopLeftClip</td></tr> <tr><td>8</td> <td>(8) <code>glm::tvec2&lt;float,0&gt;</code></td> <td>mBottomRightClip</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>mClipsChildren</td></tr> <tr><td>17</td> <td>(1) <code>bool</code></td> <td>mEnableScissorTest</td></tr> <tr><td>24</td> <td>(16) <code>ClipAreas</code></td> <td>mClipArea</td></tr></tbody></table> <h3 id="batchvisualstate"><a href="#batchvisualstate" class="header-anchor">#</a> <code>BatchVisualState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mAlpha</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mPropagatedAlpha</td></tr></tbody></table> <h3 id="batchkey"><a href="#batchkey" class="header-anchor">#</a> <code>BatchKey</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>UIBatchType</code></td> <td>mBatchType</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mCustomId</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mDepth</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mAlpha</td></tr> <tr><td>16</td> <td>(16) <code>mce::Color</code></td> <td>mColor</td></tr> <tr><td>32</td> <td>(4) <code>_BYTE[4]</code></td> <td>mUIMaterialType</td></tr> <tr><td>40</td> <td>(40) <code>BatchClippingState</code></td> <td>mClippingState</td></tr> <tr><td>80</td> <td>(112) <code>std::array&lt;ResourceLocation,2&gt;</code></td> <td>mResourceLocations</td></tr></tbody></table> <h3 id="bindinfo"><a href="#bindinfo" class="header-anchor">#</a> <code>BindInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>BindType</code></td> <td>bindType</td></tr> <tr><td>4</td> <td>(1) <code>bool</code></td> <td>autoScale</td></tr> <tr><td>8</td> <td>(12) <code>Vec3</code></td> <td>pos</td></tr> <tr><td>24</td> <td>(8) <code>ActorUniqueID</code></td> <td>bindEntityId</td></tr> <tr><td>32</td> <td>(4) <code>float</code></td> <td>scaleRate</td></tr></tbody></table> <h3 id="bindingfactory"><a href="#bindingfactory" class="header-anchor">#</a> <code>BindingFactory</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BindingFactory_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="buildactionintention"><a href="#buildactionintention" class="header-anchor">#</a> <code>BuildActionIntention</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mAction</td></tr></tbody></table> <h3 id="bgfx-d3d9-vertexbufferd3d9"><a href="#bgfx-d3d9-vertexbufferd3d9" class="header-anchor">#</a> <code>bgfx::d3d9::VertexBufferD3D9</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>IDirect3DVertexBuffer9 *</code></td> <td>m_ptr</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int8 *</code></td> <td>m_dynamic</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>20</td> <td>(2) <code>bgfx::VertexDeclHandle</code></td> <td>m_decl</td></tr></tbody></table> <h3 id="bosseventpacket"><a href="#bosseventpacket" class="header-anchor">#</a> <code>BossEventPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(4) <code>const int</code></td> <td>FLAG_DARKEN</td></tr> <tr><td>44</td> <td>(4) <code>const int</code></td> <td>FLAG_FOG</td></tr> <tr><td>48</td> <td>(8) <code>ActorUniqueID</code></td> <td>mBossID</td></tr> <tr><td>56</td> <td>(8) <code>ActorUniqueID</code></td> <td>mPlayerID</td></tr> <tr><td>64</td> <td>(4) <code>BossEventUpdateType</code></td> <td>mEventType</td></tr> <tr><td>72</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>104</td> <td>(4) <code>float</code></td> <td>mHealthPercent</td></tr> <tr><td>108</td> <td>(4) <code>BossBarColor</code></td> <td>mColor</td></tr> <tr><td>112</td> <td>(4) <code>BossBarOverlay</code></td> <td>mOverlay</td></tr> <tr><td>116</td> <td>(1) <code>unsigned __int8</code></td> <td>mDarkenScreen</td></tr> <tr><td>117</td> <td>(1) <code>unsigned __int8</code></td> <td>mCreateWorldFog</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-fogdefinitionregistry-const"><a href="#bedrock-nonownerpointer-fogdefinitionregistry-const" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;FogDefinitionRegistry const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="blockeventpacket"><a href="#blockeventpacket" class="header-anchor">#</a> <code>BlockEventPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(12) <code>NetworkBlockPosition</code></td> <td>mPos</td></tr> <tr><td>52</td> <td>(4) <code>int</code></td> <td>mB0</td></tr> <tr><td>56</td> <td>(4) <code>int</code></td> <td>mB1</td></tr></tbody></table> <h3 id="buffer-span-mut-expressionnode"><a href="#buffer-span-mut-expressionnode" class="header-anchor">#</a> <code>buffer_span_mut&lt;ExpressionNode&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ExpressionNode *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>ExpressionNode *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="blockgeometry-elementbox"><a href="#blockgeometry-elementbox" class="header-anchor">#</a> <code>BlockGeometry::ElementBox</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>mOrigin</td></tr> <tr><td>12</td> <td>(12) <code>glm::tvec3&lt;float,0&gt;</code></td> <td>mSize</td></tr> <tr><td>24</td> <td>(384) <code>std::array&lt;BlockGeometry::Face,6&gt;</code></td> <td>mFaces</td></tr></tbody></table> <h3 id="blockgeometry-face"><a href="#blockgeometry-face" class="header-anchor">#</a> <code>BlockGeometry::Face</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>u0</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>v0</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>u1</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>v1</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>rotation</td></tr> <tr><td>24</td> <td>(32) <code>std::string</code></td> <td>texture</td></tr> <tr><td>56</td> <td>(4) <code>int</code></td> <td>textureIndex</td></tr> <tr><td>60</td> <td>(1) <code>bool</code></td> <td>enabled</td></tr></tbody></table> <h3 id="blockgraphics"><a href="#blockgraphics" class="header-anchor">#</a> <code>BlockGraphics</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockGraphics_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(8) <code>IsotropicFaceData</code></td> <td>mIsotropicFaceData</td></tr> <tr><td>16</td> <td>(8) <code>const Block *</code></td> <td>mBlock</td></tr> <tr><td>24</td> <td>(4) <code>BlockRenderLayer</code></td> <td>mRenderLayer</td></tr> <tr><td>28</td> <td>(4) <code>BlockShape</code></td> <td>mBlockShape</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>mAnimatedTexture</td></tr> <tr><td>36</td> <td>(4) <code>float</code></td> <td>mBrightnessGamma</td></tr> <tr><td>40</td> <td>(1) <code>bool</code></td> <td>mFancy</td></tr> <tr><td>41</td> <td>(1) <code>bool</code></td> <td>mAllowSame</td></tr> <tr><td>44</td> <td>(4) <code>BlockSoundType</code></td> <td>mSoundType</td></tr> <tr><td>48</td> <td>(28) <code>AABB</code></td> <td>mVisualShape</td></tr> <tr><td>80</td> <td>(24) <code>std::vector&lt;TextureItem&gt;</code></td> <td>mTextureItems</td></tr> <tr><td>104</td> <td>(8) <code>unsigned __int64</code></td> <td>mIconTextureIndex</td></tr> <tr><td>112</td> <td>(24) <code>std::vector&lt;std::vector&lt;BlockGeometry::Model const *&gt;&gt;</code></td> <td>mBlockModelVariants</td></tr> <tr><td>136</td> <td>(24) <code>std::vector&lt;std::vector&lt;BlockGraphics::ModelItem&gt;&gt;</code></td> <td>mTessellatedModelParts</td></tr> <tr><td>160</td> <td>(16) <code>?</code></td> <td>mUsingModTessellatedModel</td></tr></tbody></table> <h3 id="blockgraphics-initblocks-l2-lambda-ae40432cfeaa2b9f26426c68835add40"><a href="#blockgraphics-initblocks-l2-lambda-ae40432cfeaa2b9f26426c68835add40" class="header-anchor">#</a> <code>BlockGraphics::initBlocks::__l2::&lt;lambda_ae40432cfeaa2b9f26426c68835add40&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="blockoccluder"><a href="#blockoccluder" class="header-anchor">#</a> <code>BlockOccluder</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>std::bitset&lt;6&gt;</code></td> <td>mFacingOccluded</td></tr> <tr><td>8</td> <td>(8) <code>BlockTessellatorCache *</code></td> <td>mBlockCache</td></tr></tbody></table> <h3 id="blocktessellatorblockinworld"><a href="#blocktessellatorblockinworld" class="header-anchor">#</a> <code>BlockTessellatorBlockInWorld</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const Block *</code></td> <td>block</td></tr> <tr><td>8</td> <td>(4) <code>BlockRenderLayer</code></td> <td>layer</td></tr> <tr><td>12</td> <td>(12) <code>BlockPos</code></td> <td>pos</td></tr> <tr><td>24</td> <td>(8) <code>const void *</code></td> <td>owner</td></tr></tbody></table> <h3 id="blocktessellatorcustomextradata-cauldrondata"><a href="#blocktessellatorcustomextradata-cauldrondata" class="header-anchor">#</a> <code>BlockTessellatorCustomExtraData::CauldronData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>mce::Color</code></td> <td>mColor</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>mTextureIndex</td></tr> <tr><td>20</td> <td>(4) <code>int</code></td> <td>mRenderLayer</td></tr></tbody></table> <h3 id="bannerblockactor"><a href="#bannerblockactor" class="header-anchor">#</a> <code>BannerBlockActor</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(288) <code>BlockActor</code></td> <td>baseclass_0</td></tr> <tr><td>288</td> <td>(1) <code>bool</code></td> <td>mDirtyBounds</td></tr> <tr><td>289</td> <td>(1) <code>unsigned __int8</code></td> <td>mBaseColor</td></tr> <tr><td>296</td> <td>(24) <code>std::vector&lt;unsigned char&gt;</code></td> <td>mPatterns</td></tr> <tr><td>320</td> <td>(24) <code>std::vector&lt;unsigned char&gt;</code></td> <td>mColors</td></tr> <tr><td>344</td> <td>(4) <code>BannerBlockType</code></td> <td>mBannerType</td></tr></tbody></table> <h3 id="blockactor"><a href="#blockactor" class="header-anchor">#</a> <code>BlockActor</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockActor_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mTickCount</td></tr> <tr><td>12</td> <td>(16) <code>mce::Color</code></td> <td>mFront</td></tr> <tr><td>28</td> <td>(16) <code>mce::Color</code></td> <td>mBack</td></tr> <tr><td>48</td> <td>(8) <code>long double</code></td> <td>mPercent</td></tr> <tr><td>56</td> <td>(1) <code>bool</code></td> <td>mShowProcessBar</td></tr> <tr><td>57</td> <td>(1) <code>bool</code></td> <td>mCanRenderNameTag</td></tr> <tr><td>64</td> <td>(8) <code>const Block *</code></td> <td>mBlock</td></tr> <tr><td>72</td> <td>(4) <code>float</code></td> <td>mDestroyTimer</td></tr> <tr><td>76</td> <td>(12) <code>Vec3</code></td> <td>mDestroyDirection</td></tr> <tr><td>88</td> <td>(4) <code>float</code></td> <td>mDestroyProgress</td></tr> <tr><td>92</td> <td>(12) <code>BlockPos</code></td> <td>mPosition</td></tr> <tr><td>104</td> <td>(28) <code>AABB</code></td> <td>mBB</td></tr> <tr><td>132</td> <td>(4) <code>const BlockActorType</code></td> <td>mType</td></tr> <tr><td>136</td> <td>(4) <code>BlockActorRendererId</code></td> <td>mRendererId</td></tr> <tr><td>144</td> <td>(32) <code>std::string</code></td> <td>mCustomName</td></tr> <tr><td>176</td> <td>(32) <code>std::string</code></td> <td>mFilteredCustomName</td></tr> <tr><td>208</td> <td>(4) <code>int</code></td> <td>mRepairCost</td></tr> <tr><td>212</td> <td>(1) <code>bool</code></td> <td>mClientSideOnly</td></tr> <tr><td>213</td> <td>(1) <code>bool</code></td> <td>mIsMovable</td></tr> <tr><td>214</td> <td>(1) <code>bool</code></td> <td>mSaveCustomName</td></tr> <tr><td>215</td> <td>(1) <code>bool</code></td> <td>mCanRenderCustomName</td></tr> <tr><td>216</td> <td>(4) <code>const float</code></td> <td>signShadowRadius</td></tr> <tr><td>224</td> <td>(32) <code>std::string</code></td> <td>mUserCustomData</td></tr> <tr><td>256</td> <td>(24) <code>ActorTerrainInterlockData</code></td> <td>mTerrainInterlockData</td></tr> <tr><td>280</td> <td>(1) <code>bool</code></td> <td>mChanged</td></tr></tbody></table> <h3 id="bannerrenderer-setuptextureatlas-l2-lambda-d1aa061d604d54f0e610811945668f01"><a href="#bannerrenderer-setuptextureatlas-l2-lambda-d1aa061d604d54f0e610811945668f01" class="header-anchor">#</a> <code>BannerRenderer::_setupTextureAtlas::__l2::&lt;lambda_d1aa061d604d54f0e610811945668f01&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BannerRenderer *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(8) <code>mce::TextureGroup *</code></td> <td>textures</td></tr> <tr><td>16</td> <td>(24) <code>std::vector&lt;std::string&gt;</code></td> <td>patternTextures</td></tr> <tr><td>40</td> <td>(16) <code>std::map&lt;std::string,BackwardsCompatTextureInfo&gt;</code></td> <td>backCompatTextures</td></tr></tbody></table> <h3 id="buffer-span-mut-subchunk"><a href="#buffer-span-mut-subchunk" class="header-anchor">#</a> <code>buffer_span_mut&lt;SubChunk&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>SubChunk *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>SubChunk *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="bytemask"><a href="#bytemask" class="header-anchor">#</a> <code>ByteMask</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>mask</td></tr></tbody></table> <h3 id="blocktessellatorcustomextradata-map"><a href="#blocktessellatorcustomextradata-map" class="header-anchor">#</a> <code>BlockTessellatorCustomExtraData::Map</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;BlockPos,BlockTessellatorCustomExtraData::CauldronData&gt;</code></td> <td>mExtraCauldronData</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;BlockPos,BlockTessellatorCustomExtraData::FlowerPotData&gt;</code></td> <td>mExtraFlowerPotData</td></tr></tbody></table> <h3 id="buffer-span-mut-rangeindices"><a href="#buffer-span-mut-rangeindices" class="header-anchor">#</a> <code>buffer_span_mut&lt;RangeIndices&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>RangeIndices *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>RangeIndices *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="blockactorblocksyncmessage"><a href="#blockactorblocksyncmessage" class="header-anchor">#</a> <code>BlockActorBlockSyncMessage</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>BlockPos</code></td> <td>mBlockEntityPos</td></tr> <tr><td>12</td> <td>(4) <code>_BYTE[4]</code></td> <td>mMessage</td></tr></tbody></table> <h3 id="buffer-span-mut-commandlistfuture"><a href="#buffer-span-mut-commandlistfuture" class="header-anchor">#</a> <code>buffer_span_mut&lt;CommandListFuture&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>CommandListFuture *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>CommandListFuture *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="blockdestructinfo"><a href="#blockdestructinfo" class="header-anchor">#</a> <code>BlockDestructInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>destructRate</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>destructProgress</td></tr></tbody></table> <h3 id="buffer-span-mut-std-shared-ptr-renderchunkinstanced"><a href="#buffer-span-mut-std-shared-ptr-renderchunkinstanced" class="header-anchor">#</a> <code>buffer_span_mut&lt;std::shared_ptr&lt;RenderChunkInstanced&gt; &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::shared_ptr&lt;RenderChunkInstanced&gt; *</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>std::shared_ptr&lt;RenderChunkInstanced&gt; *</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="bedrock-threading-countreference"><a href="#bedrock-threading-countreference" class="header-anchor">#</a> <code>Bedrock::Threading::CountReference</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Bedrock::Threading::CountTracker *</code></td> <td>mCountSource</td></tr></tbody></table> <h3 id="bgfx-d3d12-fencesynccontext-addbuffer-l2-lambda-ac6b7a419de5ff0a554a1beba548a9d9"><a href="#bgfx-d3d12-fencesynccontext-addbuffer-l2-lambda-ac6b7a419de5ff0a554a1beba548a9d9" class="header-anchor">#</a> <code>bgfx::d3d12::FenceSyncContext::addBuffer::__l2::&lt;lambda_ac6b7a419de5ff0a554a1beba548a9d9&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;0&gt; &gt; *</code></td> <td>buffer</td></tr></tbody></table> <h3 id="bedrock-threading-burst-details-worktargetitem"><a href="#bedrock-threading-burst-details-worktargetitem" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Details::WorkTargetItem</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>mWorkerCount</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>mKickCount</td></tr></tbody></table> <h3 id="blockdescriptor"><a href="#blockdescriptor" class="header-anchor">#</a> <code>BlockDescriptor</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(48) <code>HashedString</code></td> <td>mBlockName</td></tr> <tr><td>48</td> <td>(16) <code>std::shared_ptr&lt;ExpressionNode&gt;</code></td> <td>mTags</td></tr> <tr><td>64</td> <td>(24) <code>std::vector&lt;BlockDescriptor::BlockState&gt;</code></td> <td>mStates</td></tr> <tr><td>88</td> <td>(4) <code>_BYTE[4]</code></td> <td>mCompareType</td></tr> <tr><td>96</td> <td>(8) <code>const Block *</code></td> <td>mBlock</td></tr> <tr><td>104</td> <td>(1) <code>bool</code></td> <td>mValid</td></tr> <tr><td>105</td> <td>(1) <code>bool</code></td> <td>mIsDeferred</td></tr></tbody></table> <h3 id="buoyancycomponent"><a href="#buoyancycomponent" class="header-anchor">#</a> <code>BuoyancyComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mBaseBuoyancy</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mDragDownOnRemoval</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>mBigWaveProbability</td></tr> <tr><td>12</td> <td>(4) <code>float</code></td> <td>mBigWaveSpeedMultiplier</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>mSimulateWaves</td></tr> <tr><td>17</td> <td>(1) <code>bool</code></td> <td>mApplyGravity</td></tr> <tr><td>24</td> <td>(8) <code>long double</code></td> <td>mTimer</td></tr> <tr><td>32</td> <td>(24) <code>std::vector&lt;BlockDescriptor&gt;</code></td> <td>mLiquidBlocks</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-packstorage-packstorageimpl"><a href="#bedrock-nonownerpointer-packstorage-packstorageimpl" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;PackStorage::PackStorageImpl&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-cg-texturesetlayerdefinition-const"><a href="#bedrock-nonownerpointer-cg-texturesetlayerdefinition-const" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;cg::TextureSetLayerDefinition const &gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-28e21e68b5d2bdce02834018dcd63395"><a href="#biomecomponentloading-buildschema-l2-lambda-28e21e68b5d2bdce02834018dcd63395" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_28e21e68b5d2bdce02834018dcd63395&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;CappedSurfaceAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-d6ab075ac52cb670009075d6b429800e"><a href="#biomecomponentloading-buildschema-l2-lambda-d6ab075ac52cb670009075d6b429800e" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_d6ab075ac52cb670009075d6b429800e&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;CappedSurfaceAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="blockraycastcomponent"><a href="#blockraycastcomponent" class="header-anchor">#</a> <code>BlockRaycastComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mEnabled</td></tr> <tr><td>1</td> <td>(1) <code>bool</code></td> <td>mWorldInfoBaked</td></tr> <tr><td>4</td> <td>(28) <code>AABB</code></td> <td>mOriginalAABB</td></tr> <tr><td>32</td> <td>(28) <code>AABB</code></td> <td>mTransformedAABB</td></tr></tbody></table> <h3 id="blockfrictioncomponent"><a href="#blockfrictioncomponent" class="header-anchor">#</a> <code>BlockFrictionComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mFriction</td></tr></tbody></table> <h3 id="blockdisplaynamecomponent"><a href="#blockdisplaynamecomponent" class="header-anchor">#</a> <code>BlockDisplayNameComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mDisplayName</td></tr></tbody></table> <h3 id="blockgeometrycomponent"><a href="#blockgeometrycomponent" class="header-anchor">#</a> <code>BlockGeometryComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mGeometryName</td></tr> <tr><td>32</td> <td>(16) <code>std::shared_ptr&lt;ClientBlockPipeline::BlockSchematic&gt;</code></td> <td>mBlockSchematic</td></tr></tbody></table> <h3 id="blocklightemissioncomponent"><a href="#blocklightemissioncomponent" class="header-anchor">#</a> <code>BlockLightEmissionComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>Brightness</code></td> <td>mLightEmission</td></tr></tbody></table> <h3 id="blockplacementcondition"><a href="#blockplacementcondition" class="header-anchor">#</a> <code>BlockPlacementCondition</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>directionalFilter</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;BlockDescriptor&gt;</code></td> <td>blockFilter</td></tr></tbody></table> <h3 id="blockplacementfiltercomponent"><a href="#blockplacementfiltercomponent" class="header-anchor">#</a> <code>BlockPlacementFilterComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;BlockPlacementCondition&gt;</code></td> <td>conditions</td></tr></tbody></table> <h3 id="blockqueuedtickingcomponent"><a href="#blockqueuedtickingcomponent" class="header-anchor">#</a> <code>BlockQueuedTickingComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>float[2]</code></td> <td>mDelayRange</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>mLooping</td></tr> <tr><td>16</td> <td>(320) <code>DefinitionTrigger</code></td> <td>mOnTimeDown</td></tr></tbody></table> <h3 id="blockunitcubecomponent"><a href="#blockunitcubecomponent" class="header-anchor">#</a> <code>BlockUnitCubeComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;ClientBlockPipeline::BlockSchematic&gt;</code></td> <td>mBlockSchematic</td></tr></tbody></table> <h3 id="bidirectionalunorderedmap-int-unsigned-int64"><a href="#bidirectionalunorderedmap-int-unsigned-int64" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;int,unsigned __int64&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;int,unsigned __int64&gt;</code></td> <td>mRight</td></tr> <tr><td>64</td> <td>(64) <code>std::unordered_map&lt;unsigned __int64,int&gt;</code></td> <td>mLeft</td></tr></tbody></table> <h3 id="blockvolume"><a href="#blockvolume" class="header-anchor">#</a> <code>BlockVolume</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>buffer_span_mut&lt;Block const *&gt;</code></td> <td>mBlocks</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>mWidth</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>mHeight</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>mDepth</td></tr></tbody></table> <h3 id="buffer-span-mut-block-const"><a href="#buffer-span-mut-block-const" class="header-anchor">#</a> <code>buffer_span_mut&lt;Block const *&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const Block **</code></td> <td>mBegin</td></tr> <tr><td>8</td> <td>(8) <code>const Block **</code></td> <td>mEnd</td></tr></tbody></table> <h3 id="boundingbox"><a href="#boundingbox" class="header-anchor">#</a> <code>BoundingBox</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>BlockPos</code></td> <td>min</td></tr> <tr><td>12</td> <td>(12) <code>BlockPos</code></td> <td>max</td></tr></tbody></table> <h3 id="beardandshaverdescription"><a href="#beardandshaverdescription" class="header-anchor">#</a> <code>BeardAndShaverDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>BoundingBox</code></td> <td>mCachedPieceBounds</td></tr> <tr><td>24</td> <td>(4) <code>int</code></td> <td>mCachedPieceBaseY</td></tr> <tr><td>28</td> <td>(4) <code>int</code></td> <td>mCachedXCenter</td></tr> <tr><td>32</td> <td>(4) <code>int</code></td> <td>mCachedZCenter</td></tr> <tr><td>36</td> <td>(4) <code>float</code></td> <td>mCachedMaxRadius</td></tr> <tr><td>40</td> <td>(4) <code>int</code></td> <td>mDeltaTargetY</td></tr> <tr><td>44</td> <td>(24) <code>BoundingBox</code></td> <td>mBoundingBox</td></tr> <tr><td>68</td> <td>(4) <code>float</code></td> <td>mMinBeardWidth</td></tr> <tr><td>72</td> <td>(4) <code>float</code></td> <td>mMaxBeardWidth</td></tr></tbody></table> <h3 id="breedabletype"><a href="#breedabletype" class="header-anchor">#</a> <code>BreedableType</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(176) <code>ActorDefinitionIdentifier</code></td> <td>mMateType</td></tr> <tr><td>176</td> <td>(176) <code>ActorDefinitionIdentifier</code></td> <td>mBabyType</td></tr> <tr><td>352</td> <td>(320) <code>DefinitionTrigger</code></td> <td>mOnBred</td></tr></tbody></table> <h3 id="blockbreaksensorcomponent"><a href="#blockbreaksensorcomponent" class="header-anchor">#</a> <code>BlockBreakSensorComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>mSensorRadius</td></tr> <tr><td>4</td> <td>(12) <code>Vec3</code></td> <td>mSensorPos</td></tr> <tr><td>16</td> <td>(16) <code>BlockEventDispatcherToken</code></td> <td>mListener</td></tr> <tr><td>32</td> <td>(24) <code>std::vector&lt;BlockListEventMap&gt;</code></td> <td>mBlockSets</td></tr></tbody></table> <h3 id="blockeventdispatchertoken"><a href="#blockeventdispatchertoken" class="header-anchor">#</a> <code>BlockEventDispatcherToken</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mHandle</td></tr> <tr><td>8</td> <td>(8) <code>BlockEventDispatcher *</code></td> <td>mDispatcher</td></tr></tbody></table> <h3 id="binaryheap"><a href="#binaryheap" class="header-anchor">#</a> <code>BinaryHeap</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;PathfinderNode *&gt;</code></td> <td>heap</td></tr> <tr><td>24</td> <td>(4) <code>int</code></td> <td>sizeVar</td></tr></tbody></table> <h3 id="blockset"><a href="#blockset" class="header-anchor">#</a> <code>BlockSet</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>float</code></td> <td>cost</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;BlockDescriptor&gt;</code></td> <td>blockDescriptors</td></tr></tbody></table> <h3 id="bosscomponent"><a href="#bosscomponent" class="header-anchor">#</a> <code>BossComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>mHealthBarVisible</td></tr> <tr><td>36</td> <td>(4) <code>float</code></td> <td>mHealthPercent</td></tr> <tr><td>40</td> <td>(1) <code>bool</code></td> <td>mShouldDarkenSky</td></tr> <tr><td>41</td> <td>(1) <code>bool</code></td> <td>mCreateWorldFog</td></tr> <tr><td>44</td> <td>(4) <code>BossBarColor</code></td> <td>mColor</td></tr> <tr><td>48</td> <td>(4) <code>BossBarOverlay</code></td> <td>mOverlay</td></tr> <tr><td>52</td> <td>(4) <code>int</code></td> <td>mPlayersRegistered</td></tr> <tr><td>56</td> <td>(4) <code>int</code></td> <td>mLastHealth</td></tr> <tr><td>60</td> <td>(4) <code>int</code></td> <td>mHudRangeSquared</td></tr> <tr><td>64</td> <td>(8) <code>std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt;</code></td> <td>mLastPlayerUpdate</td></tr> <tr><td>72</td> <td>(64) <code>std::unordered_map&lt;mce::UUID,int&gt;</code></td> <td>mPlayerParty</td></tr></tbody></table> <h3 id="behaviorcomponent"><a href="#behaviorcomponent" class="header-anchor">#</a> <code>BehaviorComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>BehaviorTreeDefinitionPtr</code></td> <td>mTreeDefinition</td></tr> <tr><td>16</td> <td>(8) <code>std::unique_ptr&lt;BehaviorNode&gt;</code></td> <td>mRoot</td></tr> <tr><td>24</td> <td>(88) <code>BehaviorData</code></td> <td>mBehaviorData</td></tr> <tr><td>112</td> <td>(32) <code>std::string</code></td> <td>mBehaviorTreeId</td></tr></tbody></table> <h3 id="behaviordata"><a href="#behaviordata" class="header-anchor">#</a> <code>BehaviorData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_map&lt;std::string,std::unique_ptr&lt;BehaviorData::DataProxy&gt;&gt;</code></td> <td>mData</td></tr> <tr><td>64</td> <td>(24) <code>std::vector&lt;std::unique_ptr&lt;BehaviorData::DataProxy&gt;&gt;</code></td> <td>mDataStack</td></tr></tbody></table> <h3 id="breakblockssystem-tick-l2-lambda-6fc3bb95378df2694061b49575fc6c14"><a href="#breakblockssystem-tick-l2-lambda-6fc3bb95378df2694061b49575fc6c14" class="header-anchor">#</a> <code>BreakBlocksSystem::tick::__l2::&lt;lambda_6fc3bb95378df2694061b49575fc6c14&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BreakBlocksSystem *const</code></td> <td>__this</td></tr></tbody></table> <h3 id="breathablecomponent"><a href="#breathablecomponent" class="header-anchor">#</a> <code>BreathableComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mSuffocateTime</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>mInhaleTime</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mAirRegenPerTick</td></tr> <tr><td>12</td> <td>(1) <code>bool</code></td> <td>mBreathesAir</td></tr> <tr><td>13</td> <td>(1) <code>bool</code></td> <td>mBreathesWater</td></tr> <tr><td>14</td> <td>(1) <code>bool</code></td> <td>mBreathesLava</td></tr> <tr><td>15</td> <td>(1) <code>bool</code></td> <td>mBreathesSolids</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>mGeneratesBubbles</td></tr> <tr><td>18</td> <td>(2) <code>__int16</code></td> <td>mAirSupply</td></tr> <tr><td>20</td> <td>(2) <code>__int16</code></td> <td>mAirSupplyMax</td></tr> <tr><td>24</td> <td>(24) <code>std::vector&lt;BlockDescriptor&gt;</code></td> <td>mBreathableBlocks</td></tr> <tr><td>48</td> <td>(24) <code>std::vector&lt;BlockDescriptor&gt;</code></td> <td>mNonBreathableBlocks</td></tr> <tr><td>72</td> <td>(4) <code>BreathableComponent::BreathableState</code></td> <td>mBreathableState</td></tr> <tr><td>76</td> <td>(1) <code>bool</code></td> <td>mIsConsumingAirSupply</td></tr></tbody></table> <h3 id="bytetag"><a href="#bytetag" class="header-anchor">#</a> <code>ByteTag</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Tag</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(1) <code>unsigned __int8</code></td> <td>data</td></tr></tbody></table> <h3 id="bytearraytag"><a href="#bytearraytag" class="header-anchor">#</a> <code>ByteArrayTag</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Tag</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(24) <code>TagMemoryChunk</code></td> <td>data</td></tr></tbody></table> <h3 id="batchednetworkpeer-datacallback"><a href="#batchednetworkpeer-datacallback" class="header-anchor">#</a> <code>BatchedNetworkPeer::DataCallback</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>data</td></tr> <tr><td>32</td> <td>(4) <code>Compressibility</code></td> <td>compressible</td></tr> <tr><td>40</td> <td>(64) <code>std::function&lt;void __cdecl(void)&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="bookeditpacket"><a href="#bookeditpacket" class="header-anchor">#</a> <code>BookEditPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(1) <code>BookEditAction</code></td> <td>mAction</td></tr> <tr><td>44</td> <td>(4) <code>int</code></td> <td>mBookSlot</td></tr> <tr><td>48</td> <td>(4) <code>int</code></td> <td>mPageIndex1</td></tr> <tr><td>52</td> <td>(4) <code>int</code></td> <td>mPageIndex2</td></tr> <tr><td>56</td> <td>(32) <code>std::string</code></td> <td>mText1</td></tr> <tr><td>88</td> <td>(32) <code>std::string</code></td> <td>mText2</td></tr> <tr><td>120</td> <td>(32) <code>std::string</code></td> <td>mText3</td></tr></tbody></table> <h3 id="blockvolume-blockvolumeiter"><a href="#blockvolume-blockvolumeiter" class="header-anchor">#</a> <code>BlockVolume::BlockVolumeIter</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(12) <code>Pos</code></td> <td>pos</td></tr> <tr><td>12</td> <td>(12) <code>Pos</code></td> <td>dims</td></tr> <tr><td>24</td> <td>(8) <code>buffer_span_mut&lt;Block const *&gt;::iterator</code></td> <td>blockIter</td></tr></tbody></table> <h3 id="buffer-span-mut-block-const-iterator"><a href="#buffer-span-mut-block-const-iterator" class="header-anchor">#</a> <code>buffer_span_mut&lt;Block const *&gt;::iterator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const Block **</code></td> <td>mPtr</td></tr></tbody></table> <h3 id="binarystream"><a href="#binarystream" class="header-anchor">#</a> <code>BinaryStream</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>ReadOnlyBinaryStream</code></td> <td>baseclass_0</td></tr> <tr><td>64</td> <td>(32) <code>std::string</code></td> <td>mOwnedBuffer</td></tr> <tr><td>96</td> <td>(8) <code>std::string *</code></td> <td>mBuffer</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-serverinstanceeventcoordinator"><a href="#bedrock-nonownerpointer-serverinstanceeventcoordinator" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ServerInstanceEventCoordinator&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="blockchange"><a href="#blockchange" class="header-anchor">#</a> <code>BlockChange</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>mUpdateFlags</td></tr> <tr><td>8</td> <td>(8) <code>const Block *</code></td> <td>mOldBlock</td></tr> <tr><td>16</td> <td>(8) <code>const Block *</code></td> <td>mNewBlock</td></tr></tbody></table> <h3 id="bedrock-threading-completethen-l2-lambda-0b7e0b68a12c863263a53ce71992289b"><a href="#bedrock-threading-completethen-l2-lambda-0b7e0b68a12c863263a53ce71992289b" class="header-anchor">#</a> <code>Bedrock::Threading::completeThen::__l2::&lt;lambda_0b7e0b68a12c863263a53ce71992289b&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::Threading::AsyncDeferredResultT&lt;std::pair&lt;Json::Value,Core::PathBuffer&lt;std::string &gt; &gt; &gt; &gt;</code></td> <td>wrapperTask</td></tr> <tr><td>16</td> <td>(40) <code>ActorDefinitionGroup::_getResources::__l8::&lt;lambda_d64fe27ef6da0a56cad972a0ec1d52ab&gt;</code></td> <td>callback</td></tr></tbody></table> <h3 id="bedrock-nonownerpointer-level"><a href="#bedrock-nonownerpointer-level" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Level&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt;</code></td> <td>mControlBlock</td></tr></tbody></table> <h3 id="bartercomponent"><a href="#bartercomponent" class="header-anchor">#</a> <code>BarterComponent</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ActorUniqueID</code></td> <td>mItemOriginationActorUniqueID</td></tr> <tr><td>8</td> <td>(2) <code>__int16</code></td> <td>mBarterItemId</td></tr> <tr><td>10</td> <td>(1) <code>bool</code></td> <td>mExecuteTrade</td></tr></tbody></table> <h3 id="blockreducer"><a href="#blockreducer" class="header-anchor">#</a> <code>BlockReducer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockReducer_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(64) <code>std::unordered_map&lt;int,std::vector&lt;ItemStack&gt;&gt;</code></td> <td>mBlockToElements</td></tr></tbody></table> <h3 id="blocklegacy-trygetstatefromlegacydata-l2-lambda-aa356eec0c94171593ee29f169b1c8dd"><a href="#blocklegacy-trygetstatefromlegacydata-l2-lambda-aa356eec0c94171593ee29f169b1c8dd" class="header-anchor">#</a> <code>BlockLegacy::tryGetStateFromLegacyData::__l2::&lt;lambda_aa356eec0c94171593ee29f169b1c8dd&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const BlockLegacy *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>data</td></tr></tbody></table> <h3 id="buildmatch"><a href="#buildmatch" class="header-anchor">#</a> <code>BuildMatch</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mMatched</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>mForward</td></tr> <tr><td>2</td> <td>(1) <code>unsigned __int8</code></td> <td>mUp</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>mNumPatterns</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>mPatternSize</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>mSubPatternIndex</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>mRowIndex</td></tr> <tr><td>20</td> <td>(12) <code>BlockPos</code></td> <td>mPattern</td></tr> <tr><td>32</td> <td>(12) <code>Vec3</code></td> <td>mObjectPos</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-45198a55f8a28523ff9cd66bab017799"><a href="#biomecomponentloading-buildschema-l2-lambda-588cbba04482f56d12cfb2e5c6cae432-l2-lambda-45198a55f8a28523ff9cd66bab017799" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_588cbba04482f56d12cfb2e5c6cae432&gt;::()::__l2::&lt;lambda_45198a55f8a28523ff9cd66bab017799&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;BiomeDecorationAttributes&lt;ListedFeatures&gt; &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-2b22735977b37e611b382921ec440033"><a href="#biomecomponentloading-buildschema-l2-lambda-2b22735977b37e611b382921ec440033" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_2b22735977b37e611b382921ec440033&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;ClimateAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-45252a856d8739e9c6bb0100836f32b3"><a href="#biomecomponentloading-buildschema-l2-lambda-45252a856d8739e9c6bb0100836f32b3" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_45252a856d8739e9c6bb0100836f32b3&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;SurfaceMaterialAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-e1885f2df24d7b159c293c55fe6bfd77"><a href="#biomecomponentloading-buildschema-l2-lambda-e1885f2df24d7b159c293c55fe6bfd77" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_e1885f2df24d7b159c293c55fe6bfd77&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;OverworldHeightAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-9cd4a940da8b9d3c7f88c55d5cb46739"><a href="#biomecomponentloading-buildschema-l2-lambda-9cd4a940da8b9d3c7f88c55d5cb46739" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_9cd4a940da8b9d3c7f88c55d5cb46739&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;OverworldHeightAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomedecorationattributes-listedfeatures"><a href="#biomedecorationattributes-listedfeatures" class="header-anchor">#</a> <code>BiomeDecorationAttributes&lt;ListedFeatures&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;BiomeDecorationFeature *&gt;</code></td> <td>mFeatures</td></tr> <tr><td>24</td> <td>(64) <code>std::unordered_set&lt;HashedString&gt;</code></td> <td>mFeatureRuleNameSet</td></tr></tbody></table> <h3 id="blockactorfactory-createblockentity-l4-lambda-0a8b0200222e817880ba31bb39105399"><a href="#blockactorfactory-createblockentity-l4-lambda-0a8b0200222e817880ba31bb39105399" class="header-anchor">#</a> <code>BlockActorFactory::createBlockEntity::__l4::&lt;lambda_0a8b0200222e817880ba31bb39105399&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockActorType *</code></td> <td>type</td></tr></tbody></table> <h3 id="baserailblock-rail"><a href="#baserailblock-rail" class="header-anchor">#</a> <code>BaseRailBlock::Rail</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockSource *</code></td> <td>mRegion</td></tr> <tr><td>8</td> <td>(12) <code>BlockPos</code></td> <td>mPos</td></tr> <tr><td>20</td> <td>(1) <code>bool</code></td> <td>mUsesDataBit</td></tr> <tr><td>24</td> <td>(24) <code>std::vector&lt;BlockPos&gt;</code></td> <td>mConnections</td></tr></tbody></table> <h3 id="blockdefinition"><a href="#blockdefinition" class="header-anchor">#</a> <code>BlockDefinition</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(112) <code>SemVersion</code></td> <td>mFormatVersion</td></tr> <tr><td>112</td> <td>(192) <code>BlockDescription</code></td> <td>mDescription</td></tr> <tr><td>304</td> <td>(48) <code>BlockComponentGroupDescription</code></td> <td>mBaseComponents</td></tr> <tr><td>352</td> <td>(24) <code>std::vector&lt;BlockPermutationDescription&gt;</code></td> <td>mPermutationDescriptions</td></tr> <tr><td>376</td> <td>(64) <code>std::unordered_map&lt;std::string,DefinitionEvent&gt;</code></td> <td>mEventHandlers</td></tr></tbody></table> <h3 id="blockdescription"><a href="#blockdescription" class="header-anchor">#</a> <code>BlockDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mIdentifier</td></tr> <tr><td>32</td> <td>(24) <code>std::vector&lt;BlockStateDefinition&gt;</code></td> <td>mStates</td></tr> <tr><td>56</td> <td>(32) <code>std::string</code></td> <td>mMaterial</td></tr> <tr><td>88</td> <td>(32) <code>std::string</code></td> <td>mBaseBlock</td></tr> <tr><td>120</td> <td>(32) <code>std::string</code></td> <td>mCategory</td></tr> <tr><td>152</td> <td>(32) <code>std::string</code></td> <td>mMicroSize</td></tr> <tr><td>184</td> <td>(1) <code>bool</code></td> <td>mRegisterToCreativeMenu</td></tr></tbody></table> <h3 id="blockcomponentgroupdescription"><a href="#blockcomponentgroupdescription" class="header-anchor">#</a> <code>BlockComponentGroupDescription</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;std::shared_ptr&lt;BlockComponentDescription&gt;&gt;</code></td> <td>mDescriptions</td></tr> <tr><td>24</td> <td>(24) <code>std::vector&lt;HashedString&gt;</code></td> <td>mTags</td></tr></tbody></table> <h3 id="blockstatedefinition"><a href="#blockstatedefinition" class="header-anchor">#</a> <code>BlockStateDefinition</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>32</td> <td>(1) <code>_BYTE[1]</code></td> <td>mType</td></tr> <tr><td>40</td> <td>(8) <code>std::unique_ptr&lt;ListTag&gt;</code></td> <td>mEnumValues</td></tr> <tr><td>48</td> <td>(8) <code>const ItemState *</code></td> <td>mEngineState</td></tr></tbody></table> <h3 id="blockdefinitiongroup-loadresourcesmod-l2-blockresource"><a href="#blockdefinitiongroup-loadresourcesmod-l2-blockresource" class="header-anchor">#</a> <code>BlockDefinitionGroup::loadResourcesMod::__l2::BlockResource</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(112) <code>SemVersion</code></td> <td>mVersion</td></tr> <tr><td>112</td> <td>(192) <code>BlockDescription</code></td> <td>mDescription</td></tr> <tr><td>304</td> <td>(16) <code>Json::Value</code></td> <td>mRoot</td></tr></tbody></table> <h3 id="blocksource-fetchblocksincylinder-l2-lambda-0d9328dc3cbb3a479fb4635880f92988"><a href="#blocksource-fetchblocksincylinder-l2-lambda-0d9328dc3cbb3a479fb4635880f92988" class="header-anchor">#</a> <code>BlockSource::fetchBlocksInCylinder::__l2::&lt;lambda_0d9328dc3cbb3a479fb4635880f92988&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockSource *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(8) <code>const BlockPos *</code></td> <td>centerPos</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>radius</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>height</td></tr> <tr><td>24</td> <td>(8) <code>std::function&lt;bool __cdecl(Block const &amp;)&gt; *</code></td> <td>predicate</td></tr></tbody></table> <h3 id="blocksource-fetchblocksinbox-l2-lambda-f079637cc512a127f579039b711c8a60"><a href="#blocksource-fetchblocksinbox-l2-lambda-f079637cc512a127f579039b711c8a60" class="header-anchor">#</a> <code>BlockSource::fetchBlocksInBox::__l2::&lt;lambda_f079637cc512a127f579039b711c8a60&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockSource *const</code></td> <td>__this</td></tr> <tr><td>8</td> <td>(8) <code>const BoundingBox *</code></td> <td>box</td></tr> <tr><td>16</td> <td>(8) <code>std::function&lt;bool __cdecl(Block const &amp;)&gt; *</code></td> <td>predicate</td></tr></tbody></table> <h3 id="blocktickingqueue-blocktick"><a href="#blocktickingqueue-blocktick" class="header-anchor">#</a> <code>BlockTickingQueue::BlockTick</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>bool</code></td> <td>mIsRemoved</td></tr> <tr><td>8</td> <td>(40) <code>TickNextTickData</code></td> <td>mData</td></tr></tbody></table> <h3 id="blockfetchresult"><a href="#blockfetchresult" class="header-anchor">#</a> <code>BlockFetchResult</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>std::reference_wrapper&lt;Block const &gt;</code></td> <td>mBlock</td></tr> <tr><td>8</td> <td>(12) <code>BlockPos</code></td> <td>mBlockPos</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>mDistanceSquared</td></tr></tbody></table> <h3 id="biomedecorationfeature"><a href="#biomedecorationfeature" class="header-anchor">#</a> <code>BiomeDecorationFeature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1816) <code>ScatterParams</code></td> <td>mScatter</td></tr> <tr><td>1816</td> <td>(24) <code>WeakRefT&lt;FeatureRefTraits&gt;</code></td> <td>mFeature</td></tr> <tr><td>1840</td> <td>(48) <code>HashedString</code></td> <td>mIdentifier</td></tr></tbody></table> <h3 id="biomefiltergroup"><a href="#biomefiltergroup" class="header-anchor">#</a> <code>BiomeFilterGroup</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>FilterGroup</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="block"><a href="#block" class="header-anchor">#</a> <code>Block</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Block_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(2) <code>const unsigned __int16</code></td> <td>mData</td></tr> <tr><td>16</td> <td>(8) <code>gsl::not_null&lt;BlockLegacy *&gt;</code></td> <td>mLegacyBlock</td></tr> <tr><td>24</td> <td>(24) <code>CompoundTag</code></td> <td>mSerializationId</td></tr> <tr><td>48</td> <td>(4) <code>unsigned int</code></td> <td>mRuntimeId</td></tr> <tr><td>52</td> <td>(1) <code>bool</code></td> <td>mHasRuntimeId</td></tr> <tr><td>56</td> <td>(20) <code>CachedComponentData</code></td> <td>mCachedComponentData</td></tr> <tr><td>80</td> <td>(24) <code>OwnerPtrT&lt;EntityRefTraits&gt;</code></td> <td>mEntity</td></tr> <tr><td>104</td> <td>(24) <code>std::vector&lt;HashedString&gt;</code></td> <td>mTags</td></tr> <tr><td>128</td> <td>(1) <code>bool</code></td> <td>mSetByPlayer</td></tr></tbody></table> <h3 id="biomesource"><a href="#biomesource" class="header-anchor">#</a> <code>BiomeSource</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BiomeSource_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="bonuschestfeature"><a href="#bonuschestfeature" class="header-anchor">#</a> <code>BonusChestFeature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>Feature</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bigendianstringbyteinput"><a href="#bigendianstringbyteinput" class="header-anchor">#</a> <code>BigEndianStringByteInput</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>StringByteInput</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bytesdatainput"><a href="#bytesdatainput" class="header-anchor">#</a> <code>BytesDataInput</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>IDataInput</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="blocktickingqueue-tickdataset"><a href="#blocktickingqueue-tickdataset" class="header-anchor">#</a> <code>BlockTickingQueue::TickDataSet</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>MovePriorityQueue&lt;BlockTickingQueue::BlockTick,std::greater&lt;BlockTickingQueue::BlockTick&gt; &gt;</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="biomechunkdata"><a href="#biomechunkdata" class="header-anchor">#</a> <code>BiomeChunkData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>biome</td></tr></tbody></table> <h3 id="bgfx-memory"><a href="#bgfx-memory" class="header-anchor">#</a> <code>bgfx::Memory</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int8 *</code></td> <td>data</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>size</td></tr></tbody></table> <h3 id="bgfx-shaderhandle"><a href="#bgfx-shaderhandle" class="header-anchor">#</a> <code>bgfx::ShaderHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-init"><a href="#bgfx-init" class="header-anchor">#</a> <code>bgfx::Init</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::RendererType::Enum</code></td> <td>type</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>vendorId</td></tr> <tr><td>6</td> <td>(2) <code>unsigned __int16</code></td> <td>deviceId</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>debug</td></tr> <tr><td>9</td> <td>(1) <code>bool</code></td> <td>profile</td></tr> <tr><td>12</td> <td>(12) <code>bgfx::Resolution</code></td> <td>resolution</td></tr> <tr><td>24</td> <td>(16) <code>bgfx::Init::Limits</code></td> <td>limits</td></tr> <tr><td>40</td> <td>(8) <code>bgfx::CallbackI *</code></td> <td>callback</td></tr> <tr><td>48</td> <td>(8) <code>bx::AllocatorI *</code></td> <td>allocator</td></tr></tbody></table> <h3 id="bgfx-init-limits"><a href="#bgfx-init-limits" class="header-anchor">#</a> <code>bgfx::Init::Limits</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>maxEncoders</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>transientVbSize</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>transientIbSize</td></tr> <tr><td>12</td> <td>(1) <code>unsigned __int8</code></td> <td>maxRendererWorkers</td></tr></tbody></table> <h3 id="bgfx-instancedatabuffer"><a href="#bgfx-instancedatabuffer" class="header-anchor">#</a> <code>bgfx::InstanceDataBuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int8 *</code></td> <td>data</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>size</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>offset</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>num</td></tr> <tr><td>20</td> <td>(2) <code>unsigned __int16</code></td> <td>stride</td></tr> <tr><td>22</td> <td>(2) <code>bgfx::VertexBufferHandle</code></td> <td>handle</td></tr></tbody></table> <h3 id="basegamepackslices"><a href="#basegamepackslices" class="header-anchor">#</a> <code>BaseGamePackSlices</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;BaseGamePackSlices::BaseGameVersionPack&gt;</code></td> <td>mBaseGameVersionPacks</td></tr> <tr><td>24</td> <td>(24) <code>std::vector&lt;BaseGamePackSlices::BaseGameVersionPack&gt;</code></td> <td>mBaseGameVersionTestPacks</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-304b29c86db3d6bdd6f6537782e989e0"><a href="#biomecomponentloading-buildschema-l2-lambda-304b29c86db3d6bdd6f6537782e989e0" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_304b29c86db3d6bdd6f6537782e989e0&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;MesaSurfaceAttributes &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-7bf6a58d63e3c81bd35ab4e9d081ecbf"><a href="#biomecomponentloading-buildschema-l2-lambda-7bf6a58d63e3c81bd35ab4e9d081ecbf" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_7bf6a58d63e3c81bd35ab4e9d081ecbf&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;WeightedBiomeAttributes&lt;HillsTransformation&gt; &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-86a0f9e6e32f92158f68bfa3784704c3"><a href="#biomecomponentloading-buildschema-l2-lambda-86a0f9e6e32f92158f68bfa3784704c3" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_86a0f9e6e32f92158f68bfa3784704c3&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;WeightedBiomeAttributes&lt;MutateBiomeTransformation&gt; &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-2892db5edaa4d8160c8761f115eea62c"><a href="#biomecomponentloading-buildschema-l2-lambda-2892db5edaa4d8160c8761f115eea62c" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_2892db5edaa4d8160c8761f115eea62c&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;WeightedBiomeAttributes&lt;RiverTransformation&gt; &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-9d9461e1e6ffd446a377f5480aefaf21"><a href="#biomecomponentloading-buildschema-l2-lambda-9d9461e1e6ffd446a377f5480aefaf21" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_9d9461e1e6ffd446a377f5480aefaf21&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;WeightedBiomeAttributes&lt;ShoreTransformation&gt; &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>componentAccessor</td></tr></tbody></table> <h3 id="biomecomponentloading-buildschema-l2-lambda-f24f1fe26483478c4c9f59e59c913b83"><a href="#biomecomponentloading-buildschema-l2-lambda-f24f1fe26483478c4c9f59e59c913b83" class="header-anchor">#</a> <code>BiomeComponentLoading::_buildSchema::__l2::&lt;lambda_f24f1fe26483478c4c9f59e59c913b83&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::function&lt;std::vector&lt;std::pair&lt;Biome *,unsigned int&gt;&gt; &amp; __cdecl(std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; *)&gt;</code></td> <td>biomeVectorAccessor</td></tr></tbody></table> <h3 id="blockselector"><a href="#blockselector" class="header-anchor">#</a> <code>BlockSelector</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>BlockSelector_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="blocktickingqueue"><a href="#blocktickingqueue" class="header-anchor">#</a> <code>BlockTickingQueue</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>LevelChunk *</code></td> <td>mOwningChunk</td></tr> <tr><td>8</td> <td>(8) <code>Tick</code></td> <td>mCurrentTick</td></tr> <tr><td>16</td> <td>(24) <code>BlockTickingQueue::TickDataSet</code></td> <td>mNextTickQueue</td></tr> <tr><td>40</td> <td>(24) <code>BlockTickingQueue::TickDataSet</code></td> <td>mActiveTickQueue</td></tr> <tr><td>64</td> <td>(1) <code>TickingQueueType</code></td> <td>mQueueType</td></tr> <tr><td>65</td> <td>(1) <code>bool</code></td> <td>mInstaTick</td></tr></tbody></table> <h3 id="biomearea"><a href="#biomearea" class="header-anchor">#</a> <code>BiomeArea</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>mStride</td></tr> <tr><td>8</td> <td>(24) <code>std::vector&lt;Biome const *&gt;</code></td> <td>mBiomes</td></tr></tbody></table> <h3 id="biome"><a href="#biome" class="header-anchor">#</a> <code>Biome</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Biome_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>8</td> <td>(32) <code>std::string</code></td> <td>mName</td></tr> <tr><td>40</td> <td>(4) <code>int</code></td> <td>mDebugMapColor</td></tr> <tr><td>44</td> <td>(4) <code>int</code></td> <td>mDebugMapOddColor</td></tr> <tr><td>48</td> <td>(4) <code>float</code></td> <td>mTemperature</td></tr> <tr><td>52</td> <td>(4) <code>float</code></td> <td>mDownfall</td></tr> <tr><td>56</td> <td>(4) <code>float</code></td> <td>mRedSporeDensity</td></tr> <tr><td>60</td> <td>(4) <code>float</code></td> <td>mBlueSporeDensity</td></tr> <tr><td>64</td> <td>(4) <code>float</code></td> <td>mAshDensity</td></tr> <tr><td>68</td> <td>(4) <code>float</code></td> <td>mWhiteAshDensity</td></tr> <tr><td>72</td> <td>(4) <code>float</code></td> <td>mSnowAccumulation</td></tr> <tr><td>76</td> <td>(4) <code>float</code></td> <td>mFoliageSnow</td></tr> <tr><td>80</td> <td>(4) <code>float</code></td> <td>mMinSnowLevel</td></tr> <tr><td>84</td> <td>(4) <code>float</code></td> <td>mMaxSnowLevel</td></tr> <tr><td>88</td> <td>(4) <code>float</code></td> <td>mDepth</td></tr> <tr><td>92</td> <td>(4) <code>float</code></td> <td>mScale</td></tr> <tr><td>96</td> <td>(16) <code>mce::Color</code></td> <td>mWaterColor</td></tr> <tr><td>112</td> <td>(4) <code>float</code></td> <td>mWaterTransparency</td></tr> <tr><td>116</td> <td>(1) <code>bool</code></td> <td>mRain</td></tr> <tr><td>120</td> <td>(4) <code>int</code></td> <td>mId</td></tr> <tr><td>128</td> <td>(16) <code>WeakRefT&lt;SharePtrRefTraits&lt;FogDefinition const &gt; &gt;</code></td> <td>mFogDefinition</td></tr> <tr><td>144</td> <td>(12) <code>OceanRuinConfiguration</code></td> <td>mOceanRuinConfig</td></tr> <tr><td>160</td> <td>(24) <code>std::vector&lt;MobSpawnerData&gt;</code></td> <td>mMobs</td></tr> <tr><td>184</td> <td>(8) <code>std::unique_ptr&lt;PerlinSimplexNoise&gt;</code></td> <td>mTemperatureNoise</td></tr> <tr><td>192</td> <td>(8) <code>std::unique_ptr&lt;PerlinSimplexNoise&gt;</code></td> <td>mFrozenTemperatureNoise</td></tr> <tr><td>200</td> <td>(24) <code>OwnerPtrT&lt;EntityRefTraits&gt;</code></td> <td>mEntity</td></tr> <tr><td>224</td> <td>(16) <code>OwnerPtrT&lt;SharePtrRefTraits&lt;PerlinSimplexNoise&gt; &gt;</code></td> <td>mBiomeInfoNoise</td></tr> <tr><td>240</td> <td>(4) <code>AutomaticID&lt;Dimension,int&gt;</code></td> <td>mDimensionType</td></tr> <tr><td>248</td> <td>(32) <code>std::string</code></td> <td>mVanillaName</td></tr></tbody></table> <h3 id="blockactorfactory-registercustomblockentitycreationcallback-l2-lambda-fff5251917a5d96d413be26580a41046"><a href="#blockactorfactory-registercustomblockentitycreationcallback-l2-lambda-fff5251917a5d96d413be26580a41046" class="header-anchor">#</a> <code>BlockActorFactory::registerCustomBlockEntityCreationCallback::__l2::&lt;lambda_fff5251917a5d96d413be26580a41046&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody></tbody></table> <h3 id="buttonchordtracker-chordbuttondetails"><a href="#buttonchordtracker-chordbuttondetails" class="header-anchor">#</a> <code>ButtonChordTracker::ChordButtonDetails</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>buttonMaskForThisChord</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>completeChordMask</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>resultantButtonId</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>currentStateIndex</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>originalChordButtonSequenceIndex</td></tr></tbody></table> <h3 id="buttoneventdata"><a href="#buttoneventdata" class="header-anchor">#</a> <code>ButtonEventData</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>id</td></tr> <tr><td>4</td> <td>(1) <code>ButtonState</code></td> <td>state</td></tr> <tr><td>5</td> <td>(1) <code>bool</code></td> <td>exclusive</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>repeatInterval</td></tr></tbody></table> <h3 id="buttonchordtracker-trackermappingandstate"><a href="#buttonchordtracker-trackermappingandstate" class="header-anchor">#</a> <code>ButtonChordTracker::TrackerMappingAndState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>std::unordered_multimap&lt;unsigned int,ButtonChordTracker::ChordButtonDetails&gt;</code></td> <td>mChordMap</td></tr> <tr><td>64</td> <td>(24) <code>std::vector&lt;int&gt;</code></td> <td>mChordState</td></tr> <tr><td>88</td> <td>(24) <code>std::vector&lt;std::vector&lt;unsigned int&gt;&gt;</code></td> <td>mButtonSequences</td></tr></tbody></table> <h3 id="bedrock-jsonobject-valuewrapper"><a href="#bedrock-jsonobject-valuewrapper" class="header-anchor">#</a> <code>Bedrock::JSONObject::ValueWrapper</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>Bedrock::JSONObject::JSONType</code></td> <td>mType</td></tr> <tr><td>8</td> <td>(64) <code>$26CCF555AF14FCAE7148684434635FE2</code></td> <td>___u1</td></tr></tbody></table> <h3 id="bedrock-jsonobject-valuewrapper-numberinfo"><a href="#bedrock-jsonobject-valuewrapper-numberinfo" class="header-anchor">#</a> <code>Bedrock::JSONObject::ValueWrapper::NumberInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>$3EB15921B14454EE0C46C34FC3F1335B</code></td> <td>___u0</td></tr> <tr><td>8</td> <td>(1) <code>bool</code></td> <td>mIsFloatingPoint</td></tr></tbody></table> <h3 id="bedrock-jsonobject-valuewrapper-stringinfo"><a href="#bedrock-jsonobject-valuewrapper-stringinfo" class="header-anchor">#</a> <code>Bedrock::JSONObject::ValueWrapper::StringInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>mString</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>mLength</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>mCopy</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-irradiancecacheclearcontext"><a href="#bgfx-d3d12rtx-irradiancecacheclearcontext" class="header-anchor">#</a> <code>bgfx::d3d12rtx::IrradianceCacheClearContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_blasIdx</td></tr></tbody></table> <h3 id="bedrock-jsonobject-parsehandler"><a href="#bedrock-jsonobject-parsehandler" class="header-anchor">#</a> <code>Bedrock::JSONObject::ParseHandler</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>gsl::not_null&lt;Bedrock::JSONObject::Document *&gt;</code></td> <td>mDocument</td></tr> <tr><td>8</td> <td>(8) <code>Bedrock::JSONObject::ParseHandler::StackEntry *</code></td> <td>mStack</td></tr></tbody></table> <h3 id="bedrock-intrusive-list-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-iterator-base-0"><a href="#bedrock-intrusive-list-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-iterator-base-0" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;::iterator_base&lt;0&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>Bedrock::JSONObject::NodeBase *</code></td> <td>mHook</td></tr></tbody></table> <h3 id="black-tworker"><a href="#black-tworker" class="header-anchor">#</a> <code>black_TWorker_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>precision_bits</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>precision</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>precision_half</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>precision_scale</td></tr> <tr><td>16</td> <td>(4) <code>int</code></td> <td>precision_step</td></tr> <tr><td>20</td> <td>(4) <code>int</code></td> <td>precision_jitter</td></tr> <tr><td>24</td> <td>(8) <code>int *</code></td> <td>buff</td></tr> <tr><td>32</td> <td>(8) <code>int *</code></td> <td>sizeBuff</td></tr> <tr><td>40</td> <td>(8) <code>int *</code></td> <td>maxBuff</td></tr> <tr><td>48</td> <td>(8) <code>int *</code></td> <td>top</td></tr> <tr><td>56</td> <td>(4) <code>int</code></td> <td>error</td></tr> <tr><td>60</td> <td>(4) <code>int</code></td> <td>numTurns</td></tr> <tr><td>64</td> <td>(8) <code>TPoint_ *</code></td> <td>arc</td></tr> <tr><td>72</td> <td>(2) <code>unsigned __int16</code></td> <td>bWidth</td></tr> <tr><td>80</td> <td>(8) <code>unsigned __int8 *</code></td> <td>bOrigin</td></tr> <tr><td>88</td> <td>(4) <code>int</code></td> <td>lastX</td></tr> <tr><td>92</td> <td>(4) <code>int</code></td> <td>lastY</td></tr> <tr><td>96</td> <td>(4) <code>int</code></td> <td>minY</td></tr> <tr><td>100</td> <td>(4) <code>int</code></td> <td>maxY</td></tr> <tr><td>104</td> <td>(2) <code>unsigned __int16</code></td> <td>num_Profs</td></tr> <tr><td>106</td> <td>(1) <code>char</code></td> <td>fresh</td></tr> <tr><td>107</td> <td>(1) <code>char</code></td> <td>joint</td></tr> <tr><td>112</td> <td>(8) <code>TProfile_ *</code></td> <td>cProfile</td></tr> <tr><td>120</td> <td>(8) <code>TProfile_ *</code></td> <td>fProfile</td></tr> <tr><td>128</td> <td>(8) <code>TProfile_ *</code></td> <td>gProfile</td></tr> <tr><td>136</td> <td>(4) <code>TStates_</code></td> <td>state</td></tr> <tr><td>144</td> <td>(40) <code>FT_Bitmap_</code></td> <td>target</td></tr> <tr><td>184</td> <td>(40) <code>FT_Outline_</code></td> <td>outline</td></tr> <tr><td>224</td> <td>(4) <code>int</code></td> <td>traceOfs</td></tr> <tr><td>228</td> <td>(2) <code>__int16</code></td> <td>traceIncr</td></tr> <tr><td>232</td> <td>(8) <code>void (__fastcall *)(black_TWorker_ *, __int16 *, __int16 *)</code></td> <td>Proc_Sweep_Init</td></tr> <tr><td>240</td> <td>(8) <code>void (__fastcall *)(black_TWorker_ *, __int16, int, int, TProfile_ *, TProfile_ *)</code></td> <td>Proc_Sweep_Span</td></tr> <tr><td>248</td> <td>(8) <code>void (__fastcall *)(black_TWorker_ *, __int16, int, int, TProfile_ *, TProfile_ *)</code></td> <td>Proc_Sweep_Drop</td></tr> <tr><td>256</td> <td>(8) <code>void (__fastcall *)(black_TWorker_ *)</code></td> <td>Proc_Sweep_Step</td></tr> <tr><td>264</td> <td>(1) <code>unsigned __int8</code></td> <td>dropOutControl</td></tr> <tr><td>265</td> <td>(1) <code>char</code></td> <td>second_pass</td></tr> <tr><td>268</td> <td>(776) <code>TPoint_[97]</code></td> <td>arcs</td></tr> <tr><td>1044</td> <td>(64) <code>black_TBand_[16]</code></td> <td>band_stack</td></tr> <tr><td>1108</td> <td>(4) <code>int</code></td> <td>band_top</td></tr></tbody></table> <h3 id="black-tband"><a href="#black-tband" class="header-anchor">#</a> <code>black_TBand_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>__int16</code></td> <td>y_min</td></tr> <tr><td>2</td> <td>(2) <code>__int16</code></td> <td>y_max</td></tr></tbody></table> <h3 id="bdf-propertyrec"><a href="#bdf-propertyrec" class="header-anchor">#</a> <code>BDF_PropertyRec_</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>BDF_PropertyType_</code></td> <td>type</td></tr> <tr><td>8</td> <td>(8) <code>union {const char *atom;int integer;unsigned int cardinal;}</code></td> <td>u</td></tr></tbody></table> <h3 id="bufferinfo"><a href="#bufferinfo" class="header-anchor">#</a> <code>bufferinfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void *</code></td> <td>buf</td></tr> <tr><td>8</td> <td>(8) <code>_object *</code></td> <td>obj</td></tr> <tr><td>16</td> <td>(8) <code>__int64</code></td> <td>len</td></tr> <tr><td>24</td> <td>(8) <code>__int64</code></td> <td>itemsize</td></tr> <tr><td>32</td> <td>(4) <code>int</code></td> <td>readonly</td></tr> <tr><td>36</td> <td>(4) <code>int</code></td> <td>ndim</td></tr> <tr><td>40</td> <td>(8) <code>char *</code></td> <td>format</td></tr> <tr><td>48</td> <td>(8) <code>__int64 *</code></td> <td>shape</td></tr> <tr><td>56</td> <td>(8) <code>__int64 *</code></td> <td>strides</td></tr> <tr><td>64</td> <td>(8) <code>__int64 *</code></td> <td>suboffsets</td></tr> <tr><td>72</td> <td>(16) <code>__int64[2]</code></td> <td>smalltable</td></tr> <tr><td>88</td> <td>(8) <code>void *</code></td> <td>internal</td></tr></tbody></table> <h3 id="buffered"><a href="#buffered" class="header-anchor">#</a> <code>buffered</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>__int64</code></td> <td>ob_refcnt</td></tr> <tr><td>8</td> <td>(8) <code>_typeobject *</code></td> <td>ob_type</td></tr> <tr><td>16</td> <td>(8) <code>_object *</code></td> <td>raw</td></tr> <tr><td>24</td> <td>(4) <code>int</code></td> <td>ok</td></tr> <tr><td>28</td> <td>(4) <code>int</code></td> <td>detached</td></tr> <tr><td>32</td> <td>(4) <code>int</code></td> <td>readable</td></tr> <tr><td>36</td> <td>(4) <code>int</code></td> <td>writable</td></tr> <tr><td>40</td> <td>(4) <code>int</code></td> <td>fast_closed_checks</td></tr> <tr><td>48</td> <td>(8) <code>__int64</code></td> <td>abs_pos</td></tr> <tr><td>56</td> <td>(8) <code>char *</code></td> <td>buffer</td></tr> <tr><td>64</td> <td>(8) <code>__int64</code></td> <td>pos</td></tr> <tr><td>72</td> <td>(8) <code>__int64</code></td> <td>raw_pos</td></tr> <tr><td>80</td> <td>(8) <code>__int64</code></td> <td>read_end</td></tr> <tr><td>88</td> <td>(8) <code>__int64</code></td> <td>write_pos</td></tr> <tr><td>96</td> <td>(8) <code>__int64</code></td> <td>write_end</td></tr> <tr><td>104</td> <td>(8) <code>void *</code></td> <td>lock</td></tr> <tr><td>112</td> <td>(4) <code>volatile int</code></td> <td>owner</td></tr> <tr><td>120</td> <td>(8) <code>__int64</code></td> <td>buffer_size</td></tr> <tr><td>128</td> <td>(8) <code>__int64</code></td> <td>buffer_mask</td></tr> <tr><td>136</td> <td>(8) <code>_object *</code></td> <td>dict</td></tr> <tr><td>144</td> <td>(8) <code>_object *</code></td> <td>weakreflist</td></tr></tbody></table> <h3 id="bcinfo"><a href="#bcinfo" class="header-anchor">#</a> <code>BCinfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>int</code></td> <td>e0</td></tr> <tr><td>4</td> <td>(4) <code>int</code></td> <td>nd</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>nd0</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>scale</td></tr></tbody></table> <h3 id="bgfx-nonlocalallocator-allocation"><a href="#bgfx-nonlocalallocator-allocation" class="header-anchor">#</a> <code>bgfx::NonLocalAllocator::Allocation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>m_ptr</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_offset</td></tr></tbody></table> <h3 id="bgfx-context-dynamicvertexallocation"><a href="#bgfx-context-dynamicvertexallocation" class="header-anchor">#</a> <code>bgfx::Context::DynamicVertexAllocation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>m_ptr</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_offset</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>m_totalSize</td></tr></tbody></table> <h3 id="bx-memoryreader"><a href="#bx-memoryreader" class="header-anchor">#</a> <code>bx::MemoryReader</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bx::ReaderSeekerI</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>m_data</td></tr> <tr><td>24</td> <td>(8) <code>__int64</code></td> <td>m_pos</td></tr> <tr><td>32</td> <td>(8) <code>__int64</code></td> <td>m_top</td></tr></tbody></table> <h3 id="bx-readerseekeri"><a href="#bx-readerseekeri" class="header-anchor">#</a> <code>bx::ReaderSeekerI</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::ReaderI</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>bx::SeekerI</code></td> <td>baseclass_8</td></tr></tbody></table> <h3 id="bx-readeri"><a href="#bx-readeri" class="header-anchor">#</a> <code>bx::ReaderI</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::ReaderI_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="bx-seekeri"><a href="#bx-seekeri" class="header-anchor">#</a> <code>bx::SeekerI</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::SeekerI_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="bx-error"><a href="#bx-error" class="header-anchor">#</a> <code>bx::Error</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bx::StringView</code></td> <td>m_msg</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_code</td></tr></tbody></table> <h3 id="bx-stringview"><a href="#bx-stringview" class="header-anchor">#</a> <code>bx::StringView</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>m_ptr</td></tr> <tr><td>8</td> <td>(4) <code>int</code></td> <td>m_len</td></tr></tbody></table> <h3 id="bimg-imagecontainer"><a href="#bimg-imagecontainer" class="header-anchor">#</a> <code>bimg::ImageContainer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::AllocatorI *</code></td> <td>m_allocator</td></tr> <tr><td>8</td> <td>(8) <code>void *</code></td> <td>m_data</td></tr> <tr><td>16</td> <td>(4) <code>_BYTE[4]</code></td> <td>m_format</td></tr> <tr><td>20</td> <td>(4) <code>bimg::Orientation::Enum</code></td> <td>m_orientation</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>m_offset</td></tr> <tr><td>32</td> <td>(4) <code>unsigned int</code></td> <td>m_width</td></tr> <tr><td>36</td> <td>(4) <code>unsigned int</code></td> <td>m_height</td></tr> <tr><td>40</td> <td>(4) <code>unsigned int</code></td> <td>m_depth</td></tr> <tr><td>44</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numLayers</td></tr> <tr><td>46</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numMips</td></tr> <tr><td>47</td> <td>(1) <code>bool</code></td> <td>m_hasAlpha</td></tr> <tr><td>48</td> <td>(1) <code>bool</code></td> <td>m_cubeMap</td></tr> <tr><td>49</td> <td>(1) <code>bool</code></td> <td>m_ktx</td></tr> <tr><td>50</td> <td>(1) <code>bool</code></td> <td>m_ktxLE</td></tr> <tr><td>51</td> <td>(1) <code>bool</code></td> <td>m_srgb</td></tr></tbody></table> <h3 id="bx-writeri"><a href="#bx-writeri" class="header-anchor">#</a> <code>bx::WriterI</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::WriterI_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="bx-defaultallocator"><a href="#bx-defaultallocator" class="header-anchor">#</a> <code>bx::DefaultAllocator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::AllocatorI</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bx-allocatori"><a href="#bx-allocatori" class="header-anchor">#</a> <code>bx::AllocatorI</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::AllocatorI_vtbl *</code></td> <td>__vftable</td></tr></tbody></table> <h3 id="bgfx-context"><a href="#bgfx-context" class="header-anchor">#</a> <code>bgfx::Context</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(128) <code>bx::Semaphore</code></td> <td>m_renderSem</td></tr> <tr><td>128</td> <td>(128) <code>bx::Semaphore</code></td> <td>m_apiSem</td></tr> <tr><td>256</td> <td>(128) <code>bx::Semaphore</code></td> <td>m_encoderEndSem</td></tr> <tr><td>384</td> <td>(64) <code>bx::Mutex</code></td> <td>m_encoderApiLock</td></tr> <tr><td>448</td> <td>(64) <code>bx::Mutex</code></td> <td>m_resourceApiLock</td></tr> <tr><td>512</td> <td>(464) <code>bx::Thread</code></td> <td>m_thread</td></tr> <tr><td>976</td> <td>(8) <code>bgfx::EncoderStats *</code></td> <td>m_encoderStats</td></tr> <tr><td>984</td> <td>(8) <code>bgfx::Encoder *</code></td> <td>m_encoder0</td></tr> <tr><td>992</td> <td>(8) <code>bgfx::EncoderImpl *</code></td> <td>m_encoder</td></tr> <tr><td>1000</td> <td>(4) <code>unsigned int</code></td> <td>m_numEncoders</td></tr> <tr><td>1008</td> <td>(8) <code>bx::HandleAlloc *</code></td> <td>m_encoderHandle</td></tr> <tr><td>1024</td> <td>(96326016) <code>bgfx::Frame[2]</code></td> <td>m_frame</td></tr> <tr><td>96327040</td> <td>(8) <code>bgfx::Frame *</code></td> <td>m_render</td></tr> <tr><td>96327048</td> <td>(8) <code>bgfx::Frame *</code></td> <td>m_submit</td></tr> <tr><td>96327056</td> <td>(524280) <code>unsigned __int64[65535]</code></td> <td>m_tempKeys</td></tr> <tr><td>96851336</td> <td>(131070) <code>unsigned __int16[65535]</code></td> <td>m_tempValues</td></tr> <tr><td>96982408</td> <td>(16384) <code>bgfx::IndexBuffer[4096]</code></td> <td>m_indexBuffers</td></tr> <tr><td>96998792</td> <td>(32768) <code>bgfx::VertexBuffer[4096]</code></td> <td>m_vertexBuffers</td></tr> <tr><td>97031560</td> <td>(81920) <code>bgfx::DynamicIndexBuffer[4096]</code></td> <td>m_dynamicIndexBuffers</td></tr> <tr><td>97113480</td> <td>(114688) <code>bgfx::DynamicVertexBuffer[4096]</code></td> <td>m_dynamicVertexBuffers</td></tr> <tr><td>97228168</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numFreeDynamicIndexBufferHandles</td></tr> <tr><td>97228170</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numFreeDynamicVertexBufferHandles</td></tr> <tr><td>97228172</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numFreeOcclusionQueryHandles</td></tr> <tr><td>97228174</td> <td>(8192) <code>bgfx::DynamicIndexBufferHandle[4096]</code></td> <td>m_freeDynamicIndexBufferHandle</td></tr> <tr><td>97236366</td> <td>(8192) <code>bgfx::DynamicVertexBufferHandle[4096]</code></td> <td>m_freeDynamicVertexBufferHandle</td></tr> <tr><td>97244558</td> <td>(512) <code>bgfx::OcclusionQueryHandle[256]</code></td> <td>m_freeOcclusionQueryHandle</td></tr> <tr><td>97245072</td> <td>(56) <code>bgfx::NonLocalAllocator</code></td> <td>m_dynIndexBufferAllocator</td></tr> <tr><td>97245128</td> <td>(16388) <code>bx::HandleAllocT&lt;4096&gt;</code></td> <td>m_dynamicIndexBufferHandle</td></tr> <tr><td>97261520</td> <td>(56) <code>bgfx::NonLocalAllocator</code></td> <td>m_dynVertexBufferAllocator</td></tr> <tr><td>97261576</td> <td>(16388) <code>bx::HandleAllocT&lt;4096&gt;</code></td> <td>m_dynamicVertexBufferHandle</td></tr> <tr><td>97277964</td> <td>(16388) <code>bx::HandleAllocT&lt;4096&gt;</code></td> <td>m_indexBufferHandle</td></tr> <tr><td>97294352</td> <td>(260) <code>bx::HandleAllocT&lt;64&gt;</code></td> <td>m_vertexDeclHandle</td></tr> <tr><td>97294612</td> <td>(16388) <code>bx::HandleAllocT&lt;4096&gt;</code></td> <td>m_vertexBufferHandle</td></tr> <tr><td>97311000</td> <td>(16388) <code>bx::HandleAllocT&lt;4096&gt;</code></td> <td>m_shaderHandle</td></tr> <tr><td>97327388</td> <td>(8196) <code>bx::HandleAllocT&lt;2048&gt;</code></td> <td>m_programHandle</td></tr> <tr><td>97335584</td> <td>(16388) <code>bx::HandleAllocT&lt;4096&gt;</code></td> <td>m_textureHandle</td></tr> <tr><td>97351972</td> <td>(16388) <code>bx::HandleAllocT&lt;4096&gt;</code></td> <td>m_shaderBufferHandle</td></tr> <tr><td>97368360</td> <td>(516) <code>bx::HandleAllocT&lt;128&gt;</code></td> <td>m_frameBufferHandle</td></tr> <tr><td>97368876</td> <td>(2052) <code>bx::HandleAllocT&lt;512&gt;</code></td> <td>m_uniformHandle</td></tr> <tr><td>97370928</td> <td>(1028) <code>bx::HandleAllocT&lt;256&gt;</code></td> <td>m_occlusionQueryHandle</td></tr> <tr><td>97371956</td> <td>(131076) <code>bx::HandleAllocT&lt;32768&gt;</code></td> <td>m_accelerationStructureBufferHandle</td></tr> <tr><td>97503032</td> <td>(6152) <code>bx::HandleHashMapT&lt;1024,unsigned int&gt;</code></td> <td>m_uniformHashMap</td></tr> <tr><td>97509184</td> <td>(12288) <code>bgfx::Context::UniformRef[512]</code></td> <td>m_uniformRef</td></tr> <tr><td>97521472</td> <td>(49160) <code>bx::HandleHashMapT&lt;8192,unsigned int&gt;</code></td> <td>m_shaderHashMap</td></tr> <tr><td>97570632</td> <td>(131072) <code>bgfx::Context::ShaderRef[4096]</code></td> <td>m_shaderRef</td></tr> <tr><td>97701704</td> <td>(24584) <code>bx::HandleHashMapT&lt;4096,unsigned int&gt;</code></td> <td>m_programHashMap</td></tr> <tr><td>97726288</td> <td>(12288) <code>bgfx::Context::ProgramRef[2048]</code></td> <td>m_programRef</td></tr> <tr><td>97738576</td> <td>(163840) <code>bgfx::Context::TextureRef[4096]</code></td> <td>m_textureRef</td></tr> <tr><td>97902416</td> <td>(163840) <code>bgfx::Context::ShaderBufferRef[4096]</code></td> <td>m_shaderBufferRef</td></tr> <tr><td>98066256</td> <td>(3072) <code>bgfx::Context::FrameBufferRef[128]</code></td> <td>m_frameBufferRef</td></tr> <tr><td>98069328</td> <td>(17288) <code>bgfx::VertexDeclRef</code></td> <td>m_declRef</td></tr> <tr><td>98086616</td> <td>(512) <code>unsigned __int16[256]</code></td> <td>m_viewRemap</td></tr> <tr><td>98087128</td> <td>(1024) <code>unsigned int[256]</code></td> <td>m_seq</td></tr> <tr><td>98088192</td> <td>(65536) <code>bgfx::View[256]</code></td> <td>m_view</td></tr> <tr><td>98153728</td> <td>(256) <code>float[16][4]</code></td> <td>m_clearColor</td></tr> <tr><td>98153984</td> <td>(1) <code>unsigned __int8</code></td> <td>m_colorPaletteDirty</td></tr> <tr><td>98153992</td> <td>(56) <code>bgfx::Init</code></td> <td>m_init</td></tr> <tr><td>98154048</td> <td>(8) <code>__int64</code></td> <td>m_frameTimeLast</td></tr> <tr><td>98154056</td> <td>(4) <code>unsigned int</code></td> <td>m_frames</td></tr> <tr><td>98154060</td> <td>(4) <code>unsigned int</code></td> <td>m_debug</td></tr> <tr><td>98154064</td> <td>(8) <code>__int64</code></td> <td>m_rtMemoryUsed</td></tr> <tr><td>98154072</td> <td>(8) <code>__int64</code></td> <td>m_textureMemoryUsed</td></tr> <tr><td>98154080</td> <td>(8) <code>__int64</code></td> <td>m_shaderBufferMemoryUsed</td></tr> <tr><td>98154088</td> <td>(112) <code>bgfx::TextVideoMemBlitter</code></td> <td>m_textVideoMemBlitter</td></tr> <tr><td>98154200</td> <td>(104) <code>bgfx::ClearQuad</code></td> <td>m_clearQuad</td></tr> <tr><td>98154304</td> <td>(8) <code>bgfx::RendererContextI *</code></td> <td>m_renderCtx</td></tr> <tr><td>98154312</td> <td>(8) <code>bgfx::RendererContextI *</code></td> <td>m_renderMain</td></tr> <tr><td>98154320</td> <td>(8) <code>bgfx::RendererContextI *</code></td> <td>m_renderNoop</td></tr> <tr><td>98154328</td> <td>(1) <code>bool</code></td> <td>m_rendererInitialized</td></tr> <tr><td>98154329</td> <td>(1) <code>bool</code></td> <td>m_exit</td></tr> <tr><td>98154330</td> <td>(1) <code>bool</code></td> <td>m_flipAfterRender</td></tr> <tr><td>98154331</td> <td>(1) <code>bool</code></td> <td>m_singleThreaded</td></tr> <tr><td>98154332</td> <td>(1) <code>bool</code></td> <td>m_flipped</td></tr> <tr><td>98154368</td> <td>(2052) <code>bgfx::UpdateBatchT&lt;256&gt;</code></td> <td>m_textureUpdateBatch</td></tr></tbody></table> <h3 id="bx-semaphore"><a href="#bx-semaphore" class="header-anchor">#</a> <code>bx::Semaphore</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(128) <code>unsigned __int8[128]</code></td> <td>m_internal</td></tr></tbody></table> <h3 id="bx-mutex"><a href="#bx-mutex" class="header-anchor">#</a> <code>bx::Mutex</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>unsigned __int8[64]</code></td> <td>m_internal</td></tr></tbody></table> <h3 id="bx-thread"><a href="#bx-thread" class="header-anchor">#</a> <code>bx::Thread</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::Thread_vtbl *</code></td> <td>__vftable</td></tr> <tr><td>16</td> <td>(64) <code>unsigned __int8[64]</code></td> <td>m_internal</td></tr> <tr><td>80</td> <td>(8) <code>int (__fastcall *)(bx::Thread *, void *)</code></td> <td>m_fn</td></tr> <tr><td>88</td> <td>(8) <code>void *</code></td> <td>m_userData</td></tr> <tr><td>96</td> <td>(224) <code>bx::MpScUnboundedBlockingQueue&lt;void&gt;</code></td> <td>m_queue</td></tr> <tr><td>320</td> <td>(128) <code>bx::Semaphore</code></td> <td>m_sem</td></tr> <tr><td>448</td> <td>(4) <code>unsigned int</code></td> <td>m_stackSize</td></tr> <tr><td>452</td> <td>(4) <code>int</code></td> <td>m_exitCode</td></tr> <tr><td>456</td> <td>(1) <code>bool</code></td> <td>m_running</td></tr></tbody></table> <h3 id="bx-mpscunboundedblockingqueue-void"><a href="#bx-mpscunboundedblockingqueue-void" class="header-anchor">#</a> <code>bx::MpScUnboundedBlockingQueue&lt;void&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(96) <code>bx::MpScUnboundedQueueT&lt;void&gt;</code></td> <td>m_queue</td></tr> <tr><td>96</td> <td>(128) <code>bx::Semaphore</code></td> <td>m_sem</td></tr></tbody></table> <h3 id="bx-mpscunboundedqueuet-void"><a href="#bx-mpscunboundedqueuet-void" class="header-anchor">#</a> <code>bx::MpScUnboundedQueueT&lt;void&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(64) <code>bx::Mutex</code></td> <td>m_write</td></tr> <tr><td>64</td> <td>(32) <code>bx::SpScUnboundedQueueT&lt;void&gt;</code></td> <td>m_queue</td></tr></tbody></table> <h3 id="bx-spscunboundedqueuet-void"><a href="#bx-spscunboundedqueuet-void" class="header-anchor">#</a> <code>bx::SpScUnboundedQueueT&lt;void&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>bx::SpScUnboundedQueue</code></td> <td>m_queue</td></tr></tbody></table> <h3 id="bx-spscunboundedqueue"><a href="#bx-spscunboundedqueue" class="header-anchor">#</a> <code>bx::SpScUnboundedQueue</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::AllocatorI *</code></td> <td>m_allocator</td></tr> <tr><td>8</td> <td>(8) <code>bx::SpScUnboundedQueue::Node *</code></td> <td>m_first</td></tr> <tr><td>16</td> <td>(8) <code>bx::SpScUnboundedQueue::Node *</code></td> <td>m_divider</td></tr> <tr><td>24</td> <td>(8) <code>bx::SpScUnboundedQueue::Node *</code></td> <td>m_last</td></tr></tbody></table> <h3 id="bgfx-frame"><a href="#bgfx-frame" class="header-anchor">#</a> <code>bgfx::Frame</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(512) <code>unsigned __int16[256]</code></td> <td>m_viewRemap</td></tr> <tr><td>512</td> <td>(256) <code>float[16][4]</code></td> <td>m_colorPalette</td></tr> <tr><td>768</td> <td>(65536) <code>bgfx::View[256]</code></td> <td>m_view</td></tr> <tr><td>66304</td> <td>(1024) <code>int[256]</code></td> <td>m_occlusion</td></tr> <tr><td>67328</td> <td>(524288) <code>unsigned __int64[65536]</code></td> <td>m_sortKeys</td></tr> <tr><td>591616</td> <td>(131072) <code>unsigned __int16[65536]</code></td> <td>m_sortValues</td></tr> <tr><td>722688</td> <td>(8388608) <code>bgfx::RenderItem[65536]</code></td> <td>m_renderItem</td></tr> <tr><td>9111296</td> <td>(33554432) <code>bgfx::RenderBind[65536]</code></td> <td>m_renderItemBind</td></tr> <tr><td>42665728</td> <td>(4100) <code>unsigned int[1025]</code></td> <td>m_blitKeys</td></tr> <tr><td>42669888</td> <td>(65600) <code>bgfx::BlitItem[1025]</code></td> <td>m_blitItem</td></tr> <tr><td>42735488</td> <td>(4718624) <code>bgfx::FrameCache</code></td> <td>m_frameCache</td></tr> <tr><td>47454112</td> <td>(8) <code>bgfx::UniformBuffer **</code></td> <td>m_uniformBuffer</td></tr> <tr><td>47454120</td> <td>(4) <code>unsigned int</code></td> <td>m_numRenderItems</td></tr> <tr><td>47454124</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numBlitItems</td></tr> <tr><td>47454128</td> <td>(4) <code>unsigned int</code></td> <td>m_iboffset</td></tr> <tr><td>47454132</td> <td>(4) <code>unsigned int</code></td> <td>m_vboffset</td></tr> <tr><td>47454136</td> <td>(8) <code>bgfx::TransientIndexBuffer *</code></td> <td>m_transientIb</td></tr> <tr><td>47454144</td> <td>(8) <code>bgfx::TransientVertexBuffer *</code></td> <td>m_transientVb</td></tr> <tr><td>47454152</td> <td>(12) <code>bgfx::Resolution</code></td> <td>m_resolution</td></tr> <tr><td>47454164</td> <td>(4) <code>unsigned int</code></td> <td>m_debug</td></tr> <tr><td>47454168</td> <td>(262152) <code>bgfx::CommandBuffer</code></td> <td>m_cmdPre</td></tr> <tr><td>47716320</td> <td>(262152) <code>bgfx::CommandBuffer</code></td> <td>m_cmdPost</td></tr> <tr><td>47978472</td> <td>(8194) <code>bgfx::Frame::FreeHandle&lt;bgfx::IndexBufferHandle,4096&gt;</code></td> <td>m_freeIndexBuffer</td></tr> <tr><td>47986666</td> <td>(130) <code>bgfx::Frame::FreeHandle&lt;bgfx::VertexDeclHandle,64&gt;</code></td> <td>m_freeVertexDecl</td></tr> <tr><td>47986796</td> <td>(8194) <code>bgfx::Frame::FreeHandle&lt;bgfx::VertexBufferHandle,4096&gt;</code></td> <td>m_freeVertexBuffer</td></tr> <tr><td>47994990</td> <td>(8194) <code>bgfx::Frame::FreeHandle&lt;bgfx::ShaderHandle,4096&gt;</code></td> <td>m_freeShader</td></tr> <tr><td>48003184</td> <td>(4098) <code>bgfx::Frame::FreeHandle&lt;bgfx::ProgramHandle,2048&gt;</code></td> <td>m_freeProgram</td></tr> <tr><td>48007282</td> <td>(8194) <code>bgfx::Frame::FreeHandle&lt;bgfx::TextureHandle,4096&gt;</code></td> <td>m_freeTexture</td></tr> <tr><td>48015476</td> <td>(8194) <code>bgfx::Frame::FreeHandle&lt;bgfx::ShaderBufferHandle,4096&gt;</code></td> <td>m_freeShaderBuffer</td></tr> <tr><td>48023670</td> <td>(258) <code>bgfx::Frame::FreeHandle&lt;bgfx::FrameBufferHandle,128&gt;</code></td> <td>m_freeFrameBuffer</td></tr> <tr><td>48023928</td> <td>(1026) <code>bgfx::Frame::FreeHandle&lt;bgfx::UniformHandle,512&gt;</code></td> <td>m_freeUniform</td></tr> <tr><td>48024954</td> <td>(65538) <code>bgfx::Frame::FreeHandle&lt;bgfx::AccelerationStructureHandle,32768&gt;</code></td> <td>m_freeAccelerationStructure</td></tr> <tr><td>48090496</td> <td>(8) <code>bgfx::TextVideoMem *</code></td> <td>m_textVideoMem</td></tr> <tr><td>48090504</td> <td>(216) <code>bgfx::Stats</code></td> <td>m_perfStats</td></tr> <tr><td>48090720</td> <td>(71680) <code>bgfx::ViewStats[256]</code></td> <td>m_viewStats</td></tr> <tr><td>48162400</td> <td>(8) <code>__int64</code></td> <td>m_waitSubmit</td></tr> <tr><td>48162408</td> <td>(8) <code>__int64</code></td> <td>m_waitRender</td></tr> <tr><td>48162416</td> <td>(536) <code>bgfx::RayTracingConfiguration</code></td> <td>m_rtConfig</td></tr> <tr><td>48162952</td> <td>(1) <code>bool</code></td> <td>m_capture</td></tr> <tr><td>48162953</td> <td>(1) <code>bool</code></td> <td>m_skipFlip</td></tr></tbody></table> <h3 id="bgfx-view"><a href="#bgfx-view" class="header-anchor">#</a> <code>bgfx::View</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bgfx::Clear</code></td> <td>m_clear</td></tr> <tr><td>16</td> <td>(8) <code>bgfx::Rect</code></td> <td>m_rect</td></tr> <tr><td>24</td> <td>(8) <code>bgfx::Rect</code></td> <td>m_scissor</td></tr> <tr><td>32</td> <td>(64) <code>bgfx::Matrix4</code></td> <td>m_view</td></tr> <tr><td>96</td> <td>(128) <code>bgfx::Matrix4[2]</code></td> <td>m_proj</td></tr> <tr><td>224</td> <td>(2) <code>bgfx::FrameBufferHandle</code></td> <td>m_fbh</td></tr> <tr><td>226</td> <td>(1) <code>unsigned __int8</code></td> <td>m_mode</td></tr> <tr><td>227</td> <td>(1) <code>unsigned __int8</code></td> <td>m_flags</td></tr></tbody></table> <h3 id="bgfx-clear"><a href="#bgfx-clear" class="header-anchor">#</a> <code>bgfx::Clear</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int8[8]</code></td> <td>m_index</td></tr> <tr><td>8</td> <td>(4) <code>float</code></td> <td>m_depth</td></tr> <tr><td>12</td> <td>(1) <code>unsigned __int8</code></td> <td>m_stencil</td></tr> <tr><td>14</td> <td>(2) <code>unsigned __int16</code></td> <td>m_flags</td></tr></tbody></table> <h3 id="bgfx-renderitem"><a href="#bgfx-renderitem" class="header-anchor">#</a> <code>bgfx::RenderItem</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(128) <code>bgfx::RenderDraw</code></td> <td>draw</td></tr> <tr><td>1</td> <td>(64) <code>bgfx::RenderCompute</code></td> <td>compute</td></tr></tbody></table> <h3 id="bgfx-renderdraw"><a href="#bgfx-renderdraw" class="header-anchor">#</a> <code>bgfx::RenderDraw</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>bgfx::Stream[4]</code></td> <td>m_stream</td></tr> <tr><td>32</td> <td>(8) <code>unsigned __int64</code></td> <td>m_stateFlags</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>m_stencil</td></tr> <tr><td>48</td> <td>(4) <code>unsigned int</code></td> <td>m_rgba</td></tr> <tr><td>52</td> <td>(4) <code>unsigned int</code></td> <td>m_uniformBegin</td></tr> <tr><td>56</td> <td>(4) <code>unsigned int</code></td> <td>m_uniformEnd</td></tr> <tr><td>60</td> <td>(4) <code>unsigned int</code></td> <td>m_startMatrix</td></tr> <tr><td>64</td> <td>(4) <code>unsigned int</code></td> <td>m_startIndex</td></tr> <tr><td>68</td> <td>(4) <code>unsigned int</code></td> <td>m_numIndices</td></tr> <tr><td>72</td> <td>(4) <code>unsigned int</code></td> <td>m_numVertices</td></tr> <tr><td>76</td> <td>(4) <code>unsigned int</code></td> <td>m_instanceDataOffset</td></tr> <tr><td>80</td> <td>(4) <code>unsigned int</code></td> <td>m_numInstances</td></tr> <tr><td>84</td> <td>(2) <code>unsigned __int16</code></td> <td>m_instanceDataStride</td></tr> <tr><td>86</td> <td>(2) <code>unsigned __int16</code></td> <td>m_startIndirect</td></tr> <tr><td>88</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numIndirect</td></tr> <tr><td>90</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numMatrices</td></tr> <tr><td>92</td> <td>(2) <code>unsigned __int16</code></td> <td>m_scissor</td></tr> <tr><td>94</td> <td>(1) <code>unsigned __int8</code></td> <td>m_submitFlags</td></tr> <tr><td>95</td> <td>(1) <code>unsigned __int8</code></td> <td>m_streamMask</td></tr> <tr><td>96</td> <td>(1) <code>unsigned __int8</code></td> <td>m_uniformIdx</td></tr> <tr><td>100</td> <td>(4) <code>int</code></td> <td>m_biasConst</td></tr> <tr><td>104</td> <td>(4) <code>float</code></td> <td>m_biasSlope</td></tr> <tr><td>108</td> <td>(4) <code>float</code></td> <td>m_biasClamp</td></tr> <tr><td>112</td> <td>(2) <code>bgfx::IndexBufferHandle</code></td> <td>m_indexBuffer</td></tr> <tr><td>114</td> <td>(2) <code>bgfx::VertexBufferHandle</code></td> <td>m_instanceDataBuffer</td></tr> <tr><td>116</td> <td>(2) <code>bgfx::IndirectBufferHandle</code></td> <td>m_indirectBuffer</td></tr> <tr><td>118</td> <td>(2) <code>bgfx::OcclusionQueryHandle</code></td> <td>m_occlusionQuery</td></tr></tbody></table> <h3 id="bgfx-stream"><a href="#bgfx-stream" class="header-anchor">#</a> <code>bgfx::Stream</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_startVertex</td></tr> <tr><td>4</td> <td>(2) <code>bgfx::VertexBufferHandle</code></td> <td>m_handle</td></tr> <tr><td>6</td> <td>(2) <code>bgfx::VertexDeclHandle</code></td> <td>m_decl</td></tr></tbody></table> <h3 id="bgfx-occlusionqueryhandle"><a href="#bgfx-occlusionqueryhandle" class="header-anchor">#</a> <code>bgfx::OcclusionQueryHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-rendercompute"><a href="#bgfx-rendercompute" class="header-anchor">#</a> <code>bgfx::RenderCompute</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_uniformBegin</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_uniformEnd</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_startMatrix</td></tr> <tr><td>12</td> <td>(2) <code>bgfx::IndirectBufferHandle</code></td> <td>m_indirectBuffer</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_numX</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>m_numY</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_numZ</td></tr> <tr><td>28</td> <td>(2) <code>unsigned __int16</code></td> <td>m_startIndirect</td></tr> <tr><td>30</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numIndirect</td></tr> <tr><td>32</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numMatrices</td></tr> <tr><td>34</td> <td>(1) <code>unsigned __int8</code></td> <td>m_submitFlags</td></tr> <tr><td>35</td> <td>(1) <code>unsigned __int8</code></td> <td>m_uniformIdx</td></tr> <tr><td>36</td> <td>(1) <code>bool</code></td> <td>m_isRayTracing</td></tr></tbody></table> <h3 id="bgfx-renderbind"><a href="#bgfx-renderbind" class="header-anchor">#</a> <code>bgfx::RenderBind</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(512) <code>bgfx::Binding[64]</code></td> <td>m_bind</td></tr></tbody></table> <h3 id="bgfx-binding"><a href="#bgfx-binding" class="header-anchor">#</a> <code>bgfx::Binding</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>m_idx</td></tr> <tr><td>2</td> <td>(1) <code>unsigned __int8</code></td> <td>m_type</td></tr> <tr><td>4</td> <td>(4) <code>bgfx::Binding::&lt;unnamed_type_m_un&gt;</code></td> <td>m_un</td></tr></tbody></table> <h3 id="bgfx-binding-unnamed-type-m-un"><a href="#bgfx-binding-unnamed-type-m-un" class="header-anchor">#</a> <code>bgfx::Binding::&lt;unnamed_type_m_un&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::Binding::&lt;unnamed_type_m_un&gt;::&lt;unnamed_type_m_draw&gt;</code></td> <td>m_draw</td></tr> <tr><td>1</td> <td>(3) <code>bgfx::Binding::&lt;unnamed_type_m_un&gt;::&lt;unnamed_type_m_compute&gt;</code></td> <td>m_compute</td></tr></tbody></table> <h3 id="bgfx-binding-unnamed-type-m-un-unnamed-type-m-draw"><a href="#bgfx-binding-unnamed-type-m-un-unnamed-type-m-draw" class="header-anchor">#</a> <code>bgfx::Binding::&lt;unnamed_type_m_un&gt;::&lt;unnamed_type_m_draw&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_textureFlags</td></tr></tbody></table> <h3 id="bgfx-binding-unnamed-type-m-un-unnamed-type-m-compute"><a href="#bgfx-binding-unnamed-type-m-un-unnamed-type-m-compute" class="header-anchor">#</a> <code>bgfx::Binding::&lt;unnamed_type_m_un&gt;::&lt;unnamed_type_m_compute&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1) <code>unsigned __int8</code></td> <td>m_format</td></tr> <tr><td>1</td> <td>(1) <code>unsigned __int8</code></td> <td>m_access</td></tr> <tr><td>2</td> <td>(1) <code>unsigned __int8</code></td> <td>m_mip</td></tr></tbody></table> <h3 id="bgfx-blititem"><a href="#bgfx-blititem" class="header-anchor">#</a> <code>bgfx::BlitItem</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>m_srcX</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>m_srcY</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>m_srcZ</td></tr> <tr><td>6</td> <td>(2) <code>unsigned __int16</code></td> <td>m_dstX</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>m_dstY</td></tr> <tr><td>10</td> <td>(2) <code>unsigned __int16</code></td> <td>m_dstZ</td></tr> <tr><td>12</td> <td>(2) <code>unsigned __int16</code></td> <td>m_width</td></tr> <tr><td>14</td> <td>(2) <code>unsigned __int16</code></td> <td>m_height</td></tr> <tr><td>16</td> <td>(2) <code>unsigned __int16</code></td> <td>m_depth</td></tr> <tr><td>18</td> <td>(1) <code>unsigned __int8</code></td> <td>m_srcMip</td></tr> <tr><td>19</td> <td>(1) <code>unsigned __int8</code></td> <td>m_dstMip</td></tr> <tr><td>20</td> <td>(2) <code>bgfx::TextureHandle</code></td> <td>m_src</td></tr> <tr><td>22</td> <td>(2) <code>bgfx::TextureHandle</code></td> <td>m_dst</td></tr></tbody></table> <h3 id="bgfx-framecache"><a href="#bgfx-framecache" class="header-anchor">#</a> <code>bgfx::FrameCache</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4194320) <code>bgfx::MatrixCache</code></td> <td>m_matrixCache</td></tr> <tr><td>4194320</td> <td>(524292) <code>bgfx::RectCache</code></td> <td>m_rectCache</td></tr></tbody></table> <h3 id="bgfx-matrixcache"><a href="#bgfx-matrixcache" class="header-anchor">#</a> <code>bgfx::MatrixCache</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4194304) <code>bgfx::Matrix4[65536]</code></td> <td>m_cache</td></tr> <tr><td>4194304</td> <td>(4) <code>unsigned int</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-rectcache"><a href="#bgfx-rectcache" class="header-anchor">#</a> <code>bgfx::RectCache</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(524288) <code>bgfx::Rect[65536]</code></td> <td>m_cache</td></tr> <tr><td>524288</td> <td>(4) <code>unsigned int</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-commandbuffer"><a href="#bgfx-commandbuffer" class="header-anchor">#</a> <code>bgfx::CommandBuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_pos</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>8</td> <td>(262144) <code>unsigned __int8[262144]</code></td> <td>m_buffer</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-indexbufferhandle-4096"><a href="#bgfx-frame-freehandle-bgfx-indexbufferhandle-4096" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::IndexBufferHandle,4096&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8192) <code>bgfx::IndexBufferHandle[4096]</code></td> <td>m_queue</td></tr> <tr><td>8192</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-vertexdeclhandle-64"><a href="#bgfx-frame-freehandle-bgfx-vertexdeclhandle-64" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::VertexDeclHandle,64&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(128) <code>bgfx::VertexDeclHandle[64]</code></td> <td>m_queue</td></tr> <tr><td>128</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-vertexbufferhandle-4096"><a href="#bgfx-frame-freehandle-bgfx-vertexbufferhandle-4096" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::VertexBufferHandle,4096&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8192) <code>bgfx::VertexBufferHandle[4096]</code></td> <td>m_queue</td></tr> <tr><td>8192</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-shaderhandle-4096"><a href="#bgfx-frame-freehandle-bgfx-shaderhandle-4096" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::ShaderHandle,4096&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8192) <code>bgfx::ShaderHandle[4096]</code></td> <td>m_queue</td></tr> <tr><td>8192</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-programhandle-2048"><a href="#bgfx-frame-freehandle-bgfx-programhandle-2048" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::ProgramHandle,2048&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4096) <code>bgfx::ProgramHandle[2048]</code></td> <td>m_queue</td></tr> <tr><td>4096</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-programhandle"><a href="#bgfx-programhandle" class="header-anchor">#</a> <code>bgfx::ProgramHandle</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>idx</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-texturehandle-4096"><a href="#bgfx-frame-freehandle-bgfx-texturehandle-4096" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::TextureHandle,4096&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8192) <code>bgfx::TextureHandle[4096]</code></td> <td>m_queue</td></tr> <tr><td>8192</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-shaderbufferhandle-4096"><a href="#bgfx-frame-freehandle-bgfx-shaderbufferhandle-4096" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::ShaderBufferHandle,4096&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8192) <code>bgfx::ShaderBufferHandle[4096]</code></td> <td>m_queue</td></tr> <tr><td>8192</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-framebufferhandle-128"><a href="#bgfx-frame-freehandle-bgfx-framebufferhandle-128" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::FrameBufferHandle,128&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(256) <code>bgfx::FrameBufferHandle[128]</code></td> <td>m_queue</td></tr> <tr><td>256</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-uniformhandle-512"><a href="#bgfx-frame-freehandle-bgfx-uniformhandle-512" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::UniformHandle,512&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(1024) <code>bgfx::UniformHandle[512]</code></td> <td>m_queue</td></tr> <tr><td>1024</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-frame-freehandle-bgfx-accelerationstructurehandle-32768"><a href="#bgfx-frame-freehandle-bgfx-accelerationstructurehandle-32768" class="header-anchor">#</a> <code>bgfx::Frame::FreeHandle&lt;bgfx::AccelerationStructureHandle,32768&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(65536) <code>bgfx::AccelerationStructureHandle[32768]</code></td> <td>m_queue</td></tr> <tr><td>65536</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bgfx-stats"><a href="#bgfx-stats" class="header-anchor">#</a> <code>bgfx::Stats</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>__int64</code></td> <td>cpuTimeFrame</td></tr> <tr><td>8</td> <td>(8) <code>__int64</code></td> <td>cpuTimeBegin</td></tr> <tr><td>16</td> <td>(8) <code>__int64</code></td> <td>cpuTimeEnd</td></tr> <tr><td>24</td> <td>(8) <code>__int64</code></td> <td>cpuTimerFreq</td></tr> <tr><td>32</td> <td>(8) <code>__int64</code></td> <td>gpuTimeBegin</td></tr> <tr><td>40</td> <td>(8) <code>__int64</code></td> <td>gpuTimeEnd</td></tr> <tr><td>48</td> <td>(8) <code>__int64</code></td> <td>gpuTimerFreq</td></tr> <tr><td>56</td> <td>(8) <code>__int64</code></td> <td>waitRender</td></tr> <tr><td>64</td> <td>(8) <code>__int64</code></td> <td>waitSubmit</td></tr> <tr><td>72</td> <td>(4) <code>unsigned int</code></td> <td>numDraw</td></tr> <tr><td>76</td> <td>(4) <code>unsigned int</code></td> <td>numCompute</td></tr> <tr><td>80</td> <td>(4) <code>unsigned int</code></td> <td>maxGpuLatency</td></tr> <tr><td>84</td> <td>(2) <code>unsigned __int16</code></td> <td>numDynamicIndexBuffers</td></tr> <tr><td>86</td> <td>(2) <code>unsigned __int16</code></td> <td>numDynamicVertexBuffers</td></tr> <tr><td>88</td> <td>(2) <code>unsigned __int16</code></td> <td>numFrameBuffers</td></tr> <tr><td>90</td> <td>(2) <code>unsigned __int16</code></td> <td>numIndexBuffers</td></tr> <tr><td>92</td> <td>(2) <code>unsigned __int16</code></td> <td>numOcclusionQueries</td></tr> <tr><td>94</td> <td>(2) <code>unsigned __int16</code></td> <td>numPrograms</td></tr> <tr><td>96</td> <td>(2) <code>unsigned __int16</code></td> <td>numShaders</td></tr> <tr><td>98</td> <td>(2) <code>unsigned __int16</code></td> <td>numTextures</td></tr> <tr><td>100</td> <td>(2) <code>unsigned __int16</code></td> <td>numUniforms</td></tr> <tr><td>102</td> <td>(2) <code>unsigned __int16</code></td> <td>numVertexBuffers</td></tr> <tr><td>104</td> <td>(2) <code>unsigned __int16</code></td> <td>numVertexDecls</td></tr> <tr><td>112</td> <td>(8) <code>__int64</code></td> <td>textureMemoryUsed</td></tr> <tr><td>120</td> <td>(8) <code>__int64</code></td> <td>rtMemoryUsed</td></tr> <tr><td>128</td> <td>(4) <code>int</code></td> <td>transientVbUsed</td></tr> <tr><td>132</td> <td>(4) <code>int</code></td> <td>transientIbUsed</td></tr> <tr><td>136</td> <td>(20) <code>unsigned int[5]</code></td> <td>numPrims</td></tr> <tr><td>160</td> <td>(8) <code>unsigned __int64</code></td> <td>gpuMemoryMax</td></tr> <tr><td>168</td> <td>(8) <code>unsigned __int64</code></td> <td>gpuMemoryUsed</td></tr> <tr><td>176</td> <td>(2) <code>unsigned __int16</code></td> <td>width</td></tr> <tr><td>178</td> <td>(2) <code>unsigned __int16</code></td> <td>height</td></tr> <tr><td>180</td> <td>(2) <code>unsigned __int16</code></td> <td>textWidth</td></tr> <tr><td>182</td> <td>(2) <code>unsigned __int16</code></td> <td>textHeight</td></tr> <tr><td>184</td> <td>(2) <code>unsigned __int16</code></td> <td>numViews</td></tr> <tr><td>192</td> <td>(8) <code>bgfx::ViewStats *</code></td> <td>viewStats</td></tr> <tr><td>200</td> <td>(1) <code>unsigned __int8</code></td> <td>numEncoders</td></tr> <tr><td>208</td> <td>(8) <code>bgfx::EncoderStats *</code></td> <td>encoderStats</td></tr></tbody></table> <h3 id="bgfx-viewstats"><a href="#bgfx-viewstats" class="header-anchor">#</a> <code>bgfx::ViewStats</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(256) <code>char[256]</code></td> <td>name</td></tr> <tr><td>256</td> <td>(2) <code>unsigned __int16</code></td> <td>view</td></tr> <tr><td>264</td> <td>(8) <code>__int64</code></td> <td>cpuTimeElapsed</td></tr> <tr><td>272</td> <td>(8) <code>__int64</code></td> <td>gpuTimeElapsed</td></tr></tbody></table> <h3 id="bgfx-indexbuffer"><a href="#bgfx-indexbuffer" class="header-anchor">#</a> <code>bgfx::IndexBuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr></tbody></table> <h3 id="bgfx-vertexbuffer"><a href="#bgfx-vertexbuffer" class="header-anchor">#</a> <code>bgfx::VertexBuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>4</td> <td>(2) <code>unsigned __int16</code></td> <td>m_stride</td></tr></tbody></table> <h3 id="bgfx-dynamicindexbuffer"><a href="#bgfx-dynamicindexbuffer" class="header-anchor">#</a> <code>bgfx::DynamicIndexBuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>bgfx::IndexBufferHandle</code></td> <td>m_handle</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_offset</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_startIndex</td></tr> <tr><td>16</td> <td>(2) <code>unsigned __int16</code></td> <td>m_flags</td></tr></tbody></table> <h3 id="bgfx-dynamicvertexbuffer"><a href="#bgfx-dynamicvertexbuffer" class="header-anchor">#</a> <code>bgfx::DynamicVertexBuffer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>bgfx::VertexBufferHandle</code></td> <td>m_handle</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_offset</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_startVertex</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_numVertices</td></tr> <tr><td>20</td> <td>(2) <code>unsigned __int16</code></td> <td>m_stride</td></tr> <tr><td>22</td> <td>(2) <code>bgfx::VertexDeclHandle</code></td> <td>m_decl</td></tr> <tr><td>24</td> <td>(2) <code>unsigned __int16</code></td> <td>m_flags</td></tr></tbody></table> <h3 id="bgfx-nonlocalallocator"><a href="#bgfx-nonlocalallocator" class="header-anchor">#</a> <code>bgfx::NonLocalAllocator</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>tinystl::list&lt;bgfx::NonLocalAllocator::Free,bgfx::TinyStlAllocator&gt;</code></td> <td>m_free</td></tr> <tr><td>24</td> <td>(32) <code>tinystl::unordered_map&lt;unsigned __int64,unsigned int,bgfx::TinyStlAllocator&gt;</code></td> <td>m_used</td></tr></tbody></table> <h3 id="bx-handlealloct-4096"><a href="#bx-handlealloct-4096" class="header-anchor">#</a> <code>bx::HandleAllocT&lt;4096&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bx::HandleAlloc</code></td> <td>baseclass_0</td></tr> <tr><td>4</td> <td>(16384) <code>unsigned __int16[8192]</code></td> <td>m_padding</td></tr></tbody></table> <h3 id="bx-handlealloc"><a href="#bx-handlealloc" class="header-anchor">#</a> <code>bx::HandleAlloc</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numHandles</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>m_maxHandles</td></tr></tbody></table> <h3 id="bx-handlealloct-64"><a href="#bx-handlealloct-64" class="header-anchor">#</a> <code>bx::HandleAllocT&lt;64&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bx::HandleAlloc</code></td> <td>baseclass_0</td></tr> <tr><td>4</td> <td>(256) <code>unsigned __int16[128]</code></td> <td>m_padding</td></tr></tbody></table> <h3 id="bx-handlealloct-2048"><a href="#bx-handlealloct-2048" class="header-anchor">#</a> <code>bx::HandleAllocT&lt;2048&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bx::HandleAlloc</code></td> <td>baseclass_0</td></tr> <tr><td>4</td> <td>(8192) <code>unsigned __int16[4096]</code></td> <td>m_padding</td></tr></tbody></table> <h3 id="bx-handlealloct-128"><a href="#bx-handlealloct-128" class="header-anchor">#</a> <code>bx::HandleAllocT&lt;128&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bx::HandleAlloc</code></td> <td>baseclass_0</td></tr> <tr><td>4</td> <td>(512) <code>unsigned __int16[256]</code></td> <td>m_padding</td></tr></tbody></table> <h3 id="bx-handlealloct-512"><a href="#bx-handlealloct-512" class="header-anchor">#</a> <code>bx::HandleAllocT&lt;512&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bx::HandleAlloc</code></td> <td>baseclass_0</td></tr> <tr><td>4</td> <td>(2048) <code>unsigned __int16[1024]</code></td> <td>m_padding</td></tr></tbody></table> <h3 id="bx-handlealloct-256"><a href="#bx-handlealloct-256" class="header-anchor">#</a> <code>bx::HandleAllocT&lt;256&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bx::HandleAlloc</code></td> <td>baseclass_0</td></tr> <tr><td>4</td> <td>(1024) <code>unsigned __int16[512]</code></td> <td>m_padding</td></tr></tbody></table> <h3 id="bx-handlealloct-32768"><a href="#bx-handlealloct-32768" class="header-anchor">#</a> <code>bx::HandleAllocT&lt;32768&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bx::HandleAlloc</code></td> <td>baseclass_0</td></tr> <tr><td>4</td> <td>(131072) <code>unsigned __int16[65536]</code></td> <td>m_padding</td></tr></tbody></table> <h3 id="bgfx-context-uniformref"><a href="#bgfx-context-uniformref" class="header-anchor">#</a> <code>bgfx::Context::UniformRef</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bx::StringT&lt;&amp;bgfx::g_allocator&gt;</code></td> <td>m_name</td></tr> <tr><td>16</td> <td>(4) <code>_BYTE[4]</code></td> <td>m_type</td></tr> <tr><td>20</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr> <tr><td>22</td> <td>(2) <code>__int16</code></td> <td>m_refCount</td></tr></tbody></table> <h3 id="bx-stringt-bgfx-g-allocator"><a href="#bx-stringt-bgfx-g-allocator" class="header-anchor">#</a> <code>bx::StringT&lt;&amp;bgfx::g_allocator&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bx::StringView</code></td> <td>baseclass_0</td></tr></tbody></table> <h3 id="bx-handlehashmapt-8192-unsigned-int"><a href="#bx-handlehashmapt-8192-unsigned-int" class="header-anchor">#</a> <code>bx::HandleHashMapT&lt;8192,unsigned int&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_maxCapacity</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_numElements</td></tr> <tr><td>8</td> <td>(32768) <code>unsigned int[8192]</code></td> <td>m_key</td></tr> <tr><td>32776</td> <td>(16384) <code>unsigned __int16[8192]</code></td> <td>m_handle</td></tr></tbody></table> <h3 id="bgfx-context-shaderref"><a href="#bgfx-context-shaderref" class="header-anchor">#</a> <code>bgfx::Context::ShaderRef</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::UniformHandle *</code></td> <td>m_uniforms</td></tr> <tr><td>8</td> <td>(16) <code>bx::StringT&lt;&amp;bgfx::g_allocator&gt;</code></td> <td>m_name</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_hash</td></tr> <tr><td>28</td> <td>(2) <code>__int16</code></td> <td>m_refCount</td></tr> <tr><td>30</td> <td>(2) <code>unsigned __int16</code></td> <td>m_num</td></tr></tbody></table> <h3 id="bx-handlehashmapt-4096-unsigned-int"><a href="#bx-handlehashmapt-4096-unsigned-int" class="header-anchor">#</a> <code>bx::HandleHashMapT&lt;4096,unsigned int&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_maxCapacity</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_numElements</td></tr> <tr><td>8</td> <td>(16384) <code>unsigned int[4096]</code></td> <td>m_key</td></tr> <tr><td>16392</td> <td>(8192) <code>unsigned __int16[4096]</code></td> <td>m_handle</td></tr></tbody></table> <h3 id="bgfx-context-programref"><a href="#bgfx-context-programref" class="header-anchor">#</a> <code>bgfx::Context::ProgramRef</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>bgfx::ShaderHandle</code></td> <td>m_vsh</td></tr> <tr><td>2</td> <td>(2) <code>bgfx::ShaderHandle</code></td> <td>m_fsh</td></tr> <tr><td>4</td> <td>(2) <code>__int16</code></td> <td>m_refCount</td></tr></tbody></table> <h3 id="bgfx-context-textureref"><a href="#bgfx-context-textureref" class="header-anchor">#</a> <code>bgfx::Context::TextureRef</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bx::StringT&lt;&amp;bgfx::g_allocator&gt;</code></td> <td>m_name</td></tr> <tr><td>16</td> <td>(8) <code>void *</code></td> <td>m_ptr</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_storageSize</td></tr> <tr><td>28</td> <td>(2) <code>__int16</code></td> <td>m_refCount</td></tr> <tr><td>30</td> <td>(1) <code>unsigned __int8</code></td> <td>m_bbRatio</td></tr> <tr><td>31</td> <td>(1) <code>unsigned __int8</code></td> <td>m_format</td></tr> <tr><td>32</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numMips</td></tr> <tr><td>34</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numLayers</td></tr> <tr><td>36</td> <td>(1) <code>bool</code></td> <td>m_owned</td></tr> <tr><td>37</td> <td>(1) <code>bool</code></td> <td>m_immutable</td></tr> <tr><td>38</td> <td>(1) <code>bool</code></td> <td>m_rt</td></tr></tbody></table> <h3 id="bgfx-context-shaderbufferref"><a href="#bgfx-context-shaderbufferref" class="header-anchor">#</a> <code>bgfx::Context::ShaderBufferRef</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bx::StringT&lt;&amp;bgfx::g_allocator&gt;</code></td> <td>m_name</td></tr> <tr><td>16</td> <td>(8) <code>void *</code></td> <td>m_ptr</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_stride</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>m_count</td></tr> <tr><td>32</td> <td>(2) <code>__int16</code></td> <td>m_refCount</td></tr></tbody></table> <h3 id="bgfx-context-framebufferref"><a href="#bgfx-context-framebufferref" class="header-anchor">#</a> <code>bgfx::Context::FrameBufferRef</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bgfx::Context::FrameBufferRef::un</code></td> <td>un</td></tr> <tr><td>16</td> <td>(1) <code>bool</code></td> <td>m_window</td></tr></tbody></table> <h3 id="bgfx-context-framebufferref-un"><a href="#bgfx-context-framebufferref-un" class="header-anchor">#</a> <code>bgfx::Context::FrameBufferRef::un</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bgfx::TextureHandle[8]</code></td> <td>m_th</td></tr> <tr><td>1</td> <td>(8) <code>void *</code></td> <td>m_nwh</td></tr></tbody></table> <h3 id="bgfx-vertexdeclref"><a href="#bgfx-vertexdeclref" class="header-anchor">#</a> <code>bgfx::VertexDeclRef</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(776) <code>bx::HandleHashMapT&lt;128,unsigned int&gt;</code></td> <td>m_vertexDeclMap</td></tr> <tr><td>776</td> <td>(128) <code>unsigned __int16[64]</code></td> <td>m_vertexDeclRef</td></tr> <tr><td>904</td> <td>(8192) <code>bgfx::VertexDeclHandle[4096]</code></td> <td>m_vertexBufferRef</td></tr> <tr><td>9096</td> <td>(8192) <code>bgfx::VertexDeclHandle[4096]</code></td> <td>m_dynamicVertexBufferRef</td></tr></tbody></table> <h3 id="bx-handlehashmapt-128-unsigned-int"><a href="#bx-handlehashmapt-128-unsigned-int" class="header-anchor">#</a> <code>bx::HandleHashMapT&lt;128,unsigned int&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_maxCapacity</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_numElements</td></tr> <tr><td>8</td> <td>(512) <code>unsigned int[128]</code></td> <td>m_key</td></tr> <tr><td>520</td> <td>(256) <code>unsigned __int16[128]</code></td> <td>m_handle</td></tr></tbody></table> <h3 id="bgfx-textvideomemblitter"><a href="#bgfx-textvideomemblitter" class="header-anchor">#</a> <code>bgfx::TextVideoMemBlitter</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>bgfx::TextureHandle</code></td> <td>m_texture</td></tr> <tr><td>8</td> <td>(8) <code>bgfx::TransientVertexBuffer *</code></td> <td>m_vb</td></tr> <tr><td>16</td> <td>(8) <code>bgfx::TransientIndexBuffer *</code></td> <td>m_ib</td></tr> <tr><td>24</td> <td>(80) <code>bgfx::VertexDecl</code></td> <td>m_decl</td></tr> <tr><td>104</td> <td>(2) <code>bgfx::ProgramHandle</code></td> <td>m_program</td></tr></tbody></table> <h3 id="bgfx-clearquad"><a href="#bgfx-clearquad" class="header-anchor">#</a> <code>bgfx::ClearQuad</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::TransientVertexBuffer *</code></td> <td>m_vb</td></tr> <tr><td>8</td> <td>(80) <code>bgfx::VertexDecl</code></td> <td>m_decl</td></tr> <tr><td>88</td> <td>(16) <code>bgfx::ProgramHandle[8]</code></td> <td>m_program</td></tr></tbody></table> <h3 id="bgfx-updatebatcht-256"><a href="#bgfx-updatebatcht-256" class="header-anchor">#</a> <code>bgfx::UpdateBatchT&lt;256&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_num</td></tr> <tr><td>4</td> <td>(1024) <code>unsigned int[256]</code></td> <td>m_keys</td></tr> <tr><td>1028</td> <td>(1024) <code>unsigned int[256]</code></td> <td>m_values</td></tr></tbody></table> <h3 id="bx-memorywriter"><a href="#bx-memorywriter" class="header-anchor">#</a> <code>bx::MemoryWriter</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>bx::WriterSeekerI</code></td> <td>baseclass_0</td></tr> <tr><td>16</td> <td>(8) <code>bx::MemoryBlockI *</code></td> <td>m_memBlock</td></tr> <tr><td>24</td> <td>(8) <code>unsigned __int8 *</code></td> <td>m_data</td></tr> <tr><td>32</td> <td>(8) <code>__int64</code></td> <td>m_pos</td></tr> <tr><td>40</td> <td>(8) <code>__int64</code></td> <td>m_top</td></tr> <tr><td>48</td> <td>(8) <code>__int64</code></td> <td>m_size</td></tr></tbody></table> <h3 id="bx-writerseekeri"><a href="#bx-writerseekeri" class="header-anchor">#</a> <code>bx::WriterSeekerI</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bx::WriterI</code></td> <td>baseclass_0</td></tr> <tr><td>8</td> <td>(8) <code>bx::SeekerI</code></td> <td>baseclass_8</td></tr></tbody></table> <h3 id="bx-hashmurmur2a"><a href="#bx-hashmurmur2a" class="header-anchor">#</a> <code>bx::HashMurmur2A</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_hash</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_tail</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_count</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr></tbody></table> <h3 id="bgfx-nvmemoryinfov2"><a href="#bgfx-nvmemoryinfov2" class="header-anchor">#</a> <code>bgfx::NvMemoryInfoV2</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>version</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>dedicatedVideoMemory</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>availableDedicatedVideoMemory</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>systemVideoMemory</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>sharedSystemMemory</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>curAvailableDedicatedVideoMemory</td></tr></tbody></table> <h3 id="bgfx-d3d11-agsdriverversioninfo"><a href="#bgfx-d3d11-agsdriverversioninfo" class="header-anchor">#</a> <code>bgfx::d3d11::AGSDriverVersionInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(256) <code>char[256]</code></td> <td>strDriverVersion</td></tr> <tr><td>256</td> <td>(256) <code>char[256]</code></td> <td>strCatalystVersion</td></tr> <tr><td>512</td> <td>(256) <code>char[256]</code></td> <td>strCatalystWebLink</td></tr></tbody></table> <h3 id="bgfx-dxbcshader"><a href="#bgfx-dxbcshader" class="header-anchor">#</a> <code>bgfx::DxbcShader</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>version</td></tr> <tr><td>8</td> <td>(24) <code>tinystl::vector&lt;unsigned char,bgfx::TinyStlAllocator&gt;</code></td> <td>byteCode</td></tr> <tr><td>32</td> <td>(1) <code>bool</code></td> <td>shex</td></tr> <tr><td>33</td> <td>(1) <code>bool</code></td> <td>aon9</td></tr></tbody></table> <h3 id="bimg-imagemip"><a href="#bimg-imagemip" class="header-anchor">#</a> <code>bimg::ImageMip</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>_BYTE[4]</code></td> <td>m_format</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_width</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_height</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_depth</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_blockSize</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>24</td> <td>(1) <code>unsigned __int8</code></td> <td>m_bpp</td></tr> <tr><td>25</td> <td>(1) <code>bool</code></td> <td>m_hasAlpha</td></tr> <tr><td>32</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>m_data</td></tr></tbody></table> <h3 id="bgfx-swapchaindesc"><a href="#bgfx-swapchaindesc" class="header-anchor">#</a> <code>bgfx::SwapChainDesc</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>width</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>height</td></tr> <tr><td>8</td> <td>(4) <code>DXGI_FORMAT</code></td> <td>format</td></tr> <tr><td>12</td> <td>(1) <code>bool</code></td> <td>stereo</td></tr> <tr><td>16</td> <td>(8) <code>DXGI_SAMPLE_DESC</code></td> <td>sampleDesc</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>bufferUsage</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>bufferCount</td></tr> <tr><td>32</td> <td>(4) <code>DXGI_SCALING</code></td> <td>scaling</td></tr> <tr><td>36</td> <td>(4) <code>DXGI_SWAP_EFFECT</code></td> <td>swapEffect</td></tr> <tr><td>40</td> <td>(4) <code>DXGI_ALPHA_MODE</code></td> <td>alphaMode</td></tr> <tr><td>44</td> <td>(4) <code>unsigned int</code></td> <td>flags</td></tr> <tr><td>48</td> <td>(8) <code>void *</code></td> <td>nwh</td></tr> <tr><td>56</td> <td>(8) <code>void *</code></td> <td>ndt</td></tr> <tr><td>64</td> <td>(1) <code>bool</code></td> <td>windowed</td></tr></tbody></table> <h3 id="bgfx-blitstate"><a href="#bgfx-blitstate" class="header-anchor">#</a> <code>bgfx::BlitState</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const bgfx::Frame *</code></td> <td>m_frame</td></tr> <tr><td>8</td> <td>(4) <code>bgfx::BlitKey</code></td> <td>m_key</td></tr> <tr><td>12</td> <td>(2) <code>unsigned __int16</code></td> <td>m_item</td></tr></tbody></table> <h3 id="bgfx-blitkey"><a href="#bgfx-blitkey" class="header-anchor">#</a> <code>bgfx::BlitKey</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(2) <code>unsigned __int16</code></td> <td>m_item</td></tr> <tr><td>2</td> <td>(2) <code>unsigned __int16</code></td> <td>m_view</td></tr></tbody></table> <h3 id="bgfx-profiler-bgfx-d3d11-timerqueryd3d11"><a href="#bgfx-profiler-bgfx-d3d11-timerqueryd3d11" class="header-anchor">#</a> <code>bgfx::Profiler&lt;bgfx::d3d11::TimerQueryD3D11&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char (*)[256]</code></td> <td>m_viewName</td></tr> <tr><td>8</td> <td>(8) <code>bgfx::Frame *</code></td> <td>m_frame</td></tr> <tr><td>16</td> <td>(8) <code>bgfx::d3d11::TimerQueryD3D11 *</code></td> <td>m_gpuTimer</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_queryIdx</td></tr> <tr><td>28</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numViews</td></tr> <tr><td>30</td> <td>(1) <code>bool</code></td> <td>m_enabled</td></tr></tbody></table> <h3 id="bgfx-vk-vksampler"><a href="#bgfx-vk-vksampler" class="header-anchor">#</a> <code>bgfx::vk::VkSampler</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>struct VkSampler_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-d3d12-resourcecreate"><a href="#bgfx-d3d12-resourcecreate" class="header-anchor">#</a> <code>bgfx::d3d12::ResourceCreate</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ID3D12Resource *</code></td> <td>m_ptr</td></tr> <tr><td>8</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_initialState</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int64</code></td> <td>m_gpuVA</td></tr></tbody></table> <h3 id="bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-2-location"><a href="#bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-2-location" class="header-anchor">#</a> <code>bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;2&gt; &gt;::Location</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_offset</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>8</td> <td>(32) <code>bgfx::d3d12::StagingBufferD3D12</code></td> <td>m_buffer</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>m_gpuAddr</td></tr> <tr><td>48</td> <td>(8) <code>void *</code></td> <td>m_cpuAddr</td></tr></tbody></table> <h3 id="bgfx-d3d12-stagingbufferd3d12"><a href="#bgfx-d3d12-stagingbufferd3d12" class="header-anchor">#</a> <code>bgfx::d3d12::StagingBufferD3D12</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>ID3D12Resource *</code></td> <td>m_upload</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>m_gpuVA</td></tr> <tr><td>16</td> <td>(8) <code>unsigned __int8 *</code></td> <td>m_data</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>28</td> <td>(4) <code>bgfx::d3d12::HeapProperty::Enum</code></td> <td>m_properties</td></tr></tbody></table> <h3 id="bgfx-dxbccontext"><a href="#bgfx-dxbccontext" class="header-anchor">#</a> <code>bgfx::DxbcContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>bgfx::DxbcContext::Header</code></td> <td>header</td></tr> <tr><td>32</td> <td>(32) <code>bgfx::DxbcSignature</code></td> <td>inputSignature</td></tr> <tr><td>64</td> <td>(32) <code>bgfx::DxbcSignature</code></td> <td>outputSignature</td></tr> <tr><td>96</td> <td>(40) <code>bgfx::DxbcShader</code></td> <td>shader</td></tr> <tr><td>136</td> <td>(24) <code>tinystl::vector&lt;unsigned char,bgfx::TinyStlAllocator&gt;</code></td> <td>debugInfo</td></tr> <tr><td>160</td> <td>(4) <code>unsigned int</code></td> <td>debugInfoFormat</td></tr></tbody></table> <h3 id="bgfx-dxbccontext-header"><a href="#bgfx-dxbccontext-header" class="header-anchor">#</a> <code>bgfx::DxbcContext::Header</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>magic</td></tr> <tr><td>4</td> <td>(16) <code>unsigned __int8[16]</code></td> <td>hash</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>version</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>size</td></tr> <tr><td>28</td> <td>(4) <code>unsigned int</code></td> <td>numChunks</td></tr></tbody></table> <h3 id="bgfx-dxbcsignature"><a href="#bgfx-dxbcsignature" class="header-anchor">#</a> <code>bgfx::DxbcSignature</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>key</td></tr> <tr><td>8</td> <td>(24) <code>tinystl::vector&lt;bgfx::DxbcSignature::Element,bgfx::TinyStlAllocator&gt;</code></td> <td>elements</td></tr></tbody></table> <h3 id="bgfx-d3d12-bind"><a href="#bgfx-d3d12-bind" class="header-anchor">#</a> <code>bgfx::d3d12::Bind</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>D3D12_GPU_DESCRIPTOR_HANDLE</code></td> <td>m_srvHandle</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>m_samplerStateIdx</td></tr></tbody></table> <h3 id="bgfx-d3d12-uniformbufferinstance"><a href="#bgfx-d3d12-uniformbufferinstance" class="header-anchor">#</a> <code>bgfx::d3d12::UniformBufferInstance</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::optional&lt;bgfx::UniformBufferView&gt;</code></td> <td>m_vsCb</td></tr> <tr><td>24</td> <td>(24) <code>std::optional&lt;bgfx::UniformBufferView&gt;</code></td> <td>m_fsCb</td></tr></tbody></table> <h3 id="bgfx-uniformbufferview"><a href="#bgfx-uniformbufferview" class="header-anchor">#</a> <code>bgfx::UniformBufferView</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const bgfx::UniformBuffer *</code></td> <td>m_uniforms</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>m_pos</td></tr></tbody></table> <h3 id="bgfx-d3d12-constantbufferdatacontainer"><a href="#bgfx-d3d12-constantbufferdatacontainer" class="header-anchor">#</a> <code>bgfx::d3d12::ConstantBufferDataContainer</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::d3d12::ConstantBufferScratch *</code></td> <td>m_scratch</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>m_currentOffset</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_cbSize</td></tr> <tr><td>24</td> <td>(8) <code>bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;2&gt; &gt; *</code></td> <td>m_uploadBuffer</td></tr> <tr><td>32</td> <td>(56) <code>bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;2&gt; &gt;::Location</code></td> <td>m_cbData</td></tr> <tr><td>88</td> <td>(8) <code>unsigned __int64</code></td> <td>m_vsDataSize</td></tr> <tr><td>96</td> <td>(8) <code>unsigned __int64</code></td> <td>m_fsDataSize</td></tr></tbody></table> <h3 id="bgfx-fencedringbuffer-bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-2-ringbufferresourceallocator-0-scopedallocation"><a href="#bgfx-fencedringbuffer-bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-2-ringbufferresourceallocator-0-scopedallocation" class="header-anchor">#</a> <code>bgfx::FencedRingBuffer&lt;bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;2&gt; &gt;::RingBufferResourceAllocator,0&gt;::ScopedAllocation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>std::shared_ptr&lt;bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;2&gt; &gt;::RingBufferResourceAllocator::Buffer&gt;</code></td> <td>m_buffer</td></tr> <tr><td>16</td> <td>(8) <code>const unsigned __int64</code></td> <td>m_offset</td></tr> <tr><td>24</td> <td>(8) <code>const unsigned __int64</code></td> <td>m_size</td></tr> <tr><td>32</td> <td>(8) <code>const unsigned __int64</code></td> <td>m_alignmentPrefixSize</td></tr> <tr><td>40</td> <td>(8) <code>const unsigned __int64</code></td> <td>m_fenceValue</td></tr></tbody></table> <h3 id="bgfx-fencedringbuffer-bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-2-ringbufferresourceallocator-0-linearallocation"><a href="#bgfx-fencedringbuffer-bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-2-ringbufferresourceallocator-0-linearallocation" class="header-anchor">#</a> <code>bgfx::FencedRingBuffer&lt;bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;2&gt; &gt;::RingBufferResourceAllocator,0&gt;::LinearAllocation</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>unsigned __int64</code></td> <td>m_offsetPrefix</td></tr> <tr><td>8</td> <td>(8) <code>unsigned __int64</code></td> <td>m_dataOffset</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-d3d12rtprogram"><a href="#bgfx-d3d12rtx-d3d12rtprogram" class="header-anchor">#</a> <code>bgfx::d3d12rtx::D3D12RTProgram</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>bgfx::d3d12rtx::D3D12RTShaderInfo</code></td> <td>info</td></tr> <tr><td>24</td> <td>(8) <code>IDxcBlob *</code></td> <td>blob</td></tr> <tr><td>32</td> <td>(32) <code>D3D12_DXIL_LIBRARY_DESC</code></td> <td>dxilLibDesc</td></tr> <tr><td>64</td> <td>(24) <code>D3D12_EXPORT_DESC</code></td> <td>exportDesc</td></tr> <tr><td>88</td> <td>(16) <code>D3D12_STATE_SUBOBJECT</code></td> <td>subobject</td></tr> <tr><td>104</td> <td>(32) <code>std::wstring</code></td> <td>exportName</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-d3d12rtshaderinfo"><a href="#bgfx-d3d12rtx-d3d12rtshaderinfo" class="header-anchor">#</a> <code>bgfx::d3d12rtx::D3D12RTShaderInfo</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const wchar_t *</code></td> <td>filename</td></tr> <tr><td>8</td> <td>(8) <code>const wchar_t *</code></td> <td>entryPoint</td></tr> <tr><td>16</td> <td>(8) <code>const wchar_t *</code></td> <td>targetProfile</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-adaptivedenoiserlightsortkey"><a href="#bgfx-d3d12rtx-adaptivedenoiserlightsortkey" class="header-anchor">#</a> <code>bgfx::d3d12rtx::AdaptiveDenoiserLightSortKey</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>idx</td></tr> <tr><td>4</td> <td>(4) <code>float</code></td> <td>distanceSquared</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-renderercontextd3d12rtx-blascompactioncontext"><a href="#bgfx-d3d12rtx-renderercontextd3d12rtx-blascompactioncontext" class="header-anchor">#</a> <code>bgfx::d3d12rtx::RendererContextD3D12RTX::BlasCompactionContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::d3d12rtx::RTBlasCompactionState</code></td> <td>state</td></tr> <tr><td>4</td> <td>(2) <code>bgfx::AccelerationStructureHandle</code></td> <td>hBuffer</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>beforeSize</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>afterSize</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>frameCountOfLastUpdate</td></tr> <tr><td>20</td> <td>(4) <code>int</code></td> <td>sizeRequestIndex</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-renderercontextd3d12rtx-blasbuildcontext"><a href="#bgfx-d3d12rtx-renderercontextd3d12rtx-blasbuildcontext" class="header-anchor">#</a> <code>bgfx::d3d12rtx::RendererContextD3D12RTX::BlasBuildContext</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(56) <code>D3D12_RAYTRACING_GEOMETRY_DESC</code></td> <td>desc</td></tr> <tr><td>56</td> <td>(2) <code>bgfx::AccelerationStructureHandle</code></td> <td>hBuffer</td></tr> <tr><td>60</td> <td>(4) <code>D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS</code></td> <td>flags</td></tr> <tr><td>64</td> <td>(4) <code>unsigned int</code></td> <td>scratchSize</td></tr></tbody></table> <h3 id="bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-0-location"><a href="#bgfx-ringbuffer-bgfx-d3d12-stagingbufferd3d12-unsigned-int64-void-bgfx-d3d12-ringbufferallocator-0-location" class="header-anchor">#</a> <code>bgfx::RingBuffer&lt;bgfx::d3d12::StagingBufferD3D12,unsigned __int64,void *,bgfx::d3d12::RingBufferAllocator&lt;0&gt; &gt;::Location</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>unsigned int</code></td> <td>m_offset</td></tr> <tr><td>4</td> <td>(4) <code>unsigned int</code></td> <td>m_size</td></tr> <tr><td>8</td> <td>(32) <code>bgfx::d3d12::StagingBufferD3D12</code></td> <td>m_buffer</td></tr> <tr><td>40</td> <td>(8) <code>unsigned __int64</code></td> <td>m_gpuAddr</td></tr> <tr><td>48</td> <td>(8) <code>void *</code></td> <td>m_cpuAddr</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-renderercontextd3d12rtx-globaldescriptortabletexturetransition"><a href="#bgfx-d3d12rtx-renderercontextd3d12rtx-globaldescriptortabletexturetransition" class="header-anchor">#</a> <code>bgfx::d3d12rtx::RendererContextD3D12RTX::GlobalDescriptorTableTextureTransition</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::d3d12rtx::RTGlobalDescriptorTable</code></td> <td>m_whichEntry</td></tr> <tr><td>4</td> <td>(4) <code>D3D12_RESOURCE_STATES</code></td> <td>m_assumedPreviousState</td></tr></tbody></table> <h3 id="bgfx-d3d12rtx-renderercontextd3d12rtx-float3x4"><a href="#bgfx-d3d12rtx-renderercontextd3d12rtx-float3x4" class="header-anchor">#</a> <code>bgfx::d3d12rtx::RendererContextD3D12RTX::float3x4</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(48) <code>float[3][4]</code></td> <td>data</td></tr></tbody></table> <h3 id="bgfx-gl-framebuffergl"><a href="#bgfx-gl-framebuffergl" class="header-anchor">#</a> <code>bgfx::gl::FrameBufferGL</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>bgfx::gl::SwapChainGL *</code></td> <td>m_swapChain</td></tr> <tr><td>8</td> <td>(8) <code>unsigned int[2]</code></td> <td>m_fbo</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>m_width</td></tr> <tr><td>20</td> <td>(4) <code>unsigned int</code></td> <td>m_height</td></tr> <tr><td>24</td> <td>(2) <code>unsigned __int16</code></td> <td>m_denseIdx</td></tr> <tr><td>26</td> <td>(1) <code>unsigned __int8</code></td> <td>m_num</td></tr> <tr><td>27</td> <td>(1) <code>unsigned __int8</code></td> <td>m_numTh</td></tr> <tr><td>28</td> <td>(1) <code>bool</code></td> <td>m_needPresent</td></tr> <tr><td>30</td> <td>(48) <code>bgfx::Attachment[8]</code></td> <td>m_attachment</td></tr></tbody></table> <h3 id="bgfx-vk-vkpipeline"><a href="#bgfx-vk-vkpipeline" class="header-anchor">#</a> <code>bgfx::vk::VkPipeline</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>struct VkPipeline_T *</code></td> <td>vk</td></tr></tbody></table> <h3 id="bgfx-dxbcsuboperand"><a href="#bgfx-dxbcsuboperand" class="header-anchor">#</a> <code>bgfx::DxbcSubOperand</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::DxbcOperandType::Enum</code></td> <td>type</td></tr> <tr><td>4</td> <td>(1) <code>unsigned __int8</code></td> <td>mode</td></tr> <tr><td>5</td> <td>(1) <code>unsigned __int8</code></td> <td>modeBits</td></tr> <tr><td>6</td> <td>(1) <code>unsigned __int8</code></td> <td>num</td></tr> <tr><td>7</td> <td>(1) <code>unsigned __int8</code></td> <td>numAddrModes</td></tr> <tr><td>8</td> <td>(1) <code>unsigned __int8</code></td> <td>addrMode</td></tr> <tr><td>12</td> <td>(4) <code>unsigned int</code></td> <td>regIndex</td></tr></tbody></table> <h3 id="bgfx-dxbcoperand"><a href="#bgfx-dxbcoperand" class="header-anchor">#</a> <code>bgfx::DxbcOperand</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::DxbcOperandType::Enum</code></td> <td>type</td></tr> <tr><td>4</td> <td>(4) <code>bgfx::DxbcOperandMode::Enum</code></td> <td>mode</td></tr> <tr><td>8</td> <td>(1) <code>unsigned __int8</code></td> <td>modeBits</td></tr> <tr><td>9</td> <td>(1) <code>unsigned __int8</code></td> <td>num</td></tr> <tr><td>12</td> <td>(4) <code>_BYTE[4]</code></td> <td>modifier</td></tr> <tr><td>16</td> <td>(1) <code>unsigned __int8</code></td> <td>numAddrModes</td></tr> <tr><td>17</td> <td>(3) <code>unsigned __int8[3]</code></td> <td>addrMode</td></tr> <tr><td>20</td> <td>(12) <code>unsigned int[3]</code></td> <td>regIndex</td></tr> <tr><td>32</td> <td>(48) <code>bgfx::DxbcSubOperand[3]</code></td> <td>subOperand</td></tr> <tr><td>80</td> <td>(32) <code>bgfx::DxbcOperand::&lt;unnamed_type_un&gt;</code></td> <td>un</td></tr></tbody></table> <h3 id="bgfx-dxbcoperand-unnamed-type-un"><a href="#bgfx-dxbcoperand-unnamed-type-un" class="header-anchor">#</a> <code>bgfx::DxbcOperand::&lt;unnamed_type_un&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(16) <code>unsigned int[4]</code></td> <td>imm32</td></tr> <tr><td>1</td> <td>(32) <code>unsigned __int64[4]</code></td> <td>imm64</td></tr></tbody></table> <h3 id="bgfx-dxbcinstruction"><a href="#bgfx-dxbcinstruction" class="header-anchor">#</a> <code>bgfx::DxbcInstruction</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(4) <code>bgfx::DxbcOpcode::Enum</code></td> <td>opcode</td></tr> <tr><td>4</td> <td>(12) <code>unsigned int[3]</code></td> <td>value</td></tr> <tr><td>16</td> <td>(4) <code>unsigned int</code></td> <td>length</td></tr> <tr><td>20</td> <td>(1) <code>unsigned __int8</code></td> <td>numOperands</td></tr> <tr><td>24</td> <td>(12) <code>bgfx::DxbcInstruction::ExtendedType::Enum[3]</code></td> <td>extended</td></tr> <tr><td>36</td> <td>(4) <code>_BYTE[4]</code></td> <td>srv</td></tr> <tr><td>40</td> <td>(1) <code>unsigned __int8</code></td> <td>samples</td></tr> <tr><td>44</td> <td>(4) <code>_BYTE[4]</code></td> <td>interpolation</td></tr> <tr><td>48</td> <td>(1) <code>bool</code></td> <td>shadow</td></tr> <tr><td>49</td> <td>(1) <code>bool</code></td> <td>mono</td></tr> <tr><td>50</td> <td>(1) <code>bool</code></td> <td>allowRefactoring</td></tr> <tr><td>51</td> <td>(1) <code>bool</code></td> <td>fp64</td></tr> <tr><td>52</td> <td>(1) <code>bool</code></td> <td>earlyDepth</td></tr> <tr><td>53</td> <td>(1) <code>bool</code></td> <td>enableBuffers</td></tr> <tr><td>54</td> <td>(1) <code>bool</code></td> <td>skipOptimization</td></tr> <tr><td>55</td> <td>(1) <code>bool</code></td> <td>enableMinPrecision</td></tr> <tr><td>56</td> <td>(1) <code>bool</code></td> <td>enableDoubleExtensions</td></tr> <tr><td>57</td> <td>(1) <code>bool</code></td> <td>enableShaderExtensions</td></tr> <tr><td>58</td> <td>(1) <code>bool</code></td> <td>threadsInGroup</td></tr> <tr><td>59</td> <td>(1) <code>bool</code></td> <td>sharedMemory</td></tr> <tr><td>60</td> <td>(1) <code>bool</code></td> <td>uavGroup</td></tr> <tr><td>61</td> <td>(1) <code>bool</code></td> <td>uavGlobal</td></tr> <tr><td>64</td> <td>(4) <code>bgfx::DxbcResourceReturnType::Enum</code></td> <td>retType</td></tr> <tr><td>68</td> <td>(1) <code>bool</code></td> <td>saturate</td></tr> <tr><td>69</td> <td>(1) <code>unsigned __int8</code></td> <td>testNZ</td></tr> <tr><td>70</td> <td>(3) <code>unsigned __int8[3]</code></td> <td>sampleOffsets</td></tr> <tr><td>73</td> <td>(1) <code>unsigned __int8</code></td> <td>resourceTarget</td></tr> <tr><td>74</td> <td>(1) <code>unsigned __int8</code></td> <td>resourceStride</td></tr> <tr><td>76</td> <td>(16) <code>bgfx::DxbcResourceReturnType::Enum[4]</code></td> <td>resourceReturnTypes</td></tr> <tr><td>96</td> <td>(672) <code>bgfx::DxbcOperand[6]</code></td> <td>operand</td></tr> <tr><td>768</td> <td>(4) <code>bgfx::DxbcCustomDataClass::Enum</code></td> <td>customDataClass</td></tr> <tr><td>776</td> <td>(24) <code>tinystl::vector&lt;unsigned int,bgfx::TinyStlAllocator&gt;</code></td> <td>customData</td></tr></tbody></table> <h3 id="bimg-bitreader"><a href="#bimg-bitreader" class="header-anchor">#</a> <code>bimg::BitReader</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const unsigned __int8 *</code></td> <td>m_data</td></tr> <tr><td>8</td> <td>(2) <code>unsigned __int16</code></td> <td>m_bitPos</td></tr></tbody></table> <h3 id="bgfx-d3d12-constantbufferscratch"><a href="#bgfx-d3d12-constantbufferscratch" class="header-anchor">#</a> <code>bgfx::d3d12::ConstantBufferScratch</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(24) <code>std::vector&lt;unsigned char&gt;</code></td> <td>m_data</td></tr></tbody></table> <h3 id="blockactordatapacket"><a href="#blockactordatapacket" class="header-anchor">#</a> <code>BlockActorDataPacket</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(40) <code>Packet</code></td> <td>baseclass_0</td></tr> <tr><td>40</td> <td>(12) <code>NetworkBlockPosition</code></td> <td>mPos</td></tr> <tr><td>56</td> <td>(24) <code>CompoundTag</code></td> <td>mData</td></tr></tbody></table> <h3 id="bgfx-profiler-bgfx-gl-timerquerygl"><a href="#bgfx-profiler-bgfx-gl-timerquerygl" class="header-anchor">#</a> <code>bgfx::Profiler&lt;bgfx::gl::TimerQueryGL&gt;</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char (*)[256]</code></td> <td>m_viewName</td></tr> <tr><td>8</td> <td>(8) <code>bgfx::Frame *</code></td> <td>m_frame</td></tr> <tr><td>16</td> <td>(8) <code>bgfx::gl::TimerQueryGL *</code></td> <td>m_gpuTimer</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>m_queryIdx</td></tr> <tr><td>28</td> <td>(2) <code>unsigned __int16</code></td> <td>m_numViews</td></tr> <tr><td>30</td> <td>(1) <code>bool</code></td> <td>m_enabled</td></tr></tbody></table> <h3 id="bedrock-jsonobject-document"><a href="#bedrock-jsonobject-document" class="header-anchor">#</a> <code>Bedrock::JSONObject::Document</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(32) <code>Bedrock::JSONObject::DocumentOptions</code></td> <td>mOptions</td></tr> <tr><td>32</td> <td>(16) <code>Bedrock::JSONObject::ParseResult</code></td> <td>mParseResult</td></tr> <tr><td>48</td> <td>(8) <code>Bedrock::Memory::IMemoryAllocator *</code></td> <td>mAllocator</td></tr> <tr><td>56</td> <td>(8) <code>Bedrock::JSONObject::MemoryPage *</code></td> <td>mPageHead</td></tr> <tr><td>64</td> <td>(8) <code>Bedrock::JSONObject::Node *</code></td> <td>mRootNode</td></tr> <tr><td>72</td> <td>(8) <code>Bedrock::JSONObject::Document::AllocatedResources *</code></td> <td>mAllocatedResources</td></tr> <tr><td>80</td> <td>(4) <code>unsigned int</code></td> <td>mPageCount</td></tr></tbody></table> <h3 id="bedrock-jsonobject-documentoptions"><a href="#bedrock-jsonobject-documentoptions" class="header-anchor">#</a> <code>Bedrock::JSONObject::DocumentOptions</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>void *</code></td> <td>mFixedBlock</td></tr> <tr><td>8</td> <td>(8) <code>Bedrock::Memory::IMemoryAllocator *</code></td> <td>mAllocator</td></tr> <tr><td>16</td> <td>(8) <code>char *</code></td> <td>mInSituBuffer</td></tr> <tr><td>24</td> <td>(4) <code>unsigned int</code></td> <td>mFixedBlockLength</td></tr> <tr><td>28</td> <td>(1) <code>bool</code></td> <td>mAllowDynamicAllocation</td></tr></tbody></table> <h3 id="bedrock-jsonobject-parseresult"><a href="#bedrock-jsonobject-parseresult" class="header-anchor">#</a> <code>Bedrock::JSONObject::ParseResult</code></h3> <table><thead><tr><th>Offset</th> <th>Type</th> <th>Name</th></tr></thead> <tbody><tr><td>0</td> <td>(8) <code>const char *</code></td> <td>mErrorDescription</td></tr> <tr><td>8</td> <td>(4) <code>unsigned int</code></td> <td>mOffset</td></tr> <tr><td>12</td> <td>(4) <code>int</code></td> <td>mErrorCode</td></tr></tbody></table> <h3 id="bedrock-threading-prioritizedefault"><a href="#bedrock-threading-prioritizedefault" class="header-anchor">#</a> <code>Bedrock::Threading::PrioritizeDefault</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::PrioritizeDefault
{
  std::mutex mLock;
  std::hash&lt;std::thread::id&gt; mThreadHasher;
  const unsigned __int64 mNoThreadId;
  unsigned __int64 mOwnerThread;
  unsigned __int64 mReadCount;
  std::condition_variable mWriteQueue;
  std::condition_variable mReadQueue;
};

</code></pre></div><h3 id="bedrock-threading-prioritizeuniqueownership"><a href="#bedrock-threading-prioritizeuniqueownership" class="header-anchor">#</a> <code>Bedrock::Threading::PrioritizeUniqueOwnership</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::PrioritizeUniqueOwnership
{
  std::mutex mLock;
  std::hash&lt;std::thread::id&gt; mThreadHasher;
  const unsigned __int64 mNoThreadId;
  unsigned __int64 mOwnerThread;
  unsigned __int64 mWriteCount;
  unsigned __int64 mReadCount;
  std::condition_variable mPriorityWriteQueue;
  std::condition_variable mWriteQueue;
  std::condition_variable mReadQueue;
};

</code></pre></div><h3 id="blocksource-vtbl"><a href="#blocksource-vtbl" class="header-anchor">#</a> <code>BlockSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockSource_vtbl
{
  void (__fastcall *~BlockSource)(BlockSource *this);
};

</code></pre></div><h3 id="blocksourcelistener"><a href="#blocksourcelistener" class="header-anchor">#</a> <code>BlockSourceListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSourceListener
{
  BlockSourceListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="block-vtbl"><a href="#block-vtbl" class="header-anchor">#</a> <code>Block_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Block_vtbl
{
  void (__fastcall *~Block)(Block *this);
  BlockRenderLayer (__fastcall *getRenderLayer)(Block *this);
};

</code></pre></div><h3 id="blocklegacy"><a href="#blocklegacy" class="header-anchor">#</a> <code>BlockLegacy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLegacy
{
  BlockLegacy_vtbl *__vftable /*VFT*/;
  std::string mDescriptionId;
  HashedString mRawNameId;
  std::string mNamespace;
  HashedString mFullName;
  bool mFancy;
  BlockRenderLayer mRenderLayer;
  bool mRenderLayerCanRenderAsOpaque;
  __declspec(align(8)) _BYTE mProperties[8];
  BlockActorType mBlockEntityType;
  bool mAnimatedTexture;
  float mBrightnessGamma;
  float mThickness;
  bool mCanSlide;
  bool mCanInstatick;
  bool mIsInteraction;
  float mGravity;
  const Material *mMaterial;
  bool mHeavy;
  float mParticleQuantityScalar;
  CreativeItemCategory mCreativeCategory;
  std::string mCreativeGroup;
  bool mAllowsRunes;
  bool mCanBeBrokenFromFalling;
  bool mSolid;
  bool mPushesOutItems;
  bool mIgnoreBlockForInsideCubeRenderer;
  bool mIsTrapdoor;
  bool mIsDoor;
  float mTranslucency;
  bool mShouldRandomTick;
  bool mShouldRandomTickExtraLayer;
  bool mIsMobPiece;
  bool mCanBeExtraBlock;
  bool mCanPropagateBrightness;
  Brightness mLightBlock;
  Brightness mLightEmission;
  int mFlameOdds;
  int mBurnOdds;
  float mDestroySpeed;
  float mExplosionResistance;
  mce::Color mMapColor;
  float mFriction;
  NewBlockID mID;
  BaseGameVersion mMinRequiredBaseGameVersion;
  bool mIsVanilla;
  std::vector&lt;HashedString&gt; mTags;
  bool mTickToScript;
  bool mSendNeighborChangedToScript;
  bool mFireResistant;
  std::unordered_map&lt;std::string,DefinitionEvent&gt; mEventHandlers;
  AABB mVisualShape;
  unsigned int mBitsUsed;
  unsigned int mTotalBitsUsed;
  std::map&lt;unsigned __int64,ItemStateInstance&gt; mStates;
  std::unordered_map&lt;HashedString,unsigned __int64&gt; mStateNameMap;
  unsigned __int64 mCreativeEnumState;
  std::vector&lt;std::unique_ptr&lt;Block&gt;&gt; mBlockPermutations;
  const Block *mDefaultState;
  Core::Cache&lt;unsigned short,Block const *,Block const *&gt; mLegacyDataLookupTable;
  OwnerPtrT&lt;EntityRefTraits&gt; mEntity;
  std::unique_ptr&lt;BlockStateGroup&gt; mBlockStateGroup;
  HashedString mHashedFullName;
};

</code></pre></div><h3 id="bytetag-vtbl"><a href="#bytetag-vtbl" class="header-anchor">#</a> <code>ByteTag_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ByteTag_vtbl
{
  void (__fastcall *~Tag)(Tag *this);
  void (__fastcall *deleteChildren)(Tag *this);
  void (__fastcall *write)(Tag *this, IDataOutput *);
  void (__fastcall *load)(Tag *this, IDataInput *);
  void (__fastcall *writeScriptData)(Tag *this, IDataOutput *);
  void (__fastcall *loadScriptData)(Tag *this, IDataInput *);
  std::string *(__fastcall *toString)(Tag *this, std::string *result);
  Tag::Type (__fastcall *getId)(Tag *this);
  bool (__fastcall *equals)(Tag *this, const Tag *);
  void (__fastcall *print)(Tag *this, const std::string *, PrintStream *);
  void (__fastcall *print)(Tag *this, PrintStream *);
  std::unique_ptr&lt;Tag&gt; *(__fastcall *copy)(Tag *this, std::unique_ptr&lt;Tag&gt; *result);
  unsigned __int64 (__fastcall *hash)(Tag *this);
};

</code></pre></div><h3 id="bytearraytag-vtbl"><a href="#bytearraytag-vtbl" class="header-anchor">#</a> <code>ByteArrayTag_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ByteArrayTag_vtbl
{
  void (__fastcall *~Tag)(Tag *this);
  void (__fastcall *deleteChildren)(Tag *this);
  void (__fastcall *write)(Tag *this, IDataOutput *);
  void (__fastcall *load)(Tag *this, IDataInput *);
  void (__fastcall *writeScriptData)(Tag *this, IDataOutput *);
  void (__fastcall *loadScriptData)(Tag *this, IDataInput *);
  std::string *(__fastcall *toString)(Tag *this, std::string *result);
  Tag::Type (__fastcall *getId)(Tag *this);
  bool (__fastcall *equals)(Tag *this, const Tag *);
  void (__fastcall *print)(Tag *this, const std::string *, PrintStream *);
  void (__fastcall *print)(Tag *this, PrintStream *);
  std::unique_ptr&lt;Tag&gt; *(__fastcall *copy)(Tag *this, std::unique_ptr&lt;Tag&gt; *result);
  unsigned __int64 (__fastcall *hash)(Tag *this);
};

</code></pre></div><h3 id="baseactorrendercontext-vtbl"><a href="#baseactorrendercontext-vtbl" class="header-anchor">#</a> <code>BaseActorRenderContext_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseActorRenderContext_vtbl
{
  void (__fastcall *~BaseActorRenderContext)(BaseActorRenderContext *this);
};

</code></pre></div><h3 id="binarystream-vtbl"><a href="#binarystream-vtbl" class="header-anchor">#</a> <code>BinaryStream_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BinaryStream_vtbl
{
  void (__fastcall *~ReadOnlyBinaryStream)(ReadOnlyBinaryStream *this);
  bool (__fastcall *read)(ReadOnlyBinaryStream *this, void *, unsigned __int64);
};

</code></pre></div><h3 id="backgroundtaskbase"><a href="#backgroundtaskbase" class="header-anchor">#</a> <code>BackgroundTaskBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BackgroundTaskBase
{
  BackgroundTaskBase_vtbl *__vftable /*VFT*/;
  const bool mIsAsync;
  ITaskGroup *mGroup;
  BackgroundTaskBase *mPrevTask;
  std::shared_ptr&lt;BackgroundTaskBase&gt; mNextTask;
  int mPriority;
  std::thread::id mAffinity;
  const int mBackDownPriorityAmount;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mStartAfterTime;
};

</code></pre></div><h3 id="backgroundtaskbase-vtbl"><a href="#backgroundtaskbase-vtbl" class="header-anchor">#</a> <code>BackgroundTaskBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BackgroundTaskBase_vtbl
{
  void (__fastcall *~BackgroundTaskBase)(BackgroundTaskBase *this);
  void (__fastcall *cancel)(BackgroundTaskBase *this);
  bool (__fastcall *isReady)(BackgroundTaskBase *this);
  TaskRunResult (__fastcall *run)(BackgroundTaskBase *this, const ITaskExecutionContext *);
};

</code></pre></div><h3 id="bedrock-enablenonownerreferences-controlblock"><a href="#bedrock-enablenonownerreferences-controlblock" class="header-anchor">#</a> <code>Bedrock::EnableNonOwnerReferences::ControlBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::EnableNonOwnerReferences::ControlBlock
{
  Bedrock::EnableNonOwnerReferences *mPtr;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-scheduler"><a href="#bedrock-nonownerpointer-scheduler" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Scheduler&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;Scheduler&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="batchednetworkpeer"><a href="#batchednetworkpeer" class="header-anchor">#</a> <code>BatchedNetworkPeer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BatchedNetworkPeer : NetworkPeer
{
  BinaryStream mOutgoingData;
  unsigned __int64 mCompressibleBytes;
  std::string mIncomingDataBuffer;
  std::unique_ptr&lt;ReadOnlyBinaryStream&gt; mIncomingData;
  std::unique_ptr&lt;TaskGroup&gt; mTaskGroup;
  SPSCQueue&lt;BatchedNetworkPeer::DataCallback,512&gt; mSendQueue;
  std::atomic&lt;bool&gt; mTaskRunning;
  std::atomic&lt;unsigned __int64&gt; mQueuedPackets;
  unsigned __int64 mSentPackets;
  unsigned __int16 mCompressionThreshold;
  bool mAsyncEnabled;
};

</code></pre></div><h3 id="batchednetworkpeer-vtbl"><a href="#batchednetworkpeer-vtbl" class="header-anchor">#</a> <code>BatchedNetworkPeer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BatchedNetworkPeer_vtbl
{
  void (__fastcall *~NetworkPeer)(NetworkPeer *this);
  void (__fastcall *sendPacket)(NetworkPeer *this, const std::string *, NetworkPeer::Reliability, int, unsigned __int16, Compressibility);
  NetworkPeer::DataStatus (__fastcall *receivePacket)(NetworkPeer *this, std::string *);
  NetworkPeer::NetworkStatus *(__fastcall *getNetworkStatus)(NetworkPeer *this, NetworkPeer::NetworkStatus *result);
  void (__fastcall *addIncomingData)(NetworkPeer *this, std::string);
  void (__fastcall *update)(NetworkPeer *this);
  void (__fastcall *flush)(NetworkPeer *this, std::function&lt;void __cdecl(void)&gt; *);
};

</code></pre></div><h3 id="bedrock-threading-asyncbase"><a href="#bedrock-threading-asyncbase" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncBase : std::enable_shared_from_this&lt;Bedrock::Threading::AsyncBase&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-void"><a href="#bedrock-threading-iasyncresult-void" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::IAsyncResult&lt;void&gt; : Bedrock::Threading::AsyncBase
{
  Bedrock::Threading::IAsyncResult&lt;void&gt;_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-void-vtbl"><a href="#bedrock-threading-iasyncresult-void-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;void&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::IAsyncResult&lt;void&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="biomedefinitionlistpacket"><a href="#biomedefinitionlistpacket" class="header-anchor">#</a> <code>BiomeDefinitionListPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj BiomeDefinitionListPacket : Packet
{
  CompoundTag mBiomeData;
};

</code></pre></div><h3 id="biomedefinitionlistpacket-vtbl"><a href="#biomedefinitionlistpacket-vtbl" class="header-anchor">#</a> <code>BiomeDefinitionListPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BiomeDefinitionListPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="bookeditpacket-vtbl"><a href="#bookeditpacket-vtbl" class="header-anchor">#</a> <code>BookEditPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BookEditPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="bosseventpacket-vtbl"><a href="#bosseventpacket-vtbl" class="header-anchor">#</a> <code>BossEventPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BossEventPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="blockactordatapacket-vtbl"><a href="#blockactordatapacket-vtbl" class="header-anchor">#</a> <code>BlockActorDataPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockActorDataPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="blockpickrequestpacket"><a href="#blockpickrequestpacket" class="header-anchor">#</a> <code>BlockPickRequestPacket</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(4)) BlockPickRequestPacket : Packet
{
  BlockPos mPos;
  bool mWithData;
  unsigned __int8 mMaxSlots;
};

</code></pre></div><h3 id="blockpickrequestpacket-vtbl"><a href="#blockpickrequestpacket-vtbl" class="header-anchor">#</a> <code>BlockPickRequestPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockPickRequestPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="blockeventpacket-vtbl"><a href="#blockeventpacket-vtbl" class="header-anchor">#</a> <code>BlockEventPacket_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockEventPacket_vtbl
{
  void (__fastcall *~Packet)(Packet *this);
  MinecraftPacketIds (__fastcall *getId)(Packet *this);
  std::string *(__fastcall *getName)(Packet *this, std::string *result);
  void (__fastcall *write)(Packet *this, BinaryStream *);
  StreamReadResult (__fastcall *read)(Packet *this, ReadOnlyBinaryStream *);
  ExtendedStreamReadResult *(__fastcall *readExtended)(Packet *this, ExtendedStreamReadResult *result, ReadOnlyBinaryStream *);
  bool (__fastcall *disallowBatching)(Packet *this);
};

</code></pre></div><h3 id="blockpalette"><a href="#blockpalette" class="header-anchor">#</a> <code>BlockPalette</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj BlockPalette
{
  std::mutex mLegacyBlockStatesConversionWarningMutex;
  std::set&lt;std::pair&lt;int,int&gt;&gt; mLegacyBlockStatesConversionWarningSet;
  std::map&lt;std::string,BlockLegacy const *&gt; mNameLookup;
  std::vector&lt;Block const *&gt; mBlockFromRuntimeId;
  Level *mLevel;
};

</code></pre></div><h3 id="backgroundtaskqueue"><a href="#backgroundtaskqueue" class="header-anchor">#</a> <code>BackgroundTaskQueue</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BackgroundTaskQueue
{
  std::mutex mIngressLock;
  std::mutex mEgressLock;
  SPSCQueue&lt;std::shared_ptr&lt;BackgroundTaskBase&gt;,512&gt; mTasks;
  std::atomic&lt;unsigned __int64&gt; mQueuedTasksCount;
  std::atomic&lt;bool&gt; mResortQueue;
  std::mutex mQueueLock;
  MovePriorityQueue&lt;std::shared_ptr&lt;BackgroundTaskBase&gt;,BackgroundTaskBase::PriorityComparer&gt; mLocalPriorityQueue;
  std::atomic&lt;int&gt; mNextItemPriority;
};

</code></pre></div><h3 id="backgroundworker"><a href="#backgroundworker" class="header-anchor">#</a> <code>BackgroundWorker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BackgroundWorker : ITaskExecutionContext
{
  const bool mAsync;
  Bedrock::Threading::OSThreadPriority mPriority;
  std::optional&lt;unsigned __int64&gt; mCoreAffinity;
  std::string mName;
  std::thread mThread;
  std::thread::id mWorkerThreadID;
  std::atomic&lt;enum BackgroundWorker::State&gt; mState;
  ResetEventObj mResetEvent;
  std::atomic&lt;bool&gt; mIdle;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mIdleSinceTime;
  std::shared_ptr&lt;BackgroundTaskBase&gt; mCurrentTask;
  WorkerPool *mWorkerPool;
  std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; mMaxSpinlockDuration;
  BackgroundTaskQueue mTaskQueue;
};

</code></pre></div><h3 id="backgroundworker-vtbl"><a href="#backgroundworker-vtbl" class="header-anchor">#</a> <code>BackgroundWorker_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BackgroundWorker_vtbl
{
  void (__fastcall *~ITaskExecutionContext)(ITaskExecutionContext *this);
  bool (__fastcall *isAsync)(ITaskExecutionContext *this);
  bool (__fastcall *canTaskRunAgain)(ITaskExecutionContext *this);
};

</code></pre></div><h3 id="backgroundworkerperfinfo"><a href="#backgroundworkerperfinfo" class="header-anchor">#</a> <code>BackgroundWorkerPerfInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BackgroundWorkerPerfInfo
{
  const BackgroundWorker *mUpdaterWorker;
  std::atomic&lt;unsigned __int64&gt; mTotalRunTasks;
  std::atomic&lt;unsigned __int64&gt; mTotalRunTasksTicks;
  std::atomic&lt;unsigned int&gt; mTotalWakeUps;
  std::atomic&lt;double&gt; mAverageTaskDuration;
  std::atomic&lt;unsigned int&gt; mWakeUpsPerSecond;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mLastPerfInfoUpdate;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mNextPerfInfoUpdate;
};

</code></pre></div><h3 id="bedrock-pubsub-detail-dispatcher-bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-void-void-option-const"><a href="#bedrock-pubsub-detail-dispatcher-bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-void-void-option-const" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;,void,void,Option const &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;,void,void,Option const &amp;&gt;
{
};

</code></pre></div><h3 id="bedrock-pubsub-detail-subscriptionbodyinterface"><a href="#bedrock-pubsub-detail-subscriptionbodyinterface" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::SubscriptionBodyInterface</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Detail::SubscriptionBodyInterface
{
  Bedrock::PubSub::Detail::SubscriptionBodyInterface_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-pubsub-subscriptioncontext"><a href="#bedrock-pubsub-subscriptioncontext" class="header-anchor">#</a> <code>Bedrock::PubSub::SubscriptionContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj Bedrock::PubSub::SubscriptionContext
{
  Bedrock::PubSub::SubscriptionContext_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-pubsub-subscriptioncontext-vtbl"><a href="#bedrock-pubsub-subscriptioncontext-vtbl" class="header-anchor">#</a> <code>Bedrock::PubSub::SubscriptionContext_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::PubSub::SubscriptionContext_vtbl
{
  void (__fastcall *~SubscriptionContext)(Bedrock::PubSub::SubscriptionContext *this);
  void (__fastcall *to_string)(Bedrock::PubSub::SubscriptionContext *this, std::string *);
};

</code></pre></div><h3 id="bedrock-pubsub-detail-subscriptionbodyinterface-vtbl"><a href="#bedrock-pubsub-detail-subscriptionbodyinterface-vtbl" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::SubscriptionBodyInterface_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::PubSub::Detail::SubscriptionBodyInterface_vtbl
{
  void (__fastcall *~SubscriptionBodyInterface)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  const Bedrock::PubSub::SubscriptionContext *(__fastcall *_getContext)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  void (__fastcall *_disconnect)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this, std::shared_ptr&lt;Bedrock::PubSub::Detail::SubscriptionBodyInterface&gt; *);
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-subscriptionbody"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-subscriptionbody" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;::SubscriptionBody</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;::SubscriptionBody : Bedrock::PubSub::Detail::SubscriptionBodyInterface
{
  Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt; *mOwner;
  std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;std::shared_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;::SubscriptionBody&gt; &gt; &gt; &gt; mIterator;
  std::function&lt;void __cdecl(Option const &amp;)&gt; mFunction;
  std::unique_ptr&lt;Bedrock::PubSub::SubscriptionContext&gt; mContext;
  int mGroup;
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-subscriptionbody-vtbl"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-subscriptionbody-vtbl" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;::SubscriptionBody_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;)&gt;::SubscriptionBody_vtbl
{
  void (__fastcall *~SubscriptionBodyInterface)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  const Bedrock::PubSub::SubscriptionContext *(__fastcall *_getContext)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  void (__fastcall *_disconnect)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this, std::shared_ptr&lt;Bedrock::PubSub::Detail::SubscriptionBodyInterface&gt; *);
};

</code></pre></div><h3 id="bedrock-pubsub-detail-dispatcher-bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-enum-inputmode-void-void-option-const-enum-inputmode"><a href="#bedrock-pubsub-detail-dispatcher-bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-enum-inputmode-void-void-option-const-enum-inputmode" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;,void,void,Option const &amp;,enum InputMode&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;,void,void,Option const &amp;,enum InputMode&gt;
{
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-enum-inputmode-subscriptionbody"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-enum-inputmode-subscriptionbody" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;::SubscriptionBody</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;::SubscriptionBody : Bedrock::PubSub::Detail::SubscriptionBodyInterface
{
  Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt; *mOwner;
  std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;std::shared_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;::SubscriptionBody&gt; &gt; &gt; &gt; mIterator;
  std::function&lt;void __cdecl(Option const &amp;,enum InputMode)&gt; mFunction;
  std::unique_ptr&lt;Bedrock::PubSub::SubscriptionContext&gt; mContext;
  int mGroup;
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-enum-inputmode-subscriptionbody-vtbl"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-option-const-enum-inputmode-subscriptionbody-vtbl" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;::SubscriptionBody_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Option const &amp;,enum InputMode)&gt;::SubscriptionBody_vtbl
{
  void (__fastcall *~SubscriptionBodyInterface)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  const Bedrock::PubSub::SubscriptionContext *(__fastcall *_getContext)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  void (__fastcall *_disconnect)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this, std::shared_ptr&lt;Bedrock::PubSub::Detail::SubscriptionBodyInterface&gt; *);
};

</code></pre></div><h3 id="bedrock-pubsub-detail-dispatcher-bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-bool-void-void-bool"><a href="#bedrock-pubsub-detail-dispatcher-bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-bool-void-void-bool" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;,void,void,bool &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;,void,void,bool &amp;&gt;
{
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-bool"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-bool" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt; : Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;,void,void,bool &amp;&gt;
{
  std::list&lt;std::shared_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;::SubscriptionBody&gt;&gt; mSubscriptions;
  std::mutex mMutex;
  std::weak_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;::SubscriptionBody&gt; mSingleSubscriber;
  std::atomic&lt;unsigned __int64&gt; mSubscriberCount;
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-bool-subscriptionbody"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-bool-subscriptionbody" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;::SubscriptionBody</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;::SubscriptionBody : Bedrock::PubSub::Detail::SubscriptionBodyInterface
{
  Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt; *mOwner;
  std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;std::shared_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;::SubscriptionBody&gt; &gt; &gt; &gt; mIterator;
  std::function&lt;void __cdecl(bool &amp;)&gt; mFunction;
  std::unique_ptr&lt;Bedrock::PubSub::SubscriptionContext&gt; mContext;
  int mGroup;
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-bool-subscriptionbody-vtbl"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-bool-subscriptionbody-vtbl" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;::SubscriptionBody_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;::SubscriptionBody_vtbl
{
  void (__fastcall *~SubscriptionBodyInterface)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  const Bedrock::PubSub::SubscriptionContext *(__fastcall *_getContext)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  void (__fastcall *_disconnect)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this, std::shared_ptr&lt;Bedrock::PubSub::Detail::SubscriptionBodyInterface&gt; *);
};

</code></pre></div><h3 id="bedrock-pubsub-publisher-void-cdecl-bool-bedrock-pubsub-threadmodel-multithreaded-void"><a href="#bedrock-pubsub-publisher-void-cdecl-bool-bedrock-pubsub-threadmodel-multithreaded-void" class="header-anchor">#</a> <code>Bedrock::PubSub::Publisher&lt;void __cdecl(bool &amp;),Bedrock::PubSub::ThreadModel::MultiThreaded,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Publisher&lt;void __cdecl(bool &amp;),Bedrock::PubSub::ThreadModel::MultiThreaded,void&gt; : Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(bool &amp;)&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-string"><a href="#bedrock-threading-iasyncresult-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::IAsyncResult&lt;std::string &gt; : Bedrock::Threading::AsyncBase
{
  Bedrock::Threading::IAsyncResult&lt;std::string &gt;_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-string-vtbl"><a href="#bedrock-threading-iasyncresult-std-string-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::string &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::IAsyncResult&lt;std::string &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::string &gt;)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::exception_ptr *result);
  std::string *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::string *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::string &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-vector-resourcepath"><a href="#bedrock-threading-iasyncresult-std-vector-resourcepath" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; : Bedrock::Threading::AsyncBase
{
  Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt;_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-vector-resourcepath-vtbl"><a href="#bedrock-threading-iasyncresult-std-vector-resourcepath-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt;)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; *this, std::exception_ptr *result);
  std::vector&lt;ResourcePath&gt; *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; *this, std::vector&lt;ResourcePath&gt; *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::vector&lt;ResourcePath&gt; &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-shared-ptr-mce-image"><a href="#bedrock-threading-iasyncresult-std-shared-ptr-mce-image" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; : Bedrock::Threading::AsyncBase
{
  Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt;_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-shared-ptr-mce-image-vtbl"><a href="#bedrock-threading-iasyncresult-std-shared-ptr-mce-image-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt;)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this, std::exception_ptr *result);
  std::shared_ptr&lt;mce::Image&gt; *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this, std::shared_ptr&lt;mce::Image&gt; *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;mce::Image&gt; &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-bool"><a href="#bedrock-threading-iasyncresult-bool" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::IAsyncResult&lt;bool&gt; : Bedrock::Threading::AsyncBase
{
  Bedrock::Threading::IAsyncResult&lt;bool&gt;_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-bool-vtbl"><a href="#bedrock-threading-iasyncresult-bool-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;bool&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::IAsyncResult&lt;bool&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;bool&gt;)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this, std::exception_ptr *result);
  bool (__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;bool&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;bool&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="baselightdata"><a href="#baselightdata" class="header-anchor">#</a> <code>BaseLightData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseLightData
{
  BaseLightData_vtbl *__vftable /*VFT*/;
  mce::Color mSunriseColor;
  float mGamma;
  float mSkyDarken;
  AutomaticID&lt;Dimension,int&gt; mDimensionType;
  float mDarkenWorldAmount;
  float mPreviousDarkenWorldAmount;
  bool mNightvisionActive;
  float mNightvisionScale;
  bool mUnderwaterVision;
  float mUnderwaterScale;
  int mSkyFlashTime;
};

</code></pre></div><h3 id="baselightdata-vtbl"><a href="#baselightdata-vtbl" class="header-anchor">#</a> <code>BaseLightData_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseLightData_vtbl
{
  bool (__fastcall *operator==)(BaseLightData *this, const BaseLightData *);
  void (__fastcall *~BaseLightData)(BaseLightData *this);
};

</code></pre></div><h3 id="biomechunkstate"><a href="#biomechunkstate" class="header-anchor">#</a> <code>BiomeChunkState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeChunkState
{
  unsigned __int8 snowLevel;
};

</code></pre></div><h3 id="buffer-span-pos"><a href="#buffer-span-pos" class="header-anchor">#</a> <code>buffer_span&lt;Pos&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;Pos&gt;
{
  const Pos *mBegin;
  const Pos *mEnd;
};

</code></pre></div><h3 id="buffer-span-unsigned-int"><a href="#buffer-span-unsigned-int" class="header-anchor">#</a> <code>buffer_span&lt;unsigned int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;unsigned int&gt;
{
  const unsigned int *mBegin;
  const unsigned int *mEnd;
};

</code></pre></div><h3 id="blockeventlistener"><a href="#blockeventlistener" class="header-anchor">#</a> <code>BlockEventListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventListener
{
  BlockEventListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="blocksourcehandle"><a href="#blocksourcehandle" class="header-anchor">#</a> <code>BlockSourceHandle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockSourceHandle : BlockSourceListener
{
  BlockSource *mSource;
};

</code></pre></div><h3 id="blockeventlistener-vtbl"><a href="#blockeventlistener-vtbl" class="header-anchor">#</a> <code>BlockEventListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockEventListener_vtbl
{
  void (__fastcall *~BlockEventListener)(BlockEventListener *this);
  EventResult (__fastcall *onBlockPlacedByPlayer)(BlockEventListener *this, Player *, const Block *, const BlockPos *, bool);
  EventResult (__fastcall *onBlockDestroyedByPlayer)(BlockEventListener *this, Player *, const std::string, const BlockPos *);
  EventResult (__fastcall *onBlockMovedByPiston)(BlockEventListener *this, const BlockPos *, const BlockPos *, const PistonBlockActor::PistonState);
  EventResult (__fastcall *onBlockDestructionStopped)(BlockEventListener *this, Player *, const BlockPos *, int);
  EventResult (__fastcall *onBlockDestructionStarted)(BlockEventListener *this, Player *, const BlockPos *);
  EventResult (__fastcall *onBlockInteractedWith)(BlockEventListener *this, Player *, const BlockPos *);
  EventResult (__fastcall *onBlockExploded)(BlockEventListener *this, const BlockPos *, const Block *, Actor *);
  EventResult (__fastcall *onBlockModified)(BlockEventListener *this, const BlockPos *, const Block *, const Block *);
  EventResult (__fastcall *onChestBlockTryPaired)(BlockEventListener *this, const ChestBlockTryPairEvent *);
  EventResult (__fastcall *onUnknownBlockReceived)(BlockEventListener *this, Level *, const NewBlockID *, unsigned __int16);
};

</code></pre></div><h3 id="biomeregistry"><a href="#biomeregistry" class="header-anchor">#</a> <code>BiomeRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry : IEntityRegistryOwner
{
  WellKnownBiomeTags mWellKnownBiomeTags;
  std::unordered_map&lt;AutomaticID&lt;Dimension,int&gt;,unsigned int,std::hash&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::equal_to&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::allocator&lt;std::pair&lt;AutomaticID&lt;Dimension,int&gt; const ,unsigned int&gt; &gt; &gt; mDimensionNextId;
  std::unordered_map&lt;AutomaticID&lt;Dimension,int&gt;,std::vector&lt;std::unique_ptr&lt;Biome&gt;&gt;,std::hash&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::equal_to&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::allocator&lt;std::pair&lt;AutomaticID&lt;Dimension,int&gt; const ,std::vector&lt;std::unique_ptr&lt;Biome&gt;&gt; &gt; &gt; &gt; mDimensionBiomes;
  std::vector&lt;std::unique_ptr&lt;Biome&gt;&gt; mBiomes;
  OwnerPtrT&lt;EntityRegistryRefTraits&gt; mEntities;
  unsigned int mNextId;
  std::atomic&lt;bool&gt; mClosedForRegistration;
  bool mLoadFromPacks;
  TagRegistry&lt;IDType&lt;BiomeTagIDType&gt;,IDType&lt;BiomeTagSetIDType&gt; &gt; mTagRegistry;
  Biome *mEmptyBiome;
  std::unique_ptr&lt;JsonDefinitionUpgrader::IJsonDefinitionUpgrader&gt; mBiomeDefinitionUpgrader;
};

</code></pre></div><h3 id="biome-vtbl"><a href="#biome-vtbl" class="header-anchor">#</a> <code>Biome_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Biome_vtbl
{
  void (__fastcall *~Biome)(Biome *this);
};

</code></pre></div><h3 id="biomeregistry-vtbl"><a href="#biomeregistry-vtbl" class="header-anchor">#</a> <code>BiomeRegistry_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BiomeRegistry_vtbl
{
  OwnerPtrT&lt;EntityRegistryRefTraits&gt; *(__fastcall *getEntityRegistry)(IEntityRegistryOwner *this);
  void (__fastcall *~BiomeRegistry)(BiomeRegistry *this);
};

</code></pre></div><h3 id="bedrock-logendpoint"><a href="#bedrock-logendpoint" class="header-anchor">#</a> <code>Bedrock::LogEndPoint</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::LogEndPoint
{
  Bedrock::LogEndPoint_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-logendpoint-vtbl"><a href="#bedrock-logendpoint-vtbl" class="header-anchor">#</a> <code>Bedrock::LogEndPoint_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::LogEndPoint_vtbl
{
  void (__fastcall *~LogEndPoint)(Bedrock::LogEndPoint *this);
  void (__fastcall *log)(Bedrock::LogEndPoint *this, const char *);
  void (__fastcall *flush)(Bedrock::LogEndPoint *this);
  void (__fastcall *setEnabled)(Bedrock::LogEndPoint *this, bool);
  bool (__fastcall *isEnabled)(Bedrock::LogEndPoint *this);
};

</code></pre></div><h3 id="bedrock-nonownerpointer-textfilteringprocessor"><a href="#bedrock-nonownerpointer-textfilteringprocessor" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;TextFilteringProcessor&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;TextFilteringProcessor&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-threading-enablequeueformainthread"><a href="#bedrock-threading-enablequeueformainthread" class="header-anchor">#</a> <code>Bedrock::Threading::EnableQueueForMainThread</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::EnableQueueForMainThread
{
  Bedrock::Threading::EnableQueueForMainThread_vtbl *__vftable /*VFT*/;
  std::unique_ptr&lt;TaskGroup&gt; mQueueForMainThreadTaskGroup;
};

</code></pre></div><h3 id="bedrock-threading-enablequeueformainthread-vtbl"><a href="#bedrock-threading-enablequeueformainthread-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::EnableQueueForMainThread_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::EnableQueueForMainThread_vtbl
{
  void (__fastcall *~EnableQueueForMainThread)(Bedrock::Threading::EnableQueueForMainThread *this);
};

</code></pre></div><h3 id="bedrock-threading-counttracker"><a href="#bedrock-threading-counttracker" class="header-anchor">#</a> <code>Bedrock::Threading::CountTracker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::CountTracker
{
  std::atomic&lt;unsigned int&gt; mCount;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-textureatlas"><a href="#bedrock-nonownerpointer-textureatlas" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;TextureAtlas&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;TextureAtlas&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="basecontainermenu"><a href="#basecontainermenu" class="header-anchor">#</a> <code>BaseContainerMenu</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BaseContainerMenu : ContainerContentChangeListener, IContainerManager
{
  Player *mPlayer;
  std::vector&lt;ItemStack&gt; mLastSlots;
  ContainerID mContainerId;
  ContainerType mContainerType;
};

</code></pre></div><h3 id="basecontainermenu-vtbl"><a href="#basecontainermenu-vtbl" class="header-anchor">#</a> <code>BaseContainerMenu_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseContainerMenu_vtbl
{
  void (__fastcall *containerContentChanged)(ContainerContentChangeListener *this, int);
  void (__fastcall *~ContainerContentChangeListener)(ContainerContentChangeListener *this);
  void (__fastcall *containerAddCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *containerRemoveCallback)(ContainerContentChangeListener *this, Container *);
  void (__fastcall *removeSlot)(BaseContainerMenu *this, int, int);
  bool (__fastcall *isSlotDirty)(BaseContainerMenu *this, int);
  bool (__fastcall *isResultSlot)(BaseContainerMenu *this, int);
  Container *(__fastcall *_getContainer)(BaseContainerMenu *this);
};

</code></pre></div><h3 id="bedrock-nonownerpointer-storecatalogconfig"><a href="#bedrock-nonownerpointer-storecatalogconfig" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;StoreCatalogConfig&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;StoreCatalogConfig&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-uieventcoordinator"><a href="#bedrock-nonownerpointer-uieventcoordinator" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;UIEventCoordinator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;UIEventCoordinator&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="basescreen"><a href="#basescreen" class="header-anchor">#</a> <code>BaseScreen</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseScreen : AbstractScene
{
  int mWidth;
  int mHeight;
  bool mShouldSendEvents;
  bool mWantsTextOnly;
  bool mIsPopped;
  bool mShowingModUI;
  std::unique_ptr&lt;AbstractScreenSetupCleanupStrategy&gt; mScreenSetupCleanup;
};

</code></pre></div><h3 id="basescreen-vtbl"><a href="#basescreen-vtbl" class="header-anchor">#</a> <code>BaseScreen_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseScreen_vtbl
{
  void (__fastcall *~AbstractScene)(AbstractScene *this);
  void (__fastcall *OnMessage)(AbstractScene *this, UIMessage, std::string, std::vector&lt;std::shared_ptr&lt;MessageParam&gt;&gt;);
  std::shared_ptr&lt;UIControl&gt; *(__fastcall *getRootControl)(AbstractScene *this, std::shared_ptr&lt;UIControl&gt; *result);
  std::shared_ptr&lt;UIControlFactory&gt; *(__fastcall *getControlFactory)(AbstractScene *this, std::shared_ptr&lt;UIControlFactory&gt; *result);
  bool (__fastcall *isShowingModUI)(AbstractScene *this);
  void (__fastcall *setIsShowingModUI)(AbstractScene *this, bool);
  bool (__fastcall *isUIScene)(AbstractScene *this);
  void (__fastcall *init)(AbstractScene *this, const ScreenSizeData *);
  void (__fastcall *setSize)(AbstractScene *this, const ScreenSizeData *);
  void (__fastcall *onSetKeyboardHeight)(AbstractScene *this, float);
  void (__fastcall *onInternetUpdate)(AbstractScene *this);
  std::vector&lt;RectangleArea&gt; *(__fastcall *getInputAreas)(AbstractScene *this, std::vector&lt;RectangleArea&gt; *result);
  void (__fastcall *onFocusGained)(AbstractScene *this);
  void (__fastcall *onFocusLost)(AbstractScene *this);
  void (__fastcall *terminate)(AbstractScene *this);
  void (__fastcall *onCreation)(AbstractScene *this);
  void (__fastcall *onLeave)(AbstractScene *this);
  void (__fastcall *onGameEventNotification)(AbstractScene *this, ui::GameEventNotification);
  void (__fastcall *_handleDirtyVisualTree)(AbstractScene *this, bool);
  void (__fastcall *leaveScreen)(AbstractScene *this);
  void (__fastcall *tick)(AbstractScene *this, int, int);
  void (__fastcall *updateEvents)(AbstractScene *this);
  void (__fastcall *applyInput)(AbstractScene *this, float);
  void (__fastcall *update)(AbstractScene *this, long double);
  void (__fastcall *frameUpdate)(AbstractScene *this, MinecraftUIFrameUpdateContext *);
  void (__fastcall *preRenderUpdate)(AbstractScene *this, ScreenContext *);
  void (__fastcall *prepareFrame)(AbstractScene *this, ScreenContext *);
  void (__fastcall *render)(AbstractScene *this, ScreenContext *, const FrameRenderObject *);
  void (__fastcall *postRenderUpdate)(AbstractScene *this, ScreenContext *);
  void (__fastcall *setupAndRender)(AbstractScene *this, ScreenContext *);
  void (__fastcall *handleInputModeChanged)(AbstractScene *this, InputMode);
  void (__fastcall *handleHoloInputModeChanged)(AbstractScene *this, HoloUIInputMode);
  void (__fastcall *handleButtonPress)(AbstractScene *this, unsigned int, FocusImpact);
  void (__fastcall *handleButtonRelease)(AbstractScene *this, unsigned int, FocusImpact);
  void (__fastcall *handleRawInputEvent)(AbstractScene *this, int, RawInputType, ButtonState, bool);
  bool (__fastcall *handlePointerLocation)(AbstractScene *this, const PointerLocationEventData *, FocusImpact);
  void (__fastcall *handlePointerPressed)(AbstractScene *this, bool);
  void (__fastcall *handleDirection)(AbstractScene *this, DirectionId, float, float, FocusImpact);
  bool (__fastcall *handleBackEvent)(AbstractScene *this, bool);
  void (__fastcall *handleTextChar)(AbstractScene *this, const std::string *, bool, FocusImpact);
  void (__fastcall *handleCaretLocation)(AbstractScene *this, int, FocusImpact);
  void (__fastcall *setTextboxText)(AbstractScene *this, const std::string *);
  void (__fastcall *onKeyboardDismissed)(AbstractScene *this);
  void (__fastcall *onKeyboardDisabled)(AbstractScene *this);
  void (__fastcall *handleLicenseChanged)(AbstractScene *this);
  void (__fastcall *handleIdentityGained)(AbstractScene *this);
  void (__fastcall *handleIdentityLost)(AbstractScene *this);
  void (__fastcall *handleGazeGestureInput)(AbstractScene *this, __int16, float, float, float, FocusImpact);
  void (__fastcall *handleDictationEvent)(AbstractScene *this, const std::string *);
  void (__fastcall *handleCommandEvent)(AbstractScene *this, const VoiceCommand *);
  bool (__fastcall *renderGameBehind)(AbstractScene *this);
  bool (__fastcall *absorbsInput)(AbstractScene *this);
  bool (__fastcall *closeOnPlayerHurt)(AbstractScene *this);
  bool (__fastcall *isModal)(AbstractScene *this);
  bool (__fastcall *isShowingMenu)(AbstractScene *this);
  bool (__fastcall *shouldStealMouse)(AbstractScene *this);
  bool (__fastcall *screenIsNotFlushable)(AbstractScene *this);
  bool (__fastcall *alwaysAcceptsInput)(AbstractScene *this);
  bool (__fastcall *screenDrawsLast)(AbstractScene *this);
  bool (__fastcall *isPlayScreen)(AbstractScene *this);
  bool (__fastcall *renderOnlyWhenTopMost)(AbstractScene *this);
  bool (__fastcall *lowFreqRendering)(AbstractScene *this);
  bool (__fastcall *ignoreAsTop)(AbstractScene *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(AbstractScene *this);
  bool (__fastcall *shouldUpdateWhenSuspended)(AbstractScene *this);
  int (__fastcall *getWidth)(AbstractScene *this);
  int (__fastcall *getHeight)(AbstractScene *this);
  void (__fastcall *reload)(AbstractScene *this);
  const RectangleArea *(__fastcall *getRenderingAABB)(AbstractScene *this);
  EyeRenderingModeBit (__fastcall *getEyeRenderingMode)(AbstractScene *this);
  ui::SceneType (__fastcall *getSceneType)(AbstractScene *this);
  std::string *(__fastcall *getScreenName)(AbstractScene *this, std::string *result);
  std::string *(__fastcall *getRoute)(AbstractScene *this, std::string *result);
  std::string *(__fastcall *getScreenTelemetryName)(AbstractScene *this, std::string *result);
  void (__fastcall *addEventProperties)(AbstractScene *this, std::unordered_map&lt;std::string,std::string&gt; *);
  int (__fastcall *getScreenVersion)(AbstractScene *this);
  void (__fastcall *processBufferedTextCharEvents)(AbstractScene *this, const std::vector&lt;TextCharEventData&gt; *);
  bool (__fastcall *getShouldSendEvents)(AbstractScene *this);
  void (__fastcall *setShouldSendEvents)(AbstractScene *this, bool);
  bool (__fastcall *getWantsTextOnly)(AbstractScene *this);
  void (__fastcall *setWantsTextOnly)(AbstractScene *this, bool);
  void (__fastcall *onDelete)(AbstractScene *this, CachedScenes *, TaskGroup *);
  bool (__fastcall *isGamepadCursorEnabled)(AbstractScene *this);
  bool (__fastcall *isGamepadDeflectionModeEnabled)(AbstractScene *this);
  const glm::tvec2&lt;float,0&gt; *(__fastcall *getGamepadCursorPosition)(AbstractScene *this);
  void (__fastcall *cleanInputComponents)(AbstractScene *this);
  std::weak_ptr&lt;AbstractSceneProxy&gt; *(__fastcall *getProxy)(AbstractScene *this, std::weak_ptr&lt;AbstractSceneProxy&gt; *result);
  bool (__fastcall *canBePushed)(AbstractScene *this);
  bool (__fastcall *canBePopped)(AbstractScene *this);
  bool (__fastcall *canBeTransitioned)(AbstractScene *this);
  void (__fastcall *onScreenExit)(AbstractScene *this, bool, bool);
  void (__fastcall *onScreenEntrance)(AbstractScene *this, bool, bool);
  bool (__fastcall *isEntering)(AbstractScene *this);
  bool (__fastcall *isExiting)(AbstractScene *this);
  void (__fastcall *schedulePop)(AbstractScene *this);
  bool (__fastcall *isTerminating)(AbstractScene *this);
  bool (__fastcall *loadScreenImmediately)(AbstractScene *this);
  bool (__fastcall *forceUpdateActiveSceneStackWhenPushed)(AbstractScene *this);
  bool (__fastcall *hasFinishedLoading)(AbstractScene *this);
  void (__fastcall *sendScreenEvent)(AbstractScene *this, const std::string *, const std::string *);
  void (__fastcall *setDebugFeature)(AbstractScene *this, UIDebugCommandFeature, bool);
  void (__fastcall *setScreenState)(AbstractScene *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *setupForRendering)(BaseScreen *this, ScreenContext *);
  void (__fastcall *cleanupForRendering)(BaseScreen *this, ScreenContext *);
  void (__fastcall *setScreenSetupCleanup)(BaseScreen *this, std::unique_ptr&lt;AbstractScreenSetupCleanupStrategy&gt;);
};

</code></pre></div><h3 id="bedrock-nonownerpointer-personaservice"><a href="#bedrock-nonownerpointer-personaservice" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;PersonaService&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;PersonaService&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-filearchiver"><a href="#bedrock-nonownerpointer-filearchiver" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;FileArchiver&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;FileArchiver&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-void"><a href="#bedrock-threading-asyncdeferredresultt-void" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncDeferredResultT&lt;void&gt; : Bedrock::Threading::IAsyncResult&lt;void&gt;
{
  std::mutex mLock;
  Bedrock::Threading::AsyncDeferredResultT&lt;void&gt;::DelayStatus mStatus;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;&gt; mComplete;
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-void-vtbl"><a href="#bedrock-threading-asyncdeferredresultt-void-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;void&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncDeferredResultT&lt;void&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="baseactorrenderer"><a href="#baseactorrenderer" class="header-anchor">#</a> <code>BaseActorRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseActorRenderer : ActorShaderManager
{
  mce::MaterialPtr mNameTagMat;
  mce::MaterialPtr mDepthTestedNameTagMat;
  mce::MaterialPtr mDepthTestedNameTextMat;
  mce::MaterialPtr mDepthTestedHealthMat;
};

</code></pre></div><h3 id="baseactorrenderer-vtbl"><a href="#baseactorrenderer-vtbl" class="header-anchor">#</a> <code>BaseActorRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseActorRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
};

</code></pre></div><h3 id="blockactorrenderdata"><a href="#blockactorrenderdata" class="header-anchor">#</a> <code>BlockActorRenderData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockActorRenderData
{
  BlockSource *renderSource;
  BlockActor *entity;
  const Block *block;
  const Vec3 *position;
  const mce::MaterialPtr *forcedMat;
  const mce::ClientTexture forcedTex;
  int breakingAmount;
  const dragon::RenderMetadata actorRenderMetadata;
};

</code></pre></div><h3 id="blockactorrenderer"><a href="#blockactorrenderer" class="header-anchor">#</a> <code>BlockActorRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockActorRenderer : BaseActorRenderer
{
};

</code></pre></div><h3 id="blockactorrenderer-vtbl"><a href="#blockactorrenderer-vtbl" class="header-anchor">#</a> <code>BlockActorRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockActorRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  void (__fastcall *renderAlpha)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  std::vector&lt;NameTagRenderObject&gt; *(__fastcall *extractText)(BlockActorRenderer *this, std::vector&lt;NameTagRenderObject&gt; *result, Tessellator *, BlockActor *, const std::string *, const std::vector&lt;int&gt; *, Vec3, bool);
};

</code></pre></div><h3 id="boneanimationchannel"><a href="#boneanimationchannel" class="header-anchor">#</a> <code>BoneAnimationChannel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BoneAnimationChannel
{
  BoneTransformType mBoneTransformType;
  std::vector&lt;KeyFrameTransform&gt; mKeyFrames;
};

</code></pre></div><h3 id="boneanimation"><a href="#boneanimation" class="header-anchor">#</a> <code>BoneAnimation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BoneAnimation
{
  HashedString mBoneName;
  std::vector&lt;BoneAnimationChannel&gt; mAnimationChannels;
  _BYTE mRotationRelativeMode[4];
};

</code></pre></div><h3 id="buffer-span-std-string"><a href="#buffer-span-std-string" class="header-anchor">#</a> <code>buffer_span&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;std::string &gt;
{
  const std::string *mBegin;
  const std::string *mEnd;
};

</code></pre></div><h3 id="blockactorrenderdispatcher"><a href="#blockactorrenderdispatcher" class="header-anchor">#</a> <code>BlockActorRenderDispatcher</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockActorRenderDispatcher
{
  std::map&lt;enum BlockActorRendererId,std::unique_ptr&lt;BlockActorRenderer&gt;&gt; mRenderers;
  std::vector&lt;std::function&lt;void __cdecl(ActorResourceDefinitionGroup const &amp;,mce::TextureGroup *)&gt;&gt; mGameSpecificRegistrationCallbacks;
};

</code></pre></div><h3 id="blocktessellator-uvoverride"><a href="#blocktessellator-uvoverride" class="header-anchor">#</a> <code>BlockTessellator::UVOverride</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTessellator::UVOverride
{
  unsigned __int16 pbrTextureDataHandle;
  float u0;
  float u1;
  float v0;
  float v1;
};

</code></pre></div><h3 id="blockgraphics-vtbl"><a href="#blockgraphics-vtbl" class="header-anchor">#</a> <code>BlockGraphics_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockGraphics_vtbl
{
  void (__fastcall *~BlockGraphics)(BlockGraphics *this);
  int (__fastcall *getIconYOffset)(BlockGraphics *this);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockGraphics *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColor)(BlockGraphics *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColor)(BlockGraphics *this, int);
  int (__fastcall *getColorForParticle)(BlockGraphics *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *isSeasonTinted)(BlockGraphics *this, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockGraphics *this, bool, bool);
  int (__fastcall *getExtraRenderLayers)(BlockGraphics *this);
  const AABB *(__fastcall *getVisualShape)(BlockGraphics *this, unsigned __int16, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockGraphics *this, const Block *, AABB *, bool);
  const TextureUVCoordinateSet *(__fastcall *getCarriedTexture)(BlockGraphics *this, unsigned __int64, int);
  void (__fastcall *animateTick)(BlockGraphics *this, BlockSource *, const BlockPos *, Random *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockGraphics *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockGraphics *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *setVisualShape)(BlockGraphics *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockGraphics *this, const AABB *);
};

</code></pre></div><h3 id="blockgeometry-element"><a href="#blockgeometry-element" class="header-anchor">#</a> <code>BlockGeometry::Element</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGeometry::Element
{
  std::string mName;
  std::string mParent;
  glm::tvec3&lt;float,0&gt; mPivot;
  glm::tvec3&lt;float,0&gt; mRotation;
  std::vector&lt;BlockGeometry::ElementBox&gt; mBoxes;
};

</code></pre></div><h3 id="blockgeometry-model"><a href="#blockgeometry-model" class="header-anchor">#</a> <code>BlockGeometry::Model</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj BlockGeometry::Model
{
  GameVersion mVersion;
  std::string mName;
  std::string mParent;
  std::vector&lt;BlockGeometry::Element&gt; mElements;
  std::unordered_map&lt;std::string,std::string&gt; mTextureMap;
  std::vector&lt;std::string&gt; mTextureList;
  std::vector&lt;std::string&gt; mTextureStack;
};

</code></pre></div><h3 id="blockgeometry-alignedface"><a href="#blockgeometry-alignedface" class="header-anchor">#</a> <code>BlockGeometry::AlignedFace</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGeometry::AlignedFace
{
  std::array&lt;Vec3,4&gt; verts;
  std::array&lt;Vec2,4&gt; uvs;
  unsigned __int64 textureIndex;
};

</code></pre></div><h3 id="blockgeometry-orientedface"><a href="#blockgeometry-orientedface" class="header-anchor">#</a> <code>BlockGeometry::OrientedFace</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGeometry::OrientedFace
{
  std::array&lt;Vec3,4&gt; verts;
  std::array&lt;Vec2,4&gt; uvs;
  Vec3 norm;
  unsigned __int64 textureIndex;
};

</code></pre></div><h3 id="blockgeometry-tessellatedmodel-occlusion"><a href="#blockgeometry-tessellatedmodel-occlusion" class="header-anchor">#</a> <code>BlockGeometry::TessellatedModel::Occlusion</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct BlockGeometry::TessellatedModel::Occlusion
{
  std::array&lt;unsigned char,8&gt; blocking;
  std::array&lt;unsigned char,8&gt; visible;
};

</code></pre></div><h3 id="blockgeometry-tessellatedmodel"><a href="#blockgeometry-tessellatedmodel" class="header-anchor">#</a> <code>BlockGeometry::TessellatedModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj BlockGeometry::TessellatedModel
{
  std::array&lt;AABB,4&gt; mAABoxes;
  std::array&lt;std::vector&lt;BlockGeometry::AlignedFace&gt;,6&gt; mEdgeSet;
  std::array&lt;std::vector&lt;BlockGeometry::AlignedFace&gt;,6&gt; mAlignedSet;
  std::vector&lt;BlockGeometry::OrientedFace&gt; mOrientedSet;
  std::array&lt;BlockGeometry::TessellatedModel::Occlusion,6&gt; mOcclusion;
  std::array&lt;BlockGeometry::TessellatedModel::Occlusion,3&gt; mTopOcclusionRot;
  std::array&lt;BlockGeometry::TessellatedModel::Occlusion,3&gt; mBotOcclusionRot;
  std::vector&lt;std::string&gt; mTextureNames;
};

</code></pre></div><h3 id="blockgraphics-modelitem"><a href="#blockgraphics-modelitem" class="header-anchor">#</a> <code>BlockGraphics::ModelItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGraphics::ModelItem
{
  std::string name;
  const BlockGeometry::TessellatedModel *model;
  std::vector&lt;unsigned __int64&gt; textureIndices;
};

</code></pre></div><h3 id="blocktessellatorcache"><a href="#blocktessellatorcache" class="header-anchor">#</a> <code>BlockTessellatorCache</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTessellatorCache
{
  BlockPos mPos;
  BlockSource *mRegion;
  std::array&lt;BrightnessPair,8000&gt; mLightColors;
  std::array&lt;Block const *,8000&gt; mBlocks;
  std::array&lt;Block const *,8000&gt; mExtraBlocks;
  std::array&lt;BlockGraphics const *,8000&gt; mBlockGraphics[2];
};

</code></pre></div><h3 id="blocktessellator-aocblockfacedata"><a href="#blocktessellator-aocblockfacedata" class="header-anchor">#</a> <code>BlockTessellator::AocBlockFaceData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTessellator::AocBlockFaceData
{
  std::array&lt;mce::Color,4&gt; aocCL;
  std::array&lt;mce::Color,4&gt; aocCH;
  std::array&lt;Vec2,4&gt; aocUVL;
  std::array&lt;Vec2,4&gt; aocUVH;
};

</code></pre></div><h3 id="blocktessellatorcustomextradata-flowerpotdata"><a href="#blocktessellatorcustomextradata-flowerpotdata" class="header-anchor">#</a> <code>BlockTessellatorCustomExtraData::FlowerPotData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTessellatorCustomExtraData::FlowerPotData
{
  const Block *mPlant;
};

</code></pre></div><h3 id="blocktessellator"><a href="#blocktessellator" class="header-anchor">#</a> <code>BlockTessellator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTessellator
{
  bool mRenderingExtra;
  bool mUseNormals;
  BlockSource *mRegion;
  TextureUVCoordinateSet mFixedTexture;
  bool mUseFixedTexture;
  bool mUseOccluder;
  bool _tmpUseRegion;
  bool mXFlipTexture;
  int mRenderingLayer;
  bool mRenderingGUI;
  bool mUsePBRFormats;
  bool mShouldEmitPointLights;
  bool mUseFixedColor;
  std::array&lt;mce::Color,6&gt; mFixedColors;
  bool mApplyAmbientOcclusion;
  __declspec(align(4)) _BYTE mBakedLighting[4];
  bool mForExport;
  mce::Color mAoColors[8];
  BrightnessPair mTc[4];
  std::array&lt;enum Flip,6&gt; mFlipFace;
  std::array&lt;BlockTessellator::UVOverride,6&gt; mTextureOverride;
  const Block *mAmbientOcclusionCacheBlocks[125];
  mce::MaterialPtr mItemMat;
  AABB mCurrentShapeBB;
  bool mCurrentShapeSet;
  const Block *mCurrentShapeBlock;
  BlockPos mCurrentShapeBlockPos;
  float mCurrentScale;
  std::unordered_map&lt;unsigned int,mce::Mesh&gt; mBlockMeshes;
  std::unordered_map&lt;BlockTessellatorBlockInWorld,mce::Mesh&gt; mInWorldBlockMeshes;
  BlockTessellatorCache mBlockCache;
  std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; mCachedGetBlock;
  bool mForceOpaque;
  std::vector&lt;mce::PointLight&gt; mPointLights;
  std::array&lt;BlockTessellator::AocBlockFaceData,6&gt; mAocBlockData;
  BlockTessellatorCustomExtraData::Map mBlockExtraDataMap;
};

</code></pre></div><h3 id="blockqueueentry"><a href="#blockqueueentry" class="header-anchor">#</a> <code>BlockQueueEntry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockQueueEntry
{
  BlockPos pos;
  const Block *blockInfo;
};

</code></pre></div><h3 id="blockactordelayeddeletioninfo"><a href="#blockactordelayeddeletioninfo" class="header-anchor">#</a> <code>BlockActorDelayedDeletionInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockActorDelayedDeletionInfo
{
  std::shared_ptr&lt;BlockActor&gt; mBlockEntity;
  std::chrono::time_point&lt;std::chrono::steady_clock,std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; &gt; mExpirationTime;
  const Block *mBlock;
};

</code></pre></div><h3 id="bedrock-threading-burst-strategy-console"><a href="#bedrock-threading-burst-strategy-console" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Strategy::Console</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::Strategy::Console
{
  unsigned __int64 mPrimaryWorkerCount;
  unsigned __int64 mSecondaryWorkerCount;
};

</code></pre></div><h3 id="bedrock-threading-burst-details-lifetime"><a href="#bedrock-threading-burst-details-lifetime" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Details::Lifetime</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::Details::Lifetime
{
  std::atomic&lt;unsigned __int64&gt; mLifetime;
};

</code></pre></div><h3 id="bedrock-threading-burst-strategy-execution-greedyexecution"><a href="#bedrock-threading-burst-strategy-execution-greedyexecution" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution
{
};

</code></pre></div><h3 id="bedrock-threading-burst-details-workertask-bedrock-threading-burst-strategy-execution-greedyexecution"><a href="#bedrock-threading-burst-details-workertask-bedrock-threading-burst-strategy-execution-greedyexecution" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;
{
  const std::string mName;
  const unsigned int mPriority;
  const std::thread::id mAffinity;
  std::shared_ptr&lt;Bedrock::Threading::Burst::Details::Lifetime&gt; mCurrentLifetime;
  TaskGroup *mTaskGroup;
  const std::function&lt;TaskResult __cdecl(void)&gt; mCallback;
  Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution mExecutionStrategy;
};

</code></pre></div><h3 id="bedrock-threading-burst-workqueue-std-function-void-cdecl-std-nullptr-t-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution-taskgrouptasks"><a href="#bedrock-threading-burst-workqueue-std-function-void-cdecl-std-nullptr-t-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution-taskgrouptasks" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks
{
  TaskGroup mTaskGroup;
  std::vector&lt;std::unique_ptr&lt;Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;&gt;&gt; mTasks;
};

</code></pre></div><h3 id="bedrock-threading-burst-workqueue-std-function-void-cdecl-std-nullptr-t-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution"><a href="#bedrock-threading-burst-workqueue-std-function-void-cdecl-std-nullptr-t-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt; : Bedrock::Threading::Burst::Strategy::Console
{
  std::vector&lt;TaskGroup *&gt; mTaskGroups;
  const std::string mName;
  const unsigned int mPriority;
  std::function&lt;void __cdecl(std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt; &amp;&amp;)&gt; mPredicate;
  std::atomic&lt;unsigned __int64&gt; mTotalItems;
  MPMCQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt; &gt; mQueue;
  std::mutex mWaitMutex;
  std::condition_variable mWait;
  std::unique_ptr&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks,std::default_delete&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks&gt; &gt; mPrimaryGroup;
  std::vector&lt;std::unique_ptr&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks,std::default_delete&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks&gt; &gt;&gt; mSecondaryGroups;
  std::vector&lt;std::thread::id&gt; mAffinities;
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocalbase"><a href="#bedrock-threading-instancedthreadlocalbase" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocalBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::InstancedThreadLocalBase
{
};

</code></pre></div><h3 id="bedrock-intrusive-list-standard-operations-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void"><a href="#bedrock-intrusive-list-standard-operations-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void" class="header-anchor">#</a> <code>Bedrock::Intrusive::list_standard_operations&lt;Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list_standard_operations&lt;Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;
{
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-threadedframeconstantscontainer-std-allocator-threadedframeconstantscontainer-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void"><a href="#bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-threadedframeconstantscontainer-std-allocator-threadedframeconstantscontainer-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;
{
  Bedrock::Intrusive::list_base_hook&lt;void&gt; mSentinel;
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocal-threadedframeconstantscontainer-std-allocator-threadedframeconstantscontainer"><a href="#bedrock-threading-instancedthreadlocal-threadedframeconstantscontainer-std-allocator-threadedframeconstantscontainer" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt; : Bedrock::Threading::InstancedThreadLocalBase
{
  std::function&lt;void __cdecl(ThreadedFrameConstantsContainer *)&gt; mConstructor;
  Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt; mItems;
  std::mutex mMutex;
  unsigned int mKey;
  bool mInitialized;
};

</code></pre></div><h3 id="bedrock-iislandcore"><a href="#bedrock-iislandcore" class="header-anchor">#</a> <code>Bedrock::IIslandCore</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::IIslandCore
{
  Bedrock::IIslandCore_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-activationarguments"><a href="#bedrock-activationarguments" class="header-anchor">#</a> <code>Bedrock::ActivationArguments</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(4)) Bedrock::ActivationArguments
{
  std::unordered_map&lt;std::string,std::string&gt; mArguments;
  std::string mProcessRegistrationKey;
  std::string mUrl;
  _BYTE mType[4];
  unsigned int mNumArgs;
  ARVRPlatform mARVRPlatform;
  bool mGenerateDocumentation;
  bool mDisablePauseMenuOnFocusLost;
};

</code></pre></div><h3 id="bedrock-iislandcore-vtbl"><a href="#bedrock-iislandcore-vtbl" class="header-anchor">#</a> <code>Bedrock::IIslandCore_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::IIslandCore_vtbl
{
  void (__fastcall *~IIslandCore)(Bedrock::IIslandCore *this);
  unsigned __int16 (__fastcall *getId)(Bedrock::IIslandCore *this);
  bool (__fastcall *start)(Bedrock::IIslandCore *this);
  bool (__fastcall *suspend)(Bedrock::IIslandCore *this);
  bool (__fastcall *resume)(Bedrock::IIslandCore *this);
  bool (__fastcall *stop)(Bedrock::IIslandCore *this);
  void (__fastcall *mainUpdate)(Bedrock::IIslandCore *this);
  void (__fastcall *processActivationArguments)(Bedrock::IIslandCore *this, const Bedrock::ActivationArguments *);
};

</code></pre></div><h3 id="bedrock-signalreceiver"><a href="#bedrock-signalreceiver" class="header-anchor">#</a> <code>Bedrock::SignalReceiver</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::SignalReceiver
{
  Bedrock::SignalReceiver_vtbl *__vftable /*VFT*/;
  std::vector&lt;moodycamel::ConcurrentQueue&lt;std::shared_ptr&lt;Bedrock::SignalBase&gt;,moodycamel::ConcurrentQueueDefaultTraits&gt;&gt; mSignalQueues;
  std::vector&lt;std::weak_ptr&lt;Bedrock::ISignalHandlerMap&gt;&gt; mHandlerMapVector;
  std::vector&lt;std::weak_ptr&lt;Bedrock::SignalRouteBase&gt;&gt; mRouteVector;
  unsigned __int16 mReceiverId;
};

</code></pre></div><h3 id="bedrock-signalreceiver-vtbl"><a href="#bedrock-signalreceiver-vtbl" class="header-anchor">#</a> <code>Bedrock::SignalReceiver_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::SignalReceiver_vtbl
{
  void (__fastcall *~SignalReceiver)(Bedrock::SignalReceiver *this);
};

</code></pre></div><h3 id="bedrock-isignalhandlermap"><a href="#bedrock-isignalhandlermap" class="header-anchor">#</a> <code>Bedrock::ISignalHandlerMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::ISignalHandlerMap
{
  Bedrock::ISignalHandlerMap_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-isignalhandlermap-vtbl"><a href="#bedrock-isignalhandlermap-vtbl" class="header-anchor">#</a> <code>Bedrock::ISignalHandlerMap_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::ISignalHandlerMap_vtbl
{
  void (__fastcall *~ISignalHandlerMap)(Bedrock::ISignalHandlerMap *this);
  bool (__fastcall *remove)(Bedrock::ISignalHandlerMap *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signalbase"><a href="#bedrock-signalbase" class="header-anchor">#</a> <code>Bedrock::SignalBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::SignalBase : std::enable_shared_from_this&lt;Bedrock::SignalBase&gt;
{
  Bedrock::SignalBase_vtbl *__vftable /*VFT*/;
  std::shared_ptr&lt;Bedrock::SignalRouteNode&gt; mNode;
  unsigned __int64 mCurrentPriority;
  bool mConsume;
};

</code></pre></div><h3 id="bedrock-signalbase-vtbl"><a href="#bedrock-signalbase-vtbl" class="header-anchor">#</a> <code>Bedrock::SignalBase_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::SignalBase_vtbl
{
  void (__fastcall *~SignalBase)(Bedrock::SignalBase *this);
  bool (__fastcall *invokeHandler)(Bedrock::SignalBase *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signalroutenode"><a href="#bedrock-signalroutenode" class="header-anchor">#</a> <code>Bedrock::SignalRouteNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::SignalRouteNode
{
  std::function&lt;void __cdecl(std::shared_ptr&lt;Bedrock::SignalBase&gt;)&gt; mHandler;
  Bedrock::SignalReceiver *mRcvr;
  unsigned __int64 mQueueIdx;
};

</code></pre></div><h3 id="bedrock-signalroutebase"><a href="#bedrock-signalroutebase" class="header-anchor">#</a> <code>Bedrock::SignalRouteBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::SignalRouteBase
{
  std::vector&lt;std::shared_ptr&lt;Bedrock::SignalRouteNode&gt;&gt; mNodes;
};

</code></pre></div><h3 id="bedrock-appisland"><a href="#bedrock-appisland" class="header-anchor">#</a> <code>Bedrock::AppIsland</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::AppIsland : Bedrock::IIslandCore
{
  std::unique_ptr&lt;Bedrock::SignalReceiver&gt; mSignalRcvr;
};

</code></pre></div><h3 id="bedrock-appisland-vtbl"><a href="#bedrock-appisland-vtbl" class="header-anchor">#</a> <code>Bedrock::AppIsland_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::AppIsland_vtbl
{
  void (__fastcall *~IIslandCore)(Bedrock::IIslandCore *this);
  unsigned __int16 (__fastcall *getId)(Bedrock::IIslandCore *this);
  bool (__fastcall *start)(Bedrock::IIslandCore *this);
  bool (__fastcall *suspend)(Bedrock::IIslandCore *this);
  bool (__fastcall *resume)(Bedrock::IIslandCore *this);
  bool (__fastcall *stop)(Bedrock::IIslandCore *this);
  void (__fastcall *mainUpdate)(Bedrock::IIslandCore *this);
  void (__fastcall *processActivationArguments)(Bedrock::IIslandCore *this, const Bedrock::ActivationArguments *);
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-boost-container-flat-map-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-less-dragon-mesh-vertexdeclmanager-impl-validationkey-boost-container-new-allocator-std-pair-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-allocator-boost-container-flat-map-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-less-dragon-mesh-vertexdeclmanager-impl-validationkey-boost-container-new-allocator-std-pair-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void"><a href="#bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-boost-container-flat-map-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-less-dragon-mesh-vertexdeclmanager-impl-validationkey-boost-container-new-allocator-std-pair-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-allocator-boost-container-flat-map-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-less-dragon-mesh-vertexdeclmanager-impl-validationkey-boost-container-new-allocator-std-pair-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt;,std::allocator&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt; &gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt;,std::allocator&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt; &gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;
{
  Bedrock::Intrusive::list_base_hook&lt;void&gt; mSentinel;
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocal-boost-container-flat-map-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-less-dragon-mesh-vertexdeclmanager-impl-validationkey-boost-container-new-allocator-std-pair-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-allocator-boost-container-flat-map-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-less-dragon-mesh-vertexdeclmanager-impl-validationkey-boost-container-new-allocator-std-pair-dragon-mesh-vertexdeclmanager-impl-validationkey-bool"><a href="#bedrock-threading-instancedthreadlocal-boost-container-flat-map-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-less-dragon-mesh-vertexdeclmanager-impl-validationkey-boost-container-new-allocator-std-pair-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-allocator-boost-container-flat-map-dragon-mesh-vertexdeclmanager-impl-validationkey-bool-std-less-dragon-mesh-vertexdeclmanager-impl-validationkey-boost-container-new-allocator-std-pair-dragon-mesh-vertexdeclmanager-impl-validationkey-bool" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt;,std::allocator&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) Bedrock::Threading::InstancedThreadLocal&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt;,std::allocator&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt; &gt; &gt; : Bedrock::Threading::InstancedThreadLocalBase
{
  std::function&lt;void __cdecl(boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt; *)&gt; mConstructor;
  Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt;,std::allocator&lt;boost::container::flat_map&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool,std::less&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey&gt;,boost::container::new_allocator&lt;std::pair&lt;dragon::mesh::VertexDeclManager::Impl::ValidationKey,bool&gt; &gt; &gt; &gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt; mItems;
  std::mutex mMutex;
  unsigned int mKey;
  bool mInitialized;
};

</code></pre></div><h3 id="bedrock-threading-burst-workqueue-std-function-void-cdecl-dragon-rendering-rendercontext-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution-taskgrouptasks"><a href="#bedrock-threading-burst-workqueue-std-function-void-cdecl-dragon-rendering-rendercontext-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution-taskgrouptasks" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks
{
  TaskGroup mTaskGroup;
  std::vector&lt;std::unique_ptr&lt;Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;&gt;&gt; mTasks;
};

</code></pre></div><h3 id="bedrock-threading-burst-workqueue-std-function-void-cdecl-dragon-rendering-rendercontext-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution"><a href="#bedrock-threading-burst-workqueue-std-function-void-cdecl-dragon-rendering-rendercontext-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt; : Bedrock::Threading::Burst::Strategy::Console
{
  std::vector&lt;TaskGroup *&gt; mTaskGroups;
  const std::string mName;
  const unsigned int mPriority;
  std::function&lt;void __cdecl(std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt; &amp;&amp;)&gt; mPredicate;
  std::atomic&lt;unsigned __int64&gt; mTotalItems;
  MPMCQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt; &gt; mQueue;
  std::mutex mWaitMutex;
  std::condition_variable mWait;
  std::unique_ptr&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks,std::default_delete&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks&gt; &gt; mPrimaryGroup;
  std::vector&lt;std::unique_ptr&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks,std::default_delete&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(dragon::rendering::RenderContext &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks&gt; &gt;&gt; mSecondaryGroups;
  std::vector&lt;std::thread::id&gt; mAffinities;
};

</code></pre></div><h3 id="bedrock-threading-burst-workqueue-std-function-void-cdecl-void-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution-taskgrouptasks"><a href="#bedrock-threading-burst-workqueue-std-function-void-cdecl-void-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution-taskgrouptasks" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(void)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(void)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks
{
  TaskGroup mTaskGroup;
  std::vector&lt;std::unique_ptr&lt;Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;&gt;&gt; mTasks;
};

</code></pre></div><h3 id="bedrock-threading-burst-workqueue-std-function-void-cdecl-void-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution"><a href="#bedrock-threading-burst-workqueue-std-function-void-cdecl-void-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(void)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(void)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt; : Bedrock::Threading::Burst::Strategy::Console
{
  std::vector&lt;TaskGroup *&gt; mTaskGroups;
  const std::string mName;
  const unsigned int mPriority;
  std::function&lt;void __cdecl(std::function&lt;void __cdecl(void)&gt; &amp;&amp;)&gt; mPredicate;
  std::atomic&lt;unsigned __int64&gt; mTotalItems;
  MPMCQueue&lt;std::function&lt;void __cdecl(void)&gt; &gt; mQueue;
  std::mutex mWaitMutex;
  std::condition_variable mWait;
  std::unique_ptr&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(void)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks,std::default_delete&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(void)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks&gt; &gt; mPrimaryGroup;
  std::vector&lt;std::unique_ptr&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(void)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks,std::default_delete&lt;Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(void)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::TaskGroupTasks&gt; &gt;&gt; mSecondaryGroups;
  std::vector&lt;std::thread::id&gt; mAffinities;
};

</code></pre></div><h3 id="bgfx-rtlightinfo"><a href="#bgfx-rtlightinfo" class="header-anchor">#</a> <code>bgfx::RtLightInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct bgfx::RtLightInfo
{
  unsigned __int16 mWorldSpacePosition[3];
  unsigned int packedData;
};

</code></pre></div><h3 id="bgfx-pbrtexturedata"><a href="#bgfx-pbrtexturedata" class="header-anchor">#</a> <code>bgfx::PBRTextureData</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::PBRTextureData
{
  float colourToMaterialUvScale[2];
  float colourToMaterialUvBias[2];
  float colourToNormalUvScale[2];
  float colourToNormalUvBias[2];
  int flags;
  float uniformRoughness;
  float uniformEmissive;
  float uniformMetalness;
  float maxMipColour;
  float maxMipMer;
  float maxMipNormalOrHeight;
  float pad;
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-contentlog-threadspecificdata-std-allocator-contentlog-threadspecificdata-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void"><a href="#bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-contentlog-threadspecificdata-std-allocator-contentlog-threadspecificdata-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;
{
  Bedrock::Intrusive::list_base_hook&lt;void&gt; mSentinel;
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocal-contentlog-threadspecificdata-std-allocator-contentlog-threadspecificdata"><a href="#bedrock-threading-instancedthreadlocal-contentlog-threadspecificdata-std-allocator-contentlog-threadspecificdata" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt; : Bedrock::Threading::InstancedThreadLocalBase
{
  std::function&lt;void __cdecl(ContentLog::ThreadSpecificData *)&gt; mConstructor;
  Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt; mItems;
  std::mutex mMutex;
  unsigned int mKey;
  bool mInitialized;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-resourcepackmanager"><a href="#bedrock-nonownerpointer-resourcepackmanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ResourcePackManager&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;ResourcePackManager&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-hbui-ilibrary"><a href="#bedrock-nonownerpointer-hbui-ilibrary" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;hbui::ILibrary&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;hbui::ILibrary&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-threading-details-pendingconditional"><a href="#bedrock-threading-details-pendingconditional" class="header-anchor">#</a> <code>Bedrock::Threading::Details::PendingConditional</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Details::PendingConditional : Bedrock::Threading::IAsyncResult&lt;void&gt;
{
  std::function&lt;bool __cdecl(void)&gt; mCondition;
  std::mutex mLock;
  Bedrock::Threading::Details::ConditionalState mState;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;&gt; mCallbacks;
};

</code></pre></div><h3 id="bedrock-threading-details-pendingconditional-vtbl"><a href="#bedrock-threading-details-pendingconditional-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::Details::PendingConditional_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::Details::PendingConditional_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-pendingconditionals"><a href="#bedrock-threading-pendingconditionals" class="header-anchor">#</a> <code>Bedrock::Threading::PendingConditionals</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::PendingConditionals : Bedrock::EnableNonOwnerReferences
{
  std::mutex mLock;
  std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::Details::PendingConditional&gt;&gt; mConditionals;
};

</code></pre></div><h3 id="bindingfactory-vtbl"><a href="#bindingfactory-vtbl" class="header-anchor">#</a> <code>BindingFactory_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BindingFactory_vtbl
{
  void (__fastcall *~BindingFactory)(BindingFactory *this);
  std::function&lt;bool __cdecl(void)&gt; *(__fastcall *getBooleanBinding)(BindingFactory *this, std::function&lt;bool __cdecl(void)&gt; *result, const std::string *);
  std::function&lt;std::string __cdecl(void)&gt; *(__fastcall *getStringBinding)(BindingFactory *this, std::function&lt;std::string __cdecl(void)&gt; *result, const std::string *);
  std::function&lt;glm::tvec2&lt;float,0&gt; __cdecl(void)&gt; *(__fastcall *getPointBinding)(BindingFactory *this, std::function&lt;glm::tvec2&lt;float,0&gt; __cdecl(void)&gt; *result, const std::string *);
  std::function&lt;RectangleArea __cdecl(void)&gt; *(__fastcall *getAreaBinding)(BindingFactory *this, std::function&lt;RectangleArea __cdecl(void)&gt; *result, const std::string *);
};

</code></pre></div><h3 id="bedrock-nonownerpointer-clientinstanceeventcoordinator"><a href="#bedrock-nonownerpointer-clientinstanceeventcoordinator" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ClientInstanceEventCoordinator&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;ClientInstanceEventCoordinator&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagesourcelistener"><a href="#bedrock-dynamicpackage-dynamicpackagesourcelistener" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageSourceListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::DynamicPackage::DynamicPackageSourceListener : Bedrock::EnableNonOwnerReferences
{
  Bedrock::DynamicPackage::DynamicPackageSourceListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagesourcelistener-vtbl"><a href="#bedrock-dynamicpackage-dynamicpackagesourcelistener-vtbl" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageSourceListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::DynamicPackage::DynamicPackageSourceListener_vtbl
{
  void (__fastcall *~DynamicPackageSourceListener)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this);
  void (__fastcall *onDownloadStarted)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this);
  void (__fastcall *onDownloadStateChanged)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this, bool, bool, bool, bool, bool, Bedrock::DynamicPackage::DownloadPausedReason, Bedrock::DynamicPackage::DownloadFailedReason);
  void (__fastcall *onDownloadProgress)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this, unsigned __int64, unsigned __int64, float, unsigned __int64);
  void (__fastcall *onMountStateChanged)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this, std::string, Bedrock::DynamicPackage::MountState);
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagesource"><a href="#bedrock-dynamicpackage-dynamicpackagesource" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageSource</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::DynamicPackage::DynamicPackageSource
{
  Bedrock::DynamicPackage::DynamicPackageSource_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-bedrock-dynamicpackage-dynamicpackagesourcelistener"><a href="#bedrock-nonownerpointer-bedrock-dynamicpackage-dynamicpackagesourcelistener" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Bedrock::DynamicPackage::DynamicPackageSourceListener&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;Bedrock::DynamicPackage::DynamicPackageSourceListener&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-checkfilesresult"><a href="#bedrock-dynamicpackage-checkfilesresult" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::CheckFilesResult</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct Bedrock::DynamicPackage::CheckFilesResult
{
  Bedrock::DynamicPackage::CheckFilesResult::Value value;
  unsigned __int64 fileSize;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagesource-vtbl"><a href="#bedrock-dynamicpackage-dynamicpackagesource-vtbl" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageSource_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::DynamicPackage::DynamicPackageSource_vtbl
{
  void (__fastcall *~DynamicPackageSource)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  void (__fastcall *setListener)(Bedrock::DynamicPackage::DynamicPackageSource *this, Bedrock::NonOwnerPointer&lt;Bedrock::DynamicPackage::DynamicPackageSourceListener&gt;);
  void (__fastcall *setConfig)(Bedrock::DynamicPackage::DynamicPackageSource *this, const rapidjson::GenericDocument&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt;,rapidjson::CrtAllocator&gt; *);
  bool (__fastcall *requireProcess)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  void (__fastcall *checkFiles)(Bedrock::DynamicPackage::DynamicPackageSource *this, Bedrock::NonOwnerPointer&lt;AppPlatform&gt;, std::weak_ptr&lt;bool&gt;, std::function&lt;void __cdecl(Bedrock::DynamicPackage::CheckFilesResult)&gt; *);
  void (__fastcall *mountFiles)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  void (__fastcall *downloadFiles)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  void (__fastcall *pauseDownload)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  void (__fastcall *resumeDownload)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  void (__fastcall *resumeDownloadOnCell)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  void (__fastcall *abortDownload)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  const Core::PathBuffer&lt;std::string &gt; *(__fastcall *getMountPath)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  const Core::PathBuffer&lt;std::string &gt; *(__fastcall *getDownloadDirectoryPath)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  const Core::PathBuffer&lt;std::string &gt; *(__fastcall *getDownloadFilePath)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  unsigned __int64 (__fastcall *getDownloadSize)(Bedrock::DynamicPackage::DynamicPackageSource *this);
  void (__fastcall *onLanguageChanged)(Bedrock::DynamicPackage::DynamicPackageSource *this);
};

</code></pre></div><h3 id="bedrock-nonownerpointer-bedrock-dynamicpackage-dynamicpackagemanagerlistener"><a href="#bedrock-nonownerpointer-bedrock-dynamicpackage-dynamicpackagemanagerlistener" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Bedrock::DynamicPackage::DynamicPackageManagerListener&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;Bedrock::DynamicPackage::DynamicPackageManagerListener&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-downloadstate"><a href="#bedrock-dynamicpackage-downloadstate" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DownloadState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::DynamicPackage::DownloadState
{
  bool mIsStarted;
  bool mIsPaused;
  bool mIsCompleted;
  bool mIsFailed;
  bool mNeedCelularPermission;
  bool mProgressIndeterminate;
  unsigned __int64 mProgress;
  unsigned __int64 mTotal;
  float mKbpsSpeed;
  unsigned __int64 mTimeRemainingMilliseconds;
  Bedrock::DynamicPackage::DownloadPausedReason mPausedReason;
  Bedrock::DynamicPackage::DownloadFailedReason mFailedReason;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagemanagerimpl"><a href="#bedrock-dynamicpackage-dynamicpackagemanagerimpl" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageManagerImpl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::DynamicPackage::DynamicPackageManagerImpl : Bedrock::DynamicPackage::DynamicPackageSourceListener
{
  Bedrock::NonOwnerPointer&lt;AppPlatform&gt; mAppPlatform;
  std::unique_ptr&lt;TaskGroup&gt; mTaskGroup;
  std::unique_ptr&lt;Bedrock::DynamicPackage::DynamicPackageSource&gt; mDynamicPackageSource;
  std::vector&lt;Bedrock::NonOwnerPointer&lt;Bedrock::DynamicPackage::DynamicPackageManagerListener&gt;&gt; mListeners;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
  rapidjson::GenericDocument&lt;rapidjson::UTF8&lt;char&gt;,rapidjson::MemoryPoolAllocator&lt;rapidjson::CrtAllocator&gt;,rapidjson::CrtAllocator&gt; mDocument;
  _BYTE mCurrentStep[1];
  Bedrock::DynamicPackage::MountState mMountState;
  Bedrock::DynamicPackage::DownloadState mDownloadState;
  Bedrock::DynamicPackage::CheckFilesResult mLatestCheckFilesResult;
  bool mSelfCheckFiles;
  bool mSelfDownload;
  bool mSelfMount;
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; mCheckFilesHandle;
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; mMountHandle;
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; mStartDownloadHandle;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagemanagerimpl-vtbl"><a href="#bedrock-dynamicpackage-dynamicpackagemanagerimpl-vtbl" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageManagerImpl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::DynamicPackage::DynamicPackageManagerImpl_vtbl
{
  void (__fastcall *~DynamicPackageSourceListener)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this);
  void (__fastcall *onDownloadStarted)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this);
  void (__fastcall *onDownloadStateChanged)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this, bool, bool, bool, bool, bool, Bedrock::DynamicPackage::DownloadPausedReason, Bedrock::DynamicPackage::DownloadFailedReason);
  void (__fastcall *onDownloadProgress)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this, unsigned __int64, unsigned __int64, float, unsigned __int64);
  void (__fastcall *onMountStateChanged)(Bedrock::DynamicPackage::DynamicPackageSourceListener *this, std::string, Bedrock::DynamicPackage::MountState);
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagemanager"><a href="#bedrock-dynamicpackage-dynamicpackagemanager" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::DynamicPackage::DynamicPackageManager
{
  std::unique_ptr&lt;Bedrock::DynamicPackage::DynamicPackageManagerImpl&gt; mImpl;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagemanagerlistener"><a href="#bedrock-dynamicpackage-dynamicpackagemanagerlistener" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageManagerListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::DynamicPackage::DynamicPackageManagerListener : Bedrock::EnableNonOwnerReferences
{
  Bedrock::DynamicPackage::DynamicPackageManagerListener_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-dynamicpackage-dynamicpackagemanagerlistener-vtbl"><a href="#bedrock-dynamicpackage-dynamicpackagemanagerlistener-vtbl" class="header-anchor">#</a> <code>Bedrock::DynamicPackage::DynamicPackageManagerListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::DynamicPackage::DynamicPackageManagerListener_vtbl
{
  void (__fastcall *~DynamicPackageManagerListener)(Bedrock::DynamicPackage::DynamicPackageManagerListener *this);
  void (__fastcall *onInitializeComplete)(Bedrock::DynamicPackage::DynamicPackageManagerListener *this);
  void (__fastcall *onCheckFileResult)(Bedrock::DynamicPackage::DynamicPackageManagerListener *this, const Bedrock::DynamicPackage::CheckFilesResult *);
  void (__fastcall *onMountStateChanged)(Bedrock::DynamicPackage::DynamicPackageManagerListener *this, const Bedrock::DynamicPackage::MountState *);
  void (__fastcall *onDownloadStarted)(Bedrock::DynamicPackage::DynamicPackageManagerListener *this, const Bedrock::DynamicPackage::DownloadState *);
  void (__fastcall *onDownloadStateChanged)(Bedrock::DynamicPackage::DynamicPackageManagerListener *this, const Bedrock::DynamicPackage::DownloadState *);
  void (__fastcall *onDownloadCompleted)(Bedrock::DynamicPackage::DynamicPackageManagerListener *this, const Bedrock::DynamicPackage::DownloadState *);
};

</code></pre></div><h3 id="buttonchordtracker"><a href="#buttonchordtracker" class="header-anchor">#</a> <code>ButtonChordTracker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ButtonChordTracker
{
  InputEventQueue *mQueue;
  std::vector&lt;ButtonChordTracker::ChordButtonDetails *&gt; mChordsDown;
  std::unordered_map&lt;int,ButtonChordTracker::TrackerMappingAndState&gt; mPerIdTrackerData;
};

</code></pre></div><h3 id="buttonrepeater-buttontimetracker"><a href="#buttonrepeater-buttontimetracker" class="header-anchor">#</a> <code>ButtonRepeater::ButtonTimeTracker</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ButtonRepeater::ButtonTimeTracker
{
  BasicTimer mRepeatTimer;
  ButtonState mCurrentState;
  InputEvent mEventToSend;
};

</code></pre></div><h3 id="buttonrepeater"><a href="#buttonrepeater" class="header-anchor">#</a> <code>ButtonRepeater</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ButtonRepeater
{
  std::unordered_map&lt;int,std::unordered_map&lt;unsigned int,ButtonRepeater::ButtonTimeTracker&gt;&gt; mPerIdTrackerData;
};

</code></pre></div><h3 id="bindingfactorymap"><a href="#bindingfactorymap" class="header-anchor">#</a> <code>BindingFactoryMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BindingFactoryMap
{
  BindingFactoryMap_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bindingfactorymap-vtbl"><a href="#bindingfactorymap-vtbl" class="header-anchor">#</a> <code>BindingFactoryMap_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BindingFactoryMap_vtbl
{
  void (__fastcall *~BindingFactoryMap)(BindingFactoryMap *this);
  const BindingFactory *(__fastcall *getBindingFactory)(BindingFactoryMap *this, int);
};

</code></pre></div><h3 id="bedrock-nonownerpointer-contentlogfileendpoint"><a href="#bedrock-nonownerpointer-contentlogfileendpoint" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ContentLogFileEndPoint&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj Bedrock::NonOwnerPointer&lt;ContentLogFileEndPoint&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="buffer-span-chunkpos"><a href="#buffer-span-chunkpos" class="header-anchor">#</a> <code>buffer_span&lt;ChunkPos&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;ChunkPos&gt;
{
  const ChunkPos *mBegin;
  const ChunkPos *mEnd;
};

</code></pre></div><h3 id="baselighttextureimagebuilder"><a href="#baselighttextureimagebuilder" class="header-anchor">#</a> <code>BaseLightTextureImageBuilder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseLightTextureImageBuilder
{
  BaseLightTextureImageBuilder_vtbl *__vftable /*VFT*/;
  const Dimension *mDimension;
};

</code></pre></div><h3 id="baselighttextureimagebuilder-vtbl"><a href="#baselighttextureimagebuilder-vtbl" class="header-anchor">#</a> <code>BaseLightTextureImageBuilder_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseLightTextureImageBuilder_vtbl
{
  void (__fastcall *~BaseLightTextureImageBuilder)(BaseLightTextureImageBuilder *this);
  void (__fastcall *init)(BaseLightTextureImageBuilder *this, Dimension *);
  bool (__fastcall *buildImage)(BaseLightTextureImageBuilder *this, const BaseLightData *, mce::Image *, unsigned int, float, float, bool);
  void (__fastcall *getModifiedBlockBrightnessColor)(BaseLightTextureImageBuilder *this, const BlockPos *, const Block *, const Brightness *, BrightnessPair *);
  std::unique_ptr&lt;BaseLightData&gt; *(__fastcall *createBaseLightTextureData)(BaseLightTextureImageBuilder *this, std::unique_ptr&lt;BaseLightData&gt; *result, IClientInstance *, const BaseLightData *);
};

</code></pre></div><h3 id="blockeventdispatcher"><a href="#blockeventdispatcher" class="header-anchor">#</a> <code>BlockEventDispatcher</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockEventDispatcher
{
  std::unordered_map&lt;int,std::unique_ptr&lt;ListenerInfo&gt;&gt; mRegisteredListeners;
  int mHandleCounter;
};

</code></pre></div><h3 id="basecircuitcomponent"><a href="#basecircuitcomponent" class="header-anchor">#</a> <code>BaseCircuitComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BaseCircuitComponent
{
  BaseCircuitComponent_vtbl *__vftable /*VFT*/;
  CircuitComponentList mSources;
  bool mIgnoreFirstUpdate;
  bool mIsFirstTime;
  bool mNeedsUpdate;
  BlockPos mChunkPosition;
  bool mShouldEvaluate;
  int mStrength;
  unsigned __int8 mDirection;
  bool mAllowPowerUp;
  bool mAllowPowerDown;
  bool mRemoved;
};

</code></pre></div><h3 id="basecircuitcomponent-vtbl"><a href="#basecircuitcomponent-vtbl" class="header-anchor">#</a> <code>BaseCircuitComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseCircuitComponent_vtbl
{
  void (__fastcall *~BaseCircuitComponent)(BaseCircuitComponent *this);
  int (__fastcall *getStrength)(BaseCircuitComponent *this);
  int (__fastcall *getDirection)(BaseCircuitComponent *this);
  void (__fastcall *setStrength)(BaseCircuitComponent *this, int);
  void (__fastcall *setDirection)(BaseCircuitComponent *this, unsigned __int8);
  bool (__fastcall *consumePowerAnyDirection)(BaseCircuitComponent *this);
  bool (__fastcall *canConsumerPower)(BaseCircuitComponent *this);
  bool (__fastcall *canStopPower)(BaseCircuitComponent *this);
  void (__fastcall *setStopPower)(BaseCircuitComponent *this, bool);
  unsigned __int64 (__fastcall *getBaseType)(BaseCircuitComponent *this);
  unsigned __int64 (__fastcall *getInstanceType)(BaseCircuitComponent *this);
  bool (__fastcall *removeSource)(BaseCircuitComponent *this, const BlockPos *, const BaseCircuitComponent *);
  bool (__fastcall *addSource)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, int *, bool *);
  bool (__fastcall *allowConnection)(BaseCircuitComponent *this, CircuitSceneGraph *, const CircuitTrackingInfo *, bool *);
  void (__fastcall *checkLock)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  bool (__fastcall *evaluate)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *cacheValues)(BaseCircuitComponent *this, CircuitSystem *, const BlockPos *);
  void (__fastcall *updateDependencies)(BaseCircuitComponent *this, CircuitSceneGraph *, const BlockPos *);
  bool (__fastcall *allowIndirect)(BaseCircuitComponent *this);
  bool (__fastcall *isHalfPulse)(BaseCircuitComponent *this);
  bool (__fastcall *hasSource)(BaseCircuitComponent *this, BaseCircuitComponent *);
  bool (__fastcall *hasChildrenSource)(BaseCircuitComponent *this);
  bool (__fastcall *isSecondaryPowered)(BaseCircuitComponent *this);
};

</code></pre></div><h3 id="beardandshaverstorage"><a href="#beardandshaverstorage" class="header-anchor">#</a> <code>BeardAndShaverStorage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeardAndShaverStorage
{
  std::unordered_map&lt;ChunkPos,std::vector&lt;BeardAndShaverDescription&gt;&gt; mBeardsAndShaversToProcess;
  std::shared_mutex mMutex;
};

</code></pre></div><h3 id="bossbarinfo"><a href="#bossbarinfo" class="header-anchor">#</a> <code>BossbarInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BossbarInfo
{
  BossBarColor mColor;
  int mMax;
  int mValue;
  bool mVisible;
  Json::Value mName;
  std::vector&lt;ActorUniqueID&gt; mPlayers;
};

</code></pre></div><h3 id="bossbarmanager"><a href="#bossbarmanager" class="header-anchor">#</a> <code>BossbarManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BossbarManager
{
  std::unordered_map&lt;std::string,BossbarInfo&gt; mBossbars;
};

</code></pre></div><h3 id="buffer-span-std-pair-gsl-basic-string-span-char-const-1-gsl-basic-string-span-char-const-1"><a href="#buffer-span-std-pair-gsl-basic-string-span-char-const-1-gsl-basic-string-span-char-const-1" class="header-anchor">#</a> <code>buffer_span&lt;std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; &gt;
{
  const std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; *mBegin;
  const std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; *mEnd;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-fogdefinitionregistry"><a href="#bedrock-nonownerpointer-fogdefinitionregistry" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;FogDefinitionRegistry&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;FogDefinitionRegistry&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-fogmanager"><a href="#bedrock-nonownerpointer-fogmanager" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;FogManager&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;FogManager&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-fogmanager-const"><a href="#bedrock-nonownerpointer-fogmanager-const" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;FogManager const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;FogManager const &gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="biomecomponentfactory"><a href="#biomecomponentfactory" class="header-anchor">#</a> <code>BiomeComponentFactory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) BiomeComponentFactory
{
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,std::pair&lt;std::reference_wrapper&lt;Biome&gt;,std::reference_wrapper&lt;IWorldRegistriesProvider&gt; &gt; &gt; &gt; mSchema;
  std::vector&lt;std::function&lt;void __cdecl(CompoundTag &amp;,EntityContext &amp;,IWorldRegistriesProvider &amp;)&gt;&gt; mExtraSerialization;
  BiomeComponentFactory::FactoryScope mScope;
  bool mClosedForRegistration;
};

</code></pre></div><h3 id="blockdescriptor-blockstate"><a href="#blockdescriptor-blockstate" class="header-anchor">#</a> <code>BlockDescriptor::BlockState</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockDescriptor::BlockState
{
  HashedString mName;
  int mValue;
  VanillaStates::CachedItemStateMapPtr mCachedPtr;
};

</code></pre></div><h3 id="bodycontrol"><a href="#bodycontrol" class="header-anchor">#</a> <code>BodyControl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BodyControl : Control
{
  int mTimeStill;
  float mLastHeadY;
};

</code></pre></div><h3 id="bodycontrol-vtbl"><a href="#bodycontrol-vtbl" class="header-anchor">#</a> <code>BodyControl_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BodyControl_vtbl
{
  void (__fastcall *~Control)(Control *this);
  void (__fastcall *clientTick)(BodyControl *this, Mob *);
};

</code></pre></div><h3 id="bedhelper"><a href="#bedhelper" class="header-anchor">#</a> <code>BedHelper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedHelper
{
  float mNorthDir;
  float mSouthDir;
  float mWestDir;
  float mEastDir;
  float mBedOffsetX;
  float mBedOffsetZ;
  float mMobOffsetWestX;
  float mMobOffsetEastX;
  float mMobOffsetSouthZ;
  float mMobOffsetNorthZ;
};

</code></pre></div><h3 id="blockactor-vtbl"><a href="#blockactor-vtbl" class="header-anchor">#</a> <code>BlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="blockgraphicsmodechangecontext"><a href="#blockgraphicsmodechangecontext" class="header-anchor">#</a> <code>BlockGraphicsModeChangeContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj BlockGraphicsModeChangeContext
{
  bool mFancyRendering;
  bool mTransparentLeaves;
  bool mFancyBubbles;
  bool mRayTracing;
};

</code></pre></div><h3 id="blocklegacy-vtbl"><a href="#blocklegacy-vtbl" class="header-anchor">#</a> <code>BlockLegacy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockLegacy_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="blockstatevariant"><a href="#blockstatevariant" class="header-anchor">#</a> <code>BlockStateVariant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockStateVariant : ItemState
{
  std::unique_ptr&lt;ListTag&gt; mEnumValues;
  BidirectionalUnorderedMap&lt;int,unsigned __int64&gt; mHashIndexMap;
};

</code></pre></div><h3 id="blockstatevariant-vtbl"><a href="#blockstatevariant-vtbl" class="header-anchor">#</a> <code>BlockStateVariant_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockStateVariant_vtbl
{
  void (__fastcall *~ItemState)(ItemState *this);
  void (__fastcall *toNBT)(ItemState *this, CompoundTag *, int);
  bool (__fastcall *fromNBT)(ItemState *this, const CompoundTag *, int *);
};

</code></pre></div><h3 id="bidirectionalunorderedmap-unsigned-int64-std-string"><a href="#bidirectionalunorderedmap-unsigned-int64-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;unsigned __int64,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;unsigned __int64,std::string &gt;
{
  std::unordered_map&lt;unsigned __int64,std::string&gt; mRight;
  std::unordered_map&lt;std::string,unsigned __int64&gt; mLeft;
};

</code></pre></div><h3 id="blockstatemeta"><a href="#blockstatemeta" class="header-anchor">#</a> <code>BlockStateMeta</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockStateMeta
{
  _BYTE mType[1];
  std::unique_ptr&lt;ListTag&gt; mEnumValues;
  BidirectionalUnorderedMap&lt;int,unsigned __int64&gt; mHashIndexMap;
  const ItemState *mItemState;
  std::string mName;
};

</code></pre></div><h3 id="blockstategroup"><a href="#blockstategroup" class="header-anchor">#</a> <code>BlockStateGroup</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockStateGroup
{
  std::vector&lt;std::unique_ptr&lt;BlockStateVariant&gt;&gt; mRegisteredBlockStates;
  BidirectionalUnorderedMap&lt;unsigned __int64,std::string &gt; mHashNames;
  BidirectionalUnorderedMap&lt;int,unsigned __int64&gt; mIdNames;
  std::unordered_map&lt;int,std::unique_ptr&lt;BlockStateMeta&gt;&gt; mBlockStates;
  unsigned __int64 lastStateID;
};

</code></pre></div><h3 id="blocksourcelistener-vtbl"><a href="#blocksourcelistener-vtbl" class="header-anchor">#</a> <code>BlockSourceListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockSourceListener_vtbl
{
  void (__fastcall *~BlockSourceListener)(BlockSourceListener *this);
  void (__fastcall *onSourceCreated)(BlockSourceListener *this, BlockSource *);
  void (__fastcall *onSourceDestroyed)(BlockSourceListener *this, BlockSource *);
  void (__fastcall *onAreaChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *, const BlockPos *);
  void (__fastcall *onBlockChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *, unsigned int, const Block *, const Block *, int, const ActorBlockSyncMessage *);
  void (__fastcall *onBrightnessChanged)(BlockSourceListener *this, BlockSource *, const BlockPos *);
  void (__fastcall *onBlockEntityChanged)(BlockSourceListener *this, BlockSource *, BlockActor *);
  void (__fastcall *onBlockEntityAboutToBeRemoved)(BlockSourceListener *this, BlockSource *, std::shared_ptr&lt;BlockActor&gt;);
  void (__fastcall *onEntityChanged)(BlockSourceListener *this, BlockSource *, Actor *);
  void (__fastcall *onBlockEvent)(BlockSourceListener *this, BlockSource *, int, int, int, int, int);
};

</code></pre></div><h3 id="behaviortreedescription"><a href="#behaviortreedescription" class="header-anchor">#</a> <code>BehaviorTreeDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorTreeDescription : ComponentDescription
{
  std::string mBehaviorTreeId;
};

</code></pre></div><h3 id="behaviortreedescription-vtbl"><a href="#behaviortreedescription-vtbl" class="header-anchor">#</a> <code>BehaviorTreeDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorTreeDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
  void (__fastcall *parseData)(BehaviorTreeDescription *this, Json::Value *);
};

</code></pre></div><h3 id="breakblocksdescription"><a href="#breakblocksdescription" class="header-anchor">#</a> <code>BreakBlocksDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakBlocksDescription : ComponentDescription
{
  std::unordered_set&lt;BlockLegacy const *&gt; mBreakableBlocks;
};

</code></pre></div><h3 id="breakblocksdescription-vtbl"><a href="#breakblocksdescription-vtbl" class="header-anchor">#</a> <code>BreakBlocksDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreakBlocksDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
};

</code></pre></div><h3 id="breakdoorannotationdescription"><a href="#breakdoorannotationdescription" class="header-anchor">#</a> <code>BreakDoorAnnotationDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakDoorAnnotationDescription : ComponentDescription
{
  int mBreakTicks;
  Difficulty mMinDifficulty;
};

</code></pre></div><h3 id="breakdoorannotationdescription-vtbl"><a href="#breakdoorannotationdescription-vtbl" class="header-anchor">#</a> <code>BreakDoorAnnotationDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreakDoorAnnotationDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
};

</code></pre></div><h3 id="bucketabledescription-vtbl"><a href="#bucketabledescription-vtbl" class="header-anchor">#</a> <code>BucketableDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BucketableDescription_vtbl
{
  const char *(__fastcall *getJsonName)(Description *this);
  void (__fastcall *~Description)(Description *this);
  void (__fastcall *deserializeData)(Description *this, DeserializeDataParams);
  void (__fastcall *serializeData)(Description *this, Json::Value *);
};

</code></pre></div><h3 id="blockcomponentdescription"><a href="#blockcomponentdescription" class="header-anchor">#</a> <code>BlockComponentDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockComponentDescription
{
  BlockComponentDescription_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="blockcomponentfactory"><a href="#blockcomponentfactory" class="header-anchor">#</a> <code>BlockComponentFactory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockComponentFactory : Factory&lt;BlockComponentDescription&gt;
{
};

</code></pre></div><h3 id="blockcomponentdescription-vtbl"><a href="#blockcomponentdescription-vtbl" class="header-anchor">#</a> <code>BlockComponentDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockComponentDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockpermutationdescription"><a href="#blockpermutationdescription" class="header-anchor">#</a> <code>BlockPermutationDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPermutationDescription
{
  ExpressionNode mCondition;
  BlockComponentGroupDescription mComponents;
};

</code></pre></div><h3 id="blockeventresponsefactory"><a href="#blockeventresponsefactory" class="header-anchor">#</a> <code>BlockEventResponseFactory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventResponseFactory : EventResponseFactory
{
};

</code></pre></div><h3 id="blockeventresponsefactory-vtbl"><a href="#blockeventresponsefactory-vtbl" class="header-anchor">#</a> <code>BlockEventResponseFactory_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockEventResponseFactory_vtbl
{
  void (__fastcall *~EventResponseFactory)(EventResponseFactory *this);
  void (__fastcall *initializeFactory)(EventResponseFactory *this, const Experiments *);
};

</code></pre></div><h3 id="blockdefinitiongroup"><a href="#blockdefinitiongroup" class="header-anchor">#</a> <code>BlockDefinitionGroup</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockDefinitionGroup
{
  std::unordered_map&lt;std::string,DefinitionEvent&gt; mEventHandlers;
  std::unordered_map&lt;std::string,std::unique_ptr&lt;BlockDefinition&gt;&gt; mBlockDefinitions;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockDescription&gt; &gt; mDescriptionSchema;
  std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; mBlockComponentsSchema;
  BlockEventResponseFactory mResponseFactory;
  std::unique_ptr&lt;JsonDefinitionUpgrader::IJsonDefinitionUpgrader&gt; mBlockDefinitionUpgrader;
  int mLastBlockId;
  std::vector&lt;std::unique_ptr&lt;Util::EntityComponentProcessor&gt;&gt; mComponentPostProcessors;
};

</code></pre></div><h3 id="behaviordefinition"><a href="#behaviordefinition" class="header-anchor">#</a> <code>BehaviorDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorDefinition
{
  BehaviorDefinition_vtbl *__vftable /*VFT*/;
  std::string mName;
  BehaviorTreeDefinitionPtr mTreeDefinition;
};

</code></pre></div><h3 id="behaviorfactory"><a href="#behaviorfactory" class="header-anchor">#</a> <code>BehaviorFactory</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorFactory
{
  std::unordered_map&lt;std::string,std::pair&lt;std::function&lt;std::unique_ptr&lt;BehaviorDefinition&gt; __cdecl(void)&gt;,std::function&lt;std::unique_ptr&lt;BehaviorNode&gt; __cdecl(void)&gt; &gt;&gt; mFactoryPairs;
};

</code></pre></div><h3 id="behaviornode"><a href="#behaviornode" class="header-anchor">#</a> <code>BehaviorNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BehaviorNode
{
  BehaviorNode_vtbl *__vftable /*VFT*/;
  const BehaviorDefinition *mNodeDefinition;
  BehaviorTreeDefinitionPtr mTreeDefinition;
  BehaviorNode *mParent;
  BehaviorComponent *mComponent;
  BehaviorData *mTreeData;
  BehaviorStatus mStatus;
};

</code></pre></div><h3 id="behaviornode-vtbl"><a href="#behaviornode-vtbl" class="header-anchor">#</a> <code>BehaviorNode_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorNode_vtbl
{
  void (__fastcall *~BehaviorNode)(BehaviorNode *this);
  BehaviorStatus (__fastcall *tick)(BehaviorNode *this, Actor *);
  void (__fastcall *initializeFromDefinition)(BehaviorNode *this, Actor *);
};

</code></pre></div><h3 id="behaviortreedefinition"><a href="#behaviortreedefinition" class="header-anchor">#</a> <code>BehaviorTreeDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorTreeDefinition
{
  std::string mTreeName;
  std::string mStringInput;
  std::unique_ptr&lt;BehaviorDefinition&gt; mRoot;
};

</code></pre></div><h3 id="behaviortreegroup"><a href="#behaviortreegroup" class="header-anchor">#</a> <code>BehaviorTreeGroup</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorTreeGroup
{
  ResourcePackManager *mResourcePackManager;
  BehaviorFactory *mFactory;
  std::unordered_map&lt;std::string,std::unique_ptr&lt;BehaviorTreeDefinition&gt;&gt; mDefinitions;
  std::unordered_set&lt;BehaviorTreeDefinitionPtr *&gt; mRegisteredPtrs;
};

</code></pre></div><h3 id="behaviordata-dataproxy"><a href="#behaviordata-dataproxy" class="header-anchor">#</a> <code>BehaviorData::DataProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BehaviorData::DataProxy
{
  BehaviorData::DataProxy_vtbl *__vftable /*VFT*/;
  std::string mId;
  _BYTE mType[1];
};

</code></pre></div><h3 id="behaviordata-dataproxy-vtbl"><a href="#behaviordata-dataproxy-vtbl" class="header-anchor">#</a> <code>BehaviorData::DataProxy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorData::DataProxy_vtbl
{
  void (__fastcall *~DataProxy)(BehaviorData::DataProxy *this);
  std::unique_ptr&lt;BehaviorData::DataProxy&gt; *(__fastcall *copy)(BehaviorData::DataProxy *this, std::unique_ptr&lt;BehaviorData::DataProxy&gt; *result);
};

</code></pre></div><h3 id="behaviordefinition-vtbl"><a href="#behaviordefinition-vtbl" class="header-anchor">#</a> <code>BehaviorDefinition_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorDefinition_vtbl
{
  void (__fastcall *~BehaviorDefinition)(BehaviorDefinition *this);
  void (__fastcall *load)(BehaviorDefinition *this, Json::Value, const BehaviorFactory *);
  std::unique_ptr&lt;BehaviorNode&gt; *(__fastcall *createNode)(BehaviorDefinition *this, std::unique_ptr&lt;BehaviorNode&gt; *result, Actor *, const BehaviorFactory *, BehaviorNode *, BehaviorData *);
};

</code></pre></div><h3 id="bosseventlistener-vtbl"><a href="#bosseventlistener-vtbl" class="header-anchor">#</a> <code>BossEventListener_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BossEventListener_vtbl
{
  void (__fastcall *~BossEventListener)(BossEventListener *this);
  void (__fastcall *onBossEvent)(BossEventListener *this, BossEventUpdateType);
  void (__fastcall *onBossEvent)(BossEventListener *this, BossEventUpdateType, const ActorUniqueID *, const BossEventPacket *);
};

</code></pre></div><h3 id="blockgameplayhandler"><a href="#blockgameplayhandler" class="header-anchor">#</a> <code>BlockGameplayHandler</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGameplayHandler : GameplayHandler
{
};

</code></pre></div><h3 id="blockgameplayhandler-vtbl"><a href="#blockgameplayhandler-vtbl" class="header-anchor">#</a> <code>BlockGameplayHandler_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockGameplayHandler_vtbl
{
  void (__fastcall *~GameplayHandler)(GameplayHandler *this);
  GameplayHandlerResult&lt;enum CoordinatorResult&gt; *(__fastcall *handleChestBlockTryPaired)(BlockGameplayHandler *this, GameplayHandlerResult&lt;enum CoordinatorResult&gt; *result, const ChestBlockTryPairEvent *);
};

</code></pre></div><h3 id="blockeventcoordinator"><a href="#blockeventcoordinator" class="header-anchor">#</a> <code>BlockEventCoordinator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockEventCoordinator : EventCoordinator&lt;BlockEventListener&gt;
{
  std::unique_ptr&lt;BlockGameplayHandler&gt; mBlockGameplayHandler;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-actordefinitiongroup"><a href="#bedrock-nonownerpointer-actordefinitiongroup" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ActorDefinitionGroup&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;ActorDefinitionGroup&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="blockactorlevellistener"><a href="#blockactorlevellistener" class="header-anchor">#</a> <code>BlockActorLevelListener</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockActorLevelListener : LevelListener
{
};

</code></pre></div><h3 id="blockid"><a href="#blockid" class="header-anchor">#</a> <code>BlockID</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockID : NewType&lt;unsigned char&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-asyncresult-completeresult-void"><a href="#bedrock-threading-asyncresult-completeresult-void" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncResult::CompleteResult&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncResult::CompleteResult&lt;void&gt; : Bedrock::Threading::IAsyncResult&lt;void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-asyncresult-completeresult-void-vtbl"><a href="#bedrock-threading-asyncresult-completeresult-void-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncResult::CompleteResult&lt;void&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncResult::CompleteResult&lt;void&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-shared-ptr-bedrock-threading-iasyncresult-void"><a href="#bedrock-threading-iasyncresult-std-shared-ptr-bedrock-threading-iasyncresult-void" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; : Bedrock::Threading::AsyncBase
{
  Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt;_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-threading-iasyncresult-std-shared-ptr-bedrock-threading-iasyncresult-void-vtbl"><a href="#bedrock-threading-iasyncresult-std-shared-ptr-bedrock-threading-iasyncresult-void-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt;)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; *this, std::exception_ptr *result);
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; *this, std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-asyncresult-unwrapresultbase-void"><a href="#bedrock-threading-asyncresult-unwrapresultbase-void" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncResult::UnwrapResultBase&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncResult::UnwrapResultBase&lt;void&gt; : Bedrock::Threading::IAsyncResult&lt;void&gt;
{
  std::mutex mLock;
  bool mCanceled;
  bool mDone;
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; &gt; &gt; mWrapperResult;
  std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt; mInnerResult;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;&gt; mCallbacks;
};

</code></pre></div><h3 id="bedrock-threading-asyncresult-unwrapresultbase-void-vtbl"><a href="#bedrock-threading-asyncresult-unwrapresultbase-void-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncResult::UnwrapResultBase&lt;void&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncResult::UnwrapResultBase&lt;void&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-asyncresult-unwrapresult-void"><a href="#bedrock-threading-asyncresult-unwrapresult-void" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncResult::UnwrapResult&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncResult::UnwrapResult&lt;void&gt; : Bedrock::Threading::AsyncResult::UnwrapResultBase&lt;void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-asyncresult-unwrapresult-void-vtbl"><a href="#bedrock-threading-asyncresult-unwrapresult-void-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncResult::UnwrapResult&lt;void&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncResult::UnwrapResult&lt;void&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrock-threading-whenall-void"><a href="#bedrock-threading-whenall-void" class="header-anchor">#</a> <code>Bedrock::Threading::WhenAll&lt;void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::WhenAll&lt;void&gt; : Bedrock::Threading::IAsyncResult&lt;void&gt;
{
  std::mutex mLock;
  Bedrock::Threading::AsyncStatus mStatus;
  Bedrock::Threading::AsyncStatus mAggregateResult;
  unsigned __int64 mPending;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;&gt; mCallbacks;
  std::vector&lt;std::shared_ptr&lt;Bedrock::Threading::IAsyncResult&lt;void&gt; &gt;&gt; mActions;
};

</code></pre></div><h3 id="bedrock-threading-whenall-void-vtbl"><a href="#bedrock-threading-whenall-void-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::WhenAll&lt;void&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::WhenAll&lt;void&gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;void&gt;)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::exception_ptr *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;void&gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;void&gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="bedrocklog-logareafilter"><a href="#bedrocklog-logareafilter" class="header-anchor">#</a> <code>BedrockLog::LogAreaFilter</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedrockLog::LogAreaFilter : std::bitset&lt;38&gt;
{
};

</code></pre></div><h3 id="buffer-span-workerpool"><a href="#buffer-span-workerpool" class="header-anchor">#</a> <code>buffer_span&lt;WorkerPool *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;WorkerPool *&gt;
{
  WorkerPool *const *mBegin;
  WorkerPool *const *mEnd;
};

</code></pre></div><h3 id="backgroundtaskbase-currenttaskautoscope"><a href="#backgroundtaskbase-currenttaskautoscope" class="header-anchor">#</a> <code>BackgroundTaskBase::CurrentTaskAutoScope</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BackgroundTaskBase::CurrentTaskAutoScope
{
  BackgroundTaskBase *mPrev;
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardpaste"><a href="#bedrock-signal-applicationsignal-clipboardpaste" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardPaste&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Signal&lt;ApplicationSignal::ClipboardPaste&gt; : Bedrock::SignalBase
{
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardpaste-vtbl"><a href="#bedrock-signal-applicationsignal-clipboardpaste-vtbl" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardPaste&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Signal&lt;ApplicationSignal::ClipboardPaste&gt;_vtbl
{
  void (__fastcall *~SignalBase)(Bedrock::SignalBase *this);
  bool (__fastcall *invokeHandler)(Bedrock::SignalBase *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardpaste-signalhandlermap"><a href="#bedrock-signal-applicationsignal-clipboardpaste-signalhandlermap" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardPaste&gt;::SignalHandlerMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Signal&lt;ApplicationSignal::ClipboardPaste&gt;::SignalHandlerMap : Bedrock::ISignalHandlerMap
{
  std::map&lt;unsigned short,std::function&lt;void __cdecl(std::shared_ptr&lt;ApplicationSignal::ClipboardPaste&gt;)&gt;&gt; mMap;
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardpaste-signalhandlermap-vtbl"><a href="#bedrock-signal-applicationsignal-clipboardpaste-signalhandlermap-vtbl" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardPaste&gt;::SignalHandlerMap_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Signal&lt;ApplicationSignal::ClipboardPaste&gt;::SignalHandlerMap_vtbl
{
  void (__fastcall *~ISignalHandlerMap)(Bedrock::ISignalHandlerMap *this);
  bool (__fastcall *remove)(Bedrock::ISignalHandlerMap *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signalroute-applicationsignal-clipboardpaste"><a href="#bedrock-signalroute-applicationsignal-clipboardpaste" class="header-anchor">#</a> <code>Bedrock::SignalRoute&lt;ApplicationSignal::ClipboardPaste&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::SignalRoute&lt;ApplicationSignal::ClipboardPaste&gt; : Bedrock::SignalRouteBase
{
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardcopy"><a href="#bedrock-signal-applicationsignal-clipboardcopy" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardCopy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Signal&lt;ApplicationSignal::ClipboardCopy&gt; : Bedrock::SignalBase
{
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardcopy-vtbl"><a href="#bedrock-signal-applicationsignal-clipboardcopy-vtbl" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardCopy&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Signal&lt;ApplicationSignal::ClipboardCopy&gt;_vtbl
{
  void (__fastcall *~SignalBase)(Bedrock::SignalBase *this);
  bool (__fastcall *invokeHandler)(Bedrock::SignalBase *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardcopy-signalhandlermap"><a href="#bedrock-signal-applicationsignal-clipboardcopy-signalhandlermap" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardCopy&gt;::SignalHandlerMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Signal&lt;ApplicationSignal::ClipboardCopy&gt;::SignalHandlerMap : Bedrock::ISignalHandlerMap
{
  std::map&lt;unsigned short,std::function&lt;void __cdecl(std::shared_ptr&lt;ApplicationSignal::ClipboardCopy&gt;)&gt;&gt; mMap;
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardcopy-signalhandlermap-vtbl"><a href="#bedrock-signal-applicationsignal-clipboardcopy-signalhandlermap-vtbl" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardCopy&gt;::SignalHandlerMap_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Signal&lt;ApplicationSignal::ClipboardCopy&gt;::SignalHandlerMap_vtbl
{
  void (__fastcall *~ISignalHandlerMap)(Bedrock::ISignalHandlerMap *this);
  bool (__fastcall *remove)(Bedrock::ISignalHandlerMap *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signalroute-applicationsignal-clipboardcopy"><a href="#bedrock-signalroute-applicationsignal-clipboardcopy" class="header-anchor">#</a> <code>Bedrock::SignalRoute&lt;ApplicationSignal::ClipboardCopy&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::SignalRoute&lt;ApplicationSignal::ClipboardCopy&gt; : Bedrock::SignalRouteBase
{
};

</code></pre></div><h3 id="buffer-span-bool"><a href="#buffer-span-bool" class="header-anchor">#</a> <code>buffer_span&lt;bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;bool&gt;
{
  const bool *mBegin;
  const bool *mEnd;
};

</code></pre></div><h3 id="buffer-span-unsigned-char"><a href="#buffer-span-unsigned-char" class="header-anchor">#</a> <code>buffer_span&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj buffer_span&lt;unsigned char&gt;
{
  const unsigned __int8 *mBegin;
  const unsigned __int8 *mEnd;
};

</code></pre></div><h3 id="bedrock-commonplatform"><a href="#bedrock-commonplatform" class="header-anchor">#</a> <code>Bedrock::CommonPlatform</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::CommonPlatform
{
  Bedrock::CommonPlatform_vtbl *__vftable /*VFT*/;
  std::unique_ptr&lt;Bedrock::PlatformRuntimeInfo&gt; mPlatformRuntimeInfo;
  std::unique_ptr&lt;Bedrock::PlatformBuildInfo&gt; mPlatformBuildInfo;
  std::unique_ptr&lt;Bedrock::IIslandManager&gt; mIslandMgr;
  std::shared_ptr&lt;Bedrock::AppIsland&gt; mApp;
  std::atomic&lt;bool&gt; mbQueueRenderParameterSignal;
  std::atomic&lt;bool&gt; mHasInitialized;
};

</code></pre></div><h3 id="bedrock-commonplatform-vtbl"><a href="#bedrock-commonplatform-vtbl" class="header-anchor">#</a> <code>Bedrock::CommonPlatform_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::CommonPlatform_vtbl
{
  void (__fastcall *~CommonPlatform)(Bedrock::CommonPlatform *this);
  bool (__fastcall *updatePlatformInfo)(Bedrock::CommonPlatform *this);
  bool (__fastcall *updatePlatformGraphicsInfo)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueShutdown)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueSuspend)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueResume)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueBack)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueLowMemory)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueFocusLost)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueFocusGained)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueInputPaneVisible)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueInputPaneHidden)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueSuspendWarning)(Bedrock::CommonPlatform *this);
  void (__fastcall *issueVisibilityChange)(Bedrock::CommonPlatform *this, bool);
  void (__fastcall *issueWindowSizeChange)(Bedrock::CommonPlatform *this, float, float);
  void (__fastcall *issueDPIChange)(Bedrock::CommonPlatform *this, float);
  void (__fastcall *issueOrientationChange)(Bedrock::CommonPlatform *this, const DisplayOrientation *);
  void (__fastcall *feedButtonPress)(Bedrock::CommonPlatform *this, const int *);
  void (__fastcall *feedKeyPress)(Bedrock::CommonPlatform *this, const char);
  void (__fastcall *setTextboxText)(Bedrock::CommonPlatform *this, const std::string *);
  void (__fastcall *setStorageDirectory)(Bedrock::CommonPlatform *this, FileStorageDirectory, bool, const PropertyBag *);
  FileStorageDirectory (__fastcall *setInitialStorageDirectory)(Bedrock::CommonPlatform *this, FileStorageDirectory);
  FileStorageDirectory (__fastcall *getStorageDirectory)(Bedrock::CommonPlatform *this);
  bool (__fastcall *_preAppCreation)(Bedrock::CommonPlatform *this, const Bedrock::ActivationArguments *);
  bool (__fastcall *_postAppCreation)(Bedrock::CommonPlatform *this, const Bedrock::ActivationArguments *);
  void (__fastcall *_processActivationArguments)(Bedrock::CommonPlatform *this, const Bedrock::ActivationArguments *);
  bool (__fastcall *_update)(Bedrock::CommonPlatform *this, bool);
  bool (__fastcall *_isShuttingDown)(Bedrock::CommonPlatform *this);
  bool (__fastcall *_isShutdown)(Bedrock::CommonPlatform *this);
  void (__fastcall *pushNotificationReceived_Shim)(Bedrock::CommonPlatform *this, const PushNotificationMessage *);
  void (__fastcall *notifyUriListeners_Shim)(Bedrock::CommonPlatform *this, const ActivationUri *);
  std::string *(__fastcall *getDeviceId_Shim)(Bedrock::CommonPlatform *this, std::string *result);
};

</code></pre></div><h3 id="bedrock-platformruntimeinfo"><a href="#bedrock-platformruntimeinfo" class="header-anchor">#</a> <code>Bedrock::PlatformRuntimeInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PlatformRuntimeInfo
{
  Bedrock::PlatformRuntimeInfo_vtbl *__vftable /*VFT*/;
  std::string mDeviceModelName;
  std::string mOSVersion;
  std::string mCPUType;
  std::string mCPUName;
  std::string mCPUFeatures;
  std::string mGPUDriverVersion;
  std::string mSecureId;
  std::string mSerial;
  std::string mBoard;
  std::string mInstallerPackageName;
  std::string mRegion;
  PlatformType mPlatformType;
  unsigned __int64 mCachedFreeStorageSpace_Internal;
  unsigned __int64 mCachedFreeStorageSpace_External;
  unsigned __int64 mCachedFreeStorageSpace_Cloud;
  unsigned __int64 mTotalPhysicalMemory;
  unsigned __int64 mTotalVirtualMemory;
  unsigned __int64 mUsedMemory;
  unsigned __int64 mPhysicalMemorySize;
  unsigned int mOptimalLDBSize;
  float mWidth;
  float mHeight;
  float mDPI;
  _BYTE mOrientation[4];
  int mSignaturesHash;
  bool mGraphicsTearingSupport;
  bool mAllowSplitScreen;
  bool mSupportsMSAA;
  bool mHasFastAlphaTest;
  bool mSupportsVibration;
  bool mSupportsTextToSpeech;
  bool mSupportsClipboard;
  bool mSupportsFilePicking;
  bool mAllowContentLogWrite;
  bool mIsRooted;
  bool mCanSelfTerminate;
  bool mCanLaunchUri;
  unsigned __int8 mCoreCount;
  unsigned __int8 mThreadCount;
  unsigned __int8 mHighPerfThreadCount;
  unsigned __int8 mProcessorGrade;
  unsigned __int8 mGraphicsGrade;
  unsigned __int8 mMemoryGrade;
  unsigned __int8 mStorageGrade;
  unsigned __int8 mPowerSupplyGrade;
  unsigned int mCPUBits;
  Core::PathBuffer&lt;std::string &gt; mAssetStoragePath;
  Core::PathBuffer&lt;std::string &gt; mCurrentStoragePath;
  Core::PathBuffer&lt;std::string &gt; mExternalStoragePath;
  Core::PathBuffer&lt;std::string &gt; mInternalStoragePath;
  Core::PathBuffer&lt;std::string &gt; mLoggingPath;
  Core::PathBuffer&lt;std::string &gt; mPackagePath;
  Core::PathBuffer&lt;std::string &gt; mUserDataPath;
  Core::PathBuffer&lt;std::string &gt; mCacheStoragePath;
};

</code></pre></div><h3 id="bedrock-platformruntimeinfo-vtbl"><a href="#bedrock-platformruntimeinfo-vtbl" class="header-anchor">#</a> <code>Bedrock::PlatformRuntimeInfo_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::PlatformRuntimeInfo_vtbl
{
  void (__fastcall *~PlatformRuntimeInfo)(Bedrock::PlatformRuntimeInfo *this);
};

</code></pre></div><h3 id="bedrock-platformbuildinfo"><a href="#bedrock-platformbuildinfo" class="header-anchor">#</a> <code>Bedrock::PlatformBuildInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::PlatformBuildInfo
{
  std::string mInstallerPackageName;
  Core::PathBuffer&lt;std::string &gt; mPlatformTempPath;
  Core::PathBuffer&lt;std::string &gt; mOnDiskScratchPath;
  Core::PathBuffer&lt;std::string &gt; mDataUrl;
  Core::PathBuffer&lt;std::string &gt; mAltDataUrl;
  std::string mFeedbackURL;
  __int64 mAppLastModified;
  bool mHasBuyButtonWhenLicenseInvalid;
};

</code></pre></div><h3 id="bedrock-iislandmanager"><a href="#bedrock-iislandmanager" class="header-anchor">#</a> <code>Bedrock::IIslandManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::IIslandManager
{
  Bedrock::IIslandManager_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-islandregistrationinfo"><a href="#bedrock-islandregistrationinfo" class="header-anchor">#</a> <code>Bedrock::IslandRegistrationInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::IslandRegistrationInfo
{
  unsigned __int16 mId;
  std::string mName;
  std::vector&lt;unsigned short&gt; mRequires;
  std::shared_ptr&lt;Bedrock::IIslandCore&gt; *(__fastcall *mFactory)(std::shared_ptr&lt;Bedrock::IIslandCore&gt; *result);
};

</code></pre></div><h3 id="bedrock-iislandmanager-vtbl"><a href="#bedrock-iislandmanager-vtbl" class="header-anchor">#</a> <code>Bedrock::IIslandManager_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::IIslandManager_vtbl
{
  void (__fastcall *~IIslandManager)(Bedrock::IIslandManager *this);
  bool (__fastcall *registerIsland)(Bedrock::IIslandManager *this, Bedrock::IslandRegistrationInfo *);
  std::shared_ptr&lt;Bedrock::IIslandCore&gt; *(__fastcall *getIsland)(Bedrock::IIslandManager *this, std::shared_ptr&lt;Bedrock::IIslandCore&gt; *result, unsigned __int16);
  void (__fastcall *start)(Bedrock::IIslandManager *this);
  void (__fastcall *suspend)(Bedrock::IIslandManager *this);
  void (__fastcall *resume)(Bedrock::IIslandManager *this);
  void (__fastcall *stop)(Bedrock::IIslandManager *this);
  bool (__fastcall *isTransitionComplete)(Bedrock::IIslandManager *this);
  void (__fastcall *update)(Bedrock::IIslandManager *this);
};

</code></pre></div><h3 id="bedrock-iapplicationdatastores"><a href="#bedrock-iapplicationdatastores" class="header-anchor">#</a> <code>Bedrock::IApplicationDataStores</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::IApplicationDataStores : Bedrock::EnableNonOwnerReferences
{
  Bedrock::IApplicationDataStores_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-bedrock-datastore-const"><a href="#bedrock-nonownerpointer-bedrock-datastore-const" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Bedrock::DataStore const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;Bedrock::DataStore const &gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-bedrock-datastore"><a href="#bedrock-nonownerpointer-bedrock-datastore" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;Bedrock::DataStore&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;Bedrock::DataStore&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-iapplicationdatastores-vtbl"><a href="#bedrock-iapplicationdatastores-vtbl" class="header-anchor">#</a> <code>Bedrock::IApplicationDataStores_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::IApplicationDataStores_vtbl
{
  void (__fastcall *~IApplicationDataStores)(Bedrock::IApplicationDataStores *this);
  Bedrock::NonOwnerPointer&lt;Bedrock::DataStore const &gt; *(__fastcall *getDataStore)(Bedrock::IApplicationDataStores *this, Bedrock::NonOwnerPointer&lt;Bedrock::DataStore const &gt; *result, Bedrock::IApplicationDataStores::DataStores);
  Bedrock::NonOwnerPointer&lt;Bedrock::DataStore&gt; *(__fastcall *getDataStore)(Bedrock::IApplicationDataStores *this, Bedrock::NonOwnerPointer&lt;Bedrock::DataStore&gt; *result, Bedrock::IApplicationDataStores::DataStores);
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardpasterequest"><a href="#bedrock-signal-applicationsignal-clipboardpasterequest" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardPasteRequest&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Signal&lt;ApplicationSignal::ClipboardPasteRequest&gt; : Bedrock::SignalBase
{
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardpasterequest-vtbl"><a href="#bedrock-signal-applicationsignal-clipboardpasterequest-vtbl" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardPasteRequest&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Signal&lt;ApplicationSignal::ClipboardPasteRequest&gt;_vtbl
{
  void (__fastcall *~SignalBase)(Bedrock::SignalBase *this);
  bool (__fastcall *invokeHandler)(Bedrock::SignalBase *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="buffer-span-blockid"><a href="#buffer-span-blockid" class="header-anchor">#</a> <code>buffer_span&lt;BlockID&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;BlockID&gt;
{
  const BlockID *mBegin;
  const BlockID *mEnd;
};

</code></pre></div><h3 id="buffer-span-nibblepair"><a href="#buffer-span-nibblepair" class="header-anchor">#</a> <code>buffer_span&lt;NibblePair&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;NibblePair&gt;
{
  const NibblePair *mBegin;
  const NibblePair *mEnd;
};

</code></pre></div><h3 id="buffer-span-subchunk"><a href="#buffer-span-subchunk" class="header-anchor">#</a> <code>buffer_span&lt;SubChunk&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;SubChunk&gt;
{
  const SubChunk *mBegin;
  const SubChunk *mEnd;
};

</code></pre></div><h3 id="bytesdataoutput"><a href="#bytesdataoutput" class="header-anchor">#</a> <code>BytesDataOutput</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BytesDataOutput : IDataOutput
{
};

</code></pre></div><h3 id="bytesdataoutput-vtbl"><a href="#bytesdataoutput-vtbl" class="header-anchor">#</a> <code>BytesDataOutput_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BytesDataOutput_vtbl
{
  void (__fastcall *~IDataOutput)(IDataOutput *this);
  void (__fastcall *writeString)(IDataOutput *this, gsl::basic_string_span&lt;char const ,-1&gt;);
  void (__fastcall *writeLongString)(IDataOutput *this, gsl::basic_string_span&lt;char const ,-1&gt;);
  void (__fastcall *writeFloat)(IDataOutput *this, float);
  void (__fastcall *writeDouble)(IDataOutput *this, long double);
  void (__fastcall *writeByte)(IDataOutput *this, char);
  void (__fastcall *writeShort)(IDataOutput *this, __int16);
  void (__fastcall *writeInt)(IDataOutput *this, int);
  void (__fastcall *writeLongLong)(IDataOutput *this, __int64);
  void (__fastcall *writeBytes)(IDataOutput *this, const void *, unsigned __int64);
  bool (__fastcall *isOk)(IDataOutput *this);
};

</code></pre></div><h3 id="bytesdatainput-vtbl"><a href="#bytesdatainput-vtbl" class="header-anchor">#</a> <code>BytesDataInput_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BytesDataInput_vtbl
{
  void (__fastcall *~IDataInput)(IDataInput *this);
  std::string *(__fastcall *readString)(IDataInput *this, std::string *result);
  std::string *(__fastcall *readLongString)(IDataInput *this, std::string *result);
  float (__fastcall *readFloat)(IDataInput *this);
  long double (__fastcall *readDouble)(IDataInput *this);
  char (__fastcall *readByte)(IDataInput *this);
  __int16 (__fastcall *readShort)(IDataInput *this);
  int (__fastcall *readInt)(IDataInput *this);
  __int64 (__fastcall *readLongLong)(IDataInput *this);
  bool (__fastcall *readBytes)(IDataInput *this, void *, unsigned __int64);
  unsigned __int64 (__fastcall *numBytesLeft)(IDataInput *this);
  bool (__fastcall *isOk)(IDataInput *this);
  bool (__fastcall *seek)(IDataInput *this, unsigned __int64);
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-core-random-std-allocator-core-random"><a href="#bedrock-threading-threadlocalobjectimplementation-core-random-std-allocator-core-random" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;Core::Random,std::allocator&lt;Core::Random&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;Core::Random,std::allocator&lt;Core::Random&gt; &gt;
{
  Core::Random *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-core-random-std-allocator-core-random"><a href="#bedrock-threading-threadlocalobject-core-random-std-allocator-core-random" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;Core::Random,std::allocator&lt;Core::Random&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;Core::Random,std::allocator&lt;Core::Random&gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;Core::Random,std::allocator&lt;Core::Random&gt; &gt;
{
  std::function&lt;void __cdecl(Core::Random *)&gt; mConstructor;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-random-std-allocator-random"><a href="#bedrock-threading-threadlocalobjectimplementation-random-std-allocator-random" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;Random,std::allocator&lt;Random&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;Random,std::allocator&lt;Random&gt; &gt;
{
  Random *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-random-std-allocator-random"><a href="#bedrock-threading-threadlocalobject-random-std-allocator-random" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;Random,std::allocator&lt;Random&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;Random,std::allocator&lt;Random&gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;Random,std::allocator&lt;Random&gt; &gt;
{
  std::function&lt;void __cdecl(Random *)&gt; mConstructor;
};

</code></pre></div><h3 id="biomeheight"><a href="#biomeheight" class="header-anchor">#</a> <code>BiomeHeight</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeHeight
{
  float depth;
  float scale;
};

</code></pre></div><h3 id="biomeregistry-biomeparent"><a href="#biomeregistry-biomeparent" class="header-anchor">#</a> <code>BiomeRegistry::BiomeParent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeRegistry::BiomeParent
{
  std::string parentName;
  Json::Value json;
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocal-contentlog-threadspecificdata-std-allocator-contentlog-threadspecificdata-item"><a href="#bedrock-threading-instancedthreadlocal-contentlog-threadspecificdata-std-allocator-contentlog-threadspecificdata-item" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt;::Item</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt;::Item : Bedrock::Intrusive::list_base_hook&lt;void&gt;
{
  std::_Align_type&lt;double,48&gt; mData;
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-contentlog-threadspecificdata-std-allocator-contentlog-threadspecificdata-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void-iterator-base-0"><a href="#bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-contentlog-threadspecificdata-std-allocator-contentlog-threadspecificdata-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void-iterator-base-0" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;::iterator_base&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ContentLog::ThreadSpecificData,std::allocator&lt;ContentLog::ThreadSpecificData&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;::iterator_base&lt;0&gt;
{
  Bedrock::Intrusive::list_base_hook&lt;void&gt; *mHook;
};

</code></pre></div><h3 id="boneanimationchannelplayer"><a href="#boneanimationchannelplayer" class="header-anchor">#</a> <code>BoneAnimationChannelPlayer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BoneAnimationChannelPlayer
{
  unsigned __int64 mEndFrameIndex;
  float mTime;
};

</code></pre></div><h3 id="boneanimationplayer"><a href="#boneanimationplayer" class="header-anchor">#</a> <code>BoneAnimationPlayer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BoneAnimationPlayer
{
  std::vector&lt;BoneAnimationChannelPlayer&gt; mBoneAnimationChannelPlayers;
};

</code></pre></div><h3 id="buffer-span-std-unique-ptr-block"><a href="#buffer-span-std-unique-ptr-block" class="header-anchor">#</a> <code>buffer_span&lt;std::unique_ptr&lt;Block&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;std::unique_ptr&lt;Block&gt; &gt;
{
  const std::unique_ptr&lt;Block&gt; *mBegin;
  const std::unique_ptr&lt;Block&gt; *mEnd;
};

</code></pre></div><h3 id="basegameversion-any-version-constructor"><a href="#basegameversion-any-version-constructor" class="header-anchor">#</a> <code>BaseGameVersion::any_version_constructor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseGameVersion::any_version_constructor
{
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-containertype-std-string"><a href="#bidirectionalunorderedmap-enum-containertype-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ContainerType,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum ContainerType,std::string &gt;
{
  std::unordered_map&lt;enum ContainerType,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum ContainerType&gt; mLeft;
};

</code></pre></div><h3 id="bidirectionalunorderedmap-std-string-enum-filtersubject"><a href="#bidirectionalunorderedmap-std-string-enum-filtersubject" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;std::string,enum FilterSubject&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;std::string,enum FilterSubject&gt;
{
  std::unordered_map&lt;std::string,enum FilterSubject&gt; mRight;
  std::unordered_map&lt;enum FilterSubject,std::string&gt; mLeft;
};

</code></pre></div><h3 id="buffer-span-mut-std-unique-ptr-block"><a href="#buffer-span-mut-std-unique-ptr-block" class="header-anchor">#</a> <code>buffer_span_mut&lt;std::unique_ptr&lt;Block&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;std::unique_ptr&lt;Block&gt; &gt;
{
  std::unique_ptr&lt;Block&gt; *mBegin;
  std::unique_ptr&lt;Block&gt; *mEnd;
};

</code></pre></div><h3 id="bounds-iterator"><a href="#bounds-iterator" class="header-anchor">#</a> <code>Bounds::Iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bounds::Iterator
{
  Pos mPos;
  const Bounds *mBounds;
  int mIdx;
};

</code></pre></div><h3 id="blocktyperegistry"><a href="#blocktyperegistry" class="header-anchor">#</a> <code>BlockTypeRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTypeRegistry
{
};

</code></pre></div><h3 id="blockpalette-constructortoken"><a href="#blockpalette-constructortoken" class="header-anchor">#</a> <code>BlockPalette::ConstructorToken</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPalette::ConstructorToken
{
};

</code></pre></div><h3 id="buffer-span-mut-nibblepair"><a href="#buffer-span-mut-nibblepair" class="header-anchor">#</a> <code>buffer_span_mut&lt;NibblePair&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;NibblePair&gt;
{
  NibblePair *mBegin;
  NibblePair *mEnd;
};

</code></pre></div><h3 id="buffer-span-mut-subchunk-iterator"><a href="#buffer-span-mut-subchunk-iterator" class="header-anchor">#</a> <code>buffer_span_mut&lt;SubChunk&gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;SubChunk&gt;::iterator
{
  SubChunk *mPtr;
};

</code></pre></div><h3 id="bidirectionalunorderedmap-std-string-automaticid-dimension-int"><a href="#bidirectionalunorderedmap-std-string-automaticid-dimension-int" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;std::string,AutomaticID&lt;Dimension,int&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;std::string,AutomaticID&lt;Dimension,int&gt; &gt;
{
  std::unordered_map&lt;std::string,AutomaticID&lt;Dimension,int&gt;&gt; mRight;
  std::unordered_map&lt;AutomaticID&lt;Dimension,int&gt;,std::string,std::hash&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::equal_to&lt;AutomaticID&lt;Dimension,int&gt; &gt;,std::allocator&lt;std::pair&lt;AutomaticID&lt;Dimension,int&gt; const ,std::string &gt; &gt; &gt; mLeft;
};

</code></pre></div><h3 id="behaviorpackcontents"><a href="#behaviorpackcontents" class="header-anchor">#</a> <code>BehaviorPackContents</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorPackContents
{
  unsigned int mEntities;
  unsigned int mLoots;
  unsigned int mTrades;
  unsigned int mPlugins;
};

</code></pre></div><h3 id="bedrock-pubsub-threadmodel-singlethreaded-nullmutex"><a href="#bedrock-pubsub-threadmodel-singlethreaded-nullmutex" class="header-anchor">#</a> <code>Bedrock::PubSub::ThreadModel::SingleThreaded::NullMutex</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::ThreadModel::SingleThreaded::NullMutex
{
};

</code></pre></div><h3 id="bedrock-pubsub-threadmodel-singlethreaded"><a href="#bedrock-pubsub-threadmodel-singlethreaded" class="header-anchor">#</a> <code>Bedrock::PubSub::ThreadModel::SingleThreaded</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::ThreadModel::SingleThreaded
{
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-inventorytransactionerror-std-string"><a href="#bidirectionalunorderedmap-enum-inventorytransactionerror-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum InventoryTransactionError,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum InventoryTransactionError,std::string &gt;
{
  std::unordered_map&lt;enum InventoryTransactionError,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum InventoryTransactionError&gt; mLeft;
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-complexinventorytransaction-type-std-string"><a href="#bidirectionalunorderedmap-enum-complexinventorytransaction-type-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ComplexInventoryTransaction::Type,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum ComplexInventoryTransaction::Type,std::string &gt;
{
  std::unordered_map&lt;enum ComplexInventoryTransaction::Type,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum ComplexInventoryTransaction::Type&gt; mLeft;
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardpasterequest-signalhandlermap"><a href="#bedrock-signal-applicationsignal-clipboardpasterequest-signalhandlermap" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardPasteRequest&gt;::SignalHandlerMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Signal&lt;ApplicationSignal::ClipboardPasteRequest&gt;::SignalHandlerMap : Bedrock::ISignalHandlerMap
{
  std::map&lt;unsigned short,std::function&lt;void __cdecl(std::shared_ptr&lt;ApplicationSignal::ClipboardPasteRequest&gt;)&gt;&gt; mMap;
};

</code></pre></div><h3 id="bedrock-signal-applicationsignal-clipboardpasterequest-signalhandlermap-vtbl"><a href="#bedrock-signal-applicationsignal-clipboardpasterequest-signalhandlermap-vtbl" class="header-anchor">#</a> <code>Bedrock::Signal&lt;ApplicationSignal::ClipboardPasteRequest&gt;::SignalHandlerMap_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Signal&lt;ApplicationSignal::ClipboardPasteRequest&gt;::SignalHandlerMap_vtbl
{
  void (__fastcall *~ISignalHandlerMap)(Bedrock::ISignalHandlerMap *this);
  bool (__fastcall *remove)(Bedrock::ISignalHandlerMap *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signalroute-applicationsignal-clipboardpasterequest"><a href="#bedrock-signalroute-applicationsignal-clipboardpasterequest" class="header-anchor">#</a> <code>Bedrock::SignalRoute&lt;ApplicationSignal::ClipboardPasteRequest&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::SignalRoute&lt;ApplicationSignal::ClipboardPasteRequest&gt; : Bedrock::SignalRouteBase
{
};

</code></pre></div><h3 id="bedrock-threading-whenall-void-initialize-l6-lambda-3496a18835e5c18c61a44274245c5836"><a href="#bedrock-threading-whenall-void-initialize-l6-lambda-3496a18835e5c18c61a44274245c5836" class="header-anchor">#</a> <code>Bedrock::Threading::WhenAll&lt;void&gt;::initialize::__l6::&lt;lambda_3496a18835e5c18c61a44274245c5836&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::WhenAll&lt;void&gt;::initialize::__l6::&lt;lambda_3496a18835e5c18c61a44274245c5836&gt;
{
  std::shared_ptr&lt;Bedrock::Threading::WhenAll&lt;void&gt; &gt; sharedThis;
};

</code></pre></div><h3 id="bundlesection"><a href="#bundlesection" class="header-anchor">#</a> <code>BundleSection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BundleSection : PDPSection
{
};

</code></pre></div><h3 id="bundlesection-vtbl"><a href="#bundlesection-vtbl" class="header-anchor">#</a> <code>BundleSection_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BundleSection_vtbl
{
  void (__fastcall *~PDPSection)(PDPSection *this);
  std::unique_ptr&lt;ScreenController&gt; *(__fastcall *makeScreenController)(PDPSection *this, std::unique_ptr&lt;ScreenController&gt; *result, std::shared_ptr&lt;MainMenuScreenModel&gt;);
};

</code></pre></div><h3 id="bundleupsellsection"><a href="#bundleupsellsection" class="header-anchor">#</a> <code>BundleUpsellSection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BundleUpsellSection : PDPSection
{
};

</code></pre></div><h3 id="bundleupsellsection-vtbl"><a href="#bundleupsellsection-vtbl" class="header-anchor">#</a> <code>BundleUpsellSection_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BundleUpsellSection_vtbl
{
  void (__fastcall *~PDPSection)(PDPSection *this);
  std::unique_ptr&lt;ScreenController&gt; *(__fastcall *makeScreenController)(PDPSection *this, std::unique_ptr&lt;ScreenController&gt; *result, std::shared_ptr&lt;MainMenuScreenModel&gt;);
};

</code></pre></div><h3 id="booloption-vtbl"><a href="#booloption-vtbl" class="header-anchor">#</a> <code>BoolOption_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BoolOption_vtbl
{
  void (__fastcall *~Option)(Option *this);
  void (__fastcall *save)(Option *this, std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *load)(Option *this, const Json::Value *);
  void (__fastcall *load)(Option *this, std::map&lt;std::string,std::string&gt; *);
  void (__fastcall *load)(Option *this, const std::string *);
};

</code></pre></div><h3 id="blockscreencontroller"><a href="#blockscreencontroller" class="header-anchor">#</a> <code>BlockScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockScreenController : ClientInstanceScreenController
{
  BlockActorType mBlockEntityType;
  BlockPos mBlockPos;
  ActorUniqueID mEntityUniqueID;
};

</code></pre></div><h3 id="blockscreencontroller-vtbl"><a href="#blockscreencontroller-vtbl" class="header-anchor">#</a> <code>BlockScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="bookscreenmanager"><a href="#bookscreenmanager" class="header-anchor">#</a> <code>BookScreenManager</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BookScreenManager
{
  Player *mPlayer;
  LecternBlockActor *mLectern;
  int mBookSlot;
  PacketSender *mPacketSender;
  std::unique_ptr&lt;SyncedPhotoView&gt; mPhotoView;
  std::vector&lt;Core::PathBuffer&lt;std::string &gt;&gt; mPickPictures;
  std::vector&lt;Core::PathBuffer&lt;std::string &gt;&gt; mExportFiles;
  unsigned __int64 mCurExportPage;
  bool mEdited;
  bool mIsEdu;
};

</code></pre></div><h3 id="bannerpattern"><a href="#bannerpattern" class="header-anchor">#</a> <code>BannerPattern</code></h3> <div class="language- extra-class"><pre class="language-text"><code>const struct __cppobj __declspec(align(8)) BannerPattern
{
  unsigned __int8 mID;
  std::vector&lt;std::string&gt; mPattern;
  ItemStack mIngredientItem;
  std::string mName;
  std::string mNameID;
  __int16 mPatternItemType;
  bool mIgnoreAux;
};

</code></pre></div><h3 id="buffer-span-std-string-iterator"><a href="#buffer-span-std-string-iterator" class="header-anchor">#</a> <code>buffer_span&lt;std::string &gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;std::string &gt;::iterator
{
  const std::string *mPtr;
};

</code></pre></div><h3 id="buffer-span-mut-std-string"><a href="#buffer-span-mut-std-string" class="header-anchor">#</a> <code>buffer_span_mut&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;std::string &gt;
{
  std::string *mBegin;
  std::string *mEnd;
};

</code></pre></div><h3 id="buffer-span-mut-int"><a href="#buffer-span-mut-int" class="header-anchor">#</a> <code>buffer_span_mut&lt;int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;int&gt;
{
  int *mBegin;
  int *mEnd;
};

</code></pre></div><h3 id="buffer-span-mut-bool"><a href="#buffer-span-mut-bool" class="header-anchor">#</a> <code>buffer_span_mut&lt;bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;bool&gt;
{
  bool *mBegin;
  bool *mEnd;
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-itemuseinventorytransaction-actiontype-std-string"><a href="#bidirectionalunorderedmap-enum-itemuseinventorytransaction-actiontype-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemUseInventoryTransaction::ActionType,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum ItemUseInventoryTransaction::ActionType,std::string &gt;
{
  std::unordered_map&lt;enum ItemUseInventoryTransaction::ActionType,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum ItemUseInventoryTransaction::ActionType&gt; mLeft;
};

</code></pre></div><h3 id="blockfiltergroup"><a href="#blockfiltergroup" class="header-anchor">#</a> <code>BlockFilterGroup</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockFilterGroup : FilterGroup
{
};

</code></pre></div><h3 id="boat-paddle"><a href="#boat-paddle" class="header-anchor">#</a> <code>Boat::Paddle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Boat::Paddle
{
  int mOldPressTime;
  int mPressTime;
  float mOldRowingTime;
  float mRowingTime;
  float mForce;
};

</code></pre></div><h3 id="boat"><a href="#boat" class="header-anchor">#</a> <code>Boat</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Boat : Actor
{
  MovementInterpolator mInterpolation;
  Boat::Paddle mPaddles[2];
  int mOutOfControlTicks;
  float mYRotD;
  float mInvFriction;
  bool mAboveBubbleColumn;
  bool mBubbleColumnDown;
  float mBubbleMultiplier;
  float mBubbleAngle;
  float mBubbleAngleOld;
};

</code></pre></div><h3 id="boat-vtbl"><a href="#boat-vtbl" class="header-anchor">#</a> <code>Boat_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Boat_vtbl
{
  bool (__fastcall *hasComponent)(Actor *this, const HashedString *);
  void (__fastcall *reloadHardcoded)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadHardcodedClient)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *initializeComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *reloadComponents)(Actor *this, Actor::InitializationMethod, const VariantParameterList *);
  void (__fastcall *_serverInitItemStackIds)(Actor *this);
  void (__fastcall *_doInitialMove)(Actor *this);
  bool (__fastcall *checkAllSensitiveWords)(Actor *this);
  bool (__fastcall *checkNameTag)(Actor *this);
  void (__fastcall *~Actor)(Actor *this);
  void (__fastcall *reset)(Actor *this);
  int (__fastcall *getOnDeathExperience)(Actor *this);
  ActorType (__fastcall *getOwnerEntityType)(Actor *this);
  void (__fastcall *remove)(Actor *this);
  void (__fastcall *setPos)(Actor *this, const Vec3 *);
  const PredictedMovementValues *(__fastcall *getPredictedMovementValues)(Actor *this);
  const Vec3 *(__fastcall *getPos)(Actor *this);
  const Vec3 *(__fastcall *getPosOld)(Actor *this);
  const Vec3 *(__fastcall *getPosExtrapolated)(Actor *this, const Vec3 *result, float);
  Vec3 *(__fastcall *getAttachPos)(Actor *this, Vec3 *result, ActorLocation, float);
  Vec3 *(__fastcall *getFiringPos)(Actor *this, Vec3 *result);
  void (__fastcall *setRot)(Actor *this, const Vec2 *);
  void (__fastcall *move)(Actor *this, IActorMovementProxy *, const Vec3 *);
  void (__fastcall *move)(Actor *this, const Vec3 *);
  Vec3 *(__fastcall *getInterpolatedRidingPosition)(Actor *this, Vec3 *result, float);
  float (__fastcall *getInterpolatedBodyRot)(Actor *this, float);
  float (__fastcall *getInterpolatedHeadRot)(Actor *this, float);
  float (__fastcall *getInterpolatedBodyYaw)(Actor *this, float);
  float (__fastcall *getYawSpeedInDegreesPerSecond)(Actor *this);
  float (__fastcall *getInterpolatedWalkAnimSpeed)(Actor *this, float);
  Vec3 *(__fastcall *getInterpolatedRidingOffset)(Actor *this, Vec3 *result, float);
  void (__fastcall *checkBlockCollisions)(Actor *this);
  void (__fastcall *checkBlockCollisions)(Actor *this, const AABB *, std::function&lt;void __cdecl(BlockSource &amp;,Block const &amp;,BlockPos const &amp;,Actor &amp;)&gt;);
  bool (__fastcall *isFireImmune)(Actor *this);
  bool (__fastcall *breaksFallingBlocks)(Actor *this);
  void (__fastcall *blockedByShield)(Actor *this, const ActorDamageSource *, Actor *);
  void (__fastcall *teleportTo)(Actor *this, const Vec3 *, bool, int, int, const ActorUniqueID *);
  bool (__fastcall *tryTeleportTo)(Actor *this, const Vec3 *, bool, bool, int, int);
  void (__fastcall *chorusFruitTeleport)(Actor *this, Vec3 *);
  void (__fastcall *lerpTo)(Actor *this, const Vec3 *, const Vec2 *, int);
  void (__fastcall *lerpMotion)(Actor *this, const Vec3 *);
  std::unique_ptr&lt;AddActorBasePacket&gt; *(__fastcall *getAddPacket)(Actor *this, std::unique_ptr&lt;AddActorBasePacket&gt; *result);
  void (__fastcall *normalTick)(Actor *this);
  void (__fastcall *baseTick)(Actor *this);
  void (__fastcall *rideTick)(Actor *this);
  void (__fastcall *positionRider)(Actor *this, Actor *, float);
  float (__fastcall *getRidingHeight)(Actor *this);
  bool (__fastcall *startRiding)(Actor *this, Actor *);
  void (__fastcall *addRider)(Actor *this, Actor *);
  void (__fastcall *flagRiderToRemove)(Actor *this, Actor *);
  std::string *(__fastcall *getExitTip)(Actor *this, std::string *result, const std::string *, InputMode);
  bool (__fastcall *intersects)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *);
  bool (__fastcall *isFree)(Actor *this, const Vec3 *, float);
  bool (__fastcall *isInWall)(Actor *this);
  bool (__fastcall *isInvisible)(Actor *this);
  bool (__fastcall *canShowNameTag)(Actor *this);
  bool (__fastcall *canExistInPeaceful)(Actor *this);
  void (__fastcall *setNameTagVisible)(Actor *this, bool);
  const std::string *(__fastcall *getNameTag)(Actor *this);
  unsigned __int64 (__fastcall *getNameTagAsHash)(Actor *this);
  std::string *(__fastcall *getFormattedNameTag)(Actor *this, std::string *result);
  void (__fastcall *filterFormattedNameTag)(Actor *this, const UIProfanityContext *);
  void (__fastcall *setNameTag)(Actor *this, const std::string *);
  bool (__fastcall *getAlwaysShowNameTag)(Actor *this);
  void (__fastcall *setScoreTag)(Actor *this, const std::string *);
  const std::string *(__fastcall *getScoreTag)(Actor *this);
  bool (__fastcall *isInWater)(Actor *this);
  bool (__fastcall *hasEnteredWater)(Actor *this);
  bool (__fastcall *isImmersedInWater)(Actor *this);
  bool (__fastcall *isInWaterOrRain)(Actor *this);
  bool (__fastcall *isInLava)(Actor *this);
  bool (__fastcall *isUnderLiquid)(Actor *this, MaterialType);
  bool (__fastcall *isOverWater)(Actor *this);
  void (__fastcall *makeStuckInBlock)(Actor *this, const Vec3 *);
  float (__fastcall *getCameraOffset)(Actor *this);
  float (__fastcall *getShadowHeightOffs)(Actor *this);
  float (__fastcall *getShadowRadius)(Actor *this);
  Vec3 *(__fastcall *getHeadLookVector)(Actor *this, Vec3 *result, float);
  bool (__fastcall *canSeeInvisible)(Actor *this);
  bool (__fastcall *canSee)(Actor *this, const Vec3 *);
  bool (__fastcall *canSee)(Actor *this, const Actor *);
  bool (__fastcall *isSkyLit)(Actor *this, float);
  float (__fastcall *getBrightness)(Actor *this, float);
  bool (__fastcall *interactPreventDefault)(Actor *this);
  void (__fastcall *playerTouch)(Actor *this, Player *);
  void (__fastcall *onAboveBubbleColumn)(Actor *this, const bool);
  void (__fastcall *onInsideBubbleColumn)(Actor *this, const bool);
  bool (__fastcall *isImmobile)(Actor *this);
  bool (__fastcall *isSilent)(Actor *this);
  bool (__fastcall *isPickable)(Actor *this);
  bool (__fastcall *isFishable)(Actor *this);
  bool (__fastcall *isSleeping)(Actor *this);
  bool (__fastcall *isShootable)(Actor *this);
  void (__fastcall *setSneaking)(Actor *this, bool);
  bool (__fastcall *isBlocking)(Actor *this);
  bool (__fastcall *isDamageBlocked)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *isAlive)(Actor *this);
  bool (__fastcall *isOnFire)(Actor *this);
  bool (__fastcall *isOnHotBlock)(Actor *this);
  bool (__fastcall *isCreativeModeAllowed)(Actor *this);
  bool (__fastcall *isSurfaceMob)(Actor *this);
  bool (__fastcall *isTargetable)(Actor *this);
  bool (__fastcall *isLocalPlayer)(Actor *this);
  bool (__fastcall *isPlayer)(Actor *this);
  bool (__fastcall *canAttack)(Actor *this, Actor *, bool);
  void (__fastcall *setTarget)(Actor *this, Actor *);
  Actor *(__fastcall *findAttackTarget)(Actor *this);
  bool (__fastcall *isValidTarget)(Actor *this, Actor *);
  bool (__fastcall *attack)(Actor *this, Actor *);
  void (__fastcall *performRangedAttack)(Actor *this, Actor *, float);
  void (__fastcall *adjustDamageAmount)(Actor *this, int *);
  int (__fastcall *getEquipmentCount)(Actor *this);
  void (__fastcall *setOwner)(Actor *this, const ActorUniqueID);
  void (__fastcall *setSitting)(Actor *this, bool);
  void (__fastcall *onTame)(Actor *this);
  void (__fastcall *onFailedTame)(Actor *this);
  int (__fastcall *getInventorySize)(Actor *this);
  int (__fastcall *getEquipSlots)(Actor *this);
  int (__fastcall *getChestSlots)(Actor *this);
  void (__fastcall *setStanding)(Actor *this, bool);
  bool (__fastcall *canPowerJump)(Actor *this);
  void (__fastcall *setCanPowerJump)(Actor *this, bool);
  bool (__fastcall *isJumping)(Actor *this);
  bool (__fastcall *isEnchanted)(Actor *this);
  void (__fastcall *rideJumped)(Actor *this);
  void (__fastcall *rideLanded)(Actor *this, const Vec3 *, const Vec3 *);
  bool (__fastcall *shouldRender)(Actor *this);
  bool (__fastcall *isInvulnerableTo)(Actor *this, const ActorDamageSource *);
  ActorDamageCause (__fastcall *getBlockDamageCause)(Actor *this, const Block *);
  void (__fastcall *actuallyHurt)(Actor *this, int, const ActorDamageSource *, bool);
  void (__fastcall *animateHurt)(Actor *this);
  bool (__fastcall *doFireHurt)(Actor *this, int);
  void (__fastcall *onLightningHit)(Actor *this);
  void (__fastcall *onBounceStarted)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *feed)(Actor *this, int);
  void (__fastcall *handleEntityEvent)(Actor *this, ActorEvent, int);
  float (__fastcall *getPickRadius)(Actor *this);
  const HashedString *(__fastcall *getActorRendererId)(Actor *this);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const ItemStack *, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, const Block *, int);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int, float);
  ItemActor *(__fastcall *spawnAtLocation)(Actor *this, int, int);
  void (__fastcall *despawn)(Actor *this);
  void (__fastcall *killed)(Actor *this, Actor *);
  void (__fastcall *awardKillScore)(Actor *this, Actor *, int);
  void (__fastcall *setArmor)(Actor *this, ArmorSlot, const ItemStack *);
  const ItemStack *(__fastcall *getArmor)(Actor *this, ArmorSlot);
  ArmorMaterialType (__fastcall *getArmorMaterialTypeInSlot)(Actor *this, ArmorSlot);
  ArmorTextureType (__fastcall *getArmorMaterialTextureTypeInSlot)(Actor *this, ArmorSlot);
  float (__fastcall *getArmorColorInSlot)(Actor *this, ArmorSlot, int);
  const ItemStack *(__fastcall *getEquippedSlot)(Actor *this, EquipmentSlot);
  void (__fastcall *setEquippedSlot)(Actor *this, EquipmentSlot, const ItemStack *);
  const ItemStack *(__fastcall *getCarriedItem)(Actor *this);
  void (__fastcall *setCarriedItem)(Actor *this, const ItemStack *);
  void (__fastcall *setOffhandSlot)(Actor *this, const ItemStack *);
  const ItemStack *(__fastcall *getEquippedTotem)(Actor *this);
  bool (__fastcall *consumeTotem)(Actor *this);
  bool (__fastcall *save)(Actor *this, CompoundTag *);
  void (__fastcall *saveWithoutId)(Actor *this, CompoundTag *);
  bool (__fastcall *load)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *loadLinks)(Actor *this, const CompoundTag *, std::vector&lt;ActorLink&gt; *, DataLoadHelper *);
  ActorType (__fastcall *getEntityTypeId)(Actor *this);
  const HashedString *(__fastcall *queryEntityRenderer)(Actor *this);
  ActorUniqueID *(__fastcall *getSourceUniqueID)(Actor *this, ActorUniqueID *result);
  void (__fastcall *setOnFire)(Actor *this, int);
  AABB *(__fastcall *getHandleWaterAABB)(Actor *this, AABB *result);
  void (__fastcall *handleInsidePortal)(Actor *this, const BlockPos *);
  int (__fastcall *getPortalCooldown)(Actor *this);
  int (__fastcall *getPortalWaitTime)(Actor *this);
  AutomaticID&lt;Dimension,int&gt; *(__fastcall *getDimensionId)(Actor *this, AutomaticID&lt;Dimension,int&gt; *result);
  bool (__fastcall *canChangeDimensions)(Actor *this);
  void (__fastcall *changeDimension)(Actor *this, const ChangeDimensionPacket *);
  void (__fastcall *changeDimension)(Actor *this, AutomaticID&lt;Dimension,int&gt;, bool);
  ActorUniqueID *(__fastcall *getControllingPlayer)(Actor *this, ActorUniqueID *result);
  void (__fastcall *checkFallDamage)(Actor *this, float, bool);
  void (__fastcall *causeFallDamage)(Actor *this, float);
  void (__fastcall *handleFallDistanceOnServer)(Actor *this, float, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, int, bool);
  void (__fastcall *playSynchronizedSound)(Actor *this, LevelSoundEvent, const Vec3 *, const Block *, bool);
  void (__fastcall *onSynchedDataUpdate)(Actor *this, int);
  bool (__fastcall *canAddRider)(Actor *this, Actor *);
  bool (__fastcall *canPickupItem)(Actor *this, const ItemStack *);
  bool (__fastcall *canBePulledIntoVehicle)(Actor *this);
  bool (__fastcall *inCaravan)(Actor *this);
  bool (__fastcall *isLeashableType)(Actor *this);
  void (__fastcall *tickLeash)(Actor *this);
  void (__fastcall *sendMotionPacketIfNeeded)(Actor *this);
  bool (__fastcall *canSynchronizeNewEntity)(Actor *this);
  bool (__fastcall *stopRiding)(Actor *this, bool, bool, bool, bool);
  void (__fastcall *startSwimming)(Actor *this);
  void (__fastcall *stopSwimming)(Actor *this);
  void (__fastcall *buildDebugInfo)(Actor *this, std::string *);
  CommandPermissionLevel (__fastcall *getCommandPermissionLevel)(Actor *this);
  AttributeInstance *(__fastcall *getMutableAttribute)(Actor *this, const Attribute *);
  const AttributeInstance *(__fastcall *getAttribute)(Actor *this, const Attribute *);
  int (__fastcall *getDeathTime)(Actor *this);
  void (__fastcall *heal)(Actor *this, int);
  bool (__fastcall *isInvertedHealAndHarm)(Actor *this);
  bool (__fastcall *canBeAffected)(Actor *this, const MobEffectInstance *);
  bool (__fastcall *canBeAffected)(Actor *this, int);
  bool (__fastcall *canBeAffectedByArrow)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectAdded)(Actor *this, MobEffectInstance *);
  void (__fastcall *onEffectUpdated)(Actor *this, const MobEffectInstance *);
  void (__fastcall *onEffectRemoved)(Actor *this, MobEffectInstance *);
  AnimationComponent *(__fastcall *getAnimationComponent)(Actor *this);
  void (__fastcall *openContainerComponent)(Actor *this, Player *);
  void (__fastcall *swing)(Actor *this);
  void (__fastcall *useItem)(Actor *this, ItemStackBase *, ItemUseMethod, bool);
  bool (__fastcall *hasOutputSignal)(Actor *this, unsigned __int8);
  int (__fastcall *getOutputSignal)(Actor *this);
  void (__fastcall *getDebugText)(Actor *this, std::vector&lt;std::string&gt; *);
  float (__fastcall *getMapDecorationRotation)(Actor *this);
  float (__fastcall *getRiderYRotation)(Actor *this, const Actor *);
  float (__fastcall *getYHeadRot)(Actor *this);
  bool (__fastcall *isWorldBuilder)(Actor *this);
  bool (__fastcall *isCreative)(Actor *this);
  bool (__fastcall *isAdventure)(Actor *this);
  bool (__fastcall *add)(Actor *this, ItemStack *);
  bool (__fastcall *drop)(Actor *this, const ItemStack *, bool);
  bool (__fastcall *getInteraction)(Actor *this, Player *, ActorInteraction *, const Vec3 *);
  bool (__fastcall *canDestroyBlock)(Actor *this, const Block *);
  void (__fastcall *setAuxValue)(Actor *this, int);
  void (__fastcall *setSize)(Actor *this, float, float);
  int (__fastcall *getLifeSpan)(Actor *this);
  void (__fastcall *onOrphan)(Actor *this);
  void (__fastcall *wobble)(Actor *this);
  bool (__fastcall *wasHurt)(Actor *this);
  void (__fastcall *startSpinAttack)(Actor *this);
  void (__fastcall *stopSpinAttack)(Actor *this);
  void (__fastcall *setDamageNearbyMobs)(Actor *this, bool);
  bool (__fastcall *hasCritBox)(Actor *this);
  bool (__fastcall *isCritHit)(Actor *this);
  void (__fastcall *renderDebugServerState)(Actor *this, const Options *);
  void (__fastcall *reloadLootTable)(Actor *this, const EquipmentTableDefinition *);
  void (__fastcall *reloadLootTable)(Actor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(Actor *this);
  void (__fastcall *kill)(Actor *this);
  void (__fastcall *die)(Actor *this, const ActorDamageSource *);
  bool (__fastcall *shouldTick)(Actor *this);
  std::shared_ptr&lt;IActorMovementProxy&gt; *(__fastcall *createMovementProxy)(Actor *this, std::shared_ptr&lt;IActorMovementProxy&gt; *result);
  void (__fastcall *updateEntitySpecificMolangVariables)(Actor *this, RenderParams *);
  bool (__fastcall *shouldTryMakeStepSound)(Actor *this);
  float (__fastcall *getNextStep)(Actor *this, const float);
  bool (__fastcall *canMakeStepSound)(Actor *this);
  void (__fastcall *outOfWorld)(Actor *this);
  bool (__fastcall *_hurt)(Actor *this, const ActorDamageSource *, int, bool, bool);
  void (__fastcall *markHurt)(Actor *this);
  void (__fastcall *readAdditionalSaveData)(Actor *this, const CompoundTag *, DataLoadHelper *);
  void (__fastcall *addAdditionalSaveData)(Actor *this, CompoundTag *);
  void (__fastcall *_playStepSound)(Actor *this, const BlockPos *, const Block *);
  void (__fastcall *_playFlySound)(Actor *this, const BlockPos *, const Block *);
  bool (__fastcall *_makeFlySound)(Actor *this);
  void (__fastcall *checkInsideBlocks)(Actor *this, float);
  void (__fastcall *pushOutOfBlocks)(Actor *this, const Vec3 *);
  bool (__fastcall *updateWaterState)(Actor *this);
  void (__fastcall *doWaterSplashEffect)(Actor *this);
  void (__fastcall *spawnTrailBubbles)(Actor *this);
  void (__fastcall *updateInsideBlock)(Actor *this);
  LootTable *(__fastcall *getLootTable)(Actor *this);
  LootTable *(__fastcall *getDefaultLootTable)(Actor *this);
  void (__fastcall *_removeRider)(Actor *this, const ActorUniqueID *, bool, bool, bool);
  void (__fastcall *_onSizeUpdated)(Actor *this);
  void (__fastcall *_doAutoAttackOnTouch)(Actor *this, Actor *);
};

</code></pre></div><h3 id="boost-container-new-t"><a href="#boost-container-new-t" class="header-anchor">#</a> <code>boost_container_new_t</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj boost_container_new_t
{
};

</code></pre></div><h3 id="boost-move-new-t"><a href="#boost-move-new-t" class="header-anchor">#</a> <code>boost_move_new_t</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj boost_move_new_t
{
};

</code></pre></div><h3 id="buffer-span-terrainlayer"><a href="#buffer-span-terrainlayer" class="header-anchor">#</a> <code>buffer_span&lt;TerrainLayer *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;TerrainLayer *&gt;
{
  TerrainLayer *const *mBegin;
  TerrainLayer *const *mEnd;
};

</code></pre></div><h3 id="buffer-span-terrainlayer-iterator"><a href="#buffer-span-terrainlayer-iterator" class="header-anchor">#</a> <code>buffer_span&lt;TerrainLayer *&gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;TerrainLayer *&gt;::iterator
{
  TerrainLayer *const *mPtr;
};

</code></pre></div><h3 id="buffer-span-mut-terrainlayer"><a href="#buffer-span-mut-terrainlayer" class="header-anchor">#</a> <code>buffer_span_mut&lt;TerrainLayer *&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;TerrainLayer *&gt;
{
  TerrainLayer **mBegin;
  TerrainLayer **mEnd;
};

</code></pre></div><h3 id="blockunitcubedescription"><a href="#blockunitcubedescription" class="header-anchor">#</a> <code>BlockUnitCubeDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockUnitCubeDescription : BlockComponentDescription
{
};

</code></pre></div><h3 id="blockunitcubedescription-vtbl"><a href="#blockunitcubedescription-vtbl" class="header-anchor">#</a> <code>BlockUnitCubeDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockUnitCubeDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockgeometrydescription"><a href="#blockgeometrydescription" class="header-anchor">#</a> <code>BlockGeometryDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGeometryDescription : BlockComponentDescription
{
  std::string mGeometryName;
};

</code></pre></div><h3 id="blockgeometrydescription-vtbl"><a href="#blockgeometrydescription-vtbl" class="header-anchor">#</a> <code>BlockGeometryDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockGeometryDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="blockmaterialinstance"><a href="#blockmaterialinstance" class="header-anchor">#</a> <code>BlockMaterialInstance</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstance
{
  std::string mTextureName;
  std::string mRenderMethod;
  bool mAmbientOcclusion;
  bool mFaceDimming;
  BlockRenderLayer mRenderLayer;
  std::shared_ptr&lt;ClientBlockPipeline::Material const &gt; mMaterial;
};

</code></pre></div><h3 id="blockmaterialinstancesdescription"><a href="#blockmaterialinstancesdescription" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockMaterialInstancesDescription : BlockComponentDescription
{
  std::unordered_map&lt;std::string,BlockMaterialInstance&gt; mMaterials;
  std::unordered_map&lt;std::string,std::string&gt; mMaterialMappings;
};

</code></pre></div><h3 id="blockmaterialinstancesdescription-vtbl"><a href="#blockmaterialinstancesdescription-vtbl" class="header-anchor">#</a> <code>BlockMaterialInstancesDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockMaterialInstancesDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="buffer-span-mut-clientblockpipeline-blockcell"><a href="#buffer-span-mut-clientblockpipeline-blockcell" class="header-anchor">#</a> <code>buffer_span_mut&lt;ClientBlockPipeline::BlockCell&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;ClientBlockPipeline::BlockCell&gt;
{
  ClientBlockPipeline::BlockCell *mBegin;
  ClientBlockPipeline::BlockCell *mEnd;
};

</code></pre></div><h3 id="blockgraphics-constructortoken"><a href="#blockgraphics-constructortoken" class="header-anchor">#</a> <code>BlockGraphics::ConstructorToken</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGraphics::ConstructorToken
{
};

</code></pre></div><h3 id="bedrock-nonownerpointer-clientblockpipeline-material-const"><a href="#bedrock-nonownerpointer-clientblockpipeline-material-const" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;ClientBlockPipeline::Material const &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;ClientBlockPipeline::Material const &gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="buffer-span-mut-clientblockpipeline-blockschematiccell"><a href="#buffer-span-mut-clientblockpipeline-blockschematiccell" class="header-anchor">#</a> <code>buffer_span_mut&lt;ClientBlockPipeline::BlockSchematicCell&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;ClientBlockPipeline::BlockSchematicCell&gt;
{
  ClientBlockPipeline::BlockSchematicCell *mBegin;
  ClientBlockPipeline::BlockSchematicCell *mEnd;
};

</code></pre></div><h3 id="buffer-span-mut-clientblockpipeline-blockschematiccell-const-iterator"><a href="#buffer-span-mut-clientblockpipeline-blockschematiccell-const-iterator" class="header-anchor">#</a> <code>buffer_span_mut&lt;ClientBlockPipeline::BlockSchematicCell const &gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;ClientBlockPipeline::BlockSchematicCell const &gt;::iterator
{
  const ClientBlockPipeline::BlockSchematicCell *mPtr;
};

</code></pre></div><h3 id="blockrotationdescription"><a href="#blockrotationdescription" class="header-anchor">#</a> <code>BlockRotationDescription</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockRotationDescription : BlockComponentDescription
{
  Vec3 mRotation;
};

</code></pre></div><h3 id="blockrotationdescription-vtbl"><a href="#blockrotationdescription-vtbl" class="header-anchor">#</a> <code>BlockRotationDescription_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockRotationDescription_vtbl
{
  void (__fastcall *~BlockComponentDescription)(BlockComponentDescription *this);
  const std::string *(__fastcall *getName)(BlockComponentDescription *this);
  void (__fastcall *initializeComponent)(BlockComponentDescription *this, EntityContext *);
  void (__fastcall *buildSchema)(BlockComponentDescription *this, std::shared_ptr&lt;JsonUtil::JsonSchemaObjectNode&lt;JsonUtil::EmptyClass,BlockComponentGroupDescription&gt; &gt; *, const BlockComponentFactory *);
  bool (__fastcall *isNetworkComponent)(BlockComponentDescription *this);
  std::unique_ptr&lt;CompoundTag&gt; *(__fastcall *buildNetworkTag)(BlockComponentDescription *this, std::unique_ptr&lt;CompoundTag&gt; *result);
  void (__fastcall *initializeFromNetwork)(BlockComponentDescription *this, const CompoundTag *);
};

</code></pre></div><h3 id="buffer-span-mut-clientblockpipeline-blockcell-const-iterator"><a href="#buffer-span-mut-clientblockpipeline-blockcell-const-iterator" class="header-anchor">#</a> <code>buffer_span_mut&lt;ClientBlockPipeline::BlockCell const &gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;ClientBlockPipeline::BlockCell const &gt;::iterator
{
  const ClientBlockPipeline::BlockCell *mPtr;
};

</code></pre></div><h3 id="blockrotationcomponent"><a href="#blockrotationcomponent" class="header-anchor">#</a> <code>BlockRotationComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockRotationComponent
{
  Vec3 mRotation;
};

</code></pre></div><h3 id="bedrock-threading-burst-details-worktarget"><a href="#bedrock-threading-burst-details-worktarget" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Details::WorkTarget</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::Details::WorkTarget
{
  Bedrock::Threading::Burst::Details::WorkTargetItem mPrimary;
  gsl::span&lt;Bedrock::Threading::Burst::Details::WorkTargetItem,-1&gt; mSecondaries;
  std::vector&lt;Bedrock::Threading::Burst::Details::WorkTargetItem&gt; mSecondariesStorage;
};

</code></pre></div><h3 id="bedrock-threading-burst-queueconfig"><a href="#bedrock-threading-burst-queueconfig" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::QueueConfig</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::QueueConfig
{
  std::string mName;
  unsigned int mPriority;
  Scheduler *mScheduler;
  WorkerPool *mPrimaryWorkerPool;
  std::vector&lt;std::reference_wrapper&lt;WorkerPool&gt;&gt; mSecondaryWorkerPools;
  std::vector&lt;std::thread::id&gt; mAffinities;
};

</code></pre></div><h3 id="bedrock-threading-burst-strategy-execution-defaultexecution"><a href="#bedrock-threading-burst-strategy-execution-defaultexecution" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Strategy::Execution::DefaultExecution</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::Strategy::Execution::DefaultExecution
{
};

</code></pre></div><h3 id="buffer-span-mut-unsigned-char"><a href="#buffer-span-mut-unsigned-char" class="header-anchor">#</a> <code>buffer_span_mut&lt;unsigned char&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;unsigned char&gt;
{
  unsigned __int8 *mBegin;
  unsigned __int8 *mEnd;
};

</code></pre></div><h3 id="bgfx-callbacki"><a href="#bgfx-callbacki" class="header-anchor">#</a> <code>bgfx::CallbackI</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::CallbackI
{
  bgfx::CallbackI_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bgfx-callbacki-vtbl"><a href="#bgfx-callbacki-vtbl" class="header-anchor">#</a> <code>bgfx::CallbackI_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ bgfx::CallbackI_vtbl
{
  void (__fastcall *~CallbackI)(bgfx::CallbackI *this);
  void (__fastcall *fatal)(bgfx::CallbackI *this, bgfx::Fatal::Enum, const char *);
  void (__fastcall *traceVargs)(bgfx::CallbackI *this, const char *, unsigned __int16, const char *, char *);
  void (__fastcall *profilerBegin)(bgfx::CallbackI *this, const char *, unsigned int, const char *, unsigned __int16);
  void (__fastcall *profilerBeginLiteral)(bgfx::CallbackI *this, const char *, unsigned int, const char *, unsigned __int16);
  void (__fastcall *profilerEnd)(bgfx::CallbackI *this);
  unsigned int (__fastcall *cacheReadSize)(bgfx::CallbackI *this, unsigned __int64);
  bool (__fastcall *cacheRead)(bgfx::CallbackI *this, unsigned __int64, void *, unsigned int);
  void (__fastcall *cacheWrite)(bgfx::CallbackI *this, unsigned __int64, const void *, unsigned int);
  void (__fastcall *screenShot)(bgfx::CallbackI *this, const char *, unsigned int, unsigned int, unsigned int, const void *, unsigned int, bool);
  void (__fastcall *captureBegin)(bgfx::CallbackI *this, unsigned int, unsigned int, unsigned int, bgfx::TextureFormat::Enum, bool);
  void (__fastcall *captureEnd)(bgfx::CallbackI *this);
  void (__fastcall *captureFrame)(bgfx::CallbackI *this, const void *, unsigned int);
  void (__fastcall *parallelForeach)(bgfx::CallbackI *this, void *, const unsigned int, void (__fastcall *)(void *, const unsigned int));
  void (__fastcall *postRenderCommandBuffer)(bgfx::CallbackI *this, void *);
};

</code></pre></div><h3 id="bx-allocatori-vtbl"><a href="#bx-allocatori-vtbl" class="header-anchor">#</a> <code>bx::AllocatorI_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ bx::AllocatorI_vtbl
{
  void (__fastcall *~AllocatorI)(bx::AllocatorI *this);
  void *(__fastcall *realloc)(bx::AllocatorI *this, void *, unsigned __int64, unsigned __int64, const char *, unsigned int);
};

</code></pre></div><h3 id="bgfx-encoder"><a href="#bgfx-encoder" class="header-anchor">#</a> <code>bgfx::Encoder</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::Encoder
{
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void"><a href="#bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;
{
  Bedrock::Intrusive::list_base_hook&lt;void&gt; mSentinel;
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder"><a href="#bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt; : Bedrock::Threading::InstancedThreadLocalBase
{
  std::function&lt;void __cdecl(bgfx::Encoder * *)&gt; mConstructor;
  Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt; mItems;
  std::mutex mMutex;
  unsigned int mKey;
  bool mInitialized;
};

</code></pre></div><h3 id="buffer-span-mut-clientblockpipeline-blockcell-iterator"><a href="#buffer-span-mut-clientblockpipeline-blockcell-iterator" class="header-anchor">#</a> <code>buffer_span_mut&lt;ClientBlockPipeline::BlockCell&gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;ClientBlockPipeline::BlockCell&gt;::iterator
{
  ClientBlockPipeline::BlockCell *mPtr;
};

</code></pre></div><h3 id="basaltdeltasmoodsoundplayer"><a href="#basaltdeltasmoodsoundplayer" class="header-anchor">#</a> <code>BasaltDeltasMoodSoundPlayer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BasaltDeltasMoodSoundPlayer
{
};

</code></pre></div><h3 id="biomemoodsoundplayerregistry"><a href="#biomemoodsoundplayerregistry" class="header-anchor">#</a> <code>BiomeMoodSoundPlayerRegistry</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BiomeMoodSoundPlayerRegistry
{
};

</code></pre></div><h3 id="bitmapv4header"><a href="#bitmapv4header" class="header-anchor">#</a> <code>BITMAPV4HEADER</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct BITMAPV4HEADER
{
  unsigned int bV4Size;
  int bV4Width;
  int bV4Height;
  unsigned __int16 bV4Planes;
  unsigned __int16 bV4BitCount;
  unsigned int bV4V4Compression;
  unsigned int bV4SizeImage;
  int bV4XPelsPerMeter;
  int bV4YPelsPerMeter;
  unsigned int bV4ClrUsed;
  unsigned int bV4ClrImportant;
  unsigned int bV4RedMask;
  unsigned int bV4GreenMask;
  unsigned int bV4BlueMask;
  unsigned int bV4AlphaMask;
  unsigned int bV4CSType;
  tagICEXYZTRIPLE bV4Endpoints;
  unsigned int bV4GammaRed;
  unsigned int bV4GammaGreen;
  unsigned int bV4GammaBlue;
};

</code></pre></div><h3 id="battery-reporting-scale"><a href="#battery-reporting-scale" class="header-anchor">#</a> <code>BATTERY_REPORTING_SCALE</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct BATTERY_REPORTING_SCALE
{
  unsigned int Granularity;
  unsigned int Capacity;
};

</code></pre></div><h3 id="bedrock-threading-mainprocscope"><a href="#bedrock-threading-mainprocscope" class="header-anchor">#</a> <code>Bedrock::Threading::MainProcScope</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::MainProcScope
{
};

</code></pre></div><h3 id="bitmapv5header"><a href="#bitmapv5header" class="header-anchor">#</a> <code>BITMAPV5HEADER</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct BITMAPV5HEADER
{
  unsigned int bV5Size;
  int bV5Width;
  int bV5Height;
  unsigned __int16 bV5Planes;
  unsigned __int16 bV5BitCount;
  unsigned int bV5Compression;
  unsigned int bV5SizeImage;
  int bV5XPelsPerMeter;
  int bV5YPelsPerMeter;
  unsigned int bV5ClrUsed;
  unsigned int bV5ClrImportant;
  unsigned int bV5RedMask;
  unsigned int bV5GreenMask;
  unsigned int bV5BlueMask;
  unsigned int bV5AlphaMask;
  unsigned int bV5CSType;
  tagICEXYZTRIPLE bV5Endpoints;
  unsigned int bV5GammaRed;
  unsigned int bV5GammaGreen;
  unsigned int bV5GammaBlue;
  unsigned int bV5Intent;
  unsigned int bV5ProfileData;
  unsigned int bV5ProfileSize;
  unsigned int bV5Reserved;
};

</code></pre></div><h3 id="bsminfo"><a href="#bsminfo" class="header-anchor">#</a> <code>BSMINFO</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct BSMINFO
{
  unsigned int cbSize;
  HDESK__ *hdesk;
  HWND__ *hwnd;
  _LUID luid;
};

</code></pre></div><h3 id="buffer-span-rangeindices"><a href="#buffer-span-rangeindices" class="header-anchor">#</a> <code>buffer_span&lt;RangeIndices&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;RangeIndices&gt;
{
  const RangeIndices *mBegin;
  const RangeIndices *mEnd;
};

</code></pre></div><h3 id="buffer-span-std-vector-renderchunkquadinfo"><a href="#buffer-span-std-vector-renderchunkquadinfo" class="header-anchor">#</a> <code>buffer_span&lt;std::vector&lt;RenderChunkQuadInfo&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;std::vector&lt;RenderChunkQuadInfo&gt; &gt;
{
  const std::vector&lt;RenderChunkQuadInfo&gt; *mBegin;
  const std::vector&lt;RenderChunkQuadInfo&gt; *mEnd;
};

</code></pre></div><h3 id="buffer-span-actorblocksyncmessage"><a href="#buffer-span-actorblocksyncmessage" class="header-anchor">#</a> <code>buffer_span&lt;ActorBlockSyncMessage&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;ActorBlockSyncMessage&gt;
{
  const ActorBlockSyncMessage *mBegin;
  const ActorBlockSyncMessage *mEnd;
};

</code></pre></div><h3 id="buffer-span-blockactorblocksyncmessage"><a href="#buffer-span-blockactorblocksyncmessage" class="header-anchor">#</a> <code>buffer_span&lt;BlockActorBlockSyncMessage&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;BlockActorBlockSyncMessage&gt;
{
  const BlockActorBlockSyncMessage *mBegin;
  const BlockActorBlockSyncMessage *mEnd;
};

</code></pre></div><h3 id="bedrock-iislandmanagerlogger"><a href="#bedrock-iislandmanagerlogger" class="header-anchor">#</a> <code>Bedrock::IIslandManagerLogger</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::IIslandManagerLogger
{
  Bedrock::IIslandManagerLogger_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-iislandmanagerlogger-vtbl"><a href="#bedrock-iislandmanagerlogger-vtbl" class="header-anchor">#</a> <code>Bedrock::IIslandManagerLogger_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::IIslandManagerLogger_vtbl
{
  void (__fastcall *~IIslandManagerLogger)(Bedrock::IIslandManagerLogger *this);
  void (__fastcall *transitionSignaled)(Bedrock::IIslandManagerLogger *this, Bedrock::IslandTransition);
  void (__fastcall *transitionCompleted)(Bedrock::IIslandManagerLogger *this);
  void (__fastcall *islandUpdate)(Bedrock::IIslandManagerLogger *this, unsigned __int16, std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt;);
  void (__fastcall *islandTransition)(Bedrock::IIslandManagerLogger *this, unsigned __int16, Bedrock::IslandTransition, bool, std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt;);
};

</code></pre></div><h3 id="bedrock-nonownerpointer-levelstoragesource"><a href="#bedrock-nonownerpointer-levelstoragesource" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;LevelStorageSource&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;LevelStorageSource&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-signal-minecraftgame-serverinitcompleted"><a href="#bedrock-signal-minecraftgame-serverinitcompleted" class="header-anchor">#</a> <code>Bedrock::Signal&lt;MinecraftGame::ServerInitCompleted&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Signal&lt;MinecraftGame::ServerInitCompleted&gt; : Bedrock::SignalBase
{
};

</code></pre></div><h3 id="bedrock-signal-minecraftgame-serverinitcompleted-vtbl"><a href="#bedrock-signal-minecraftgame-serverinitcompleted-vtbl" class="header-anchor">#</a> <code>Bedrock::Signal&lt;MinecraftGame::ServerInitCompleted&gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Signal&lt;MinecraftGame::ServerInitCompleted&gt;_vtbl
{
  void (__fastcall *~SignalBase)(Bedrock::SignalBase *this);
  bool (__fastcall *invokeHandler)(Bedrock::SignalBase *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signal-minecraftgame-serverinitcompleted-signalhandlermap"><a href="#bedrock-signal-minecraftgame-serverinitcompleted-signalhandlermap" class="header-anchor">#</a> <code>Bedrock::Signal&lt;MinecraftGame::ServerInitCompleted&gt;::SignalHandlerMap</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Signal&lt;MinecraftGame::ServerInitCompleted&gt;::SignalHandlerMap : Bedrock::ISignalHandlerMap
{
  std::map&lt;unsigned short,std::function&lt;void __cdecl(std::shared_ptr&lt;MinecraftGame::ServerInitCompleted&gt;)&gt;&gt; mMap;
};

</code></pre></div><h3 id="bedrock-signal-minecraftgame-serverinitcompleted-signalhandlermap-vtbl"><a href="#bedrock-signal-minecraftgame-serverinitcompleted-signalhandlermap-vtbl" class="header-anchor">#</a> <code>Bedrock::Signal&lt;MinecraftGame::ServerInitCompleted&gt;::SignalHandlerMap_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Signal&lt;MinecraftGame::ServerInitCompleted&gt;::SignalHandlerMap_vtbl
{
  void (__fastcall *~ISignalHandlerMap)(Bedrock::ISignalHandlerMap *this);
  bool (__fastcall *remove)(Bedrock::ISignalHandlerMap *this, const unsigned __int16 *);
};

</code></pre></div><h3 id="bedrock-signalroute-minecraftgame-serverinitcompleted"><a href="#bedrock-signalroute-minecraftgame-serverinitcompleted" class="header-anchor">#</a> <code>Bedrock::SignalRoute&lt;MinecraftGame::ServerInitCompleted&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::SignalRoute&lt;MinecraftGame::ServerInitCompleted&gt; : Bedrock::SignalRouteBase
{
};

</code></pre></div><h3 id="bobbehavior"><a href="#bobbehavior" class="header-anchor">#</a> <code>BobBehavior</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BobBehavior : CameraBehavior&lt;BobBehavior&gt;
{
};

</code></pre></div><h3 id="bobbehavior-vtbl"><a href="#bobbehavior-vtbl" class="header-anchor">#</a> <code>BobBehavior_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BobBehavior_vtbl
{
  void (__fastcall *~ICameraBehavior)(ICameraBehavior *this);
  void (__fastcall *onSetup)(ICameraBehavior *this, IClientInstance *, CameraDirector *);
  void (__fastcall *onStart)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *update)(ICameraBehavior *this, IClientInstance *, float, float, CameraDirector *);
  void (__fastcall *handleLookInput)(ICameraBehavior *this, Vec2 *, CameraDirector *);
  void (__fastcall *renderDebug)(ICameraBehavior *this, IClientInstance *, float, CameraDirector *);
  bool (__fastcall *handleCameraSetRot)(ICameraBehavior *this, const Vec2 *, CameraDirector *);
  HashedString *(__fastcall *getId)(ICameraBehavior *this, HashedString *result);
  ICameraBehavior::UpdateOrder (__fastcall *getUpdateOrder)(ICameraBehavior *this);
};

</code></pre></div><h3 id="bedblock"><a href="#bedblock" class="header-anchor">#</a> <code>BedBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedBlock : BlockLegacy
{
};

</code></pre></div><h3 id="bedblock-vtbl"><a href="#bedblock-vtbl" class="header-anchor">#</a> <code>BedBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BedBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
};

</code></pre></div><h3 id="bobbehaviorloader"><a href="#bobbehaviorloader" class="header-anchor">#</a> <code>BobBehaviorLoader</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BobBehaviorLoader : CameraBehaviorLoader
{
};

</code></pre></div><h3 id="bobbehaviorloader-vtbl"><a href="#bobbehaviorloader-vtbl" class="header-anchor">#</a> <code>BobBehaviorLoader_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BobBehaviorLoader_vtbl
{
  void (__fastcall *~CameraBehaviorLoader)(CameraBehaviorLoader *this);
  std::unique_ptr&lt;ICameraBehavior&gt; *(__fastcall *create)(CameraBehaviorLoader *this, std::unique_ptr&lt;ICameraBehavior&gt; *result);
  void (__fastcall *parse)(CameraBehaviorLoader *this, Json::Value *, ICameraBehavior *);
};

</code></pre></div><h3 id="buffer-span-enum-flip"><a href="#buffer-span-enum-flip" class="header-anchor">#</a> <code>buffer_span&lt;enum Flip&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;enum Flip&gt;
{
  const Flip *mBegin;
  const Flip *mEnd;
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-std-string"><a href="#bedrock-threading-asyncdeferredresultt-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::AsyncDeferredResultT&lt;std::string &gt; : Bedrock::Threading::IAsyncResult&lt;std::string &gt;
{
  std::mutex mLock;
  Bedrock::Threading::AsyncDeferredResultT&lt;std::string &gt;::DelayStatus mStatus;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::string &gt; const &amp;)&gt;&gt; mComplete;
  std::optional&lt;std::string &gt; mResult;
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-std-string-vtbl"><a href="#bedrock-threading-asyncdeferredresultt-std-string-vtbl" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;std::string &gt;_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Threading::AsyncDeferredResultT&lt;std::string &gt;_vtbl
{
  void (__fastcall *~IAsyncResult&lt;std::string &gt;)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  Bedrock::Threading::AsyncStatus (__fastcall *getStatus)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  std::error_code *(__fastcall *getError)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::error_code *result);
  std::exception_ptr *(__fastcall *getException)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::exception_ptr *result);
  std::string *(__fastcall *getResult)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::string *result);
  void (__fastcall *cancel)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this);
  void (__fastcall *addOnComplete)(Bedrock::Threading::IAsyncResult&lt;std::string &gt; *this, std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;std::string &gt; const &amp;)&gt;);
};

</code></pre></div><h3 id="buffer-span-unsigned-int64-iterator"><a href="#buffer-span-unsigned-int64-iterator" class="header-anchor">#</a> <code>buffer_span&lt;unsigned __int64&gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;unsigned __int64&gt;::iterator
{
  const unsigned __int64 *mPtr;
};

</code></pre></div><h3 id="buffer-span-unsigned-int64"><a href="#buffer-span-unsigned-int64" class="header-anchor">#</a> <code>buffer_span&lt;unsigned __int64&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;unsigned __int64&gt;
{
  const unsigned __int64 *mBegin;
  const unsigned __int64 *mEnd;
};

</code></pre></div><h3 id="byvalueleveldataoverride"><a href="#byvalueleveldataoverride" class="header-anchor">#</a> <code>ByValueLevelDataOverride</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ByValueLevelDataOverride : ILevelDataOverride
{
  std::function&lt;void __cdecl(gsl::basic_string_span&lt;char const ,-1&gt;)&gt; mOnValueChanged;
  LevelDataOverrideValues mValues;
};

</code></pre></div><h3 id="byvalueleveldataoverride-vtbl"><a href="#byvalueleveldataoverride-vtbl" class="header-anchor">#</a> <code>ByValueLevelDataOverride_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ByValueLevelDataOverride_vtbl
{
  void (__fastcall *~ILevelDataOverride)(ILevelDataOverride *this);
  void (__fastcall *applyTo)(ILevelDataOverride *this, LevelData *);
};

</code></pre></div><h3 id="blockgeometry-rotation"><a href="#blockgeometry-rotation" class="header-anchor">#</a> <code>BlockGeometry::Rotation</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGeometry::Rotation
{
  glm::tvec3&lt;float,0&gt; origin;
  _BYTE axis[4];
  float angle;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-perftimer-std-allocator-perftimer"><a href="#bedrock-threading-threadlocalobjectimplementation-perftimer-std-allocator-perftimer" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;PerfTimer,std::allocator&lt;PerfTimer&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;PerfTimer,std::allocator&lt;PerfTimer&gt; &gt;
{
  PerfTimer *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-perftimer-std-allocator-perftimer"><a href="#bedrock-threading-threadlocalobject-perftimer-std-allocator-perftimer" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;PerfTimer,std::allocator&lt;PerfTimer&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;PerfTimer,std::allocator&lt;PerfTimer&gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;PerfTimer,std::allocator&lt;PerfTimer&gt; &gt;
{
  std::function&lt;void __cdecl(PerfTimer *)&gt; mConstructor;
};

</code></pre></div><h3 id="bigendianstringbyteoutput"><a href="#bigendianstringbyteoutput" class="header-anchor">#</a> <code>BigEndianStringByteOutput</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BigEndianStringByteOutput : StringByteOutput
{
};

</code></pre></div><h3 id="bigendianstringbyteoutput-vtbl"><a href="#bigendianstringbyteoutput-vtbl" class="header-anchor">#</a> <code>BigEndianStringByteOutput_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BigEndianStringByteOutput_vtbl
{
  void (__fastcall *~IDataOutput)(IDataOutput *this);
  void (__fastcall *writeString)(IDataOutput *this, gsl::basic_string_span&lt;char const ,-1&gt;);
  void (__fastcall *writeLongString)(IDataOutput *this, gsl::basic_string_span&lt;char const ,-1&gt;);
  void (__fastcall *writeFloat)(IDataOutput *this, float);
  void (__fastcall *writeDouble)(IDataOutput *this, long double);
  void (__fastcall *writeByte)(IDataOutput *this, char);
  void (__fastcall *writeShort)(IDataOutput *this, __int16);
  void (__fastcall *writeInt)(IDataOutput *this, int);
  void (__fastcall *writeLongLong)(IDataOutput *this, __int64);
  void (__fastcall *writeBytes)(IDataOutput *this, const void *, unsigned __int64);
  bool (__fastcall *isOk)(IDataOutput *this);
};

</code></pre></div><h3 id="bigendianstringbyteinput-vtbl"><a href="#bigendianstringbyteinput-vtbl" class="header-anchor">#</a> <code>BigEndianStringByteInput_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BigEndianStringByteInput_vtbl
{
  void (__fastcall *~IDataInput)(IDataInput *this);
  std::string *(__fastcall *readString)(IDataInput *this, std::string *result);
  std::string *(__fastcall *readLongString)(IDataInput *this, std::string *result);
  float (__fastcall *readFloat)(IDataInput *this);
  long double (__fastcall *readDouble)(IDataInput *this);
  char (__fastcall *readByte)(IDataInput *this);
  __int16 (__fastcall *readShort)(IDataInput *this);
  int (__fastcall *readInt)(IDataInput *this);
  __int64 (__fastcall *readLongLong)(IDataInput *this);
  bool (__fastcall *readBytes)(IDataInput *this, void *, unsigned __int64);
  unsigned __int64 (__fastcall *numBytesLeft)(IDataInput *this);
  bool (__fastcall *isOk)(IDataInput *this);
  bool (__fastcall *seek)(IDataInput *this, unsigned __int64);
  bool (__fastcall *readBigEndianBytes)(BigEndianStringByteInput *this, void *, unsigned __int64);
};

</code></pre></div><h3 id="blocklegacyptr"><a href="#blocklegacyptr" class="header-anchor">#</a> <code>BlockLegacyPtr</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockLegacyPtr
{
  const BlockLegacy *mBlockLegacy;
};

</code></pre></div><h3 id="bedrock-memory-imemoryallocator-vtbl"><a href="#bedrock-memory-imemoryallocator-vtbl" class="header-anchor">#</a> <code>Bedrock::Memory::IMemoryAllocator_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Memory::IMemoryAllocator_vtbl
{
  void (__fastcall *~IMemoryAllocator)(Bedrock::Memory::IMemoryAllocator *this);
  void *(__fastcall *allocate)(Bedrock::Memory::IMemoryAllocator *this, const unsigned __int64);
  void (__fastcall *release)(Bedrock::Memory::IMemoryAllocator *this, void *);
  void *(__fastcall *realloc)(Bedrock::Memory::IMemoryAllocator *this, void *, const unsigned __int64);
  void *(__fastcall *alignedAllocate)(Bedrock::Memory::IMemoryAllocator *this, const unsigned __int64, const unsigned __int64);
  void (__fastcall *alignedRelease)(Bedrock::Memory::IMemoryAllocator *this, void *);
  void (__fastcall *logCurrentState)(Bedrock::Memory::IMemoryAllocator *this);
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocal-threadedframeconstantscontainer-std-allocator-threadedframeconstantscontainer-item"><a href="#bedrock-threading-instancedthreadlocal-threadedframeconstantscontainer-std-allocator-threadedframeconstantscontainer-item" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt;::Item</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt;::Item : Bedrock::Intrusive::list_base_hook&lt;void&gt;
{
  std::_Align_type&lt;double,688&gt; mData;
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-threadedframeconstantscontainer-std-allocator-threadedframeconstantscontainer-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void-iterator-base-0"><a href="#bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-threadedframeconstantscontainer-std-allocator-threadedframeconstantscontainer-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void-iterator-base-0" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;::iterator_base&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;ThreadedFrameConstantsContainer,std::allocator&lt;ThreadedFrameConstantsContainer&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;::iterator_base&lt;0&gt;
{
  Bedrock::Intrusive::list_base_hook&lt;void&gt; *mHook;
};

</code></pre></div><h3 id="basestage"><a href="#basestage" class="header-anchor">#</a> <code>BaseStage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseStage : std::enable_shared_from_this&lt;BaseStage&gt;
{
  BaseStage_vtbl *__vftable /*VFT*/;
  LoginStateMachine *mMachine;
  std::atomic&lt;enum eLoginStage&gt; mStageType;
  std::atomic&lt;enum eStageStatus&gt; mStatus;
  EasyThread mThread;
};

</code></pre></div><h3 id="basestage-vtbl"><a href="#basestage-vtbl" class="header-anchor">#</a> <code>BaseStage_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseStage_vtbl
{
  void (__fastcall *~BaseStage)(BaseStage *this);
  void (__fastcall *onAwake)(BaseStage *this);
  void (__fastcall *onUpdate)(BaseStage *this);
  bool (__fastcall *ayncTask)(BaseStage *this);
};

</code></pre></div><h3 id="basictestprofilestats"><a href="#basictestprofilestats" class="header-anchor">#</a> <code>BasicTestProfileStats</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BasicTestProfileStats : Bedrock::EnableNonOwnerReferences
{
  std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; mMinecraftGameUpdateTime;
  std::chrono::duration&lt;__int64,std::ratio&lt;1,1000000000&gt; &gt; mMinecraftGameEndFrameTime;
};

</code></pre></div><h3 id="buttoncomponent"><a href="#buttoncomponent" class="header-anchor">#</a> <code>ButtonComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) ButtonComponent : UIComponent
{
  std::weak_ptr&lt;UIControl&gt; mDefaultStateControl;
  std::weak_ptr&lt;UIControl&gt; mHoverStateControl;
  std::weak_ptr&lt;UIControl&gt; mPressedStateControl;
  std::weak_ptr&lt;UIControl&gt; mLockedStateControl;
  bool mPressed;
  bool mHover;
  bool mConsumeEvents;
};

</code></pre></div><h3 id="buttoncomponent-vtbl"><a href="#buttoncomponent-vtbl" class="header-anchor">#</a> <code>ButtonComponent_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ ButtonComponent_vtbl
{
  void (__fastcall *~UIComponent)(UIComponent *this);
  void (__fastcall *OnScreenPop)(UIComponent *this);
  std::unique_ptr&lt;UIComponent&gt; *(__fastcall *clone)(UIComponent *this, std::unique_ptr&lt;UIComponent&gt; *result, UIControl *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, const ScreenEvent *);
  ComponentReceiveActionType (__fastcall *receive)(UIComponent *this, VisualTree *, ScreenInputContext *, UIAnimationController *, const ScreenEvent *);
  void (__fastcall *onNotifyChildAdded)(UIComponent *this);
  void (__fastcall *onNotifyChildRemoved)(UIComponent *this);
  void (__fastcall *onRemoved)(UIComponent *this);
  void (__fastcall *onAdded)(UIComponent *this);
  void (__fastcall *onVisibilityChanged)(UIComponent *this, bool);
  void (__fastcall *onEnabledChanged)(UIComponent *this, bool);
  bool (__fastcall *isRenderableComponent)(UIComponent *this);
  bool (__fastcall *onLayoutChange)(UIComponent *this);
  void (__fastcall *reset)(UIComponent *this);
  void (__fastcall *reload)(UIComponent *this, const UIComponent *);
  const std::string *(__fastcall *getTextToSpeechComponentValue)(UIComponent *this);
};

</code></pre></div><h3 id="backgroundrenderer"><a href="#backgroundrenderer" class="header-anchor">#</a> <code>BackgroundRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BackgroundRenderer : MinecraftUICustomRenderer
{
};

</code></pre></div><h3 id="backgroundrenderer-vtbl"><a href="#backgroundrenderer-vtbl" class="header-anchor">#</a> <code>BackgroundRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BackgroundRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="bannerpatternrenderer-bannerpatterntextureinfo"><a href="#bannerpatternrenderer-bannerpatterntextureinfo" class="header-anchor">#</a> <code>BannerPatternRenderer::BannerPatternTextureInfo</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BannerPatternRenderer::BannerPatternTextureInfo
{
  mce::TexturePtr mTexture;
  glm::tvec2&lt;float,0&gt; mUV;
  glm::tvec2&lt;float,0&gt; mUVScale;
};

</code></pre></div><h3 id="bannerpatternrenderer"><a href="#bannerpatternrenderer" class="header-anchor">#</a> <code>BannerPatternRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BannerPatternRenderer : MinecraftUICustomRenderer, ActorShaderManager
{
  bool mHasLoadedTextures;
  std::vector&lt;BannerPatternRenderer::BannerPatternTextureInfo&gt; mTextures;
  std::vector&lt;mce::Color&gt; mColors;
};

</code></pre></div><h3 id="bannerpatternrenderer-vtbl"><a href="#bannerpatternrenderer-vtbl" class="header-anchor">#</a> <code>BannerPatternRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BannerPatternRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="bohrmodelrenderer-state"><a href="#bohrmodelrenderer-state" class="header-anchor">#</a> <code>BohrModelRenderer::State</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BohrModelRenderer::State
{
  int mElectrons;
  int mProtons;
  int mNeutrons;
  int mRings;
  float mScale;
  Vec2 mTopLeft;
  Vec2 mBottomRight;
};

</code></pre></div><h3 id="bohrmodelrenderer-renderable"><a href="#bohrmodelrenderer-renderable" class="header-anchor">#</a> <code>BohrModelRenderer::Renderable</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BohrModelRenderer::Renderable
{
  std::unique_ptr&lt;mce::Mesh&gt; mMesh;
  mce::TexturePtr mTexture;
};

</code></pre></div><h3 id="bohrmodelrenderer"><a href="#bohrmodelrenderer" class="header-anchor">#</a> <code>BohrModelRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BohrModelRenderer : MinecraftUICustomRenderer
{
  std::unique_ptr&lt;Stopwatch&gt; mStopwatch;
  BohrModelRenderer::State mCurState;
  BohrModelRenderer::State mLastState;
  float mCenterRadius;
  float mRingDistance;
  float mRingThickness;
  float mMargin;
  float mElectronSize;
  float mClumpRadius;
  unsigned int mProtonSeed;
  unsigned int mNeutronSeed;
  mce::TexturePtr mRingTexture;
  mce::TexturePtr mProtonTexture;
  mce::TexturePtr mElectronTexture;
  mce::TexturePtr mNeutronTexture;
  std::vector&lt;BohrModelRenderer::Renderable&gt; mRenderables;
};

</code></pre></div><h3 id="bohrmodelrenderer-vtbl"><a href="#bohrmodelrenderer-vtbl" class="header-anchor">#</a> <code>BohrModelRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BohrModelRenderer_vtbl
{
  void (__fastcall *~UICustomRenderer)(UICustomRenderer *this);
  void (__fastcall *preRenderSetup)(UICustomRenderer *this, UIRenderContext *);
  std::shared_ptr&lt;UICustomRenderer&gt; *(__fastcall *clone)(UICustomRenderer *this, std::shared_ptr&lt;UICustomRenderer&gt; *result);
  bool (__fastcall *update)(UICustomRenderer *this, IClientInstance *, UIControl *, const UIScene *);
  void (__fastcall *frameUpdate)(UICustomRenderer *this, UIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(UICustomRenderer *this, UIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  UIBatchType (__fastcall *getBatchType)(UICustomRenderer *this);
  int (__fastcall *getCustomId)(UICustomRenderer *this);
  int (__fastcall *getNumRenderPasses)(UICustomRenderer *this);
  ResourceLocation *(__fastcall *getResourceLocation)(UICustomRenderer *this, ResourceLocation *result, int, int);
  UIMaterialType (__fastcall *getUIMaterialType)(UICustomRenderer *this, int);
  bool (__fastcall *getRequiresPreRenderSetup)(UICustomRenderer *this, int);
  void (__fastcall *onVisibilityChanged)(UICustomRenderer *this, bool);
  void (__fastcall *collectScreenEvents)(UICustomRenderer *this, std::queue&lt;ScreenEvent&gt; *);
  void (__fastcall *frameUpdate)(MinecraftUICustomRenderer *this, MinecraftUIFrameUpdateContext *, UIControl *);
  void (__fastcall *render)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *, IClientInstance *, UIControl *, int, RectangleArea *);
  void (__fastcall *preRenderSetup)(MinecraftUICustomRenderer *this, MinecraftUIRenderContext *);
};

</code></pre></div><h3 id="buttonsoundeventconditions"><a href="#buttonsoundeventconditions" class="header-anchor">#</a> <code>ButtonSoundEventConditions</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(4)) ButtonSoundEventConditions
{
  unsigned int id;
  __int8 matchSpecificButtonId : 1;
};

</code></pre></div><h3 id="bitmapfont"><a href="#bitmapfont" class="header-anchor">#</a> <code>BitmapFont</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BitmapFont : Font
{
  Core::PathBuffer&lt;std::string &gt; mAsciiFontName;
  Core::PathBuffer&lt;std::string &gt; mUnicodeFontName;
  float mCharWidths[256];
  std::shared_ptr&lt;mce::Image&gt; mBitmapFontImage;
  std::unordered_map&lt;int,float&gt; mUnicodeWidths;
  std::unordered_map&lt;int,float&gt; mUnicodeOffsets;
  std::unordered_map&lt;int,float&gt; mUnicodePageGlyphWidths;
  std::unordered_set&lt;int&gt; mSheetScannedForWidthsAndOffsets;
  std::recursive_mutex mMutex;
};

</code></pre></div><h3 id="bitmapfont-vtbl"><a href="#bitmapfont-vtbl" class="header-anchor">#</a> <code>BitmapFont_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BitmapFont_vtbl
{
  void (__fastcall *~Font)(Font *this);
  float (__fastcall *getCharWidth)(Font *this, int);
  void (__fastcall *switchFontsource)(Font *this, const Core::Path *, const Core::Path *);
  std::pair&lt;Core::PathBuffer&lt;std::string &gt; const &amp;,Core::PathBuffer&lt;std::string &gt; const &amp;&gt; *(__fastcall *getFontSources)(Font *this, std::pair&lt;Core::PathBuffer&lt;std::string &gt; const &amp;,Core::PathBuffer&lt;std::string &gt; const &amp;&gt; *result);
  void (__fastcall *fetchPage)(Font *this, int);
  Font::SheetId *(__fastcall *getSheet)(Font *this, Font::SheetId *result, int, int *, bool);
  bool (__fastcall *supportsChar)(Font *this, const int *);
  bool (__fastcall *_supportsShadowInSingleDraw)(Font *this);
  int (__fastcall *getLineLength)(Font *this, const std::string *, float, bool);
  float (__fastcall *getWrapHeight)(Font *this);
  float (__fastcall *getScaleFactor)(Font *this);
  Vec2 *(__fastcall *getTranslationFactor)(Font *this, Vec2 *result);
  bool (__fastcall *isScreenPixelAligned)(Font *this);
  bool (__fastcall *materialCanBeOverridden)(Font *this);
  void (__fastcall *uploadTextureToGPU)(Font *this);
  void (__fastcall *setTextConstantsInScreenContext)(Font *this, ScreenContext *, const Font::SheetId *, float, const mce::Color *, bool);
  float (__fastcall *_getCharWidth)(Font *this, int, bool);
  bool (__fastcall *_isIconPage)(Font *this, const Font::SheetId *);
  mce::Font::Type (__fastcall *getType)(Font *this, const Font::SheetId *);
  std::optional&lt;mce::Font::RenderingParameters&gt; *(__fastcall *tryGetRenderingParameters)(Font *this, std::optional&lt;mce::Font::RenderingParameters&gt; *result, const ScreenContext *, const Font::SheetId *, float, const mce::Color *, bool, const mce::Color *, const glm::tvec2&lt;float,0&gt; *);
  void (__fastcall *drawCached)(Font *this, ScreenContext *, const std::string *, float, float, const mce::Color *, const mce::Color *, const glm::tvec2&lt;float,0&gt; *, bool, bool, mce::MaterialPtr *, int, bool, float, const mce::Color *);
  void (__fastcall *onAppSuspended)(Font *this);
  void (__fastcall *onDeviceLost)(Font *this);
  void (__fastcall *reloadFontTextures)(Font *this, ResourceLoadManager *, bool);
  bool (__fastcall *isReloadingTextures)(Font *this);
  void (__fastcall *unloadTextures)(Font *this);
  void (__fastcall *_scanUnicodeCharacterSize)(Font *this, int, const Font::SheetId *, bool);
  bool (__fastcall *isSheetMatch)(Font *this, const Font::SheetId *);
  bool (__fastcall *_containsWideChar)(Font *this, const std::string *);
  float (__fastcall *_buildChar)(Font *this, std::vector&lt;Font::GlyphQuad&gt; *, int, const mce::Color *, bool, float, float, bool);
  ResourceLocation *(__fastcall *_getFontSheetLocation)(Font *this, ResourceLocation *result, const Font::SheetId *, bool);
  const mce::MaterialPtr *(__fastcall *getMaterial)(Font *this, const Font::SheetId *, bool);
  void (__fastcall *flushQueuedImageUploads)(Font *this);
  void (__fastcall *onLanguageChanged)(Font *this, const std::string *);
  void (__fastcall *loadFontData)(Font *this, bool);
  int (__fastcall *_getReplacementCharacter)(Font *this);
  Core::PathBuffer&lt;std::string &gt; *(__fastcall *getUnicodeFontNameWithPage)(BitmapFont *this, Core::PathBuffer&lt;std::string &gt; *result, const Core::Path *, const unsigned __int8);
};

</code></pre></div><h3 id="buffer-span-unsigned-int-iterator"><a href="#buffer-span-unsigned-int-iterator" class="header-anchor">#</a> <code>buffer_span&lt;unsigned int&gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;unsigned int&gt;::iterator
{
  const unsigned int *mPtr;
};

</code></pre></div><h3 id="buffer-span-mut-unsigned-int"><a href="#buffer-span-mut-unsigned-int" class="header-anchor">#</a> <code>buffer_span_mut&lt;unsigned int&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;unsigned int&gt;
{
  unsigned int *mBegin;
  unsigned int *mEnd;
};

</code></pre></div><h3 id="buttonedge"><a href="#buttonedge" class="header-anchor">#</a> <code>ButtonEdge</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj ButtonEdge
{
  std::function&lt;bool __cdecl(unsigned int,enum ButtonEventType,std::string const &amp;,int)&gt; mRequirement;
  _BYTE mTargetNode[4];
  int mPriority;
};

</code></pre></div><h3 id="bookscreencontroller"><a href="#bookscreencontroller" class="header-anchor">#</a> <code>BookScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController : ClientInstanceScreenController
{
  std::unique_ptr&lt;BookScreenManager&gt; mBookScreenManager;
  const bool mEditable;
  bool mEditingLeft;
  bool mEditingRight;
  std::array&lt;bool,2&gt; mPageHasCursor;
  std::vector&lt;PageContent&gt; mPages;
  int mCurrentPage;
  int mCurrentPageIndex;
  std::string mTitle;
  std::string mAuthor;
  std::string mAuthorXUID;
  BookScreenController::BookView mCurrentView;
  bool mForceUIRefresh;
  int mPickPageIndex;
  std::string mPageBlockedText;
};

</code></pre></div><h3 id="bookscreencontroller-vtbl"><a href="#bookscreencontroller-vtbl" class="header-anchor">#</a> <code>BookScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BookScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="buffer-span-gsl-basic-string-span-char-const-1-iterator"><a href="#buffer-span-gsl-basic-string-span-char-const-1-iterator" class="header-anchor">#</a> <code>buffer_span&lt;gsl::basic_string_span&lt;char const ,-1&gt; &gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;gsl::basic_string_span&lt;char const ,-1&gt; &gt;::iterator
{
  const gsl::basic_string_span&lt;char const ,-1&gt; *mPtr;
};

</code></pre></div><h3 id="buffer-span-gsl-basic-string-span-char-const-1"><a href="#buffer-span-gsl-basic-string-span-char-const-1" class="header-anchor">#</a> <code>buffer_span&lt;gsl::basic_string_span&lt;char const ,-1&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;gsl::basic_string_span&lt;char const ,-1&gt; &gt;
{
  const gsl::basic_string_span&lt;char const ,-1&gt; *mBegin;
  const gsl::basic_string_span&lt;char const ,-1&gt; *mEnd;
};

</code></pre></div><h3 id="brazescreencontroller"><a href="#brazescreencontroller" class="header-anchor">#</a> <code>BrazeScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BrazeScreenController : MinecraftScreenController
{
  bool mDirty;
};

</code></pre></div><h3 id="brazescreencontroller-vtbl"><a href="#brazescreencontroller-vtbl" class="header-anchor">#</a> <code>BrazeScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BrazeScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
};

</code></pre></div><h3 id="brewingstandscreencontrollerproxycallbacks"><a href="#brewingstandscreencontrollerproxycallbacks" class="header-anchor">#</a> <code>BrewingStandScreenControllerProxyCallbacks</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrewingStandScreenControllerProxyCallbacks
{
  std::function&lt;bool __cdecl(int &amp;,int &amp;,int)&gt; mIsFinished;
};

</code></pre></div><h3 id="brewingstandscreencontrollerproxycallbacks-lambda-dca25c3eb6c965db2860fcf8aff0badd"><a href="#brewingstandscreencontrollerproxycallbacks-lambda-dca25c3eb6c965db2860fcf8aff0badd" class="header-anchor">#</a> <code>BrewingStandScreenControllerProxyCallbacks::&lt;lambda_dca25c3eb6c965db2860fcf8aff0badd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrewingStandScreenControllerProxyCallbacks::&lt;lambda_dca25c3eb6c965db2860fcf8aff0badd&gt;
{
};

</code></pre></div><h3 id="brewingstandscreencontrollerproxy"><a href="#brewingstandscreencontrollerproxy" class="header-anchor">#</a> <code>BrewingStandScreenControllerProxy</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrewingStandScreenControllerProxy : ScreenControllerProxy
{
  const BrewingStandScreenControllerProxyCallbacks mCallbacks;
};

</code></pre></div><h3 id="brewingstandscreencontrollerproxy-vtbl"><a href="#brewingstandscreencontrollerproxy-vtbl" class="header-anchor">#</a> <code>BrewingStandScreenControllerProxy_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BrewingStandScreenControllerProxy_vtbl
{
  void (__fastcall *~ScreenControllerProxy)(ScreenControllerProxy *this);
};

</code></pre></div><h3 id="bundlepurchasewarningscreencontroller"><a href="#bundlepurchasewarningscreencontroller" class="header-anchor">#</a> <code>BundlePurchaseWarningScreenController</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BundlePurchaseWarningScreenController : StoreBaseScreenController
{
  const StoreCatalogItem *mCatalogItem;
  const OfferCollectionComponent *mBundleCollection;
  std::function&lt;void __cdecl(void)&gt; mOnPurchaseCallback;
  std::vector&lt;StoreCatalogItem *&gt; mOwnedList;
  std::vector&lt;StoreCatalogItem *&gt; mUnownedList;
  std::shared_ptr&lt;bool&gt; mExistenceTracker;
};

</code></pre></div><h3 id="bundlepurchasewarningscreencontroller-vtbl"><a href="#bundlepurchasewarningscreencontroller-vtbl" class="header-anchor">#</a> <code>BundlePurchaseWarningScreenController_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BundlePurchaseWarningScreenController_vtbl
{
  void (__fastcall *~IScreenController)(IScreenController *this);
  ui::DirtyFlag (__fastcall *tick)(IScreenController *this);
  ui::ViewRequest (__fastcall *handleEvent)(IScreenController *this, ScreenEvent *);
  std::optional&lt;std::string &gt; *(__fastcall *getRoute)(IScreenController *this, std::optional&lt;std::string &gt; *result);
  void (__fastcall *setScreenState)(IScreenController *this, const std::vector&lt;std::pair&lt;std::string,std::string &gt;&gt; *);
  void (__fastcall *onOpen)(ScreenController *this);
  void (__fastcall *onTerminate)(ScreenController *this);
  void (__fastcall *onInit)(ScreenController *this);
  void (__fastcall *onDelete)(ScreenController *this);
  bool (__fastcall *canExit)(ScreenController *this);
  ui::ViewRequest (__fastcall *tryExit)(ScreenController *this);
  bool (__fastcall *areControllerTabsEnabled)(ScreenController *this);
  void (__fastcall *onCreation)(ScreenController *this);
  void (__fastcall *logCreationTime)(ScreenController *this, const std::string *, long double, long double, unsigned __int8);
  void (__fastcall *onLeave)(ScreenController *this);
  void (__fastcall *leaveScreen)(ScreenController *this);
  ui::DirtyFlag (__fastcall *handleGameEventNotification)(ScreenController *this, ui::GameEventNotification);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  bool (__fastcall *bind)(ScreenController *this, const std::string *, unsigned int, int, const std::string *, unsigned int, const std::string *, UIPropertyBag *);
  void (__fastcall *handleLicenseChanged)(ScreenController *this);
  void (__fastcall *onDictationEvent)(ScreenController *this, const std::string *);
  void (__fastcall *setAssociatedBlockPos)(ScreenController *this, const BlockPos *);
  void (__fastcall *setAssociatedEntityUniqueID)(ScreenController *this, const ActorUniqueID);
  void (__fastcall *setSuspendInput)(ScreenController *this, bool);
  float (__fastcall *getCallbackInterval)(ScreenController *this);
  void (__fastcall *onRender)(ScreenController *this);
  void (__fastcall *addStaticScreenVars)(ScreenController *this, Json::Value *);
  std::string *(__fastcall *getAdditionalScreenInfo)(ScreenController *this, std::string *result);
  std::string *(__fastcall *getTelemetryOverride)(ScreenController *this, std::string *result);
  void (__fastcall *addEventProperties)(ScreenController *this, std::unordered_map&lt;std::string,std::string&gt; *);
  ui::SceneType (__fastcall *getSceneType)(ScreenController *this);
  int (__fastcall *getScreenVersion)(ScreenController *this);
  bool (__fastcall *screenHandlesGamepadMenuButton)(ScreenController *this);
  ScreenControllerProxy *(__fastcall *getProxy)(ScreenController *this);
  void (__fastcall *onEntered)(ScreenController *this);
  unsigned int (__fastcall *getNameId)(ScreenController *this, const std::string *);
  bool (__fastcall *verifySceneStack)(ScreenController *this, SceneStack *);
  bool (__fastcall *_doesScreenHaveExitBehavior)(ScreenController *this);
  bool (__fastcall *_isStillValid)(MinecraftScreenController *this);
  bool (__fastcall *_getGamepadHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getMixedHelperVisible)(MinecraftScreenController *this);
  bool (__fastcall *_getKeyboardHelperVisible)(MinecraftScreenController *this);
  std::string *(__fastcall *_getButtonADescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonBDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonXDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonYDescription)(MinecraftScreenController *this, std::string *result);
  std::string *(__fastcall *_getButtonKeyboardDescription)(MinecraftScreenController *this, std::string *result);
  int (__fastcall *_getRowIndex)(StoreBaseScreenController *this, const int);
  int (__fastcall *_getColIndex)(StoreBaseScreenController *this, const int);
  int (__fastcall *_getLastRowIndex)(StoreBaseScreenController *this, const int);
  int (__fastcall *_getRemainderOffers)(StoreBaseScreenController *this, const int);
};

</code></pre></div><h3 id="brazescreencontroller-registereventhandlers-l2-lambda-6ee0a4037e32ed239751915bc2fb9143"><a href="#brazescreencontroller-registereventhandlers-l2-lambda-6ee0a4037e32ed239751915bc2fb9143" class="header-anchor">#</a> <code>BrazeScreenController::_registerEventHandlers::__l2::&lt;lambda_6ee0a4037e32ed239751915bc2fb9143&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrazeScreenController::_registerEventHandlers::__l2::&lt;lambda_6ee0a4037e32ed239751915bc2fb9143&gt;
{
  const std::string button1Uri;
  BrazeScreenController *const __this;
};

</code></pre></div><h3 id="brazescreencontroller-registereventhandlers-l2-lambda-d538ff3b0a3e0bc3a1dc8e0775e63e4a"><a href="#brazescreencontroller-registereventhandlers-l2-lambda-d538ff3b0a3e0bc3a1dc8e0775e63e4a" class="header-anchor">#</a> <code>BrazeScreenController::_registerEventHandlers::__l2::&lt;lambda_d538ff3b0a3e0bc3a1dc8e0775e63e4a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrazeScreenController::_registerEventHandlers::__l2::&lt;lambda_d538ff3b0a3e0bc3a1dc8e0775e63e4a&gt;
{
  const std::string button0Uri;
  BrazeScreenController *const __this;
};

</code></pre></div><h3 id="brazescreencontroller-registerbindings-l2-lambda-5aee90bcfa1e5a70bf0ca95c9575d189"><a href="#brazescreencontroller-registerbindings-l2-lambda-5aee90bcfa1e5a70bf0ca95c9575d189" class="header-anchor">#</a> <code>BrazeScreenController::_registerBindings::__l2::&lt;lambda_5aee90bcfa1e5a70bf0ca95c9575d189&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrazeScreenController::_registerBindings::__l2::&lt;lambda_5aee90bcfa1e5a70bf0ca95c9575d189&gt;
{
  const std::string button1Text;
};

</code></pre></div><h3 id="brazescreencontroller-registerbindings-l2-lambda-e13d728b79c79e1383c5f4763f2f3684"><a href="#brazescreencontroller-registerbindings-l2-lambda-e13d728b79c79e1383c5f4763f2f3684" class="header-anchor">#</a> <code>BrazeScreenController::_registerBindings::__l2::&lt;lambda_e13d728b79c79e1383c5f4763f2f3684&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrazeScreenController::_registerBindings::__l2::&lt;lambda_e13d728b79c79e1383c5f4763f2f3684&gt;
{
  const std::string button0Text;
};

</code></pre></div><h3 id="brazescreencontroller-registerbindings-l2-lambda-5a407d611f31f08f56278e1901254b13"><a href="#brazescreencontroller-registerbindings-l2-lambda-5a407d611f31f08f56278e1901254b13" class="header-anchor">#</a> <code>BrazeScreenController::_registerBindings::__l2::&lt;lambda_5a407d611f31f08f56278e1901254b13&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrazeScreenController::_registerBindings::__l2::&lt;lambda_5a407d611f31f08f56278e1901254b13&gt;
{
  const std::string body;
};

</code></pre></div><h3 id="brazescreencontroller-registerbindings-l2-lambda-933ebebca03896adf11e9108e028ce0c"><a href="#brazescreencontroller-registerbindings-l2-lambda-933ebebca03896adf11e9108e028ce0c" class="header-anchor">#</a> <code>BrazeScreenController::_registerBindings::__l2::&lt;lambda_933ebebca03896adf11e9108e028ce0c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrazeScreenController::_registerBindings::__l2::&lt;lambda_933ebebca03896adf11e9108e028ce0c&gt;
{
  const std::string title;
};

</code></pre></div><h3 id="brazescreencontroller-ctor-l2-lambda-1d27d0a8647f7a806eb7e511f394dade"><a href="#brazescreencontroller-ctor-l2-lambda-1d27d0a8647f7a806eb7e511f394dade" class="header-anchor">#</a> <code>BrazeScreenController::{ctor}::__l2::&lt;lambda_1d27d0a8647f7a806eb7e511f394dade&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrazeScreenController::{ctor}::__l2::&lt;lambda_1d27d0a8647f7a806eb7e511f394dade&gt;
{
  BrazeScreenController *const __this;
};

</code></pre></div><h3 id="brazescreencontroller-ctor-l2-lambda-1d27d0a8647f7a806eb7e511f394dade-l2-lambda-f8252f6da819418395269bd8d455fd62"><a href="#brazescreencontroller-ctor-l2-lambda-1d27d0a8647f7a806eb7e511f394dade-l2-lambda-f8252f6da819418395269bd8d455fd62" class="header-anchor">#</a> <code>BrazeScreenController::{ctor}::__l2::&lt;lambda_1d27d0a8647f7a806eb7e511f394dade&gt;::()::__l2::&lt;lambda_f8252f6da819418395269bd8d455fd62&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BrazeScreenController::{ctor}::__l2::&lt;lambda_1d27d0a8647f7a806eb7e511f394dade&gt;::()::__l2::&lt;lambda_f8252f6da819418395269bd8d455fd62&gt;
{
  const Core::Path imagePath;
};

</code></pre></div><h3 id="bookscreencontroller-tickexport-l11-lambda-cbe2da03d3218249e5c877e06cf3bb8f"><a href="#bookscreencontroller-tickexport-l11-lambda-cbe2da03d3218249e5c877e06cf3bb8f" class="header-anchor">#</a> <code>BookScreenController::_tickExport::__l11::&lt;lambda_cbe2da03d3218249e5c877e06cf3bb8f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_tickExport::__l11::&lt;lambda_cbe2da03d3218249e5c877e06cf3bb8f&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-tickexport-l8-lambda-3ef49f4f5b7ca55f4c47ba66d73c6ba7"><a href="#bookscreencontroller-tickexport-l8-lambda-3ef49f4f5b7ca55f4c47ba66d73c6ba7" class="header-anchor">#</a> <code>BookScreenController::_tickExport::__l8::&lt;lambda_3ef49f4f5b7ca55f4c47ba66d73c6ba7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_tickExport::__l8::&lt;lambda_3ef49f4f5b7ca55f4c47ba66d73c6ba7&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-signbook-l2-lambda-56a585e9f725b0ae8749565ca4ee0752"><a href="#bookscreencontroller-signbook-l2-lambda-56a585e9f725b0ae8749565ca4ee0752" class="header-anchor">#</a> <code>BookScreenController::_signBook::__l2::&lt;lambda_56a585e9f725b0ae8749565ca4ee0752&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_signBook::__l2::&lt;lambda_56a585e9f725b0ae8749565ca4ee0752&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-setpagetext-l2-lambda-b7d07d847fcccd5b27285171e4d6a221"><a href="#bookscreencontroller-setpagetext-l2-lambda-b7d07d847fcccd5b27285171e4d6a221" class="header-anchor">#</a> <code>BookScreenController::_setPageText::__l2::&lt;lambda_b7d07d847fcccd5b27285171e4d6a221&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_setPageText::__l2::&lt;lambda_b7d07d847fcccd5b27285171e4d6a221&gt;
{
  const std::string *text;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-2c23570ba6b46212b820e69e06fa8f40"><a href="#bookscreencontroller-registerbindings-l2-lambda-2c23570ba6b46212b820e69e06fa8f40" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_2c23570ba6b46212b820e69e06fa8f40&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_2c23570ba6b46212b820e69e06fa8f40&gt;
{
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-6668922cc3a1c4f2b6c454708a8d6e31"><a href="#bookscreencontroller-registerbindings-l2-lambda-6668922cc3a1c4f2b6c454708a8d6e31" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_6668922cc3a1c4f2b6c454708a8d6e31&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_6668922cc3a1c4f2b6c454708a8d6e31&gt;
{
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-38669daa8999fedfe92008e33cbf3bcd"><a href="#bookscreencontroller-registerbindings-l2-lambda-38669daa8999fedfe92008e33cbf3bcd" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_38669daa8999fedfe92008e33cbf3bcd&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_38669daa8999fedfe92008e33cbf3bcd&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-17139683e7ad7e9fef391f4b92f4bb86"><a href="#bookscreencontroller-registerbindings-l2-lambda-17139683e7ad7e9fef391f4b92f4bb86" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_17139683e7ad7e9fef391f4b92f4bb86&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_17139683e7ad7e9fef391f4b92f4bb86&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-d3e052e72319cb8cf248fff03a1459ee"><a href="#bookscreencontroller-registerbindings-l2-lambda-d3e052e72319cb8cf248fff03a1459ee" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_d3e052e72319cb8cf248fff03a1459ee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_d3e052e72319cb8cf248fff03a1459ee&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-da3023e0ea5e8dc27cbbb8a1316a504e"><a href="#bookscreencontroller-registerbindings-l2-lambda-da3023e0ea5e8dc27cbbb8a1316a504e" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_da3023e0ea5e8dc27cbbb8a1316a504e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_da3023e0ea5e8dc27cbbb8a1316a504e&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-9c7943b6d7d49a43eb525e7cb04bc37d"><a href="#bookscreencontroller-registerbindings-l2-lambda-9c7943b6d7d49a43eb525e7cb04bc37d" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_9c7943b6d7d49a43eb525e7cb04bc37d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_9c7943b6d7d49a43eb525e7cb04bc37d&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-0a931edafd053fc993aa5a4a107548e5"><a href="#bookscreencontroller-registerbindings-l2-lambda-0a931edafd053fc993aa5a4a107548e5" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_0a931edafd053fc993aa5a4a107548e5&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_0a931edafd053fc993aa5a4a107548e5&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-1eb31ca0e1010a327ecea190879f37e2"><a href="#bookscreencontroller-registerbindings-l2-lambda-1eb31ca0e1010a327ecea190879f37e2" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_1eb31ca0e1010a327ecea190879f37e2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_1eb31ca0e1010a327ecea190879f37e2&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-f98214ab71487913885f6e2817a6ff8e"><a href="#bookscreencontroller-registerbindings-l2-lambda-f98214ab71487913885f6e2817a6ff8e" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_f98214ab71487913885f6e2817a6ff8e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_f98214ab71487913885f6e2817a6ff8e&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-2f08e915bcc85063e264a2d5a8ca9c6b"><a href="#bookscreencontroller-registerbindings-l2-lambda-2f08e915bcc85063e264a2d5a8ca9c6b" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_2f08e915bcc85063e264a2d5a8ca9c6b&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_2f08e915bcc85063e264a2d5a8ca9c6b&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-4b51d874acfcd92297d19b75e40fd9a7"><a href="#bookscreencontroller-registerbindings-l2-lambda-4b51d874acfcd92297d19b75e40fd9a7" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_4b51d874acfcd92297d19b75e40fd9a7&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_4b51d874acfcd92297d19b75e40fd9a7&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-449d7670077fabf8054ad28d5c9c4859"><a href="#bookscreencontroller-registerbindings-l2-lambda-449d7670077fabf8054ad28d5c9c4859" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_449d7670077fabf8054ad28d5c9c4859&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_449d7670077fabf8054ad28d5c9c4859&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-7fdad6c089186003b5ba72d7dceb6ae4"><a href="#bookscreencontroller-registerbindings-l2-lambda-7fdad6c089186003b5ba72d7dceb6ae4" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_7fdad6c089186003b5ba72d7dceb6ae4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_7fdad6c089186003b5ba72d7dceb6ae4&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-97b35f1f3f292a323b4a65ae99954970"><a href="#bookscreencontroller-registerbindings-l2-lambda-97b35f1f3f292a323b4a65ae99954970" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_97b35f1f3f292a323b4a65ae99954970&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_97b35f1f3f292a323b4a65ae99954970&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-b856e9944b209f0f2c4dd50065e04395"><a href="#bookscreencontroller-registerbindings-l2-lambda-b856e9944b209f0f2c4dd50065e04395" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_b856e9944b209f0f2c4dd50065e04395&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_b856e9944b209f0f2c4dd50065e04395&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-a900bd39ae590f113754eed6b73cda90"><a href="#bookscreencontroller-registerbindings-l2-lambda-a900bd39ae590f113754eed6b73cda90" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_a900bd39ae590f113754eed6b73cda90&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_a900bd39ae590f113754eed6b73cda90&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-b85a78236e3c5cf59d6b384bb7df9429"><a href="#bookscreencontroller-registerbindings-l2-lambda-b85a78236e3c5cf59d6b384bb7df9429" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_b85a78236e3c5cf59d6b384bb7df9429&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_b85a78236e3c5cf59d6b384bb7df9429&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-32e3b98b63f8b1f26c302f98d57d4448"><a href="#bookscreencontroller-registerbindings-l2-lambda-32e3b98b63f8b1f26c302f98d57d4448" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_32e3b98b63f8b1f26c302f98d57d4448&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_32e3b98b63f8b1f26c302f98d57d4448&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-0e1bf8ad4c409c2c8f875ebf2b09a5d4"><a href="#bookscreencontroller-registerbindings-l2-lambda-0e1bf8ad4c409c2c8f875ebf2b09a5d4" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_0e1bf8ad4c409c2c8f875ebf2b09a5d4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_0e1bf8ad4c409c2c8f875ebf2b09a5d4&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-32d9fff5156d1fde6cf6d921108708e6"><a href="#bookscreencontroller-registerbindings-l2-lambda-32d9fff5156d1fde6cf6d921108708e6" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_32d9fff5156d1fde6cf6d921108708e6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_32d9fff5156d1fde6cf6d921108708e6&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-a42146ef4881c0299d2772c8e0c6ca84"><a href="#bookscreencontroller-registerbindings-l2-lambda-a42146ef4881c0299d2772c8e0c6ca84" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_a42146ef4881c0299d2772c8e0c6ca84&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_a42146ef4881c0299d2772c8e0c6ca84&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-6e472ed66f0c53546a0b144ad8848394"><a href="#bookscreencontroller-registerbindings-l2-lambda-6e472ed66f0c53546a0b144ad8848394" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_6e472ed66f0c53546a0b144ad8848394&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_6e472ed66f0c53546a0b144ad8848394&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-980f57c58b056dbacc17eb339c26fd07"><a href="#bookscreencontroller-registerbindings-l2-lambda-980f57c58b056dbacc17eb339c26fd07" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_980f57c58b056dbacc17eb339c26fd07&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_980f57c58b056dbacc17eb339c26fd07&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-40ac37c21938dd767fee8bba914bc9d6"><a href="#bookscreencontroller-registerbindings-l2-lambda-40ac37c21938dd767fee8bba914bc9d6" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_40ac37c21938dd767fee8bba914bc9d6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_40ac37c21938dd767fee8bba914bc9d6&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-8960f4c6aeaa118d8afd8f231c524958"><a href="#bookscreencontroller-registerbindings-l2-lambda-8960f4c6aeaa118d8afd8f231c524958" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_8960f4c6aeaa118d8afd8f231c524958&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_8960f4c6aeaa118d8afd8f231c524958&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-919f86313deae95265162bc008fa7c8e"><a href="#bookscreencontroller-registerbindings-l2-lambda-919f86313deae95265162bc008fa7c8e" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_919f86313deae95265162bc008fa7c8e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_919f86313deae95265162bc008fa7c8e&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registerbindings-l2-lambda-94fc43a149aec474366caab8ebbaa33e"><a href="#bookscreencontroller-registerbindings-l2-lambda-94fc43a149aec474366caab8ebbaa33e" class="header-anchor">#</a> <code>BookScreenController::_registerBindings::__l2::&lt;lambda_94fc43a149aec474366caab8ebbaa33e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerBindings::__l2::&lt;lambda_94fc43a149aec474366caab8ebbaa33e&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-4ed091f1da30f81f28e5f550d66abd14"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-4ed091f1da30f81f28e5f550d66abd14" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_4ed091f1da30f81f28e5f550d66abd14&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_4ed091f1da30f81f28e5f550d66abd14&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-11b65ada601cf3200a60738aa12b400e"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-11b65ada601cf3200a60738aa12b400e" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_11b65ada601cf3200a60738aa12b400e&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_11b65ada601cf3200a60738aa12b400e&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-11b65ada601cf3200a60738aa12b400e-l2-lambda-7828bb44b1fcdb96306da87dbc474e31"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-11b65ada601cf3200a60738aa12b400e-l2-lambda-7828bb44b1fcdb96306da87dbc474e31" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_11b65ada601cf3200a60738aa12b400e&gt;::()::__l2::&lt;lambda_7828bb44b1fcdb96306da87dbc474e31&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_11b65ada601cf3200a60738aa12b400e&gt;::()::__l2::&lt;lambda_7828bb44b1fcdb96306da87dbc474e31&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-68512987264b3c9ae16ff4df9ef66b87"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-68512987264b3c9ae16ff4df9ef66b87" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_68512987264b3c9ae16ff4df9ef66b87&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_68512987264b3c9ae16ff4df9ef66b87&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-6878a4398b0ea544de0b5b508592c192"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-6878a4398b0ea544de0b5b508592c192" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_6878a4398b0ea544de0b5b508592c192&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_6878a4398b0ea544de0b5b508592c192&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-8a5705a75d9d6e43000560d6acc19a40"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-8a5705a75d9d6e43000560d6acc19a40" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_8a5705a75d9d6e43000560d6acc19a40&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_8a5705a75d9d6e43000560d6acc19a40&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-143f085f5ac4c42310864b83a7e3a178"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-143f085f5ac4c42310864b83a7e3a178" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_143f085f5ac4c42310864b83a7e3a178&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_143f085f5ac4c42310864b83a7e3a178&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-542194880356dec9682c663ff3c895b3"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-542194880356dec9682c663ff3c895b3" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_542194880356dec9682c663ff3c895b3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_542194880356dec9682c663ff3c895b3&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-b18ca6ef114d4011b6898690f5836e2c"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-b18ca6ef114d4011b6898690f5836e2c" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_b18ca6ef114d4011b6898690f5836e2c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_b18ca6ef114d4011b6898690f5836e2c&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-7e99b0c889ea7689486d9ad304660aee"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-7e99b0c889ea7689486d9ad304660aee" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_7e99b0c889ea7689486d9ad304660aee&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_7e99b0c889ea7689486d9ad304660aee&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-4236224130f9a47f1a840738f1fe0844"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-4236224130f9a47f1a840738f1fe0844" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_4236224130f9a47f1a840738f1fe0844&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_4236224130f9a47f1a840738f1fe0844&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-7f071518a46576f69e99147875a86af2"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-7f071518a46576f69e99147875a86af2" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_7f071518a46576f69e99147875a86af2&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_7f071518a46576f69e99147875a86af2&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-62c8e8496dd68fb615d2007634be761c"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-62c8e8496dd68fb615d2007634be761c" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_62c8e8496dd68fb615d2007634be761c&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_62c8e8496dd68fb615d2007634be761c&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-64f62a0f32ed2be12cfd4f4d5bc5f8a4"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-64f62a0f32ed2be12cfd4f4d5bc5f8a4" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_64f62a0f32ed2be12cfd4f4d5bc5f8a4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_64f62a0f32ed2be12cfd4f4d5bc5f8a4&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-2d25936ddb4171b92ede1cddfdeb15a6"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-2d25936ddb4171b92ede1cddfdeb15a6" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_2d25936ddb4171b92ede1cddfdeb15a6&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_2d25936ddb4171b92ede1cddfdeb15a6&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-4faeb6cb49aaaee4cc496b671d03ef9f"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-4faeb6cb49aaaee4cc496b671d03ef9f" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_4faeb6cb49aaaee4cc496b671d03ef9f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_4faeb6cb49aaaee4cc496b671d03ef9f&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-e2683272ca8caea2d4b75821a48502a3"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-e2683272ca8caea2d4b75821a48502a3" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_e2683272ca8caea2d4b75821a48502a3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_e2683272ca8caea2d4b75821a48502a3&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-83945d1606f73308a0decdf366174f80"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-83945d1606f73308a0decdf366174f80" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_83945d1606f73308a0decdf366174f80&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_83945d1606f73308a0decdf366174f80&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-d3c3eb04e7f28b0c8c70d2906a31e60d"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-d3c3eb04e7f28b0c8c70d2906a31e60d" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_d3c3eb04e7f28b0c8c70d2906a31e60d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_d3c3eb04e7f28b0c8c70d2906a31e60d&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="bookscreencontroller-registereventhandlers-l2-lambda-4844ca985ad444ebd27c9087c989b554"><a href="#bookscreencontroller-registereventhandlers-l2-lambda-4844ca985ad444ebd27c9087c989b554" class="header-anchor">#</a> <code>BookScreenController::_registerEventHandlers::__l2::&lt;lambda_4844ca985ad444ebd27c9087c989b554&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BookScreenController::_registerEventHandlers::__l2::&lt;lambda_4844ca985ad444ebd27c9087c989b554&gt;
{
  BookScreenController *const __this;
};

</code></pre></div><h3 id="basictoggle"><a href="#basictoggle" class="header-anchor">#</a> <code>BasicToggle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BasicToggle
{
  bool mIsOn;
  bool mStateChanged;
  bool mFirstStateChange;
};

</code></pre></div><h3 id="buffer-span-std-pair-gsl-basic-string-span-char-const-1-gsl-basic-string-span-char-const-1-iterator"><a href="#buffer-span-std-pair-gsl-basic-string-span-char-const-1-gsl-basic-string-span-char-const-1-iterator" class="header-anchor">#</a> <code>buffer_span&lt;std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; &gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; &gt;::iterator
{
  const std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; *mPtr;
};

</code></pre></div><h3 id="buffer-span-mut-std-pair-gsl-basic-string-span-char-const-1-gsl-basic-string-span-char-const-1"><a href="#buffer-span-mut-std-pair-gsl-basic-string-span-char-const-1-gsl-basic-string-span-char-const-1" class="header-anchor">#</a> <code>buffer_span_mut&lt;std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; &gt;
{
  std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; *mBegin;
  std::pair&lt;gsl::basic_string_span&lt;char const ,-1&gt;,gsl::basic_string_span&lt;char const ,-1&gt; &gt; *mEnd;
};

</code></pre></div><h3 id="bucketitem"><a href="#bucketitem" class="header-anchor">#</a> <code>BucketItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BucketItem : Item
{
  _BYTE mFillType[2];
  TextureUVCoordinateSet m_uvBucket;
};

</code></pre></div><h3 id="beehiveblock"><a href="#beehiveblock" class="header-anchor">#</a> <code>BeehiveBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeehiveBlock : FaceDirectionalActorBlock
{
};

</code></pre></div><h3 id="beehiveblock-vtbl"><a href="#beehiveblock-vtbl" class="header-anchor">#</a> <code>BeehiveBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BeehiveBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  ItemInstance *(__fastcall *getEntityResourceItem)(ActorBlock *this, ItemInstance *result, Random *, const BlockActor *, int);
};

</code></pre></div><h3 id="beehiveblockactor-occupant"><a href="#beehiveblockactor-occupant" class="header-anchor">#</a> <code>BeehiveBlockActor::Occupant</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BeehiveBlockActor::Occupant
{
  ActorDefinitionIdentifier mActorIdentifier;
  CompoundTag mSaveData;
  unsigned int mTicksLeftToStay;
};

</code></pre></div><h3 id="beehiveblockactor"><a href="#beehiveblockactor" class="header-anchor">#</a> <code>BeehiveBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BeehiveBlockActor : BlockActor
{
  std::vector&lt;BeehiveBlockActor::Occupant&gt; mOccupants;
  bool mShouldSpawnBees;
};

</code></pre></div><h3 id="beehiveblockactor-vtbl"><a href="#beehiveblockactor-vtbl" class="header-anchor">#</a> <code>BeehiveBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BeehiveBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="blockcommandorigin"><a href="#blockcommandorigin" class="header-anchor">#</a> <code>BlockCommandOrigin</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockCommandOrigin : CommandOrigin
{
  BlockSource *mRegion;
  BlockPos mPosition;
};

</code></pre></div><h3 id="blockcommandorigin-vtbl"><a href="#blockcommandorigin-vtbl" class="header-anchor">#</a> <code>BlockCommandOrigin_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockCommandOrigin_vtbl
{
  void (__fastcall *~CommandOrigin)(CommandOrigin *this);
  const std::string *(__fastcall *getRequestId)(CommandOrigin *this);
  std::string *(__fastcall *getName)(CommandOrigin *this, std::string *result);
  BlockPos *(__fastcall *getBlockPosition)(CommandOrigin *this, BlockPos *result);
  Vec3 *(__fastcall *getWorldPosition)(CommandOrigin *this, Vec3 *result);
  Level *(__fastcall *getLevel)(CommandOrigin *this);
  Dimension *(__fastcall *getDimension)(CommandOrigin *this);
  Actor *(__fastcall *getEntity)(CommandOrigin *this);
  CommandPermissionLevel (__fastcall *getPermissionsLevel)(CommandOrigin *this);
  std::unique_ptr&lt;CommandOrigin&gt; *(__fastcall *clone)(CommandOrigin *this, std::unique_ptr&lt;CommandOrigin&gt; *result);
  std::optional&lt;BlockPos&gt; *(__fastcall *getCursorHitBlockPos)(CommandOrigin *this, std::optional&lt;BlockPos&gt; *result);
  std::optional&lt;Vec3&gt; *(__fastcall *getCursorHitPos)(CommandOrigin *this, std::optional&lt;Vec3&gt; *result);
  bool (__fastcall *hasChatPerms)(CommandOrigin *this);
  bool (__fastcall *hasTellPerms)(CommandOrigin *this);
  bool (__fastcall *canUseAbility)(CommandOrigin *this, AbilitiesIndex);
  bool (__fastcall *isWorldBuilder)(CommandOrigin *this);
  bool (__fastcall *canUseCommandsWithoutCheatsEnabled)(CommandOrigin *this);
  bool (__fastcall *isSelectorExpansionAllowed)(CommandOrigin *this);
  const NetworkIdentifier *(__fastcall *getSourceId)(CommandOrigin *this);
  unsigned __int8 (__fastcall *getSourceSubId)(CommandOrigin *this);
  const CommandOrigin *(__fastcall *getOutputReceiver)(CommandOrigin *this);
  CommandOriginType (__fastcall *getOriginType)(CommandOrigin *this);
  CommandOriginData *(__fastcall *toCommandOriginData)(CommandOrigin *this, CommandOriginData *result);
  const mce::UUID *(__fastcall *getUUID)(CommandOrigin *this);
  void (__fastcall *handleCommandOutputCallback)(CommandOrigin *this, Json::Value *);
  void (__fastcall *_setUUID)(CommandOrigin *this, const mce::UUID *);
  CommandBlockActor *(__fastcall *getBlockEntity)(BlockCommandOrigin *this);
  BaseCommandBlock *(__fastcall *getBaseCommandBlock)(BlockCommandOrigin *this);
};

</code></pre></div><h3 id="blockptr"><a href="#blockptr" class="header-anchor">#</a> <code>BlockPtr</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPtr
{
  const Block *mBlock;
};

</code></pre></div><h3 id="balloonitem"><a href="#balloonitem" class="header-anchor">#</a> <code>BalloonItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonItem : ChemistryItem
{
};

</code></pre></div><h3 id="blockplanteritem"><a href="#blockplanteritem" class="header-anchor">#</a> <code>BlockPlanterItem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockPlanterItem : Item
{
  const Block *mBlock;
  const bool mUseBlockDescription;
};

</code></pre></div><h3 id="bedrock-threading-asvoidtask-l2-lambda-d7f1027c792d450a6d889ec9715c5110"><a href="#bedrock-threading-asvoidtask-l2-lambda-d7f1027c792d450a6d889ec9715c5110" class="header-anchor">#</a> <code>Bedrock::Threading::asVoidTask::__l2::&lt;lambda_d7f1027c792d450a6d889ec9715c5110&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::asVoidTask::__l2::&lt;lambda_d7f1027c792d450a6d889ec9715c5110&gt;
{
  std::shared_ptr&lt;Bedrock::Threading::AsyncDeferredResultT&lt;void&gt; &gt; wrapper;
};

</code></pre></div><h3 id="behavioractionmapper"><a href="#behavioractionmapper" class="header-anchor">#</a> <code>BehaviorActionMapper</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BehaviorActionMapper : InputDeviceMapper
{
  std::unordered_map&lt;int,std::unordered_multimap&lt;int,unsigned int&gt;&gt; mTestAutoActionToButtonIdMappings;
};

</code></pre></div><h3 id="behavioractionmapper-vtbl"><a href="#behavioractionmapper-vtbl" class="header-anchor">#</a> <code>BehaviorActionMapper_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BehaviorActionMapper_vtbl
{
  void (__fastcall *~InputDeviceMapper)(InputDeviceMapper *this);
  void (__fastcall *setMapping)(InputDeviceMapper *this, InputEventQueue *, const BindingFactory *, const InputMapping *, int);
  void (__fastcall *clearMapping)(InputDeviceMapper *this, int);
  void (__fastcall *clearInputDeviceQueue)(InputDeviceMapper *this);
  void (__fastcall *clearInputDeviceQueueForFrame)(InputDeviceMapper *this);
  void (__fastcall *hardResetInputDeviceQueue)(InputDeviceMapper *this);
  bool (__fastcall *tick)(InputDeviceMapper *this, InputEventQueue *, ControllerIDtoClientMap *);
  InputMode (__fastcall *getInputMode)(InputDeviceMapper *this);
  void (__fastcall *getCursorPos)(InputDeviceMapper *this, float *, float *);
  void (__fastcall *render)(InputDeviceMapper *this, InputRenderContext *);
  void (__fastcall *setWindowSize)(InputDeviceMapper *this, int, int);
  void (__fastcall *setBindingMode)(InputDeviceMapper *this, InputBindingMode, int);
  InputBindingMode (__fastcall *getBindingMode)(InputDeviceMapper *this, int);
  void (__fastcall *changeControllerId)(InputDeviceMapper *this, int, int);
};

</code></pre></div><h3 id="balloonmodel"><a href="#balloonmodel" class="header-anchor">#</a> <code>BalloonModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonModel : Model
{
  std::unique_ptr&lt;std::vector&lt;ModelPart&gt;&gt; mParts;
  std::unique_ptr&lt;mce::MaterialPtr&gt; mDefaultMaterial;
};

</code></pre></div><h3 id="balloonmodel-vtbl"><a href="#balloonmodel-vtbl" class="header-anchor">#</a> <code>BalloonModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BalloonModel_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
};

</code></pre></div><h3 id="bannermodel"><a href="#bannermodel" class="header-anchor">#</a> <code>BannerModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BannerModel : Model
{
  ModelPart mFlag;
  ModelPart mPole;
  ModelPart mLongPole;
  ModelPart mBar;
  ModelPart mForcedMatFlag;
  ModelPart mForcedMatPole;
  ModelPart mForcedMatBar;
  mce::MaterialPtr mBannerMaterial;
  mce::MaterialPtr mBannerPoleMaterial;
};

</code></pre></div><h3 id="bannermodel-vtbl"><a href="#bannermodel-vtbl" class="header-anchor">#</a> <code>BannerModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BannerModel_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
};

</code></pre></div><h3 id="bedmodel"><a href="#bedmodel" class="header-anchor">#</a> <code>BedModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedModel : Model
{
  mce::MaterialPtr mDefaultMaterial;
  ModelPart mBody;
  ModelPart mLeg0;
  ModelPart mLeg1;
  ModelPart mLeg2;
  ModelPart mLeg3;
};

</code></pre></div><h3 id="bedmodel-vtbl"><a href="#bedmodel-vtbl" class="header-anchor">#</a> <code>BedModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BedModel_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
};

</code></pre></div><h3 id="bellmodel"><a href="#bellmodel" class="header-anchor">#</a> <code>BellModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BellModel : Model
{
  mce::MaterialPtr mDefaultMaterial;
  ModelPart mBellBody;
  ModelPart mBellBase;
};

</code></pre></div><h3 id="bellmodel-vtbl"><a href="#bellmodel-vtbl" class="header-anchor">#</a> <code>BellModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BellModel_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
};

</code></pre></div><h3 id="boatmodel"><a href="#boatmodel" class="header-anchor">#</a> <code>BoatModel</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BoatModel : Model
{
  mce::MaterialPtr mDefaultMaterial;
  ModelPart mBottom;
  ModelPart mBack;
  ModelPart mFront;
  ModelPart mLeft;
  ModelPart mRight;
  ModelPart mLeftPaddle;
  ModelPart mRightPaddle;
};

</code></pre></div><h3 id="boatmodel-vtbl"><a href="#boatmodel-vtbl" class="header-anchor">#</a> <code>BoatModel_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BoatModel_vtbl
{
  void (__fastcall *~AppPlatformListener)(AppPlatformListener *this);
  void (__fastcall *onLowMemory)(AppPlatformListener *this);
  void (__fastcall *onAppPaused)(AppPlatformListener *this);
  void (__fastcall *onAppUnpaused)(AppPlatformListener *this);
  void (__fastcall *onAppPreSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppSuspended)(AppPlatformListener *this);
  void (__fastcall *onAppResumed)(AppPlatformListener *this);
  void (__fastcall *onAppFocusLost)(AppPlatformListener *this);
  void (__fastcall *onAppFocusGained)(AppPlatformListener *this);
  void (__fastcall *onAppTerminated)(AppPlatformListener *this);
  void (__fastcall *onOperationModeChanged)(AppPlatformListener *this, const OperationMode);
  void (__fastcall *onPerformanceModeChanged)(AppPlatformListener *this, const bool);
  void (__fastcall *onPushNotificationReceived)(AppPlatformListener *this, const PushNotificationMessage *);
  void (__fastcall *onResizeBegin)(AppPlatformListener *this);
  void (__fastcall *onResizeEnd)(AppPlatformListener *this);
  void (__fastcall *onDeviceLost)(AppPlatformListener *this);
  void (__fastcall *clear)(Model *this);
  void (__fastcall *preDraw)(Model *this, ScreenContext *);
  void (__fastcall *postDraw)(Model *this, ScreenContext *);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, BaseActorRenderContext *);
  void (__fastcall *render)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *render)(Model *this, ScreenContext *);
  void (__fastcall *setupAnim)(Model *this);
  void (__fastcall *setupAnim)(Model *this, float, float, float, float, float, float);
  void (__fastcall *prepareMobModel)(Model *this, Mob *, float, float, float);
  Vec3 *(__fastcall *getLeashOffsetPosition)(Model *this, Vec3 *result, bool);
  void (__fastcall *renderAniModel)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  void (__fastcall *renderMod)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float);
  void (__fastcall *youngTransform)(Model *this, ScreenContext *, Actor *, float, float, float, float, float, float, MatrixStack::MatrixStackRef *);
  float (__fastcall *getHeightAdjustment)(Model *this);
  AABB *(__fastcall *buildAABB)(Model *this, AABB *result);
};

</code></pre></div><h3 id="bedrock-threading-asvoidtask-l2-lambda-ed7b5341cd28450411fe7d5e3644acd3"><a href="#bedrock-threading-asvoidtask-l2-lambda-ed7b5341cd28450411fe7d5e3644acd3" class="header-anchor">#</a> <code>Bedrock::Threading::asVoidTask::__l2::&lt;lambda_ed7b5341cd28450411fe7d5e3644acd3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::asVoidTask::__l2::&lt;lambda_ed7b5341cd28450411fe7d5e3644acd3&gt;
{
  std::shared_ptr&lt;Bedrock::Threading::AsyncDeferredResultT&lt;void&gt; &gt; wrapper;
};

</code></pre></div><h3 id="blockdefinitiongroup-blockresource"><a href="#blockdefinitiongroup-blockresource" class="header-anchor">#</a> <code>BlockDefinitionGroup::BlockResource</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockDefinitionGroup::BlockResource
{
  SemVersion mVersion;
  BlockDescription mDescription;
  std::string mResourcePackLocation;
  std::string mResourceFileLocation;
  Json::Value mRoot;
};

</code></pre></div><h3 id="bannerrecipes"><a href="#bannerrecipes" class="header-anchor">#</a> <code>BannerRecipes</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BannerRecipes
{
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-levelstoragewritebatch-std-allocator-levelstoragewritebatch"><a href="#bedrock-threading-threadlocalobjectimplementation-levelstoragewritebatch-std-allocator-levelstoragewritebatch" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;LevelStorageWriteBatch,std::allocator&lt;LevelStorageWriteBatch&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;LevelStorageWriteBatch,std::allocator&lt;LevelStorageWriteBatch&gt; &gt;
{
  LevelStorageWriteBatch *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-levelstoragewritebatch-std-allocator-levelstoragewritebatch"><a href="#bedrock-threading-threadlocalobject-levelstoragewritebatch-std-allocator-levelstoragewritebatch" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;LevelStorageWriteBatch,std::allocator&lt;LevelStorageWriteBatch&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;LevelStorageWriteBatch,std::allocator&lt;LevelStorageWriteBatch&gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;LevelStorageWriteBatch,std::allocator&lt;LevelStorageWriteBatch&gt; &gt;
{
  std::function&lt;void __cdecl(LevelStorageWriteBatch *)&gt; mConstructor;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-std-string-std-allocator-std-string"><a href="#bedrock-threading-threadlocalobjectimplementation-std-string-std-allocator-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::string,std::allocator&lt;std::string &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::string,std::allocator&lt;std::string &gt; &gt;
{
  std::string *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-std-string-std-allocator-std-string"><a href="#bedrock-threading-threadlocalobject-std-string-std-allocator-std-string" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;std::string,std::allocator&lt;std::string &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;std::string,std::allocator&lt;std::string &gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::string,std::allocator&lt;std::string &gt; &gt;
{
  std::function&lt;void __cdecl(std::string *)&gt; mConstructor;
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-sparsecontainer-pushslotpredictionresult-std-string"><a href="#bidirectionalunorderedmap-enum-sparsecontainer-pushslotpredictionresult-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum SparseContainer::PushSlotPredictionResult,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum SparseContainer::PushSlotPredictionResult,std::string &gt;
{
  std::unordered_map&lt;enum SparseContainer::PushSlotPredictionResult,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum SparseContainer::PushSlotPredictionResult&gt; mLeft;
};

</code></pre></div><h3 id="balloongasparticle"><a href="#balloongasparticle" class="header-anchor">#</a> <code>BalloonGasParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BalloonGasParticle : EndRodParticle
{
};

</code></pre></div><h3 id="balloongasparticle-vtbl"><a href="#balloongasparticle-vtbl" class="header-anchor">#</a> <code>BalloonGasParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BalloonGasParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="blockforcefieldparticle"><a href="#blockforcefieldparticle" class="header-anchor">#</a> <code>BlockForceFieldParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BlockForceFieldParticle : Particle
{
  bool mCanFadeout;
};

</code></pre></div><h3 id="blockforcefieldparticle-vtbl"><a href="#blockforcefieldparticle-vtbl" class="header-anchor">#</a> <code>BlockForceFieldParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockForceFieldParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="bubbleparticle"><a href="#bubbleparticle" class="header-anchor">#</a> <code>BubbleParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BubbleParticle : Particle
{
};

</code></pre></div><h3 id="bubbleparticle-vtbl"><a href="#bubbleparticle-vtbl" class="header-anchor">#</a> <code>BubbleParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BubbleParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="bubblecolumnparticle"><a href="#bubblecolumnparticle" class="header-anchor">#</a> <code>BubbleColumnParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BubbleColumnParticle : BubbleParticle
{
  bool mNeedsWater;
};

</code></pre></div><h3 id="bubblecolumnparticle-vtbl"><a href="#bubblecolumnparticle-vtbl" class="header-anchor">#</a> <code>BubbleColumnParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BubbleColumnParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="bubblecolumndownparticle"><a href="#bubblecolumndownparticle" class="header-anchor">#</a> <code>BubbleColumnDownParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BubbleColumnDownParticle : BubbleColumnParticle
{
  float mAngle;
};

</code></pre></div><h3 id="bubblecolumndownparticle-vtbl"><a href="#bubblecolumndownparticle-vtbl" class="header-anchor">#</a> <code>BubbleColumnDownParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BubbleColumnDownParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="bubblecolumnupparticle"><a href="#bubblecolumnupparticle" class="header-anchor">#</a> <code>BubbleColumnUpParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BubbleColumnUpParticle : BubbleColumnParticle
{
};

</code></pre></div><h3 id="bubblecolumnupparticle-vtbl"><a href="#bubblecolumnupparticle-vtbl" class="header-anchor">#</a> <code>BubbleColumnUpParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BubbleColumnUpParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="breakingitemparticle"><a href="#breakingitemparticle" class="header-anchor">#</a> <code>BreakingItemParticle</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BreakingItemParticle : Particle
{
  const Item *mItem;
};

</code></pre></div><h3 id="breakingitemparticle-vtbl"><a href="#breakingitemparticle-vtbl" class="header-anchor">#</a> <code>BreakingItemParticle_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BreakingItemParticle_vtbl
{
  void (__fastcall *init)(Particle *this, const Vec3 *, const Vec3 *, int, ParticleEngine *);
  void (__fastcall *addTagData)(Particle *this, const CompoundTag *);
  void (__fastcall *~Particle)(Particle *this);
  void (__fastcall *normalTick)(Particle *this);
  void (__fastcall *tessellate)(Particle *this, const ParticleRenderContext *);
  const mce::TexturePtr *(__fastcall *getParticleTexture)(Particle *this);
  mce::Color *(__fastcall *getParticleLightColor)(Particle *this, mce::Color *result, float, const LightTexture *);
  void (__fastcall *setEmittingEntity)(Particle *this, Actor *);
  bool (__fastcall *_shouldUpdateVertexData)(Particle *this, float);
};

</code></pre></div><h3 id="bidirectionalunorderedmap-std-string-enum-levelsoundevent"><a href="#bidirectionalunorderedmap-std-string-enum-levelsoundevent" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;std::string,enum LevelSoundEvent&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;std::string,enum LevelSoundEvent&gt;
{
  std::unordered_map&lt;std::string,enum LevelSoundEvent&gt; mRight;
  std::unordered_map&lt;enum LevelSoundEvent,std::string&gt; mLeft;
};

</code></pre></div><h3 id="bedrock-intrusive-list-standard-operations-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase"><a href="#bedrock-intrusive-list-standard-operations-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase" class="header-anchor">#</a> <code>Bedrock::Intrusive::list_standard_operations&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list_standard_operations&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;
{
};

</code></pre></div><h3 id="bedrock-jsonobject-memorypage"><a href="#bedrock-jsonobject-memorypage" class="header-anchor">#</a> <code>Bedrock::JSONObject::MemoryPage</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::MemoryPage
{
  gsl::not_null&lt;Bedrock::JSONObject::Document *&gt; mDocument;
  Bedrock::JSONObject::MemoryPage *mPrevious;
  unsigned int mLength;
  unsigned int mPageIndex;
  unsigned __int64 mFrontPtr;
  unsigned __int64 mBackPtr;
};

</code></pre></div><h3 id="bedrock-jsonobject-nodebase-offset"><a href="#bedrock-jsonobject-nodebase-offset" class="header-anchor">#</a> <code>Bedrock::JSONObject::NodeBase::Offset</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct Bedrock::JSONObject::NodeBase::Offset
{
  $7AE99247DE4E2AB7A8FBAA39B692D4AC ___u0;
};

</code></pre></div><h3 id="bedrock-jsonobject-nodebase"><a href="#bedrock-jsonobject-nodebase" class="header-anchor">#</a> <code>Bedrock::JSONObject::NodeBase</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::NodeBase : Bedrock::Intrusive::list_standard_operations&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;
{
  $A502E20004E18863C23A549842F01CFA ___u1;
};

</code></pre></div><h3 id="bedrock-jsonobject-node"><a href="#bedrock-jsonobject-node" class="header-anchor">#</a> <code>Bedrock::JSONObject::Node</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::Node : Bedrock::JSONObject::NodeBase
{
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase"><a href="#bedrock-intrusive-list-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;
{
  Bedrock::JSONObject::NodeBase mSentinel;
};

</code></pre></div><h3 id="bedrock-jsonobject-collection"><a href="#bedrock-jsonobject-collection" class="header-anchor">#</a> <code>Bedrock::JSONObject::Collection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::Collection
{
  Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt; mList;
  unsigned int mSize;
  unsigned int mPadding;
};

</code></pre></div><h3 id="bedrock-jsonobject-arraynode"><a href="#bedrock-jsonobject-arraynode" class="header-anchor">#</a> <code>Bedrock::JSONObject::ArrayNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::ArrayNode : Bedrock::JSONObject::Node, Bedrock::JSONObject::Collection
{
};

</code></pre></div><h3 id="bedrock-jsonobject-objectnode"><a href="#bedrock-jsonobject-objectnode" class="header-anchor">#</a> <code>Bedrock::JSONObject::ObjectNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::ObjectNode : Bedrock::JSONObject::Node, Bedrock::JSONObject::Collection
{
};

</code></pre></div><h3 id="bedrock-jsonobject-document-allocatedresources"><a href="#bedrock-jsonobject-document-allocatedresources" class="header-anchor">#</a> <code>Bedrock::JSONObject::Document::AllocatedResources</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::Document::AllocatedResources
{
  Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt; mFreeNullsOrBools;
  Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt; mFreeNumbers;
  Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt; mFreeCollections;
  Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt; mFreeStringBuffers;
  Bedrock::JSONObject::ArrayNode mNullArray;
  Bedrock::JSONObject::ObjectNode mNullObject;
};

</code></pre></div><h3 id="bedrock-jsonobject-outputoptions"><a href="#bedrock-jsonobject-outputoptions" class="header-anchor">#</a> <code>Bedrock::JSONObject::OutputOptions</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) Bedrock::JSONObject::OutputOptions
{
  bool mPretty;
  unsigned int mIndentAmount;
  char mIndentChar;
};

</code></pre></div><h3 id="bedrock-jsonobject-stringnode"><a href="#bedrock-jsonobject-stringnode" class="header-anchor">#</a> <code>Bedrock::JSONObject::StringNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::StringNode : Bedrock::JSONObject::Node
{
  $4F31B525017717FAA4DCB639C7FC65D7 ___u1;
};

</code></pre></div><h3 id="bedrock-jsonobject-nullnode"><a href="#bedrock-jsonobject-nullnode" class="header-anchor">#</a> <code>Bedrock::JSONObject::NullNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::NullNode : Bedrock::JSONObject::Node
{
};

</code></pre></div><h3 id="bedrock-jsonobject-booleannode"><a href="#bedrock-jsonobject-booleannode" class="header-anchor">#</a> <code>Bedrock::JSONObject::BooleanNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::BooleanNode : Bedrock::JSONObject::Node
{
};

</code></pre></div><h3 id="bedrock-jsonobject-numbernode"><a href="#bedrock-jsonobject-numbernode" class="header-anchor">#</a> <code>Bedrock::JSONObject::NumberNode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::NumberNode : Bedrock::JSONObject::Node
{
  $3EB15921B14454EE0C46C34FC3F1335B ___u1;
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-iterator-base-1"><a href="#bedrock-intrusive-list-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-bedrock-jsonobject-nodebase-iterator-base-1" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;::iterator_base&lt;1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;::iterator_base&lt;1&gt;
{
  const Bedrock::JSONObject::NodeBase *mHook;
};

</code></pre></div><h3 id="bedrock-jsonobject-arraynode-iterator-base-0"><a href="#bedrock-jsonobject-arraynode-iterator-base-0" class="header-anchor">#</a> <code>Bedrock::JSONObject::ArrayNode::iterator_base&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::ArrayNode::iterator_base&lt;0&gt;
{
  Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;::iterator_base&lt;0&gt; mHandle;
};

</code></pre></div><h3 id="bedrock-jsonobject-arraynode-iterator-base-1"><a href="#bedrock-jsonobject-arraynode-iterator-base-1" class="header-anchor">#</a> <code>Bedrock::JSONObject::ArrayNode::iterator_base&lt;1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::ArrayNode::iterator_base&lt;1&gt;
{
  Bedrock::Intrusive::list&lt;Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase,Bedrock::JSONObject::NodeBase&gt;::iterator_base&lt;1&gt; mHandle;
};

</code></pre></div><h3 id="bedrock-jsonobject-objectnode-iterator-base-0"><a href="#bedrock-jsonobject-objectnode-iterator-base-0" class="header-anchor">#</a> <code>Bedrock::JSONObject::ObjectNode::iterator_base&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::ObjectNode::iterator_base&lt;0&gt;
{
  std::pair&lt;Bedrock::JSONObject::StringNode const *,Bedrock::JSONObject::Node *&gt; mPair;
};

</code></pre></div><h3 id="bedrock-jsonobject-objectnode-iterator-base-1"><a href="#bedrock-jsonobject-objectnode-iterator-base-1" class="header-anchor">#</a> <code>Bedrock::JSONObject::ObjectNode::iterator_base&lt;1&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::ObjectNode::iterator_base&lt;1&gt;
{
  std::pair&lt;Bedrock::JSONObject::StringNode const *,Bedrock::JSONObject::Node const *&gt; mPair;
};

</code></pre></div><h3 id="bedrock-jsonobject-numbernode-internalformat"><a href="#bedrock-jsonobject-numbernode-internalformat" class="header-anchor">#</a> <code>Bedrock::JSONObject::NumberNode::InternalFormat</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::JSONObject::NumberNode::InternalFormat
{
  $3EB15921B14454EE0C46C34FC3F1335B ___u0;
  bool mIsFloatingPoint;
};

</code></pre></div><h3 id="bedrock-jsonobject-wrap-bedrock-jsonobject-valuewrapper-void"><a href="#bedrock-jsonobject-wrap-bedrock-jsonobject-valuewrapper-void" class="header-anchor">#</a> <code>Bedrock::JSONObject::Wrap&lt;Bedrock::JSONObject::ValueWrapper,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::Wrap&lt;Bedrock::JSONObject::ValueWrapper,void&gt;
{
};

</code></pre></div><h3 id="bedrock-jsonobject-wrap-bool-void"><a href="#bedrock-jsonobject-wrap-bool-void" class="header-anchor">#</a> <code>Bedrock::JSONObject::Wrap&lt;bool,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::Wrap&lt;bool,void&gt;
{
};

</code></pre></div><h3 id="bedrock-jsonobject-wrap-gsl-basic-string-span-char-const-1-void"><a href="#bedrock-jsonobject-wrap-gsl-basic-string-span-char-const-1-void" class="header-anchor">#</a> <code>Bedrock::JSONObject::Wrap&lt;gsl::basic_string_span&lt;char const ,-1&gt;,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::JSONObject::Wrap&lt;gsl::basic_string_span&lt;char const ,-1&gt;,void&gt;
{
};

</code></pre></div><h3 id="bedrock-pubsub-detail-dispatcher-bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-core-profile-profilegroup-void-void-core-profile-profilegroup"><a href="#bedrock-pubsub-detail-dispatcher-bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-core-profile-profilegroup-void-void-core-profile-profilegroup" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;,void,void,Core::Profile::ProfileGroup &amp;&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;,void,void,Core::Profile::ProfileGroup &amp;&gt;
{
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-core-profile-profilegroup"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-core-profile-profilegroup" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt; : Bedrock::PubSub::Detail::Dispatcher&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;,void,void,Core::Profile::ProfileGroup &amp;&gt;
{
  std::list&lt;std::shared_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;::SubscriptionBody&gt;&gt; mSubscriptions;
  std::mutex mMutex;
  std::weak_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;::SubscriptionBody&gt; mSingleSubscriber;
  std::atomic&lt;unsigned __int64&gt; mSubscriberCount;
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-core-profile-profilegroup-subscriptionbody"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-core-profile-profilegroup-subscriptionbody" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;::SubscriptionBody</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;::SubscriptionBody : Bedrock::PubSub::Detail::SubscriptionBodyInterface
{
  Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt; *mOwner;
  std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;std::shared_ptr&lt;Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;::SubscriptionBody&gt; &gt; &gt; &gt; mIterator;
  std::function&lt;void __cdecl(Core::Profile::ProfileGroup &amp;)&gt; mFunction;
  std::unique_ptr&lt;Bedrock::PubSub::SubscriptionContext&gt; mContext;
  int mGroup;
};

</code></pre></div><h3 id="bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-core-profile-profilegroup-subscriptionbody-vtbl"><a href="#bedrock-pubsub-detail-publisherbase-bedrock-pubsub-threadmodel-multithreaded-void-void-cdecl-core-profile-profilegroup-subscriptionbody-vtbl" class="header-anchor">#</a> <code>Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;::SubscriptionBody_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;::SubscriptionBody_vtbl
{
  void (__fastcall *~SubscriptionBodyInterface)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  const Bedrock::PubSub::SubscriptionContext *(__fastcall *_getContext)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this);
  void (__fastcall *_disconnect)(Bedrock::PubSub::Detail::SubscriptionBodyInterface *this, std::shared_ptr&lt;Bedrock::PubSub::Detail::SubscriptionBodyInterface&gt; *);
};

</code></pre></div><h3 id="bedrock-pubsub-publisher-void-cdecl-core-profile-profilegroup-bedrock-pubsub-threadmodel-multithreaded-void"><a href="#bedrock-pubsub-publisher-void-cdecl-core-profile-profilegroup-bedrock-pubsub-threadmodel-multithreaded-void" class="header-anchor">#</a> <code>Bedrock::PubSub::Publisher&lt;void __cdecl(Core::Profile::ProfileGroup &amp;),Bedrock::PubSub::ThreadModel::MultiThreaded,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::PubSub::Publisher&lt;void __cdecl(Core::Profile::ProfileGroup &amp;),Bedrock::PubSub::ThreadModel::MultiThreaded,void&gt; : Bedrock::PubSub::Detail::PublisherBase&lt;Bedrock::PubSub::ThreadModel::MultiThreaded,void,void __cdecl(Core::Profile::ProfileGroup &amp;)&gt;
{
};

</code></pre></div><h3 id="bootstrapconfig-loadresult"><a href="#bootstrapconfig-loadresult" class="header-anchor">#</a> <code>BootstrapConfig::LoadResult</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct BootstrapConfig::LoadResult
{
  bool success;
  const char *errorMessage;
};

</code></pre></div><h3 id="bootstrapconfig"><a href="#bootstrapconfig" class="header-anchor">#</a> <code>BootstrapConfig</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BootstrapConfig
{
  char mBuffer[2048];
  char mError[512];
  Bedrock::JSONObject::Document mDocument;
  Bedrock::JSONObject::ObjectNode *mRootObject;
  bool mInitialized;
};

</code></pre></div><h3 id="boatrenderer"><a href="#boatrenderer" class="header-anchor">#</a> <code>BoatRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BoatRenderer : ActorRenderer, AppPlatformListener
{
  BoatModel mModel;
  mce::MaterialPtr mHoleMaterial;
  mce::TexturePtr mBoatTex[6];
  mce::Mesh mHole;
};

</code></pre></div><h3 id="boatrenderer-vtbl"><a href="#boatrenderer-vtbl" class="header-anchor">#</a> <code>BoatRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BoatRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderDebug)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderEffects)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderTrading)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *, float);
  void (__fastcall *renderFlame)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderLeash)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *renderWaterHole)(ActorRenderer *this, BaseActorRenderContext *, ActorRenderData *);
  void (__fastcall *addAdditionalRenderingIfNeeded)(ActorRenderer *this, mce::TextureGroup *);
  void (__fastcall *renderWeaponEffect)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  void (__fastcall *renderBindEffects)(ActorRenderer *this, BaseActorRenderContext *, Actor *);
  AABB *(__fastcall *getRenderBounds)(ActorRenderer *this, AABB *result, const Actor *);
  Vec3 *(__fastcall *getLeashOffset)(ActorRenderer *this, Vec3 *result, Actor *, float, float, float, bool, bool);
  void (__fastcall *setIsOnScreen)(ActorRenderer *this, Actor *, const bool, float);
  bool (__fastcall *shouldUpdateBonesAndEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  bool (__fastcall *shouldUpdateEffectsIfOffScreen)(ActorRenderer *this, RenderParams *);
  void (__fastcall *_bindModelEffectRender)(ActorRenderer *this, BaseActorRenderContext *, Mob *);
};

</code></pre></div><h3 id="bannerrenderer"><a href="#bannerrenderer" class="header-anchor">#</a> <code>BannerRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BannerRenderer : BlockActorRenderer
{
  bool mAtlasLoaded;
  std::unique_ptr&lt;TextureAtlas&gt; mTextureAtlas;
  glm::tvec2&lt;float,0&gt; mMaxTileSize;
  mce::TexturePtr mTexture;
  std::unique_ptr&lt;BannerModel&gt; mBannerModel;
  mce::MaterialPtr mGuiMaterial;
  mce::MaterialPtr mGuiPoleMaterial;
};

</code></pre></div><h3 id="bannerrenderer-vtbl"><a href="#bannerrenderer-vtbl" class="header-anchor">#</a> <code>BannerRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BannerRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  void (__fastcall *renderAlpha)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  std::vector&lt;NameTagRenderObject&gt; *(__fastcall *extractText)(BlockActorRenderer *this, std::vector&lt;NameTagRenderObject&gt; *result, Tessellator *, BlockActor *, const std::string *, const std::vector&lt;int&gt; *, Vec3, bool);
};

</code></pre></div><h3 id="bushblock"><a href="#bushblock" class="header-anchor">#</a> <code>BushBlock</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BushBlock : BlockLegacy
{
};

</code></pre></div><h3 id="bushblock-vtbl"><a href="#bushblock-vtbl" class="header-anchor">#</a> <code>BushBlock_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BushBlock_vtbl
{
  void (__fastcall *~BlockLegacy)(BlockLegacy *this);
  const Block *(__fastcall *getStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  const Block *(__fastcall *getModBlockStateFromLegacyData)(BlockLegacy *this, unsigned __int16);
  std::shared_ptr&lt;BlockActor&gt; *(__fastcall *newBlockEntity)(BlockLegacy *this, std::shared_ptr&lt;BlockActor&gt; *result, const BlockPos *, const Block *);
  const Block *(__fastcall *getNextBlockPermutation)(BlockLegacy *this, const Block *);
  bool (__fastcall *hasTag)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *);
  bool (__fastcall *getCollisionShape)(BlockLegacy *this, AABB *, const Block *, BlockSource *, const BlockPos *, Actor *);
  bool (__fastcall *isObstructingChests)(BlockLegacy *this, BlockSource *, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *);
  Vec3 *(__fastcall *randomlyModifyPosition)(BlockLegacy *this, Vec3 *result, const BlockPos *, int *);
  void (__fastcall *addAABBs)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *);
  const AABB *(__fastcall *getAABB)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, AABB *, bool);
  bool (__fastcall *addCollisionShapes)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, const AABB *, std::vector&lt;AABB&gt; *, Actor *);
  const AABB *(__fastcall *getOutline)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  bool (__fastcall *getLiquidClipVolume)(BlockLegacy *this, BlockSource *, const BlockPos *, AABB *);
  void (__fastcall *onProjectileHit)(BlockLegacy *this, BlockSource *, const BlockPos *, const Actor *);
  bool (__fastcall *liquidCanFlowIntoFromDirection)(BlockLegacy *this, unsigned __int8, const std::function&lt;Block const &amp; __cdecl(BlockPos const &amp;)&gt; *, const BlockPos *);
  bool (__fastcall *hasVariableLighting)(BlockLegacy *this);
  bool (__fastcall *isStrippable)(BlockLegacy *this, const Block *);
  const Block *(__fastcall *getStrippedBlock)(BlockLegacy *this, const Block *);
  bool (__fastcall *canProvideSupport)(BlockLegacy *this, const Block *, unsigned __int8, BlockSupportType);
  bool (__fastcall *canConnect)(BlockLegacy *this, const Block *, unsigned __int8, const Block *);
  void (__fastcall *getConnectedDirections)(BlockLegacy *this, const Block *, const BlockPos *, BlockSource *, bool *, bool *, bool *, bool *);
  bool (__fastcall *isStemBlock)(BlockLegacy *this);
  bool (__fastcall *isContainerBlock)(BlockLegacy *this);
  bool (__fastcall *isCraftingBlock)(BlockLegacy *this);
  bool (__fastcall *isWaterBlocking)(BlockLegacy *this);
  bool (__fastcall *isHurtableBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isFenceGateBlock)(BlockLegacy *this);
  bool (__fastcall *isThinFenceBlock)(BlockLegacy *this);
  bool (__fastcall *isWallBlock)(BlockLegacy *this);
  bool (__fastcall *isStairBlock)(BlockLegacy *this);
  bool (__fastcall *isSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoubleSlabBlock)(BlockLegacy *this);
  bool (__fastcall *isDoorBlock)(BlockLegacy *this);
  bool (__fastcall *isRailBlock)(BlockLegacy *this);
  bool (__fastcall *isButtonBlock)(BlockLegacy *this);
  bool (__fastcall *canHurtAndBreakItem)(BlockLegacy *this);
  bool (__fastcall *isSignalSource)(BlockLegacy *this);
  bool (__fastcall *canBeOriginalSurface)(BlockLegacy *this);
  bool (__fastcall *isValidAuxValue)(BlockLegacy *this, int);
  void (__fastcall *setTargetLandBlocks)(BlockLegacy *this, const std::vector&lt;std::string&gt; *);
  bool (__fastcall *canFillAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  const Block *(__fastcall *sanitizeFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *onFillBlock)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getDirectSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  bool (__fastcall *waterSpreadCausesSpawn)(BlockLegacy *this);
  bool (__fastcall *canContainLiquid)(BlockLegacy *this);
  bool (__fastcall *shouldConnectToRedstone)(BlockLegacy *this, BlockSource *, const BlockPos *, int);
  void (__fastcall *handleRain)(BlockLegacy *this, BlockSource *, const BlockPos *, float);
  bool (__fastcall *canBeUsedInCommands)(BlockLegacy *this, const BaseGameVersion *);
  float (__fastcall *getThickness)(BlockLegacy *this);
  float (__fastcall *getFlexibility)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *checkIsPathable)(BlockLegacy *this, Actor *, const BlockPos *, const BlockPos *);
  bool (__fastcall *shouldDispense)(BlockLegacy *this, BlockSource *, Container *);
  bool (__fastcall *dispense)(BlockLegacy *this, BlockSource *, Container *, int, const Vec3 *, unsigned __int8);
  void (__fastcall *transformOnFall)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *onRedstoneUpdate)(BlockLegacy *this, BlockSource *, const BlockPos *, int, bool);
  void (__fastcall *onMove)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *detachesOnPistonMove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *movedByPiston)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onStructureNeighborBlockPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *setupRedstoneComponent)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *specialUse)(BlockLegacy *this, Player *, const BlockPos *, ItemStack *);
  BlockProperty (__fastcall *getRedstoneProperty)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *updateEntityAfterFallOn)(BlockLegacy *this, IActorMovementProxy *);
  bool (__fastcall *isBounceBlock)(BlockLegacy *this);
  bool (__fastcall *ignoreEntitiesOnPistonMove)(BlockLegacy *this, const Block *);
  bool (__fastcall *onFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, FertilizerType);
  bool (__fastcall *mayConsumeFertilizer)(BlockLegacy *this, BlockSource *);
  bool (__fastcall *canBeFertilized)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *mayPick)(BlockLegacy *this, BlockSource *, const Block *, bool);
  bool (__fastcall *mayPick)(BlockLegacy *this);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *mayPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, unsigned __int8);
  bool (__fastcall *mayPlaceOn)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *tryToPlace)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const ActorBlockSyncMessage *);
  bool (__fastcall *breaksFallingBlocks)(BlockLegacy *this, const Block *);
  void (__fastcall *destroy)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, Actor *);
  bool (__fastcall *playerWillDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  bool (__fastcall *getIgnoresDestroyPermissions)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *neighborChanged)(BlockLegacy *this, BlockSource *, const BlockPos *, const BlockPos *);
  bool (__fastcall *getSecondPart)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  int (__fastcall *getResourceCount)(BlockLegacy *this, Random *, const Block *, int, bool);
  ItemInstance *(__fastcall *getResourceItem)(BlockLegacy *this, ItemInstance *result, Random *, const Block *, int);
  ItemInstance *(__fastcall *asItemInstance)(BlockLegacy *this, ItemInstance *result, BlockSource *, const BlockPos *, const Block *);
  void (__fastcall *spawnResources)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  void (__fastcall *trySpawnResourcesOnExplosion)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, std::vector&lt;Item const *&gt; *, float, int, bool);
  bool (__fastcall *spawnBurnResources)(BlockLegacy *this, BlockSource *, float, float, float);
  const Block *(__fastcall *getPlacementBlock)(BlockLegacy *this, Actor *, const BlockPos *, unsigned __int8, const Vec3 *, int);
  int (__fastcall *calcVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *isAttachedTo)(BlockLegacy *this, BlockSource *, const BlockPos *, BlockPos *);
  bool (__fastcall *attack)(BlockLegacy *this, Player *, const BlockPos *);
  void (__fastcall *handleEntityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, Vec3 *);
  void (__fastcall *entityInside)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  int (__fastcall *getExperienceDrop)(BlockLegacy *this, Random *);
  bool (__fastcall *canBeBuiltOver)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *triggerEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, int, int);
  void (__fastcall *executeEvent)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, const std::string *, Actor *);
  void (__fastcall *executeEvent)(BlockLegacy *this, const std::string *, RenderParams *);
  bool (__fastcall *executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  bool (__fastcall *executeTriggerChain)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, RenderParams *);
  const MobSpawnerData *(__fastcall *getMobToSpawn)(BlockLegacy *this, const SpawnConditions *, BlockSource *);
  bool (__fastcall *shouldStopFalling)(BlockLegacy *this, Actor *);
  bool (__fastcall *pushesUpFallingBlocks)(BlockLegacy *this);
  float (__fastcall *calcGroundFriction)(BlockLegacy *this, Mob *, const BlockPos *);
  bool (__fastcall *canHaveExtraData)(BlockLegacy *this);
  bool (__fastcall *hasComparatorSignal)(BlockLegacy *this);
  int (__fastcall *getComparatorSignal)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *, unsigned __int8);
  bool (__fastcall *onDig)(BlockLegacy *this, const Block *, Actor *, ItemStack *, const BlockPos *);
  bool (__fastcall *canSlide)(BlockLegacy *this, BlockSource *, const BlockPos *);
  bool (__fastcall *canSpawnAt)(BlockLegacy *this, const BlockSource *, const BlockPos *);
  void (__fastcall *notifySpawnedAt)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getIconYOffset)(BlockLegacy *this);
  std::string *(__fastcall *buildDescriptionId)(BlockLegacy *this, std::string *result, const Block *);
  bool (__fastcall *isAuxValueRelevantForPicking)(BlockLegacy *this);
  int (__fastcall *getColor)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  int (__fastcall *getColor)(BlockLegacy *this, const Block *);
  int (__fastcall *getColorAtPos)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getColorForParticle)(BlockLegacy *this, BlockSource *, const BlockPos *, const Block *);
  bool (__fastcall *isSeasonTinted)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  void (__fastcall *onGraphicsModeChanged)(BlockLegacy *this, const BlockGraphicsModeChangeContext *);
  float (__fastcall *getShadeBrightness)(BlockLegacy *this, const Block *);
  const AABB *(__fastcall *getVisualShapeInWorld)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *, AABB *, bool);
  const AABB *(__fastcall *getVisualShape)(BlockLegacy *this, const Block *, AABB *, bool);
  const AABB *(__fastcall *getUIShape)(BlockLegacy *this, const Block *, AABB *);
  int (__fastcall *telemetryVariant)(BlockLegacy *this, BlockSource *, const BlockPos *);
  int (__fastcall *getVariant)(BlockLegacy *this, const Block *);
  bool (__fastcall *canSpawnOn)(BlockLegacy *this);
  const Block *(__fastcall *getRenderBlock)(BlockLegacy *this);
  unsigned __int8 (__fastcall *getMappedFace)(BlockLegacy *this, unsigned __int8, const Block *);
  bool (__fastcall *renderTwoFaced)(BlockLegacy *this);
  Flip (__fastcall *getFaceFlip)(BlockLegacy *this, unsigned __int8, const Block *);
  void (__fastcall *animateTick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  BlockLegacy *(__fastcall *init)(BlockLegacy *this);
  BlockLegacy *(__fastcall *setLightBlock)(BlockLegacy *this, Brightness);
  BlockLegacy *(__fastcall *setLightEmission)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setExplodeable)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFlammable)(BlockLegacy *this, FlameOdds, BurnOdds);
  BlockLegacy *(__fastcall *setDestroyTime)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *setFriction)(BlockLegacy *this, float);
  BlockLegacy *(__fastcall *addProperty)(BlockLegacy *this, BlockProperty);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *, unsigned __int64);
  BlockLegacy *(__fastcall *addState)(BlockLegacy *this, const ItemState *);
  BlockLegacy *(__fastcall *setAllowsRunes)(BlockLegacy *this, bool);
  BlockLegacy *(__fastcall *setMapColor)(BlockLegacy *this, const mce::Color *);
  bool (__fastcall *canBeSilkTouched)(BlockLegacy *this);
  ItemInstance *(__fastcall *getSilkTouchItemInstance)(BlockLegacy *this, ItemInstance *result, const Block *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const Vec3 *, const Vec3 *);
  void (__fastcall *setVisualShape)(BlockLegacy *this, const AABB *);
  const Block *(__fastcall *tryLegacyUpgrade)(BlockLegacy *this, unsigned __int16);
  bool (__fastcall *dealsContactDamage)(BlockLegacy *this, const Actor *, const Block *, bool);
  void (__fastcall *onRemove)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onExploded)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *);
  void (__fastcall *onStandOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOn)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onStepOff)(BlockLegacy *this, Actor *, const BlockPos *);
  void (__fastcall *onPlayerPlacing)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, unsigned __int8);
  void (__fastcall *onPlace)(BlockLegacy *this, BlockSource *, const BlockPos *);
  void (__fastcall *onFallOn)(BlockLegacy *this, BlockSource *, const BlockPos *, Actor *, float);
  void (__fastcall *playerDestroy)(BlockLegacy *this, Player *, const BlockPos *, const Block *);
  void (__fastcall *tick)(BlockLegacy *this, BlockSource *, const BlockPos *, Random *);
  bool (__fastcall *shouldRandomTick)(BlockLegacy *this);
  bool (__fastcall *isInteractiveBlock)(BlockLegacy *this);
  HitResult *(__fastcall *clip)(BlockLegacy *this, HitResult *result, BlockSource *, const BlockPos *, const Vec3 *, const Vec3 *, bool);
  bool (__fastcall *use)(BlockLegacy *this, Player *, const BlockPos *, unsigned __int8);
  bool (__fastcall *canSurvive)(BlockLegacy *this, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this, const Block *, BlockSource *, const BlockPos *);
  BlockRenderLayer (__fastcall *getRenderLayer)(BlockLegacy *this);
  int (__fastcall *getExtraRenderLayers)(BlockLegacy *this);
  float (__fastcall *getExplosionResistance)(BlockLegacy *this, Actor *);
  Brightness *(__fastcall *getLightEmission)(BlockLegacy *this, Brightness *result, const Block *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result, BlockSource *, const BlockPos *);
  mce::Color *(__fastcall *getMapColor)(BlockLegacy *this, mce::Color *result);
  bool (__fastcall *isCropBlock)(BlockLegacy *this);
  void (__fastcall *_executeEvent)(BlockLegacy *this, const std::string *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  bool (__fastcall *_executeTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *_forceExecuteTrigger)(BlockLegacy *this, const DefinitionTrigger *, std::vector&lt;std::pair&lt;std::string const ,std::string const &gt;&gt; *, RenderParams *);
  void (__fastcall *checkAlive)(BushBlock *this, BlockSource *, const BlockPos *);
};

</code></pre></div><h3 id="beaconbeamsection"><a href="#beaconbeamsection" class="header-anchor">#</a> <code>BeaconBeamSection</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeaconBeamSection
{
  int mHeight;
  mce::Color mColor;
};

</code></pre></div><h3 id="beaconblockactor"><a href="#beaconblockactor" class="header-anchor">#</a> <code>BeaconBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeaconBlockActor : BlockActor, Container
{
  std::vector&lt;BeaconBeamSection&gt; mBeamSections;
  float mBeamRot;
  int mNumLevels;
  int mNumLevelsSet;
  int mBlockRefreshCounter;
  int mPrimaryEffectId;
  int mSecondaryEffectId;
  int mPrimaryEffectTier;
  int mSecondaryEffectTier;
  std::vector&lt;MobEffect *&gt; mBeaconEffects;
  std::vector&lt;std::vector&lt;MobEffect *&gt;&gt; mTierEffects;
};

</code></pre></div><h3 id="beaconblockactor-vtbl"><a href="#beaconblockactor-vtbl" class="header-anchor">#</a> <code>BeaconBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BeaconBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="beaconrenderer"><a href="#beaconrenderer" class="header-anchor">#</a> <code>BeaconRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BeaconRenderer : BlockActorRenderer
{
  mce::TexturePtr mBeaconTexture;
  mce::MaterialPtr mBeaconMaterial;
  mce::MaterialPtr mBeaconTransparentMaterial;
};

</code></pre></div><h3 id="beaconrenderer-vtbl"><a href="#beaconrenderer-vtbl" class="header-anchor">#</a> <code>BeaconRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BeaconRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  void (__fastcall *renderAlpha)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  std::vector&lt;NameTagRenderObject&gt; *(__fastcall *extractText)(BlockActorRenderer *this, std::vector&lt;NameTagRenderObject&gt; *result, Tessellator *, BlockActor *, const std::string *, const std::vector&lt;int&gt; *, Vec3, bool);
};

</code></pre></div><h3 id="bedrenderer"><a href="#bedrenderer" class="header-anchor">#</a> <code>BedRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedRenderer : BlockActorRenderer
{
  mce::TexturePtr mBookTex;
  BedModel mBed;
  mce::TexturePtr mTextures[16];
};

</code></pre></div><h3 id="bedrenderer-vtbl"><a href="#bedrenderer-vtbl" class="header-anchor">#</a> <code>BedRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BedRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  void (__fastcall *renderAlpha)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  std::vector&lt;NameTagRenderObject&gt; *(__fastcall *extractText)(BlockActorRenderer *this, std::vector&lt;NameTagRenderObject&gt; *result, Tessellator *, BlockActor *, const std::string *, const std::vector&lt;int&gt; *, Vec3, bool);
};

</code></pre></div><h3 id="bedblockactor"><a href="#bedblockactor" class="header-anchor">#</a> <code>BedBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BedBlockActor : BlockActor
{
  int mDyeColor;
  bool mDirty;
  ActorUniqueID mPetSleepingOnBed;
};

</code></pre></div><h3 id="bedblockactor-vtbl"><a href="#bedblockactor-vtbl" class="header-anchor">#</a> <code>BedBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BedBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="bellblockactorrenderer"><a href="#bellblockactorrenderer" class="header-anchor">#</a> <code>BellBlockActorRenderer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BellBlockActorRenderer : BlockActorRenderer
{
  mce::TexturePtr mBellTexture;
  BellModel mBell;
};

</code></pre></div><h3 id="bellblockactorrenderer-vtbl"><a href="#bellblockactorrenderer-vtbl" class="header-anchor">#</a> <code>BellBlockActorRenderer_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BellBlockActorRenderer_vtbl
{
  void (__fastcall *~ActorShaderManager)(ActorShaderManager *this);
  mce::Color *(__fastcall *_getOverlayColor)(ActorShaderManager *this, mce::Color *result, Actor *, float);
  void (__fastcall *render)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  void (__fastcall *renderAlpha)(BlockActorRenderer *this, BaseActorRenderContext *, BlockActorRenderData *);
  std::vector&lt;NameTagRenderObject&gt; *(__fastcall *extractText)(BlockActorRenderer *this, std::vector&lt;NameTagRenderObject&gt; *result, Tessellator *, BlockActor *, const std::string *, const std::vector&lt;int&gt; *, Vec3, bool);
};

</code></pre></div><h3 id="bellblockactor"><a href="#bellblockactor" class="header-anchor">#</a> <code>BellBlockActor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BellBlockActor : BlockActor
{
  bool mRinging;
  Direction::Type mMovementDirection;
  bool mPowered;
  int mAlarmCooldown;
};

</code></pre></div><h3 id="bellblockactor-vtbl"><a href="#bellblockactor-vtbl" class="header-anchor">#</a> <code>BellBlockActor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BellBlockActor_vtbl
{
  void (__fastcall *~BlockActor)(BlockActor *this);
  void (__fastcall *load)(BlockActor *this, Level *, const CompoundTag *, DataLoadHelper *);
  bool (__fastcall *save)(BlockActor *this, CompoundTag *);
  bool (__fastcall *saveItemInstanceData)(BlockActor *this, CompoundTag *);
  void (__fastcall *saveBlockData)(BlockActor *this, CompoundTag *, BlockSource *);
  void (__fastcall *loadBlockData)(BlockActor *this, const CompoundTag *, BlockSource *, DataLoadHelper *);
  void (__fastcall *onCustomTagLoadDone)(BlockActor *this, BlockSource *);
  void (__fastcall *tick)(BlockActor *this, BlockSource *);
  bool (__fastcall *isFinished)(BlockActor *this);
  void (__fastcall *onChanged)(BlockActor *this, BlockSource *);
  bool (__fastcall *isMovable)(BlockActor *this, BlockSource *);
  bool (__fastcall *isCustomNameSaved)(BlockActor *this);
  bool (__fastcall *onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *, const Player *);
  void (__fastcall *onPlace)(BlockActor *this, BlockSource *);
  void (__fastcall *onMove)(BlockActor *this);
  void (__fastcall *onRemoved)(BlockActor *this, BlockSource *);
  void (__fastcall *triggerEvent)(BlockActor *this, int, int);
  void (__fastcall *clearCache)(BlockActor *this);
  void (__fastcall *onNeighborChanged)(BlockActor *this, BlockSource *, const BlockPos *);
  float (__fastcall *getShadowRadius)(BlockActor *this, BlockSource *);
  bool (__fastcall *hasAlphaLayer)(BlockActor *this);
  BlockActor *(__fastcall *getCrackEntity)(BlockActor *this, BlockSource *, const BlockPos *);
  void (__fastcall *getDebugText)(BlockActor *this, std::vector&lt;std::string&gt; *, const BlockPos *);
  const std::string *(__fastcall *getCustomName)(BlockActor *this);
  const std::string *(__fastcall *getFilteredCustomName)(BlockActor *this, const UIProfanityContext *);
  std::string *(__fastcall *getName)(BlockActor *this, std::string *result);
  void (__fastcall *setCustomName)(BlockActor *this, const std::string *);
  std::string *(__fastcall *getImmersiveReaderText)(BlockActor *this, std::string *result, BlockSource *);
  int (__fastcall *getRepairCost)(BlockActor *this);
  PistonBlockActor *(__fastcall *getOwningPiston)(BlockActor *this, BlockSource *);
  const Container *(__fastcall *getContainer)(BlockActor *this);
  Container *(__fastcall *getContainer)(BlockActor *this);
  float (__fastcall *getDeletionDelayTimeSeconds)(BlockActor *this);
  void (__fastcall *checkWordsOnChunkLoad)(BlockActor *this, LevelChunk *);
  void (__fastcall *checkWordsOnUpdate)(BlockActor *this, Player *);
  void (__fastcall *onChunkLoaded)(BlockActor *this, LevelChunk *);
  void (__fastcall *onChunkUnloaded)(BlockActor *this, LevelChunk *);
  std::unique_ptr&lt;BlockActorDataPacket&gt; *(__fastcall *_getUpdatePacket)(BlockActor *this, std::unique_ptr&lt;BlockActorDataPacket&gt; *result, BlockSource *);
  void (__fastcall *_onUpdatePacket)(BlockActor *this, const CompoundTag *, BlockSource *);
  bool (__fastcall *_playerCanUpdate)(BlockActor *this, const Player *);
};

</code></pre></div><h3 id="blockgraphics-registermicroblockgraphics-l2-lambda-826af4ce9791fce1685fd480ea7c7493"><a href="#blockgraphics-registermicroblockgraphics-l2-lambda-826af4ce9791fce1685fd480ea7c7493" class="header-anchor">#</a> <code>BlockGraphics::registerMicroBlockGraphics::__l2::&lt;lambda_826af4ce9791fce1685fd480ea7c7493&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGraphics::registerMicroBlockGraphics::__l2::&lt;lambda_826af4ce9791fce1685fd480ea7c7493&gt;
{
  BlockGraphics **ptr;
};

</code></pre></div><h3 id="blockgraphics-registerblockgraphics-l2-lambda-8c64b90d378b38d9711ce518f594d580"><a href="#blockgraphics-registerblockgraphics-l2-lambda-8c64b90d378b38d9711ce518f594d580" class="header-anchor">#</a> <code>BlockGraphics::registerBlockGraphics::__l2::&lt;lambda_8c64b90d378b38d9711ce518f594d580&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockGraphics::registerBlockGraphics::__l2::&lt;lambda_8c64b90d378b38d9711ce518f594d580&gt;
{
  BlockGraphics **ptr;
};

</code></pre></div><h3 id="blocktessellator-ctor-l2-lambda-cbf0c27e84d3545f4e5c8fd5f8fc8d47"><a href="#blocktessellator-ctor-l2-lambda-cbf0c27e84d3545f4e5c8fd5f8fc8d47" class="header-anchor">#</a> <code>BlockTessellator::{ctor}::__l2::&lt;lambda_cbf0c27e84d3545f4e5c8fd5f8fc8d47&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockTessellator::{ctor}::__l2::&lt;lambda_cbf0c27e84d3545f4e5c8fd5f8fc8d47&gt;
{
  BlockTessellator *const __this;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-std-array-std-vector-blockqueueentry-14-std-allocator-std-array-std-vector-blockqueueentry-14"><a href="#bedrock-threading-threadlocalobjectimplementation-std-array-std-vector-blockqueueentry-14-std-allocator-std-array-std-vector-blockqueueentry-14" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,std::allocator&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,std::allocator&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt; &gt; &gt;
{
  std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt; *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-std-array-std-vector-blockqueueentry-14-std-allocator-std-array-std-vector-blockqueueentry-14"><a href="#bedrock-threading-threadlocalobject-std-array-std-vector-blockqueueentry-14-std-allocator-std-array-std-vector-blockqueueentry-14" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,std::allocator&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,std::allocator&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt; &gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,std::allocator&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt; &gt; &gt;
{
  std::function&lt;void __cdecl(std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt; *)&gt; mConstructor;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-std-vector-blockqueueentry-std-allocator-std-vector-blockqueueentry"><a href="#bedrock-threading-threadlocalobjectimplementation-std-vector-blockqueueentry-std-allocator-std-vector-blockqueueentry" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::vector&lt;BlockQueueEntry&gt;,std::allocator&lt;std::vector&lt;BlockQueueEntry&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::vector&lt;BlockQueueEntry&gt;,std::allocator&lt;std::vector&lt;BlockQueueEntry&gt; &gt; &gt;
{
  std::vector&lt;BlockQueueEntry&gt; *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-std-vector-blockqueueentry-std-allocator-std-vector-blockqueueentry"><a href="#bedrock-threading-threadlocalobject-std-vector-blockqueueentry-std-allocator-std-vector-blockqueueentry" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;std::vector&lt;BlockQueueEntry&gt;,std::allocator&lt;std::vector&lt;BlockQueueEntry&gt; &gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;std::vector&lt;BlockQueueEntry&gt;,std::allocator&lt;std::vector&lt;BlockQueueEntry&gt; &gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;std::vector&lt;BlockQueueEntry&gt;,std::allocator&lt;std::vector&lt;BlockQueueEntry&gt; &gt; &gt;
{
  std::function&lt;void __cdecl(std::vector&lt;BlockQueueEntry&gt; *)&gt; mConstructor;
};

</code></pre></div><h3 id="basemobspawner"><a href="#basemobspawner" class="header-anchor">#</a> <code>BaseMobSpawner</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BaseMobSpawner
{
  BaseMobSpawner_vtbl *__vftable /*VFT*/;
  int mSpawnDelay;
  float mSpin;
  float mOSpin;
  ActorDefinitionIdentifier mActorId;
  std::vector&lt;SpawnData&gt; mSpawnPotentials;
  std::unique_ptr&lt;SpawnData&gt; mNextSpawnData;
  int mMinSpawnDelay;
  int mMaxSpawnDelay;
  int mSpawnCount;
  std::unique_ptr&lt;Mob&gt; mDisplayEntity;
  int mMaxNearbyEntities;
  int mRequiredPlayerRange;
  int mSpawnRange;
  float mDisplayEntityWidth;
  float mDisplayEntityHeight;
  float mDisplayEntityScale;
};

</code></pre></div><h3 id="basemobspawner-vtbl"><a href="#basemobspawner-vtbl" class="header-anchor">#</a> <code>BaseMobSpawner_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BaseMobSpawner_vtbl
{
  void (__fastcall *~BaseMobSpawner)(BaseMobSpawner *this);
  void (__fastcall *tick)(BaseMobSpawner *this, BlockSource *);
  void (__fastcall *load)(BaseMobSpawner *this, const CompoundTag *);
  void (__fastcall *save)(BaseMobSpawner *this, CompoundTag *);
  const BlockPos *(__fastcall *getPos)(BaseMobSpawner *this);
};

</code></pre></div><h3 id="buffer-span-actorblocksyncmessage-iterator"><a href="#buffer-span-actorblocksyncmessage-iterator" class="header-anchor">#</a> <code>buffer_span&lt;ActorBlockSyncMessage&gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;ActorBlockSyncMessage&gt;::iterator
{
  const ActorBlockSyncMessage *mPtr;
};

</code></pre></div><h3 id="buffer-span-blockactorblocksyncmessage-iterator"><a href="#buffer-span-blockactorblocksyncmessage-iterator" class="header-anchor">#</a> <code>buffer_span&lt;BlockActorBlockSyncMessage&gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;BlockActorBlockSyncMessage&gt;::iterator
{
  const BlockActorBlockSyncMessage *mPtr;
};

</code></pre></div><h3 id="blockpositerator"><a href="#blockpositerator" class="header-anchor">#</a> <code>BlockPosIterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(4)) BlockPosIterator
{
  const BlockPos mMinCorner;
  const BlockPos mMaxCorner;
  BlockPos mCurrentPos;
  bool mDone;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobjectimplementation-visibilityextimator-std-allocator-visibilityextimator"><a href="#bedrock-threading-threadlocalobjectimplementation-visibilityextimator-std-allocator-visibilityextimator" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObjectImplementation&lt;VisibilityExtimator,std::allocator&lt;VisibilityExtimator&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObjectImplementation&lt;VisibilityExtimator,std::allocator&lt;VisibilityExtimator&gt; &gt;
{
  VisibilityExtimator *mPtr;
};

</code></pre></div><h3 id="bedrock-threading-threadlocalobject-visibilityextimator-std-allocator-visibilityextimator"><a href="#bedrock-threading-threadlocalobject-visibilityextimator-std-allocator-visibilityextimator" class="header-anchor">#</a> <code>Bedrock::Threading::ThreadLocalObject&lt;VisibilityExtimator,std::allocator&lt;VisibilityExtimator&gt; &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::ThreadLocalObject&lt;VisibilityExtimator,std::allocator&lt;VisibilityExtimator&gt; &gt; : Bedrock::Threading::ThreadLocalObjectImplementation&lt;VisibilityExtimator,std::allocator&lt;VisibilityExtimator&gt; &gt;
{
  std::function&lt;void __cdecl(VisibilityExtimator *)&gt; mConstructor;
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-std-vector-blockqueueentry-void"><a href="#bedrock-threading-tlsdetail-defaultconstructor-std-vector-blockqueueentry-void" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;std::vector&lt;BlockQueueEntry&gt;,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;std::vector&lt;BlockQueueEntry&gt;,void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-std-array-std-vector-blockqueueentry-14-void"><a href="#bedrock-threading-tlsdetail-defaultconstructor-std-array-std-vector-blockqueueentry-14-void" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-std-vector-blockqueueentry-void-create-l2-lambda-ace7f0cb8a0f5c69bc0e799433d574e3"><a href="#bedrock-threading-tlsdetail-defaultconstructor-std-vector-blockqueueentry-void-create-l2-lambda-ace7f0cb8a0f5c69bc0e799433d574e3" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;std::vector&lt;BlockQueueEntry&gt;,void&gt;::create::__l2::&lt;lambda_ace7f0cb8a0f5c69bc0e799433d574e3&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;std::vector&lt;BlockQueueEntry&gt;,void&gt;::create::__l2::&lt;lambda_ace7f0cb8a0f5c69bc0e799433d574e3&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-std-array-std-vector-blockqueueentry-14-void-create-l2-lambda-c9dbd5b763eda418ab002da6227e142f"><a href="#bedrock-threading-tlsdetail-defaultconstructor-std-array-std-vector-blockqueueentry-14-void-create-l2-lambda-c9dbd5b763eda418ab002da6227e142f" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,void&gt;::create::__l2::&lt;lambda_c9dbd5b763eda418ab002da6227e142f&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;std::array&lt;std::vector&lt;BlockQueueEntry&gt;,14&gt;,void&gt;::create::__l2::&lt;lambda_c9dbd5b763eda418ab002da6227e142f&gt;
{
};

</code></pre></div><h3 id="buffer-span-std-vector-renderchunkquadinfo-iterator"><a href="#buffer-span-std-vector-renderchunkquadinfo-iterator" class="header-anchor">#</a> <code>buffer_span&lt;std::vector&lt;RenderChunkQuadInfo&gt; &gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;std::vector&lt;RenderChunkQuadInfo&gt; &gt;::iterator
{
  const std::vector&lt;RenderChunkQuadInfo&gt; *mPtr;
};

</code></pre></div><h3 id="buffer-span-renderchunksorter-faceinfo"><a href="#buffer-span-renderchunksorter-faceinfo" class="header-anchor">#</a> <code>buffer_span&lt;RenderChunkSorter::FaceInfo&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span&lt;RenderChunkSorter::FaceInfo&gt;
{
  const RenderChunkSorter::FaceInfo *mBegin;
  const RenderChunkSorter::FaceInfo *mEnd;
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-visibilityextimator-void"><a href="#bedrock-threading-tlsdetail-defaultconstructor-visibilityextimator-void" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;VisibilityExtimator,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;VisibilityExtimator,void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-visibilityextimator-void-create-l2-lambda-36f8a46397ac3ff79641196e7dbcdcaf"><a href="#bedrock-threading-tlsdetail-defaultconstructor-visibilityextimator-void-create-l2-lambda-36f8a46397ac3ff79641196e7dbcdcaf" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;VisibilityExtimator,void&gt;::create::__l2::&lt;lambda_36f8a46397ac3ff79641196e7dbcdcaf&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;VisibilityExtimator,void&gt;::create::__l2::&lt;lambda_36f8a46397ac3ff79641196e7dbcdcaf&gt;
{
};

</code></pre></div><h3 id="buildtaskcontext"><a href="#buildtaskcontext" class="header-anchor">#</a> <code>BuildTaskContext</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BuildTaskContext
{
  PolygonOperatorPool&lt;RenderChunkBuilder&gt; *mBuilders;
  PolygonOperatorPool&lt;RenderChunkBuilder&gt;::PoolEntry mBuilder;
};

</code></pre></div><h3 id="buffer-span-mut-commandlistfuture-iterator"><a href="#buffer-span-mut-commandlistfuture-iterator" class="header-anchor">#</a> <code>buffer_span_mut&lt;CommandListFuture&gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;CommandListFuture&gt;::iterator
{
  CommandListFuture *mPtr;
};

</code></pre></div><h3 id="buffer-span-mut-std-shared-ptr-renderchunkinstanced-iterator"><a href="#buffer-span-mut-std-shared-ptr-renderchunkinstanced-iterator" class="header-anchor">#</a> <code>buffer_span_mut&lt;std::shared_ptr&lt;RenderChunkInstanced&gt; &gt;::iterator</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj buffer_span_mut&lt;std::shared_ptr&lt;RenderChunkInstanced&gt; &gt;::iterator
{
  std::shared_ptr&lt;RenderChunkInstanced&gt; *mPtr;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-cg-texturesetlayerdefinition"><a href="#bedrock-nonownerpointer-cg-texturesetlayerdefinition" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;cg::TextureSetLayerDefinition&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;cg::TextureSetLayerDefinition&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-nonownerpointer-custommusic"><a href="#bedrock-nonownerpointer-custommusic" class="header-anchor">#</a> <code>Bedrock::NonOwnerPointer&lt;CustomMusic&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::NonOwnerPointer&lt;CustomMusic&gt;
{
  std::shared_ptr&lt;Bedrock::EnableNonOwnerReferences::ControlBlock&gt; mControlBlock;
};

</code></pre></div><h3 id="bedrock-input-keyboardeventprocessor"><a href="#bedrock-input-keyboardeventprocessor" class="header-anchor">#</a> <code>Bedrock::Input::KeyboardEventProcessor</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Input::KeyboardEventProcessor
{
  Bedrock::Input::KeyboardEventProcessor_vtbl *__vftable /*VFT*/;
};

</code></pre></div><h3 id="bedrock-input-keyboardeventprocessor-vtbl"><a href="#bedrock-input-keyboardeventprocessor-vtbl" class="header-anchor">#</a> <code>Bedrock::Input::KeyboardEventProcessor_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ Bedrock::Input::KeyboardEventProcessor_vtbl
{
  void (__fastcall *~KeyboardEventProcessor)(Bedrock::Input::KeyboardEventProcessor *this);
  void (__fastcall *onKeyDown)(Bedrock::Input::KeyboardEventProcessor *this, int);
  void (__fastcall *onKeyUp)(Bedrock::Input::KeyboardEventProcessor *this, int);
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-threadedframeconstantscontainer-void"><a href="#bedrock-threading-tlsdetail-defaultconstructor-threadedframeconstantscontainer-void" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;ThreadedFrameConstantsContainer,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;ThreadedFrameConstantsContainer,void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-threadedframeconstantscontainer-void-create-l2-lambda-818de085286a61d3373be624e0869fe9"><a href="#bedrock-threading-tlsdetail-defaultconstructor-threadedframeconstantscontainer-void-create-l2-lambda-818de085286a61d3373be624e0869fe9" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;ThreadedFrameConstantsContainer,void&gt;::create::__l2::&lt;lambda_818de085286a61d3373be624e0869fe9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;ThreadedFrameConstantsContainer,void&gt;::create::__l2::&lt;lambda_818de085286a61d3373be624e0869fe9&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-burst-details-workertask-bedrock-threading-burst-strategy-execution-greedyexecution-kicknewworkertask-l5-lambda-4b11245632ccb66fc7aa20e2bc6b2264"><a href="#bedrock-threading-burst-details-workertask-bedrock-threading-burst-strategy-execution-greedyexecution-kicknewworkertask-l5-lambda-4b11245632ccb66fc7aa20e2bc6b2264" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::_kickNewWorkerTask::__l5::&lt;lambda_4b11245632ccb66fc7aa20e2bc6b2264&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::_kickNewWorkerTask::__l5::&lt;lambda_4b11245632ccb66fc7aa20e2bc6b2264&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-burst-details-workertask-bedrock-threading-burst-strategy-execution-greedyexecution-kicknewworkertask-l5-lambda-75cdf9faff596de1f4e63d5cc780601a"><a href="#bedrock-threading-burst-details-workertask-bedrock-threading-burst-strategy-execution-greedyexecution-kicknewworkertask-l5-lambda-75cdf9faff596de1f4e63d5cc780601a" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::_kickNewWorkerTask::__l5::&lt;lambda_75cdf9faff596de1f4e63d5cc780601a&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::_kickNewWorkerTask::__l5::&lt;lambda_75cdf9faff596de1f4e63d5cc780601a&gt;
{
  Bedrock::Threading::Burst::Details::WorkerTask&lt;Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt; *const __this;
  std::shared_ptr&lt;Bedrock::Threading::Burst::Details::Lifetime&gt; lifetime;
};

</code></pre></div><h3 id="bedrock-threading-burst-workqueue-std-function-void-cdecl-std-nullptr-t-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution-ctor-l2-lambda-d3f941515fbef779c9de2f61db7c6f6d"><a href="#bedrock-threading-burst-workqueue-std-function-void-cdecl-std-nullptr-t-bedrock-threading-burst-strategy-console-bedrock-threading-burst-strategy-execution-greedyexecution-ctor-l2-lambda-d3f941515fbef779c9de2f61db7c6f6d" class="header-anchor">#</a> <code>Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::{ctor}::__l2::&lt;lambda_d3f941515fbef779c9de2f61db7c6f6d&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt;::{ctor}::__l2::&lt;lambda_d3f941515fbef779c9de2f61db7c6f6d&gt;
{
  Bedrock::Threading::Burst::WorkQueue&lt;std::function&lt;void __cdecl(std::nullptr_t &amp;)&gt;,Bedrock::Threading::Burst::Strategy::Console,Bedrock::Threading::Burst::Strategy::Execution::GreedyExecution&gt; *const __this;
};

</code></pre></div><h3 id="bgfx-textureformat"><a href="#bgfx-textureformat" class="header-anchor">#</a> <code>bgfx::TextureFormat</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::TextureFormat
{
};

</code></pre></div><h3 id="bgfx-topology"><a href="#bgfx-topology" class="header-anchor">#</a> <code>bgfx::Topology</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::Topology
{
};

</code></pre></div><h3 id="bgfx-attrib"><a href="#bgfx-attrib" class="header-anchor">#</a> <code>bgfx::Attrib</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::Attrib
{
};

</code></pre></div><h3 id="bgfx-renderertype"><a href="#bgfx-renderertype" class="header-anchor">#</a> <code>bgfx::RendererType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::RendererType
{
};

</code></pre></div><h3 id="bgfx-viewmode"><a href="#bgfx-viewmode" class="header-anchor">#</a> <code>bgfx::ViewMode</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::ViewMode
{
};

</code></pre></div><h3 id="bgfx-transform"><a href="#bgfx-transform" class="header-anchor">#</a> <code>bgfx::Transform</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) bgfx::Transform
{
  float *data;
  unsigned __int16 num;
};

</code></pre></div><h3 id="bgfx-transientindexbuffer"><a href="#bgfx-transientindexbuffer" class="header-anchor">#</a> <code>bgfx::TransientIndexBuffer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(8)) bgfx::TransientIndexBuffer
{
  unsigned __int8 *data;
  unsigned int size;
  unsigned int startIndex;
  bgfx::IndexBufferHandle handle;
};

</code></pre></div><h3 id="bgfx-transientvertexbuffer"><a href="#bgfx-transientvertexbuffer" class="header-anchor">#</a> <code>bgfx::TransientVertexBuffer</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __declspec(align(4)) bgfx::TransientVertexBuffer
{
  unsigned __int8 *data;
  unsigned int size;
  unsigned int startVertex;
  unsigned __int16 stride;
  bgfx::VertexBufferHandle handle;
  bgfx::VertexDeclHandle decl;
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder-item"><a href="#bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder-item" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::Item</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::Item : Bedrock::Intrusive::list_base_hook&lt;void&gt;
{
  std::_Align_type&lt;double,8&gt; mData;
};

</code></pre></div><h3 id="bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void-iterator-base-0"><a href="#bedrock-intrusive-list-bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder-item-bedrock-intrusive-list-base-hook-void-bedrock-intrusive-list-base-hook-void-iterator-base-0" class="header-anchor">#</a> <code>Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;::iterator_base&lt;0&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;::iterator_base&lt;0&gt;
{
  Bedrock::Intrusive::list_base_hook&lt;void&gt; *mHook;
};

</code></pre></div><h3 id="bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder-iteratortype"><a href="#bedrock-threading-instancedthreadlocal-bgfx-encoder-std-allocator-bgfx-encoder-iteratortype" class="header-anchor">#</a> <code>Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::IteratorType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::IteratorType
{
  Bedrock::Intrusive::list&lt;Bedrock::Threading::InstancedThreadLocal&lt;bgfx::Encoder *,std::allocator&lt;bgfx::Encoder *&gt; &gt;::Item,Bedrock::Intrusive::list_base_hook&lt;void&gt;,Bedrock::Intrusive::list_base_hook&lt;void&gt; &gt;::iterator_base&lt;0&gt; mIterator;
};

</code></pre></div><h3 id="bgfx-access"><a href="#bgfx-access" class="header-anchor">#</a> <code>bgfx::Access</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::Access
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-bgfx-encoder-void"><a href="#bedrock-threading-tlsdetail-defaultconstructor-bgfx-encoder-void" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;bgfx::Encoder *,void&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;bgfx::Encoder *,void&gt;
{
};

</code></pre></div><h3 id="bedrock-threading-tlsdetail-defaultconstructor-bgfx-encoder-void-create-l2-lambda-a5b5eb428bb69d7ea1327cfc6389f2e4"><a href="#bedrock-threading-tlsdetail-defaultconstructor-bgfx-encoder-void-create-l2-lambda-a5b5eb428bb69d7ea1327cfc6389f2e4" class="header-anchor">#</a> <code>Bedrock::Threading::TLSDetail::DefaultConstructor&lt;bgfx::Encoder *,void&gt;::create::__l2::&lt;lambda_a5b5eb428bb69d7ea1327cfc6389f2e4&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj Bedrock::Threading::TLSDetail::DefaultConstructor&lt;bgfx::Encoder *,void&gt;::create::__l2::&lt;lambda_a5b5eb428bb69d7ea1327cfc6389f2e4&gt;
{
};

</code></pre></div><h3 id="bgfx-attribtype"><a href="#bgfx-attribtype" class="header-anchor">#</a> <code>bgfx::AttribType</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj bgfx::AttribType
{
};

</code></pre></div><h3 id="boost-intrusive-hmfcw-dont-care"><a href="#boost-intrusive-hmfcw-dont-care" class="header-anchor">#</a> <code>boost_intrusive_hmfcw::dont_care</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj boost_intrusive_hmfcw::dont_care
{
};

</code></pre></div><h3 id="boost-intrusive-hmfcw-no-type"><a href="#boost-intrusive-hmfcw-no-type" class="header-anchor">#</a> <code>boost_intrusive_hmfcw::no_type</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct boost_intrusive_hmfcw::no_type
{
  char dummy[2];
};

</code></pre></div><h3 id="barterdefinition"><a href="#barterdefinition" class="header-anchor">#</a> <code>BarterDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) BarterDefinition
{
  std::string mBarterItemsTable;
  int mCooldown;
};

</code></pre></div><h3 id="blockpostrackercomponent"><a href="#blockpostrackercomponent" class="header-anchor">#</a> <code>BlockPosTrackerComponent</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPosTrackerComponent
{
  bool mPreviousOnGround;
  BlockPos mPreviousBlockPos;
};

</code></pre></div><h3 id="buoyancydefinition"><a href="#buoyancydefinition" class="header-anchor">#</a> <code>BuoyancyDefinition</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BuoyancyDefinition
{
  float mBaseBuoyancy;
  float mDragDownOnRemoval;
  float mBigWaveProbability;
  float mBigWaveSpeedMultiplier;
  bool mSimulateWaves;
  bool mApplyGravity;
  std::vector&lt;BlockDescriptor&gt; mLiquidBlocks;
  Json::Value mFloatData;
};

</code></pre></div><h3 id="blockutils"><a href="#blockutils" class="header-anchor">#</a> <code>BlockUtils</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockUtils
{
};

</code></pre></div><h3 id="buoyancydefinition-buildschema-l2-lambda-9b31f2e060bc8aee1e94182a51f43d11"><a href="#buoyancydefinition-buildschema-l2-lambda-9b31f2e060bc8aee1e94182a51f43d11" class="header-anchor">#</a> <code>BuoyancyDefinition::buildSchema::__l2::&lt;lambda_9b31f2e060bc8aee1e94182a51f43d11&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BuoyancyDefinition::buildSchema::__l2::&lt;lambda_9b31f2e060bc8aee1e94182a51f43d11&gt;
{
};

</code></pre></div><h3 id="buoyancydefinition-buildschema-l2-lambda-8ed573b6261707ebee8ec5ff12cb5a04"><a href="#buoyancydefinition-buildschema-l2-lambda-8ed573b6261707ebee8ec5ff12cb5a04" class="header-anchor">#</a> <code>BuoyancyDefinition::buildSchema::__l2::&lt;lambda_8ed573b6261707ebee8ec5ff12cb5a04&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BuoyancyDefinition::buildSchema::__l2::&lt;lambda_8ed573b6261707ebee8ec5ff12cb5a04&gt;
{
};

</code></pre></div><h3 id="buoyancydefinition-buildschema-l2-lambda-6e4982b2edfd861ec7fa1334f1250fb9"><a href="#buoyancydefinition-buildschema-l2-lambda-6e4982b2edfd861ec7fa1334f1250fb9" class="header-anchor">#</a> <code>BuoyancyDefinition::buildSchema::__l2::&lt;lambda_6e4982b2edfd861ec7fa1334f1250fb9&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BuoyancyDefinition::buildSchema::__l2::&lt;lambda_6e4982b2edfd861ec7fa1334f1250fb9&gt;
{
};

</code></pre></div><h3 id="blockpostrackersystem"><a href="#blockpostrackersystem" class="header-anchor">#</a> <code>BlockPosTrackerSystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BlockPosTrackerSystem : ITickingSystem
{
};

</code></pre></div><h3 id="blockpostrackersystem-vtbl"><a href="#blockpostrackersystem-vtbl" class="header-anchor">#</a> <code>BlockPosTrackerSystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BlockPosTrackerSystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="buoyancysystem"><a href="#buoyancysystem" class="header-anchor">#</a> <code>BuoyancySystem</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BuoyancySystem : ITickingSystem
{
};

</code></pre></div><h3 id="buoyancysystem-vtbl"><a href="#buoyancysystem-vtbl" class="header-anchor">#</a> <code>BuoyancySystem_vtbl</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct /*VFT*/ BuoyancySystem_vtbl
{
  void (__fastcall *~ITickingSystem)(ITickingSystem *this);
  void (__fastcall *tick)(ITickingSystem *this, EntityRegistry *);
};

</code></pre></div><h3 id="bidirectionalunorderedmap-enum-itemstackrequestactiontype-std-string"><a href="#bidirectionalunorderedmap-enum-itemstackrequestactiontype-std-string" class="header-anchor">#</a> <code>BidirectionalUnorderedMap&lt;enum ItemStackRequestActionType,std::string &gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BidirectionalUnorderedMap&lt;enum ItemStackRequestActionType,std::string &gt;
{
  std::unordered_map&lt;enum ItemStackRequestActionType,std::string&gt; mRight;
  std::unordered_map&lt;std::string,enum ItemStackRequestActionType&gt; mLeft;
};

</code></pre></div><h3 id="batchworker-packstorage-pendingtask"><a href="#batchworker-packstorage-pendingtask" class="header-anchor">#</a> <code>BatchWorker&lt;PackStorage::PendingTask&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj BatchWorker&lt;PackStorage::PendingTask&gt;
{
  unsigned __int64 mActiveWorkers;
  const unsigned __int64 mDesiredWorkers;
  std::mutex mMutex;
  MPMCQueue&lt;PackStorage::PendingTask&gt; mTasks;
  std::function&lt;void __cdecl(PackStorage::PendingTask &amp;&amp;)&gt; mDoWork;
  std::shared_ptr&lt;ITaskGroupProxy&gt; mTaskGroup;
  std::string mName;
};

</code></pre></div><h3 id="bedrock-threading-asyncdeferredresultt-bool"><a href="#bedrock-threading-asyncdeferredresultt-bool" class="header-anchor">#</a> <code>Bedrock::Threading::AsyncDeferredResultT&lt;bool&gt;</code></h3> <div class="language- extra-class"><pre class="language-text"><code>struct __cppobj __declspec(align(8)) Bedrock::Threading::AsyncDeferredResultT&lt;bool&gt; : Bedrock::Threading::IAsyncResult&lt;bool&gt;
{
  std::mutex mLock;
  Bedrock::Threading::AsyncDeferredResultT&lt;bool&gt;::DelayStatus mStatus;
  std::vector&lt;std::function&lt;void __cdecl(Bedrock::Threading::IAsyncResult&lt;bool&gt; const &amp;)&gt;&gt; mComplete;
  std::optional&lt;bool&gt; mResult;
};

</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mcstructure/1.16.201/structure/A~1.html" class="prev">
        A~1
      </a></span> <span class="next"><a href="/mcstructure/1.16.201/structure/B~1.html">
        B~1
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mcstructure/assets/js/app.4c02fc69.js" defer></script><script src="/mcstructure/assets/js/2.ab15d2b7.js" defer></script><script src="/mcstructure/assets/js/1.9734fe39.js" defer></script><script src="/mcstructure/assets/js/105.a60ad729.js" defer></script>
  </body>
</html>
